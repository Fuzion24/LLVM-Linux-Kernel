diff --git a/block/blk-exec.c b/block/blk-exec.c
index a1ebceb..a4d9369 100644
--- a/block/blk-exec.c
+++ b/block/blk-exec.c
@@ -59,7 +59,7 @@ void blk_execute_rq_nowait(struct request_queue *q, struct gendisk *bd_disk,
 
 	rq->rq_disk = bd_disk;
 	rq->end_io = done;
-	WARN_ON(irqs_disabled());
+	(void)WARN_ON(irqs_disabled());
 	spin_lock_irq(q->queue_lock);
 	__elv_add_request(q, rq, where);
 	__blk_run_queue(q);
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index ae21919..9658301 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -1599,7 +1599,7 @@ static void cfq_remove_request(struct request *rq)
 	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
 					rq_data_dir(rq), rq_is_sync(rq));
 	if (rq->cmd_flags & REQ_META) {
-		WARN_ON(!cfqq->meta_pending);
+		(void)WARN_ON(!cfqq->meta_pending);
 		cfqq->meta_pending--;
 	}
 }
@@ -3082,7 +3082,7 @@ cfq_drop_dead_cic(struct cfq_data *cfqd, struct io_context *ioc,
 {
 	unsigned long flags;
 
-	WARN_ON(!list_empty(&cic->queue_list));
+	(void)WARN_ON(!list_empty(&cic->queue_list));
 	BUG_ON(cic->key != cfqd_dead_key(cfqd));
 
 	spin_lock_irqsave(&ioc->lock, flags);
diff --git a/block/genhd.c b/block/genhd.c
index cbf7b88..b785b94 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -613,7 +613,7 @@ void add_disk(struct gendisk *disk)
 
 	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
 				   "bdi");
-	WARN_ON(retval);
+	(void)WARN_ON(retval);
 
 	disk_add_events(disk);
 }
diff --git a/crypto/md4.c b/crypto/md4.c
index 7fca1f59..f0762d4 100644
--- a/crypto/md4.c
+++ b/crypto/md4.c
@@ -206,13 +206,13 @@ static int md4_final(struct shash_desc *desc, u8 *out)
 
 	*p++ = 0x80;
 	if (padding < 0) {
-		memset(p, 0x00, padding + sizeof (u64));
+		(void)memset(p, 0x00, padding + sizeof (u64));
 		md4_transform_helper(mctx);
 		p = (char *)mctx->block;
 		padding = 56;
 	}
 
-	memset(p, 0, padding);
+	(void)memset(p, 0, padding);
 	mctx->block[14] = mctx->byte_count << 3;
 	mctx->block[15] = mctx->byte_count >> 29;
 	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
@@ -220,7 +220,7 @@ static int md4_final(struct shash_desc *desc, u8 *out)
 	md4_transform(mctx->hash, mctx->block);
 	cpu_to_le32_array(mctx->hash, ARRAY_SIZE(mctx->hash));
 	memcpy(out, mctx->hash, sizeof(mctx->hash));
-	memset(mctx, 0, sizeof(*mctx));
+	(void)memset(mctx, 0, sizeof(*mctx));
 
 	return 0;
 }
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index 0416091..2f20037 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -63,7 +63,7 @@ static int sha1_update(struct shash_desc *desc, const u8 *data,
 			src = data + done;
 		} while (done + 63 < len);
 
-		memset(temp, 0, sizeof(temp));
+		(void)memset(temp, 0, sizeof(temp));
 		partial = 0;
 	}
 	memcpy(sctx->buffer + partial, src, len - done);
@@ -96,7 +96,7 @@ static int sha1_final(struct shash_desc *desc, u8 *out)
 		dst[i] = cpu_to_be32(sctx->state[i]);
 
 	/* Wipe context */
-	memset(sctx, 0, sizeof *sctx);
+	(void)memset(sctx, 0, sizeof *sctx);
 
 	return 0;
 }
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index cf7a0c7..5954aaa 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -91,7 +91,7 @@ static __always_inline struct devres * alloc_dr(dr_release_t release,
 	if (unlikely(!dr))
 		return NULL;
 
-	memset(dr, 0, tot_size);
+	(void)memset(dr, 0, tot_size);
 	INIT_LIST_HEAD(&dr->node.entry);
 	dr->node.release = release;
 	return dr;
@@ -518,7 +518,7 @@ void devres_close_group(struct device *dev, void *id)
 	if (grp)
 		add_dr(dev, &grp->node[1]);
 	else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 }
@@ -546,7 +546,7 @@ void devres_remove_group(struct device *dev, void *id)
 		list_del_init(&grp->node[1].entry);
 		devres_log(dev, &grp->node[0], "REM");
 	} else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 
@@ -584,7 +584,7 @@ int devres_release_group(struct device *dev, void *id)
 
 		cnt = release_nodes(dev, first, end, flags);
 	} else {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		spin_unlock_irqrestore(&dev->devres_lock, flags);
 	}
 
@@ -645,6 +645,6 @@ void devm_kfree(struct device *dev, void *p)
 	int rc;
 
 	rc = devres_destroy(dev, devm_kzalloc_release, devm_kzalloc_match, p);
-	WARN_ON(rc);
+	(void)WARN_ON(rc);
 }
 EXPORT_SYMBOL_GPL(devm_kfree);
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 2ebacf0..97c5b53 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -579,7 +579,7 @@ static int loop_thread(void *data)
 
 	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
-		wait_event_interruptible(lo->lo_event,
+		(void)wait_event_interruptible(lo->lo_event,
 				!bio_list_empty(&lo->lo_bio_list) ||
 				kthread_should_stop());
 
@@ -1021,9 +1021,9 @@ static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
 	lo->lo_encrypt_key_size = 0;
 	lo->lo_flags = 0;
 	lo->lo_thread = NULL;
-	memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
-	memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
-	memset(lo->lo_file_name, 0, LO_NAME_SIZE);
+	(void)memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
+	(void)memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
+	(void)memset(lo->lo_file_name, 0, LO_NAME_SIZE);
 	if (bdev)
 		invalidate_bdev(bdev);
 	set_capacity(lo->lo_disk, 0);
@@ -1131,7 +1131,7 @@ loop_get_status(struct loop_device *lo, struct loop_info64 *info)
 	error = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
 	if (error)
 		return error;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->lo_number = lo->lo_number;
 	info->lo_device = huge_encode_dev(stat.dev);
 	info->lo_inode = stat.ino;
@@ -1154,7 +1154,7 @@ loop_get_status(struct loop_device *lo, struct loop_info64 *info)
 static void
 loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
 {
-	memset(info64, 0, sizeof(*info64));
+	(void)memset(info64, 0, sizeof(*info64));
 	info64->lo_number = info->lo_number;
 	info64->lo_device = info->lo_device;
 	info64->lo_inode = info->lo_inode;
@@ -1176,7 +1176,7 @@ loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
 static int
 loop_info64_to_old(const struct loop_info64 *info64, struct loop_info *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->lo_number = info64->lo_number;
 	info->lo_device = info64->lo_device;
 	info->lo_inode = info64->lo_inode;
diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index b07af02..1005437 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -544,7 +544,7 @@ static int __init hci_uart_init(void)
 
 	/* Register the tty discipline */
 
-	memset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));
+	(void)memset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));
 	hci_uart_ldisc.magic		= TTY_LDISC_MAGIC;
 	hci_uart_ldisc.name		= "n_hci";
 	hci_uart_ldisc.open		= hci_uart_tty_open;
diff --git a/drivers/char/msm_rotator.c b/drivers/char/msm_rotator.c
index bd48925..87b9d36 100644
--- a/drivers/char/msm_rotator.c
+++ b/drivers/char/msm_rotator.c
@@ -329,7 +329,7 @@ static int msm_rotator_get_plane_sizes(uint32_t format,	uint32_t w, uint32_t h,
 	if ((w > MSM_ROTATOR_MAX_W) || (h > MSM_ROTATOR_MAX_H))
 		return -ERANGE;
 
-	memset(p, 0, sizeof(*p));
+	(void)memset(p, 0, sizeof(*p));
 
 	switch (format) {
 	case MDP_XRGB_8888:
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index ff15497..a9446a7 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -928,7 +928,7 @@ static int cpufreq_add_dev(struct sys_device *sys_dev)
 	/* Initially set CPU itself as the policy_cpu */
 	per_cpu(cpufreq_policy_cpu, cpu) = cpu;
 	ret = (lock_policy_rwsem_write(cpu) < 0);
-	WARN_ON(ret);
+	(void)WARN_ON(ret);
 
 	init_completion(&policy->kobj_unregister);
 	INIT_WORK(&policy->update, handle_update);
@@ -1379,7 +1379,7 @@ int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)
 {
 	int ret;
 
-	WARN_ON(!init_cpufreq_transition_notifier_list_called);
+	(void)WARN_ON(!init_cpufreq_transition_notifier_list_called);
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
diff --git a/drivers/cpuidle/driver.c b/drivers/cpuidle/driver.c
index fd1601e..0aed2be 100644
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@ -55,7 +55,7 @@ EXPORT_SYMBOL_GPL(cpuidle_get_driver);
 void cpuidle_unregister_driver(struct cpuidle_driver *drv)
 {
 	if (drv != cpuidle_curr_driver) {
-		WARN(1, "invalid cpuidle_unregister_driver(%s)\n",
+		(void)WARN(1, "invalid cpuidle_unregister_driver(%s)\n",
 			drv->name);
 		return;
 	}
diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c
index bddc80f..1c08ae3 100644
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -377,7 +377,7 @@ static int menu_enable_device(struct cpuidle_device *dev)
 {
 	struct menu_device *data = &per_cpu(menu_devices, dev->cpu);
 
-	memset(data, 0, sizeof(struct menu_device));
+	(void)memset(data, 0, sizeof(struct menu_device));
 
 	return 0;
 }
diff --git a/drivers/crypto/msm/qcedev.c b/drivers/crypto/msm/qcedev.c
index c1a65fc..21440875 100644
--- a/drivers/crypto/msm/qcedev.c
+++ b/drivers/crypto/msm/qcedev.c
@@ -694,7 +694,7 @@ static int qcedev_sha_init(struct qcedev_async_req *areq,
 {
 	struct qcedev_sha_ctxt *sha_ctxt = &handle->sha_ctxt;
 
-	memset(sha_ctxt, 0, sizeof(struct qcedev_sha_ctxt));
+	(void)memset(sha_ctxt, 0, sizeof(struct qcedev_sha_ctxt));
 	sha_ctxt->first_blk = 1;
 
 	if ((areq->sha_op_req.alg == QCEDEV_ALG_SHA1) ||
@@ -818,7 +818,7 @@ static int qcedev_sha_update_max_xfer(struct qcedev_async_req *qcedev_areq,
 
 	/*  update sha_ctxt trailing buf content to new trailing buf */
 	if (trailing_buf_len > 0) {
-		memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
+		(void)memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
 		memcpy(&handle->sha_ctxt.trailing_buf[0],
 			(k_src - trailing_buf_len),
 			trailing_buf_len);
@@ -989,7 +989,7 @@ static int qcedev_sha_final(struct qcedev_async_req *qcedev_areq,
 	handle->sha_ctxt.auth_data[0] = 0;
 	handle->sha_ctxt.auth_data[1] = 0;
 	handle->sha_ctxt.trailing_buf_len = 0;
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
+	(void)memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
 
 	kfree(k_buf_src);
 	return err;
@@ -1087,7 +1087,7 @@ static int qcedev_set_hmac_auth_key(struct qcedev_async_req *areq,
 		authkey_areq.sha_op_req.data[0].len = areq->sha_op_req.authklen;
 		authkey_areq.sha_op_req.data_len = areq->sha_op_req.authklen;
 		authkey_areq.sha_op_req.diglen = 0;
-		memset(&authkey_areq.sha_op_req.digest[0], 0,
+		(void)memset(&authkey_areq.sha_op_req.digest[0], 0,
 						QCEDEV_MAX_SHA_DIGEST);
 		if (areq->sha_op_req.alg == QCEDEV_ALG_SHA1_HMAC)
 				authkey_areq.sha_op_req.alg = QCEDEV_ALG_SHA1;
@@ -1143,7 +1143,7 @@ static int qcedev_hmac_get_ohash(struct qcedev_async_req *qcedev_areq,
 	sg_mark_end(qcedev_areq->sha_req.sreq.src);
 
 	qcedev_areq->sha_req.sreq.nbytes = sha_block_size;
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
+	(void)memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
 	memcpy(&handle->sha_ctxt.trailing_buf[0], &handle->sha_ctxt.digest[0],
 					sha_digest_size);
 	handle->sha_ctxt.trailing_buf_len = sha_digest_size;
@@ -1190,7 +1190,7 @@ static int qcedev_hmac_update_iokey(struct qcedev_async_req *areq,
 	else
 		sha_block_size = SHA256_BLOCK_SIZE;
 
-	memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
+	(void)memset(&handle->sha_ctxt.trailing_buf[0], 0, sha_block_size);
 	for (i = 0; i < sha_block_size; i++)
 		handle->sha_ctxt.trailing_buf[i] =
 				(handle->sha_ctxt.authkey[i] ^ constant);
@@ -1282,7 +1282,7 @@ static int qcedev_pmem_ablk_cipher_max_xfer(struct qcedev_async_req *areq,
 		return -ENOMEM;
 
 	}
-	memset(sg_src, 0, (sizeof(struct scatterlist) *
+	(void)memset(sg_src, 0, (sizeof(struct scatterlist) *
 				areq->cipher_op_req.entries));
 	sg_ndex = sg_src;
 	areq->cipher_req.creq.src = sg_src;
@@ -1312,7 +1312,7 @@ static int qcedev_pmem_ablk_cipher_max_xfer(struct qcedev_async_req *areq,
 			__func__, (uint32_t)sg_dst);
 			return -ENOMEM;
 		}
-		memset(sg_dst, 0, (sizeof(struct scatterlist) *
+		(void)memset(sg_dst, 0, (sizeof(struct scatterlist) *
 					areq->cipher_op_req.entries));
 		areq->cipher_req.creq.dst = sg_dst;
 		sg_ndex = sg_dst;
@@ -2157,7 +2157,7 @@ static ssize_t _debug_stats_write(struct file *file, const char __user *buf,
 
 	int qcedev = *((int *) file->private_data);
 
-	memset((char *)&_qcedev_stat[qcedev], 0, sizeof(struct qcedev_stat));
+	(void)memset((char *)&_qcedev_stat[qcedev], 0, sizeof(struct qcedev_stat));
 	return count;
 };
 
diff --git a/drivers/crypto/msm/qcrypto.c b/drivers/crypto/msm/qcrypto.c
index 3fff05c..b2a1ddc 100644
--- a/drivers/crypto/msm/qcrypto.c
+++ b/drivers/crypto/msm/qcrypto.c
@@ -733,9 +733,9 @@ static void _update_sha1_ctx(struct ahash_request  *req)
 	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
 
 	if (sha_ctx->last_blk == 1)
-		memset(sha_state_ctx, 0x00, sizeof(struct sha1_state));
+		(void)memset(sha_state_ctx, 0x00, sizeof(struct sha1_state));
 	else {
-		memset(sha_state_ctx->buffer, 0x00, SHA1_BLOCK_SIZE);
+		(void)memset(sha_state_ctx->buffer, 0x00, SHA1_BLOCK_SIZE);
 		memcpy(sha_state_ctx->buffer, sha_ctx->trailing_buf,
 						sha_ctx->trailing_buf_len);
 		_byte_stream_to_words(sha_state_ctx->state , sha_ctx->digest,
@@ -751,9 +751,9 @@ static void _update_sha256_ctx(struct ahash_request  *req)
 	struct qcrypto_sha_ctx *sha_ctx = crypto_tfm_ctx(req->base.tfm);
 
 	if (sha_ctx->last_blk == 1)
-		memset(sha_state_ctx, 0x00, sizeof(struct sha256_state));
+		(void)memset(sha_state_ctx, 0x00, sizeof(struct sha256_state));
 	else {
-		memset(sha_state_ctx->buf, 0x00, SHA256_BLOCK_SIZE);
+		(void)memset(sha_state_ctx->buf, 0x00, SHA256_BLOCK_SIZE);
 		memcpy(sha_state_ctx->buf, sha_ctx->trailing_buf,
 						sha_ctx->trailing_buf_len);
 		_byte_stream_to_words(sha_state_ctx->state, sha_ctx->digest,
@@ -917,7 +917,7 @@ static int aead_ccm_set_msg_len(u8 *block, unsigned int msglen, int csize)
 {
 	__be32 data;
 
-	memset(block, 0, csize);
+	(void)memset(block, 0, csize);
 	block += csize;
 
 	if (csize >= 4)
@@ -1658,7 +1658,7 @@ static int _qcrypto_aead_setkey(struct crypto_aead *tfm, const u8 *key,
 	if (ctx->enc_key_len >= QCRYPTO_MAX_KEY_SIZE ||
 				ctx->auth_key_len >= QCRYPTO_MAX_KEY_SIZE)
 		goto badkey;
-	memset(ctx->auth_key, 0, QCRYPTO_MAX_KEY_SIZE);
+	(void)memset(ctx->auth_key, 0, QCRYPTO_MAX_KEY_SIZE);
 	memcpy(ctx->enc_key, key + ctx->auth_key_len, ctx->enc_key_len);
 	memcpy(ctx->auth_key, key, ctx->auth_key_len);
 
@@ -2002,7 +2002,7 @@ static int _sha1_init(struct ahash_request *req)
 	_sha_init(sha_ctx);
 	sha_ctx->alg = QCE_HASH_SHA1;
 
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
+	(void)memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
 	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
 						SHA1_DIGEST_SIZE);
 	sha_ctx->diglen = SHA1_DIGEST_SIZE;
@@ -2023,7 +2023,7 @@ static int _sha256_init(struct ahash_request *req)
 	_sha_init(sha_ctx);
 	sha_ctx->alg = QCE_HASH_SHA256;
 
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
+	(void)memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
 	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
 						SHA256_DIGEST_SIZE);
 	sha_ctx->diglen = SHA256_DIGEST_SIZE;
@@ -2410,7 +2410,7 @@ static int _sha1_hmac_init(struct ahash_request *req)
 	pstat->sha1_hmac_digest++;
 
 	_sha_init(sha_ctx);
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
+	(void)memset(&sha_ctx->trailing_buf[0], 0x00, SHA1_BLOCK_SIZE);
 	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha1_uint8[0],
 						SHA1_DIGEST_SIZE);
 	sha_ctx->diglen = SHA1_DIGEST_SIZE;
@@ -2437,7 +2437,7 @@ static int _sha256_hmac_init(struct ahash_request *req)
 	pstat->sha256_hmac_digest++;
 
 	_sha_init(sha_ctx);
-	memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
+	(void)memset(&sha_ctx->trailing_buf[0], 0x00, SHA256_BLOCK_SIZE);
 	memcpy(&sha_ctx->digest[0], &_std_init_vector_sha256_uint8[0],
 						SHA256_DIGEST_SIZE);
 	sha_ctx->diglen = SHA256_DIGEST_SIZE;
@@ -3293,7 +3293,7 @@ static ssize_t _debug_stats_write(struct file *file, const char __user *buf,
 
 	int qcrypto = *((int *) file->private_data);
 
-	memset((char *)&_qcrypto_stat[qcrypto], 0, sizeof(struct crypto_stat));
+	(void)memset((char *)&_qcrypto_stat[qcrypto], 0, sizeof(struct crypto_stat));
 	return count;
 };
 
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index a971e3d..5dfa6e6 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -1236,7 +1236,7 @@ void gpio_free(unsigned gpio)
 	might_sleep();
 
 	if (!gpio_is_valid(gpio)) {
-		WARN_ON(extra_checks);
+		(void)WARN_ON(extra_checks);
 		return;
 	}
 
@@ -1258,7 +1258,7 @@ void gpio_free(unsigned gpio)
 		clear_bit(FLAG_ACTIVE_LOW, &desc->flags);
 		clear_bit(FLAG_REQUESTED, &desc->flags);
 	} else
-		WARN_ON(extra_checks);
+		(void)WARN_ON(extra_checks);
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 }
@@ -1556,7 +1556,7 @@ int __gpio_get_value(unsigned gpio)
 	int value;
 
 	chip = gpio_to_chip(gpio);
-	WARN_ON(chip->can_sleep);
+	(void)WARN_ON(chip->can_sleep);
 	value = chip->get ? chip->get(chip, gpio - chip->base) : 0;
 	trace_gpio_value(gpio, 1, value);
 	return value;
@@ -1577,7 +1577,7 @@ void __gpio_set_value(unsigned gpio, int value)
 	struct gpio_chip	*chip;
 
 	chip = gpio_to_chip(gpio);
-	WARN_ON(chip->can_sleep);
+	(void)WARN_ON(chip->can_sleep);
 	trace_gpio_value(gpio, 0, value);
 	chip->set(chip, gpio - chip->base, value);
 }
diff --git a/drivers/gpio/sx150x.c b/drivers/gpio/sx150x.c
index 93b94bd..fb2b3fc 100644
--- a/drivers/gpio/sx150x.c
+++ b/drivers/gpio/sx150x.c
@@ -625,7 +625,7 @@ static int __devinit sx150x_probe(struct i2c_client *client,
 
 	return 0;
 probe_fail_post_gpiochip_add:
-	WARN_ON(gpiochip_remove(&chip->gpio_chip) < 0);
+	(void)WARN_ON(gpiochip_remove(&chip->gpio_chip) < 0);
 probe_fail_pre_gpiochip_add:
 	kfree(chip);
 	return rc;
diff --git a/drivers/gpu/msm/adreno.c b/drivers/gpu/msm/adreno.c
index 03e447b..ed0977c 100644
--- a/drivers/gpu/msm/adreno.c
+++ b/drivers/gpu/msm/adreno.c
@@ -759,7 +759,7 @@ static int adreno_getproperty(struct kgsl_device *device,
 				break;
 			}
 
-			memset(&devinfo, 0, sizeof(devinfo));
+			(void)memset(&devinfo, 0, sizeof(devinfo));
 			devinfo.device_id = device->id+1;
 			devinfo.chip_id = adreno_dev->chip_id;
 			devinfo.mmu_enabled = kgsl_mmu_enabled();
@@ -785,7 +785,7 @@ static int adreno_getproperty(struct kgsl_device *device,
 				status = -EINVAL;
 				break;
 			}
-			memset(&shadowprop, 0, sizeof(shadowprop));
+			(void)memset(&shadowprop, 0, sizeof(shadowprop));
 			if (device->memstore.hostptr) {
 				/*NOTE: with mmu enabled, gpuaddr doesn't mean
 				 * anything to mmap().
@@ -898,7 +898,7 @@ static unsigned int adreno_isidle(struct kgsl_device *device)
 	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 	unsigned int rbbm_status;
 
-	WARN_ON(device->state == KGSL_STATE_INIT);
+	(void)WARN_ON(device->state == KGSL_STATE_INIT);
 	/* If the device isn't active, don't force it on. */
 	if (device->state == KGSL_STATE_ACTIVE) {
 		/* Is the ring buffer is empty? */
diff --git a/drivers/gpu/msm/adreno_debugfs.c b/drivers/gpu/msm/adreno_debugfs.c
index c1b9e4c..982b3a6 100644
--- a/drivers/gpu/msm/adreno_debugfs.c
+++ b/drivers/gpu/msm/adreno_debugfs.c
@@ -157,7 +157,7 @@ static ssize_t kgsl_istore_read(
 						    ADRENO_ISTORE_START + i + j,
 						    vals + j);
 		} else
-			memset(vals, 0, sizeof(vals));
+			(void)memset(vals, 0, sizeof(vals));
 
 		ss = kgsl_hex_dump("IS: %04x: ", i, (uint8_t *)vals, rowc*4,
 			linec*4, buff);
diff --git a/drivers/gpu/msm/adreno_ringbuffer.c b/drivers/gpu/msm/adreno_ringbuffer.c
index 7ace67a..0420a27 100644
--- a/drivers/gpu/msm/adreno_ringbuffer.c
+++ b/drivers/gpu/msm/adreno_ringbuffer.c
@@ -450,7 +450,7 @@ void adreno_ringbuffer_close(struct adreno_ringbuffer *rb)
 	adreno_dev->pfp_fw = NULL;
 	adreno_dev->pm4_fw = NULL;
 
-	memset(rb, 0, sizeof(struct adreno_ringbuffer));
+	(void)memset(rb, 0, sizeof(struct adreno_ringbuffer));
 }
 
 static uint32_t
diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index e9c3f08..9e40196 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -1919,7 +1919,7 @@ static long kgsl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 				goto done;
 			}
 		} else
-			memset(uptr, 0, _IOC_SIZE(cmd));
+			(void)memset(uptr, 0, _IOC_SIZE(cmd));
 	}
 
 	if (nr < ARRAY_SIZE(kgsl_ioctl_funcs) &&
diff --git a/drivers/gpu/msm/kgsl_gpummu.c b/drivers/gpu/msm/kgsl_gpummu.c
index fe5677e..2eac262 100644
--- a/drivers/gpu/msm/kgsl_gpummu.c
+++ b/drivers/gpu/msm/kgsl_gpummu.c
@@ -278,7 +278,7 @@ static void kgsl_ptpool_free(struct kgsl_ptpool *pool, void *addr)
 				pool->ptsize;
 
 			clear_bit(bit, chunk->bitmap);
-			memset(addr, 0, pool->ptsize);
+			(void)memset(addr, 0, pool->ptsize);
 
 			if (chunk->dynamic &&
 				bitmap_empty(chunk->bitmap, chunk->count))
@@ -448,7 +448,7 @@ static void *kgsl_gpummu_create_pagetable(void)
 			gpummu_pt->tlbflushfilter.size);
 		goto err_free_gpummu;
 	}
-	GSL_TLBFLUSH_FILTER_RESET();
+	(void)GSL_TLBFLUSH_FILTER_RESET();
 
 	gpummu_pt->base.hostptr = kgsl_ptpool_alloc((struct kgsl_ptpool *)
 						kgsl_driver.ptpool,
@@ -701,7 +701,7 @@ kgsl_gpummu_map(void *mmu_specific_pt,
 	if (flushtlb) {
 		/*set all devices as needing flushing*/
 		gpummu_pt->tlb_flags = UINT_MAX;
-		GSL_TLBFLUSH_FILTER_RESET();
+		(void)GSL_TLBFLUSH_FILTER_RESET();
 	}
 
 	return 0;
diff --git a/drivers/gpu/msm/kgsl_pwrctrl.c b/drivers/gpu/msm/kgsl_pwrctrl.c
index c29da39..27d06b0 100644
--- a/drivers/gpu/msm/kgsl_pwrctrl.c
+++ b/drivers/gpu/msm/kgsl_pwrctrl.c
@@ -586,7 +586,7 @@ void kgsl_idle_check(struct work_struct *work)
 {
 	struct kgsl_device *device = container_of(work, struct kgsl_device,
 							idle_check_ws);
-	WARN_ON(device == NULL);
+	(void)WARN_ON(device == NULL);
 	if (device == NULL)
 		return;
 
diff --git a/drivers/gpu/msm/kgsl_sharedmem.c b/drivers/gpu/msm/kgsl_sharedmem.c
index ec91b39..c9130d1 100644
--- a/drivers/gpu/msm/kgsl_sharedmem.c
+++ b/drivers/gpu/msm/kgsl_sharedmem.c
@@ -556,7 +556,7 @@ void kgsl_sharedmem_free(struct kgsl_memdesc *memdesc)
 
 	kfree(memdesc->sg);
 
-	memset(memdesc, 0, sizeof(*memdesc));
+	(void)memset(memdesc, 0, sizeof(*memdesc));
 }
 EXPORT_SYMBOL(kgsl_sharedmem_free);
 
@@ -637,7 +637,7 @@ kgsl_sharedmem_readl(const struct kgsl_memdesc *memdesc,
 			unsigned int offsetbytes)
 {
 	BUG_ON(memdesc == NULL || memdesc->hostptr == NULL || dst == NULL);
-	WARN_ON(offsetbytes + sizeof(unsigned int) > memdesc->size);
+	(void)WARN_ON(offsetbytes + sizeof(unsigned int) > memdesc->size);
 
 	if (offsetbytes + sizeof(unsigned int) > memdesc->size)
 		return -ERANGE;
@@ -671,7 +671,7 @@ kgsl_sharedmem_set(const struct kgsl_memdesc *memdesc, unsigned int offsetbytes,
 
 	kgsl_cffdump_setmem(memdesc->gpuaddr + offsetbytes, value,
 			    sizebytes);
-	memset(memdesc->hostptr + offsetbytes, value, sizebytes);
+	(void)memset(memdesc->hostptr + offsetbytes, value, sizebytes);
 	return 0;
 }
 EXPORT_SYMBOL(kgsl_sharedmem_set);
diff --git a/drivers/gpu/msm/z180.c b/drivers/gpu/msm/z180.c
index 718fac9..6ab69f4 100644
--- a/drivers/gpu/msm/z180.c
+++ b/drivers/gpu/msm/z180.c
@@ -490,7 +490,7 @@ error:
 static int z180_ringbuffer_init(struct kgsl_device *device)
 {
 	struct z180_device *z180_dev = Z180_DEVICE(device);
-	memset(&z180_dev->ringbuffer, 0, sizeof(struct z180_ringbuffer));
+	(void)memset(&z180_dev->ringbuffer, 0, sizeof(struct z180_ringbuffer));
 	z180_dev->ringbuffer.prevctx = Z180_INVALID_CONTEXT;
 	return kgsl_allocate_contiguous(&z180_dev->ringbuffer.cmdbufdesc,
 		Z180_RB_SIZE);
@@ -500,7 +500,7 @@ static void z180_ringbuffer_close(struct kgsl_device *device)
 {
 	struct z180_device *z180_dev = Z180_DEVICE(device);
 	kgsl_sharedmem_free(&z180_dev->ringbuffer.cmdbufdesc);
-	memset(&z180_dev->ringbuffer, 0, sizeof(struct z180_ringbuffer));
+	(void)memset(&z180_dev->ringbuffer, 0, sizeof(struct z180_ringbuffer));
 }
 
 static int __devinit z180_probe(struct platform_device *pdev)
@@ -611,7 +611,7 @@ static int z180_getproperty(struct kgsl_device *device,
 			break;
 		}
 
-		memset(&devinfo, 0, sizeof(devinfo));
+		(void)memset(&devinfo, 0, sizeof(devinfo));
 		devinfo.device_id = device->id+1;
 		devinfo.chip_id = 0;
 		devinfo.mmu_enabled = kgsl_mmu_enabled();
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 38c261a..00a2d13 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -216,7 +216,7 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	struct hid_device *hid = usb_get_intfdata(usbhid->intf);
 	int kicked;
 
-	WARN_ON(hid == NULL);
+	(void)WARN_ON(hid == NULL);
 	if (!hid)
 		return 0;
 
@@ -638,7 +638,7 @@ static int hid_get_class_descriptor(struct usb_device *dev, int ifnum,
 {
 	int result, retries = 4;
 
-	memset(buf, 0, size);
+	(void)memset(buf, 0, size);
 
 	do {
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
diff --git a/drivers/hwmon/m_adcproc.c b/drivers/hwmon/m_adcproc.c
index 70e505e..4664a88 100644
--- a/drivers/hwmon/m_adcproc.c
+++ b/drivers/hwmon/m_adcproc.c
@@ -296,7 +296,7 @@ int32_t scale_default(int32_t adc_code,
 					chan_properties->gain_denominator;
 
 	/* do_div only perform positive integer division! */
-	do_div(adc_chan_result->measurement, chan_properties->adc_graph->dy*
+	(void)do_div(adc_chan_result->measurement, chan_properties->adc_graph->dy*
 					chan_properties->gain_numerator);
 
 	if (negative_rawfromoffset)
@@ -362,7 +362,7 @@ int32_t scale_pmic_therm(int32_t adc_code,
 		adc_chan_result->measurement = (int64_t)rawfromoffset*
 					chan_properties->adc_graph->dx*
 					chan_properties->gain_denominator*1000;
-		do_div(adc_chan_result->measurement,
+		(void)do_div(adc_chan_result->measurement,
 			chan_properties->adc_graph->dy*
 			chan_properties->gain_numerator*2);
 	} else {
@@ -457,7 +457,7 @@ int32_t scale_xtern_chgr_cur(int32_t adc_code,
 		adc_chan_result->measurement = ((int64_t)rawfromoffset * 5)*
 						chan_properties->adc_graph->dx*
 					chan_properties->gain_denominator;
-		do_div(adc_chan_result->measurement,
+		(void)do_div(adc_chan_result->measurement,
 					chan_properties->adc_graph->dy*
 					chan_properties->gain_numerator);
 	} else {
diff --git a/drivers/input/keyboard/pmic8xxx-keypad.c b/drivers/input/keyboard/pmic8xxx-keypad.c
index 0866332..480fdf9 100644
--- a/drivers/input/keyboard/pmic8xxx-keypad.c
+++ b/drivers/input/keyboard/pmic8xxx-keypad.c
@@ -654,8 +654,8 @@ static int __devinit pmic8xxx_kp_probe(struct platform_device *pdev)
 	input_set_drvdata(kp->input, kp);
 
 	/* initialize keypad state */
-	memset(kp->keystate, 0xff, sizeof(kp->keystate));
-	memset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));
+	(void)memset(kp->keystate, 0xff, sizeof(kp->keystate));
+	(void)memset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));
 
 	rc = pmic8xxx_kpd_init(kp);
 	if (rc < 0) {
diff --git a/drivers/input/mouse/psmouse-base.c b/drivers/input/mouse/psmouse-base.c
index 3f74bae..94a51a5 100644
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@ -893,7 +893,7 @@ static const struct psmouse_protocol *psmouse_protocol_by_type(enum psmouse_type
 		if (psmouse_protocols[i].type == type)
 			return &psmouse_protocols[i];
 
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return &psmouse_protocols[0];
 }
 
diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c
index e06e045..789e91e 100644
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@ -403,7 +403,7 @@ static int synaptics_parse_hw_state(const unsigned char buf[],
 				    struct synaptics_data *priv,
 				    struct synaptics_hw_state *hw)
 {
-	memset(hw, 0, sizeof(struct synaptics_hw_state));
+	(void)memset(hw, 0, sizeof(struct synaptics_hw_state));
 
 	if (SYN_MODEL_NEWABS(priv->model_id)) {
 		hw->x = (((buf[3] & 0x10) << 8) |
diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index c8827ff..e1f05fc 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -238,7 +238,7 @@ static struct crypto_ablkcipher *any_tfm(struct crypt_config *cc)
 static int crypt_iv_plain_gen(struct crypt_config *cc, u8 *iv,
 			      struct dm_crypt_request *dmreq)
 {
-	memset(iv, 0, cc->iv_size);
+	(void)memset(iv, 0, cc->iv_size);
 	*(u32 *)iv = cpu_to_le32(dmreq->iv_sector & 0xffffffff);
 
 	return 0;
@@ -247,7 +247,7 @@ static int crypt_iv_plain_gen(struct crypt_config *cc, u8 *iv,
 static int crypt_iv_plain64_gen(struct crypt_config *cc, u8 *iv,
 				struct dm_crypt_request *dmreq)
 {
-	memset(iv, 0, cc->iv_size);
+	(void)memset(iv, 0, cc->iv_size);
 	*(u64 *)iv = cpu_to_le64(dmreq->iv_sector);
 
 	return 0;
@@ -290,7 +290,7 @@ static int crypt_iv_essiv_wipe(struct crypt_config *cc)
 	struct crypto_cipher *essiv_tfm;
 	int cpu, r, err = 0;
 
-	memset(essiv->salt, 0, salt_size);
+	(void)memset(essiv->salt, 0, salt_size);
 
 	for_each_possible_cpu(cpu) {
 		essiv_tfm = per_cpu_ptr(cc->cpu, cpu)->iv_private;
@@ -414,7 +414,7 @@ static int crypt_iv_essiv_gen(struct crypt_config *cc, u8 *iv,
 {
 	struct crypto_cipher *essiv_tfm = this_crypt_config(cc)->iv_private;
 
-	memset(iv, 0, cc->iv_size);
+	(void)memset(iv, 0, cc->iv_size);
 	*(u64 *)iv = cpu_to_le64(dmreq->iv_sector);
 	crypto_cipher_encrypt_one(essiv_tfm, iv, iv);
 
@@ -454,7 +454,7 @@ static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,
 {
 	__be64 val;
 
-	memset(iv, 0, cc->iv_size - sizeof(u64)); /* rest is cleared below */
+	(void)memset(iv, 0, cc->iv_size - sizeof(u64)); /* rest is cleared below */
 
 	val = cpu_to_be64(((u64)dmreq->iv_sector << cc->iv_gen_private.benbi.shift) + 1);
 	put_unaligned(val, (__be64 *)(iv + cc->iv_size - sizeof(u64)));
@@ -465,7 +465,7 @@ static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,
 static int crypt_iv_null_gen(struct crypt_config *cc, u8 *iv,
 			     struct dm_crypt_request *dmreq)
 {
-	memset(iv, 0, cc->iv_size);
+	(void)memset(iv, 0, cc->iv_size);
 
 	return 0;
 }
@@ -527,7 +527,7 @@ static int crypt_iv_lmk_wipe(struct crypt_config *cc)
 	struct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;
 
 	if (lmk->seed)
-		memset(lmk->seed, 0, LMK_SEED_SIZE);
+		(void)memset(lmk->seed, 0, LMK_SEED_SIZE);
 
 	return 0;
 }
diff --git a/drivers/md/dm-ioctl.c b/drivers/md/dm-ioctl.c
index 4cacdad..2edf19d 100644
--- a/drivers/md/dm-ioctl.c
+++ b/drivers/md/dm-ioctl.c
@@ -1533,7 +1533,7 @@ static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl **param)
 
 bad:
 	if (secure_data)
-		memset(dmi, 0, tmp.data_size);
+		(void)memset(dmi, 0, tmp.data_size);
 	vfree(dmi);
 	return -EFAULT;
 }
@@ -1640,7 +1640,7 @@ static int ctl_ioctl(uint command, struct dm_ioctl __user *user)
 
 out:
 	if (wipe_buffer)
-		memset(param, 0, input_param_size);
+		(void)memset(param, 0, input_param_size);
 
 	vfree(param);
 	return r;
diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c
index ebdae6e..9c8f1b3 100644
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -156,7 +156,7 @@ void *dm_vcalloc(unsigned long nmemb, unsigned long elem_size)
 	size = nmemb * elem_size;
 	addr = vmalloc(size);
 	if (addr)
-		memset(addr, 0, size);
+		(void)memset(addr, 0, size);
 
 	return addr;
 }
@@ -188,7 +188,7 @@ static int alloc_targets(struct dm_table *t, unsigned int num)
 		memcpy(n_targets, t->targets, sizeof(*n_targets) * n);
 	}
 
-	memset(n_highs + n, -1, sizeof(*n_highs) * (num - n));
+	(void)memset(n_highs + n, -1, sizeof(*n_highs) * (num - n));
 	vfree(t->highs);
 
 	t->num_allocated = num;
@@ -494,7 +494,7 @@ static int __table_get_device(struct dm_table *t, struct dm_target *ti,
 			return r;
 		}
 
-		format_dev_t(dd->dm_dev.name, dev);
+		(void)format_dev_t(dd->dm_dev.name, dev);
 
 		atomic_set(&dd->count, 0);
 		list_add(&dd->list, &t->devices);
@@ -750,7 +750,7 @@ int dm_table_add_target(struct dm_table *t, const char *type,
 		return r;
 
 	tgt = t->targets + t->num_targets;
-	memset(tgt, 0, sizeof(*tgt));
+	(void)memset(tgt, 0, sizeof(*tgt));
 
 	if (!len) {
 		DMERR("%s: zero-length target", dm_device_name(t->md));
@@ -1185,7 +1185,7 @@ static void dm_table_set_integrity(struct dm_table *t)
 
 	template_disk = dm_table_get_integrity_disk(t, true);
 	if (template_disk)
-		blk_integrity_register(dm_disk(t->md),
+		(void)blk_integrity_register(dm_disk(t->md),
 				       blk_get_integrity(template_disk));
 	else if (blk_integrity_is_initialized(dm_disk(t->md)))
 		DMWARN("%s: device no longer has a valid integrity profile",
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index 41abc6d..084ae27 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1057,7 +1057,7 @@ static struct bio *split_bvec(struct bio *bio, sector_t sector,
 	clone->bi_flags |= 1 << BIO_CLONED;
 
 	if (bio_integrity(bio)) {
-		bio_integrity_clone(clone, bio, GFP_NOIO, bs);
+		(void)bio_integrity_clone(clone, bio, GFP_NOIO, bs);
 		bio_integrity_trim(clone,
 				   bio_sector_offset(bio, idx, offset), len);
 	}
@@ -1084,7 +1084,7 @@ static struct bio *clone_bio(struct bio *bio, sector_t sector,
 	clone->bi_flags &= ~(1 << BIO_SEG_VALID);
 
 	if (bio_integrity(bio)) {
-		bio_integrity_clone(clone, bio, GFP_NOIO, bs);
+		(void)bio_integrity_clone(clone, bio, GFP_NOIO, bs);
 
 		if (idx != bio->bi_idx || clone->bi_size < bio->bi_size)
 			bio_integrity_trim(clone,
@@ -1101,7 +1101,7 @@ static struct dm_target_io *alloc_tio(struct clone_info *ci,
 
 	tio->io = ci->io;
 	tio->ti = ti;
-	memset(&tio->info, 0, sizeof(tio->info));
+	(void)memset(&tio->info, 0, sizeof(tio->info));
 
 	return tio;
 }
@@ -1516,7 +1516,7 @@ static struct request *clone_rq(struct request *rq, struct mapped_device *md,
 	tio->ti = NULL;
 	tio->orig = rq;
 	tio->error = 0;
-	memset(&tio->info, 0, sizeof(tio->info));
+	(void)memset(&tio->info, 0, sizeof(tio->info));
 
 	clone = &tio->clone;
 	if (setup_clone(clone, rq, tio)) {
@@ -1870,7 +1870,7 @@ static struct mapped_device *alloc_dev(int minor)
 	md->disk->private_data = md;
 	sprintf(md->disk->disk_name, "dm-%d", minor);
 	add_disk(md->disk);
-	format_dev_t(md->name, MKDEV(_major, minor));
+	(void)format_dev_t(md->name, MKDEV(_major, minor));
 
 	md->wq = alloc_workqueue("kdmflush",
 				 WQ_NON_REENTRANT | WQ_MEM_RECLAIM, 0);
@@ -2008,7 +2008,7 @@ static struct dm_table *__bind(struct mapped_device *md, struct dm_table *t,
 	 * Wipe any geometry if the size of the table changed.
 	 */
 	if (size != get_capacity(md->disk))
-		memset(&md->geometry, 0, sizeof(md->geometry));
+		(void)memset(&md->geometry, 0, sizeof(md->geometry));
 
 	__set_size(md, size);
 
@@ -2349,7 +2349,7 @@ static int lock_fs(struct mapped_device *md)
 {
 	int r;
 
-	WARN_ON(md->frozen_sb);
+	(void)WARN_ON(md->frozen_sb);
 
 	md->frozen_sb = freeze_bdev(md->bdev);
 	if (IS_ERR(md->frozen_sb)) {
diff --git a/drivers/media/common/tuners/mt20xx.c b/drivers/media/common/tuners/mt20xx.c
index d0e70e1..792567c 100644
--- a/drivers/media/common/tuners/mt20xx.c
+++ b/drivers/media/common/tuners/mt20xx.c
@@ -615,7 +615,7 @@ struct dvb_frontend *microtune_attach(struct dvb_frontend *fe,
 
 	//priv->radio_if2 = 10700 * 1000;	/* 10.7MHz - FM radio */
 
-	memset(buf,0,sizeof(buf));
+	(void)memset(buf,0,sizeof(buf));
 
 	name = "unknown";
 
diff --git a/drivers/media/common/tuners/tda18271-fe.c b/drivers/media/common/tuners/tda18271-fe.c
index 57022e8..b8117ec 100644
--- a/drivers/media/common/tuners/tda18271-fe.c
+++ b/drivers/media/common/tuners/tda18271-fe.c
@@ -1063,7 +1063,7 @@ static int tda18271_release(struct dvb_frontend *fe)
 	mutex_lock(&tda18271_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&tda18271_list_mutex);
 
diff --git a/drivers/media/common/tuners/tuner-simple.c b/drivers/media/common/tuners/tuner-simple.c
index f8ee29e..2c0b4e5 100644
--- a/drivers/media/common/tuners/tuner-simple.c
+++ b/drivers/media/common/tuners/tuner-simple.c
@@ -985,7 +985,7 @@ static int simple_release(struct dvb_frontend *fe)
 	mutex_lock(&tuner_simple_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&tuner_simple_list_mutex);
 
diff --git a/drivers/media/common/tuners/tuner-xc2028.c b/drivers/media/common/tuners/tuner-xc2028.c
index 16fba6b..5818bea 100644
--- a/drivers/media/common/tuners/tuner-xc2028.c
+++ b/drivers/media/common/tuners/tuner-xc2028.c
@@ -256,7 +256,7 @@ static void free_firmware(struct xc2028_data *priv)
 	priv->firm = NULL;
 	priv->firm_size = 0;
 
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 }
 
 static int load_all_firmwares(struct dvb_frontend *fe)
@@ -735,7 +735,7 @@ retry:
 	}
 
 	/* Updating BASE - forget about all currently loaded firmware */
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 
 	/* Reset is needed before loading firmware */
 	rc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);
@@ -854,7 +854,7 @@ read_not_reliable:
 	return 0;
 
 fail:
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 	if (retry_count < 8) {
 		msleep(50);
 		retry_count++;
@@ -1221,7 +1221,7 @@ static int xc2028_dvb_release(struct dvb_frontend *fe)
 	}
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&xc2028_list_mutex);
 
diff --git a/drivers/media/common/tuners/xc5000.c b/drivers/media/common/tuners/xc5000.c
index aa1b2e8..c03c857 100644
--- a/drivers/media/common/tuners/xc5000.c
+++ b/drivers/media/common/tuners/xc5000.c
@@ -1066,7 +1066,7 @@ static int xc5000_release(struct dvb_frontend *fe)
 	mutex_lock(&xc5000_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&xc5000_list_mutex);
 
diff --git a/drivers/media/radio/radio-tavarua.c b/drivers/media/radio/radio-tavarua.c
index 8f09b6a..fcd9fa6 100644
--- a/drivers/media/radio/radio-tavarua.c
+++ b/drivers/media/radio/radio-tavarua.c
@@ -382,7 +382,7 @@ static void tavarua_rds_read(struct tavarua_device *radio)
 		tmp[2] |= 0x40; /* corrected error(s) */
 
 		/* copy RDS block to internal buffer */
-		kfifo_in_locked(rds_buf, tmp, 3, &radio->buf_lock[TAVARUA_BUF_RAW_RDS]);
+		(void)kfifo_in_locked(rds_buf, tmp, 3, &radio->buf_lock[TAVARUA_BUF_RAW_RDS]);
 	}
 	/* wake up read queue */
 	if (kfifo_len(rds_buf))
@@ -449,7 +449,7 @@ static int copy_from_xfr(struct tavarua_device *radio,
 
 	struct kfifo *data_fifo = &radio->data_buf[buf_type];
 	unsigned char *xfr_regs = &radio->registers[XFRCTRL+1];
-	kfifo_in_locked(data_fifo, xfr_regs, n, &radio->buf_lock[buf_type]);
+	(void)kfifo_in_locked(data_fifo, xfr_regs, n, &radio->buf_lock[buf_type]);
 	return 0;
 }
 
@@ -2753,7 +2753,7 @@ static int tavarua_vidioc_s_ext_ctrls(struct file *file, void *priv,
 			FMDBG("chunk is %d", chunk_index);
 			bytes_to_copy = min(bytes_left, XFR_REG_NUM);
 			/*Clear the tx_data */
-			memset(tx_data, 0, XFR_REG_NUM);
+			(void)memset(tx_data, 0, XFR_REG_NUM);
 			if (copy_from_user(tx_data,
 				data + bytes_copied, bytes_to_copy))
 				return -EFAULT;
@@ -2766,7 +2766,7 @@ static int tavarua_vidioc_s_ext_ctrls(struct file *file, void *priv,
 			bytes_copied += bytes_to_copy;
 			bytes_left -= bytes_to_copy;
 		}
-		memset(tx_data, 0, XFR_REG_NUM);
+		(void)memset(tx_data, 0, XFR_REG_NUM);
 		/*Write the PS Header*/
 		FMDBG("Writing PS header\n");
 		extra_name_byte = (bytes_copied%8) ? 1 : 0;
@@ -2799,7 +2799,7 @@ static int tavarua_vidioc_s_ext_ctrls(struct file *file, void *priv,
 		while (bytes_left) {
 			chunk_index++;
 			bytes_to_copy = min(bytes_left, XFR_REG_NUM);
-			memset(tx_data, 0, XFR_REG_NUM);
+			(void)memset(tx_data, 0, XFR_REG_NUM);
 			if (copy_from_user(tx_data,
 				    data + bytes_copied, bytes_to_copy))
 				return -EFAULT;
@@ -3205,7 +3205,7 @@ static int tavarua_vidioc_s_ctrl(struct file *file, void *priv,
 	case V4L2_CID_PRIVATE_TAVARUA_STOP_RDS_TX_PS_NAME: {
 			FMDBG("In STOP_RDS_TX_PS_NAME\n");
 			/*Pass a sample PS string */
-			memset(tx_data, '0', XFR_REG_NUM);
+			(void)memset(tx_data, '0', XFR_REG_NUM);
 			FMDBG("Writing PS header\n");
 			retval = sync_write_xfr(radio, RDS_PS_0, tx_data);
 			FMDBG("retval of PS Header write: %d", retval);
@@ -3213,7 +3213,7 @@ static int tavarua_vidioc_s_ctrl(struct file *file, void *priv,
 		} break;
 
 	case V4L2_CID_PRIVATE_TAVARUA_STOP_RDS_TX_RT: {
-			memset(tx_data, '0', XFR_REG_NUM);
+			(void)memset(tx_data, '0', XFR_REG_NUM);
 			FMDBG("Writing RT header\n");
 			retval = sync_write_xfr(radio, RDS_RT_0, tx_data);
 			FMDBG("retval of Header write: %d", retval);
diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c
index 1c5cc65..529f7eb 100644
--- a/drivers/media/rc/ir-lirc-codec.c
+++ b/drivers/media/rc/ir-lirc-codec.c
@@ -75,7 +75,7 @@ static int ir_lirc_decode(struct rc_dev *dev, struct ir_raw_event ev)
 				lirc->gap_start));
 
 			/* Convert to ms and cap by LIRC_VALUE_MASK */
-			do_div(lirc->gap_duration, 1000);
+			(void)do_div(lirc->gap_duration, 1000);
 			lirc->gap_duration = min(lirc->gap_duration,
 							(u64)LIRC_VALUE_MASK);
 
diff --git a/drivers/media/video/gspca/gspca.c b/drivers/media/video/gspca/gspca.c
index 08ce994..826d3d3 100644
--- a/drivers/media/video/gspca/gspca.c
+++ b/drivers/media/video/gspca/gspca.c
@@ -1987,7 +1987,7 @@ static int read_alloc(struct gspca_dev *gspca_dev,
 	if (gspca_dev->nframes == 0) {
 		struct v4l2_requestbuffers rb;
 
-		memset(&rb, 0, sizeof rb);
+		(void)memset(&rb, 0, sizeof rb);
 		rb.count = gspca_dev->nbufread;
 		rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		rb.memory = GSPCA_MEMORY_READ;
@@ -1996,7 +1996,7 @@ static int read_alloc(struct gspca_dev *gspca_dev,
 			PDEBUG(D_STREAM, "read reqbuf err %d", ret);
 			return ret;
 		}
-		memset(&v4l2_buf, 0, sizeof v4l2_buf);
+		(void)memset(&v4l2_buf, 0, sizeof v4l2_buf);
 		v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		v4l2_buf.memory = GSPCA_MEMORY_READ;
 		for (i = 0; i < gspca_dev->nbufread; i++) {
@@ -2070,7 +2070,7 @@ static ssize_t dev_read(struct file *file, char __user *data,
 	timestamp.tv_sec--;
 	n = 2;
 	for (;;) {
-		memset(&v4l2_buf, 0, sizeof v4l2_buf);
+		(void)memset(&v4l2_buf, 0, sizeof v4l2_buf);
 		v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		v4l2_buf.memory = GSPCA_MEMORY_READ;
 		ret = vidioc_dqbuf(file, gspca_dev, &v4l2_buf);
diff --git a/drivers/media/video/msm/gemini/msm_gemini_core.c b/drivers/media/video/msm/gemini/msm_gemini_core.c
index 480500b..bb948d0 100644
--- a/drivers/media/video/msm/gemini/msm_gemini_core.c
+++ b/drivers/media/video/msm/gemini/msm_gemini_core.c
@@ -29,10 +29,10 @@ int msm_gemini_core_reset(uint8_t op_mode, void *base, int size)
 	unsigned long flags;
 	int rc = 0;
 	int tm = 500; /*500ms*/
-	memset(&fe_pingpong_buf, 0, sizeof(fe_pingpong_buf));
+	(void)memset(&fe_pingpong_buf, 0, sizeof(fe_pingpong_buf));
 	fe_pingpong_buf.is_fe = 1;
 	we_pingpong_index = 0;
-	memset(&we_pingpong_buf, 0, sizeof(we_pingpong_buf));
+	(void)memset(&we_pingpong_buf, 0, sizeof(we_pingpong_buf));
 	spin_lock_irqsave(&reset_lock, flags);
 	reset_done_ack = 0;
 	msm_gemini_hw_reset(base, size);
diff --git a/drivers/media/video/msm/imx074.c b/drivers/media/video/msm/imx074.c
index 636b402..758b3e4 100644
--- a/drivers/media/video/msm/imx074.c
+++ b/drivers/media/video/msm/imx074.c
@@ -212,7 +212,7 @@ static int32_t imx074_i2c_read(unsigned short raddr,
 	unsigned char buf[2];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = imx074_i2c_rxdata(imx074_client->addr, buf, rlen);
@@ -281,7 +281,7 @@ static int32_t imx074_i2c_write_b_sensor(unsigned short waddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[3];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = bdata;
@@ -298,7 +298,7 @@ static int16_t imx074_i2c_write_b_af(unsigned short saddr,
 {
 	int32_t rc;
 	unsigned char buf[2];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = baddr;
 	buf[1] = bdata;
 	rc = imx074_i2c_txdata(saddr, buf, 2);
diff --git a/drivers/media/video/msm/msm_camera.c b/drivers/media/video/msm/msm_camera.c
index 65b33c2..19dd448 100644
--- a/drivers/media/video/msm/msm_camera.c
+++ b/drivers/media/video/msm/msm_camera.c
@@ -1617,7 +1617,7 @@ static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
 		return -EFAULT;
 	}
 
-	memset(&axi_data, 0, sizeof(axi_data));
+	(void)memset(&axi_data, 0, sizeof(axi_data));
 	CDBG("%s: cmd_type %s\n", __func__, vfe_config_cmd[cfgcmd.cmd_type]);
 	switch (cfgcmd.cmd_type) {
 	case CMD_STATS_ENABLE:
@@ -1755,7 +1755,7 @@ static int msm_vpe_frame_cfg(struct msm_sync *sync,
 	struct msm_vpe_cfg_cmd *cfgcmd;
 	cfgcmd = (struct msm_vpe_cfg_cmd *)cfgcmdin;
 
-	memset(&axi_data, 0, sizeof(axi_data));
+	(void)memset(&axi_data, 0, sizeof(axi_data));
 	CDBG("In vpe_frame_cfg cfgcmd->cmd_type = %s\n",
 		vfe_config_cmd[cfgcmd->cmd_type]);
 	switch (cfgcmd->cmd_type) {
@@ -1819,7 +1819,7 @@ static int msm_frame_axi_cfg(struct msm_sync *sync,
 	struct msm_pmem_region region[MAX_PMEM_CFG_BUFFERS];
 	int pmem_type;
 
-	memset(&axi_data, 0, sizeof(axi_data));
+	(void)memset(&axi_data, 0, sizeof(axi_data));
 
 	switch (cfgcmd->cmd_type) {
 
@@ -2183,7 +2183,7 @@ static int msm_stats_axi_cfg(struct msm_sync *sync,
 	struct msm_pmem_region region[3];
 	int pmem_type = MSM_PMEM_MAX;
 
-	memset(&axi_data, 0, sizeof(axi_data));
+	(void)memset(&axi_data, 0, sizeof(axi_data));
 
 	switch (cfgcmd->cmd_type) {
 	case CMD_STATS_AXI_CFG:
@@ -3486,7 +3486,7 @@ static void msm_vfe_sync(struct msm_vfe_resp *vdata,
 		if (sync->vpefn.vpe_cfg_update) {
 			CDBG("dis_en = %d\n", *sync->vpefn.dis);
 			if (*(sync->vpefn.dis)) {
-				memset(&(vdata->vpe_bf), 0,
+				(void)memset(&(vdata->vpe_bf), 0,
 					sizeof(vdata->vpe_bf));
 
 				if (sync->cropinfo != NULL)
diff --git a/drivers/media/video/msm/msm_vfe31.c b/drivers/media/video/msm/msm_vfe31.c
index b22b6c5..5e8fb5f 100644
--- a/drivers/media/video/msm/msm_vfe31.c
+++ b/drivers/media/video/msm/msm_vfe31.c
@@ -947,22 +947,22 @@ static void vfe31_reset_internal_variables(void)
 	vfe31_ctrl->vfeFrameSkipPeriod  = 31;
 
 	/* Stats control variables. */
-	memset(&(vfe31_ctrl->afStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->afStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 
-	memset(&(vfe31_ctrl->awbStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->awbStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 
-	memset(&(vfe31_ctrl->aecStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->aecStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 
-	memset(&(vfe31_ctrl->ihistStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->ihistStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 
-	memset(&(vfe31_ctrl->rsStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->rsStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 
-	memset(&(vfe31_ctrl->csStatsControl), 0,
+	(void)memset(&(vfe31_ctrl->csStatsControl), 0,
 		sizeof(struct vfe_stats_control));
 }
 
@@ -3497,7 +3497,7 @@ static irqreturn_t vfe31_parse_irq(int irq_num, void *data)
 	struct vfe31_isr_queue_cmd *qcmd;
 	uint32_t *val;
 	CDBG("vfe_parse_irq\n");
-	memset(&irq, 0, sizeof(struct vfe31_irq_status));
+	(void)memset(&irq, 0, sizeof(struct vfe31_irq_status));
 
 	val = (uint32_t *)(vfe31_ctrl->vfebase + VFE_IRQ_STATUS_0);
 	irq.vfeIrqStatus0 = msm_io_r(val);
diff --git a/drivers/media/video/msm/msm_vpe1.c b/drivers/media/video/msm/msm_vpe1.c
index 891816f..6bec2a2 100644
--- a/drivers/media/video/msm/msm_vpe1.c
+++ b/drivers/media/video/msm/msm_vpe1.c
@@ -90,7 +90,7 @@ static   struct vpe_cmd_type vpe_cmd[] = {
 
 static long long vpe_do_div(long long num, long long den)
 {
-	do_div(num, den);
+	(void)do_div(num, den);
 	return num;
 }
 
@@ -1360,7 +1360,7 @@ static int __msm_vpe_probe(struct platform_device *pdev)
 	/* first allocate */
 
 	vpe_device = &vpe_device_data;
-	memset(vpe_device, 0, sizeof(struct vpe_device_type));
+	(void)memset(vpe_device, 0, sizeof(struct vpe_device_type));
 
 	/* does the device exist? */
 	vpeirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
diff --git a/drivers/media/video/msm/mt9d113.c b/drivers/media/video/msm/mt9d113.c
index 8e81bda..46bbc4c 100644
--- a/drivers/media/video/msm/mt9d113.c
+++ b/drivers/media/video/msm/mt9d113.c
@@ -88,7 +88,7 @@ static int32_t mt9d113_i2c_read(unsigned short   saddr,
 	unsigned char buf[4];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	switch (width) {
 	case WORD_LEN: {
 			buf[0] = (raddr & 0xFF00)>>8;
@@ -132,7 +132,7 @@ static int32_t mt9d113_i2c_write(unsigned short saddr,
 {
 	int32_t rc = -EIO;
 	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	switch (width) {
 	case WORD_LEN: {
 			buf[0] = (waddr & 0xFF00)>>8;
diff --git a/drivers/media/video/msm/mt9e013.c b/drivers/media/video/msm/mt9e013.c
index 94546f4..9da857b 100644
--- a/drivers/media/video/msm/mt9e013.c
+++ b/drivers/media/video/msm/mt9e013.c
@@ -144,7 +144,7 @@ static int32_t mt9e013_i2c_read(unsigned short raddr,
 	unsigned char buf[2];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = mt9e013_i2c_rxdata(mt9e013_client->addr<<1, buf, rlen);
@@ -161,7 +161,7 @@ static int32_t mt9e013_i2c_write_w_sensor(unsigned short waddr, uint16_t wdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = (wdata & 0xFF00) >> 8;
@@ -179,7 +179,7 @@ static int32_t mt9e013_i2c_write_b_sensor(unsigned short waddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[3];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = bdata;
diff --git a/drivers/media/video/msm/ov7692.c b/drivers/media/video/msm/ov7692.c
index 7372156..d3822a5 100644
--- a/drivers/media/video/msm/ov7692.c
+++ b/drivers/media/video/msm/ov7692.c
@@ -260,7 +260,7 @@ static int32_t ov7692_i2c_read(uint8_t raddr,
 	unsigned char buf[1];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = raddr;
 	rc = ov7692_i2c_rxdata(ov7692_client->addr >> 1, buf, rlen);
 	if (rc < 0) {
@@ -274,7 +274,7 @@ static int32_t ov7692_i2c_write_b_sensor(uint8_t waddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[2];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = waddr;
 	buf[1] = bdata;
 	CDBG("i2c_write_b addr = 0x%x, val = 0x%x\n", waddr, bdata);
diff --git a/drivers/media/video/msm/qs_s5k4e1.c b/drivers/media/video/msm/qs_s5k4e1.c
index 64db015..43e1ef7 100644
--- a/drivers/media/video/msm/qs_s5k4e1.c
+++ b/drivers/media/video/msm/qs_s5k4e1.c
@@ -163,7 +163,7 @@ static int32_t qs_s5k4e1_i2c_read(unsigned short raddr,
 	unsigned char buf[2];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = qs_s5k4e1_i2c_rxdata(qs_s5k4e1_client->addr>>1, buf, rlen);
@@ -181,7 +181,7 @@ static int32_t qs_s5k4e1_i2c_write_w_sensor(unsigned short waddr,
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = (wdata & 0xFF00) >> 8;
@@ -199,7 +199,7 @@ static int32_t qs_s5k4e1_i2c_write_b_sensor(unsigned short waddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[3];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = bdata;
@@ -233,7 +233,7 @@ static int32_t qs_s5k4e1_i2c_write_seq_sensor(unsigned short waddr,
 	int32_t rc = -EFAULT;
 	unsigned char buf[len+2];
 	int i = 0;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	for (i = 0; i < len; i++)
@@ -246,7 +246,7 @@ static int32_t af_i2c_write_b_sensor(unsigned short baddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[2];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = baddr;
 	buf[1] = bdata;
 	CDBG("i2c_write_b addr = 0x%x, val = 0x%x\n", baddr, bdata);
@@ -262,7 +262,7 @@ static int32_t bridge_i2c_write_w(unsigned short waddr, uint16_t wdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = (wdata & 0xFF00) >> 8;
@@ -283,7 +283,7 @@ static int32_t bridge_i2c_read(unsigned short raddr,
 	unsigned char buf[2];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = qs_s5k4e1_i2c_rxdata(BRIDGE_ADDR>>1, buf, rlen);
@@ -306,7 +306,7 @@ static int32_t qs_s5k4e1_eeprom_i2c_read(unsigned short raddr,
 	if (!rdata)
 		return -EIO;
 
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = qs_s5k4e1_i2c_rxdata(i2caddr, buf, rlen);
diff --git a/drivers/media/video/msm/vx6953.c b/drivers/media/video/msm/vx6953.c
index 3b8f14c..41e93d9 100644
--- a/drivers/media/video/msm/vx6953.c
+++ b/drivers/media/video/msm/vx6953.c
@@ -2034,7 +2034,7 @@ static int32_t vx6953_i2c_read(unsigned short raddr,
 	unsigned char buf[2];
 	if (!rdata)
 		return -EIO;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (raddr & 0xFF00) >> 8;
 	buf[1] = (raddr & 0x00FF);
 	rc = vx6953_i2c_rxdata(vx6953_client->addr>>1, buf, rlen);
@@ -2049,7 +2049,7 @@ static int32_t vx6953_i2c_write_b_sensor(unsigned short waddr, uint8_t bdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[3];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = bdata;
@@ -2065,7 +2065,7 @@ static int32_t vx6953_i2c_write_w_sensor(unsigned short waddr, uint16_t wdata)
 {
 	int32_t rc = -EFAULT;
 	unsigned char buf[4];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	buf[2] = (wdata & 0xFF00) >> 8;
@@ -2084,7 +2084,7 @@ static int32_t vx6953_i2c_write_seq_sensor(unsigned short waddr,
 	int32_t rc = -EFAULT;
 	unsigned char buf[len+2];
 	int i;
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 	buf[0] = (waddr & 0xFF00) >> 8;
 	buf[1] = (waddr & 0x00FF);
 	for (i = 2; i < len+2; i++)
diff --git a/drivers/media/video/uvc/uvc_ctrl.c b/drivers/media/video/uvc/uvc_ctrl.c
index a4db26f..b6d6391 100644
--- a/drivers/media/video/uvc/uvc_ctrl.c
+++ b/drivers/media/video/uvc/uvc_ctrl.c
@@ -905,7 +905,7 @@ int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		goto done;
 	}
 
-	memset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);
+	(void)memset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);
 	v4l2_ctrl->id = mapping->id;
 	v4l2_ctrl->type = mapping->v4l2_type;
 	strlcpy(v4l2_ctrl->name, mapping->name, sizeof v4l2_ctrl->name);
@@ -995,7 +995,7 @@ int uvc_query_v4l2_menu(struct uvc_video_chain *chain,
 	u32 id = query_menu->id;
 	int ret;
 
-	memset(query_menu, 0, sizeof(*query_menu));
+	(void)memset(query_menu, 0, sizeof(*query_menu));
 	query_menu->id = id;
 	query_menu->index = index;
 
@@ -1251,7 +1251,7 @@ int uvc_ctrl_set(struct uvc_video_chain *chain,
 	 */
 	if (!ctrl->loaded && (ctrl->info.size * 8) != mapping->size) {
 		if ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0) {
-			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
+			(void)memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl->info.size);
 		} else {
 			ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
diff --git a/drivers/media/video/uvc/uvc_driver.c b/drivers/media/video/uvc/uvc_driver.c
index b6eae48..81b0b7a 100644
--- a/drivers/media/video/uvc/uvc_driver.c
+++ b/drivers/media/video/uvc/uvc_driver.c
@@ -399,7 +399,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 
 		/* Create a dummy frame descriptor. */
 		frame = &format->frame[0];
-		memset(&format->frame[0], 0, sizeof format->frame[0]);
+		(void)memset(&format->frame[0], 0, sizeof format->frame[0]);
 		frame->bFrameIntervalType = 1;
 		frame->dwDefaultFrameInterval = 1;
 		frame->dwFrameInterval = *intervals;
diff --git a/drivers/media/video/uvc/uvc_queue.c b/drivers/media/video/uvc/uvc_queue.c
index f90ce9f..5f8fc94 100644
--- a/drivers/media/video/uvc/uvc_queue.c
+++ b/drivers/media/video/uvc/uvc_queue.c
@@ -165,7 +165,7 @@ int uvc_alloc_buffers(struct uvc_video_queue *queue, unsigned int nbuffers,
 	}
 
 	for (i = 0; i < nbuffers; ++i) {
-		memset(&queue->buffer[i], 0, sizeof queue->buffer[i]);
+		(void)memset(&queue->buffer[i], 0, sizeof queue->buffer[i]);
 		queue->buffer[i].buf.index = i;
 		queue->buffer[i].buf.m.offset = i * bufsize;
 		queue->buffer[i].buf.length = buflength;
diff --git a/drivers/media/video/uvc/uvc_v4l2.c b/drivers/media/video/uvc/uvc_v4l2.c
index 543a803..e80d81f 100644
--- a/drivers/media/video/uvc/uvc_v4l2.c
+++ b/drivers/media/video/uvc/uvc_v4l2.c
@@ -209,7 +209,7 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 		(100000000/interval)%10);
 
 	/* Set the format index, frame index and frame interval. */
-	memset(probe, 0, sizeof *probe);
+	(void)memset(probe, 0, sizeof *probe);
 	probe->bmHint = 1;	/* dwFrameInterval */
 	probe->bFormatIndex = format->index;
 	probe->bFrameIndex = frame->bFrameIndex;
@@ -333,7 +333,7 @@ static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 	denominator = 10000000;
 	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
 
-	memset(parm, 0, sizeof *parm);
+	(void)memset(parm, 0, sizeof *parm);
 	parm->type = stream->type;
 
 	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
@@ -566,7 +566,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 	{
 		struct v4l2_capability *cap = arg;
 
-		memset(cap, 0, sizeof *cap);
+		(void)memset(cap, 0, sizeof *cap);
 		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 		strlcpy(cap->card, vdev->name, sizeof cap->card);
 		usb_make_path(stream->dev->udev,
@@ -590,7 +590,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		struct v4l2_control *ctrl = arg;
 		struct v4l2_ext_control xctrl;
 
-		memset(&xctrl, 0, sizeof xctrl);
+		(void)memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 
 		ret = uvc_ctrl_begin(chain);
@@ -609,7 +609,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		struct v4l2_control *ctrl = arg;
 		struct v4l2_ext_control xctrl;
 
-		memset(&xctrl, 0, sizeof xctrl);
+		(void)memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 		xctrl.value = ctrl->value;
 
@@ -714,7 +714,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		if (iterm == NULL || iterm->id != pin)
 			return -EINVAL;
 
-		memset(input, 0, sizeof *input);
+		(void)memset(input, 0, sizeof *input);
 		input->index = index;
 		strlcpy(input->name, iterm->name, sizeof input->name);
 		if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
@@ -776,7 +776,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		    fmt->index >= stream->nformats)
 			return -EINVAL;
 
-		memset(fmt, 0, sizeof(*fmt));
+		(void)memset(fmt, 0, sizeof(*fmt));
 		fmt->index = index;
 		fmt->type = type;
 
diff --git a/drivers/media/video/v4l2-common.c b/drivers/media/video/v4l2-common.c
index 06b9f9f..74fda0f 100644
--- a/drivers/media/video/v4l2-common.c
+++ b/drivers/media/video/v4l2-common.c
@@ -360,7 +360,7 @@ struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,
 
 	/* Setup the i2c board info with the device type and
 	   the device address. */
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.type, client_type, sizeof(info.type));
 	info.addr = addr;
 
diff --git a/drivers/media/video/v4l2-ctrls.c b/drivers/media/video/v4l2-ctrls.c
index 2412f08..22f2f96 100644
--- a/drivers/media/video/v4l2-ctrls.c
+++ b/drivers/media/video/v4l2-ctrls.c
@@ -1008,7 +1008,7 @@ static struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,
 		ctrl->cur.string = (char *)&ctrl[1] + sz_extra - (max + 1);
 		ctrl->string = (char *)&ctrl[1] + sz_extra - 2 * (max + 1);
 		if (ctrl->minimum)
-			memset(ctrl->cur.string, ' ', ctrl->minimum);
+			(void)memset(ctrl->cur.string, ' ', ctrl->minimum);
 	}
 	if (handler_new_ref(hdl, ctrl)) {
 		kfree(ctrl);
@@ -1040,9 +1040,9 @@ struct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,
 
 	is_menu = (cfg->type == V4L2_CTRL_TYPE_MENU);
 	if (is_menu)
-		WARN_ON(step);
+		(void)WARN_ON(step);
 	else
-		WARN_ON(cfg->menu_skip_mask);
+		(void)WARN_ON(cfg->menu_skip_mask);
 	if (is_menu && qmenu == NULL)
 		qmenu = v4l2_ctrl_get_menu(cfg->id);
 
@@ -1343,7 +1343,7 @@ int v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc)
 		return -EINVAL;
 
 	ctrl = ref->ctrl;
-	memset(qc, 0, sizeof(*qc));
+	(void)memset(qc, 0, sizeof(*qc));
 	if (id >= V4L2_CID_PRIVATE_BASE)
 		qc->id = id;
 	else
@@ -1628,7 +1628,7 @@ s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)
 	s32 val = 0;
 
 	/* It's a driver bug if this happens. */
-	WARN_ON(!type_is_int(ctrl));
+	(void)WARN_ON(!type_is_int(ctrl));
 	get_ctrl(ctrl, &val);
 	return val;
 }
@@ -1869,7 +1869,7 @@ EXPORT_SYMBOL(v4l2_subdev_s_ctrl);
 int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)
 {
 	/* It's a driver bug if this happens. */
-	WARN_ON(!type_is_int(ctrl));
+	(void)WARN_ON(!type_is_int(ctrl));
 	return set_ctrl(ctrl, &val);
 }
 EXPORT_SYMBOL(v4l2_ctrl_s_ctrl);
diff --git a/drivers/media/video/v4l2-dev.c b/drivers/media/video/v4l2-dev.c
index 06f1400..9e2dd50 100644
--- a/drivers/media/video/v4l2-dev.c
+++ b/drivers/media/video/v4l2-dev.c
@@ -149,7 +149,7 @@ static void v4l2_device_release(struct device *cd)
 	if (video_device[vdev->minor] != vdev) {
 		mutex_unlock(&videodev_lock);
 		/* should not happen */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -205,7 +205,7 @@ static inline bool prio_is_valid(enum v4l2_priority prio)
 
 void v4l2_prio_init(struct v4l2_prio_state *global)
 {
-	memset(global, 0, sizeof(*global));
+	(void)memset(global, 0, sizeof(*global));
 }
 EXPORT_SYMBOL(v4l2_prio_init);
 
@@ -545,7 +545,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 	vdev->minor = -1;
 
 	/* the release callback MUST be present */
-	WARN_ON(!vdev->release);
+	(void)WARN_ON(!vdev->release);
 	if (!vdev->release)
 		return -EINVAL;
 
@@ -643,7 +643,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 	devnode_set(vdev);
 
 	/* Should not happen since we thought this minor was free */
-	WARN_ON(video_device[vdev->minor] != NULL);
+	(void)WARN_ON(video_device[vdev->minor] != NULL);
 	vdev->index = get_index(vdev);
 	mutex_unlock(&videodev_lock);
 
diff --git a/drivers/media/video/v4l2-device.c b/drivers/media/video/v4l2-device.c
index 4aae501..9656609 100644
--- a/drivers/media/video/v4l2-device.c
+++ b/drivers/media/video/v4l2-device.c
@@ -41,7 +41,7 @@ int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)
 	v4l2_dev->dev = dev;
 	if (dev == NULL) {
 		/* If dev == NULL, then name must be filled in by the caller */
-		WARN_ON(!v4l2_dev->name[0]);
+		(void)WARN_ON(!v4l2_dev->name[0]);
 		return 0;
 	}
 
@@ -147,7 +147,7 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 		return -EINVAL;
 
 	/* Warn if we apparently re-register a subdev */
-	WARN_ON(sd->v4l2_dev != NULL);
+	(void)WARN_ON(sd->v4l2_dev != NULL);
 
 	if (!try_module_get(sd->owner))
 		return -ENODEV;
diff --git a/drivers/media/video/v4l2-event.c b/drivers/media/video/v4l2-event.c
index 69fd343..7d37344 100644
--- a/drivers/media/video/v4l2-event.c
+++ b/drivers/media/video/v4l2-event.c
@@ -53,7 +53,7 @@ int v4l2_event_alloc(struct v4l2_fh *fh, unsigned int n)
 	unsigned long flags;
 
 	if (!events) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -ENOMEM;
 	}
 
@@ -111,7 +111,7 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 		return -ENOENT;
 	}
 
-	WARN_ON(events->navailable == 0);
+	(void)WARN_ON(events->navailable == 0);
 
 	kev = list_first_entry(&events->available, struct v4l2_kevent, list);
 	list_move(&kev->list, &events->free);
@@ -227,7 +227,7 @@ int v4l2_event_subscribe(struct v4l2_fh *fh,
 	unsigned long flags;
 
 	if (fh->events == NULL) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -ENOMEM;
 	}
 
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index 69e8c6f..d5821df 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -827,7 +827,7 @@ static long __video_do_ioctl(struct file *file,
 
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			if (ops->vidioc_s_fmt_vid_cap) {
 				ret = ops->vidioc_s_fmt_vid_cap(file, fh, f);
@@ -843,7 +843,7 @@ static long __video_do_ioctl(struct file *file,
 					/* Drivers shouldn't adjust from 1-plane
 					 * to more than 1-plane formats */
 					ret = -EBUSY;
-					WARN_ON(1);
+					(void)WARN_ON(1);
 					break;
 				}
 
@@ -851,7 +851,7 @@ static long __video_do_ioctl(struct file *file,
 			}
 			break;
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			if (ops->vidioc_s_fmt_vid_cap_mplane) {
 				ret = ops->vidioc_s_fmt_vid_cap_mplane(file,
@@ -869,13 +869,13 @@ static long __video_do_ioctl(struct file *file,
 			}
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-			CLEAR_AFTER_FIELD(f, fmt.win);
+			(void)CLEAR_AFTER_FIELD(f, fmt.win);
 			if (ops->vidioc_s_fmt_vid_overlay)
 				ret = ops->vidioc_s_fmt_vid_overlay(file,
 								    fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			if (ops->vidioc_s_fmt_vid_out) {
 				ret = ops->vidioc_s_fmt_vid_out(file, fh, f);
@@ -891,7 +891,7 @@ static long __video_do_ioctl(struct file *file,
 					/* Drivers shouldn't adjust from 1-plane
 					 * to more than 1-plane formats */
 					ret = -EBUSY;
-					WARN_ON(1);
+					(void)WARN_ON(1);
 					break;
 				}
 
@@ -899,7 +899,7 @@ static long __video_do_ioctl(struct file *file,
 			}
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			if (ops->vidioc_s_fmt_vid_out_mplane) {
 				ret = ops->vidioc_s_fmt_vid_out_mplane(file,
@@ -917,29 +917,29 @@ static long __video_do_ioctl(struct file *file,
 			}
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
-			CLEAR_AFTER_FIELD(f, fmt.win);
+			(void)CLEAR_AFTER_FIELD(f, fmt.win);
 			if (ops->vidioc_s_fmt_vid_out_overlay)
 				ret = ops->vidioc_s_fmt_vid_out_overlay(file,
 					fh, f);
 			break;
 		case V4L2_BUF_TYPE_VBI_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.vbi);
+			(void)CLEAR_AFTER_FIELD(f, fmt.vbi);
 			if (ops->vidioc_s_fmt_vbi_cap)
 				ret = ops->vidioc_s_fmt_vbi_cap(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_VBI_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.vbi);
+			(void)CLEAR_AFTER_FIELD(f, fmt.vbi);
 			if (ops->vidioc_s_fmt_vbi_out)
 				ret = ops->vidioc_s_fmt_vbi_out(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.sliced);
+			(void)CLEAR_AFTER_FIELD(f, fmt.sliced);
 			if (ops->vidioc_s_fmt_sliced_vbi_cap)
 				ret = ops->vidioc_s_fmt_sliced_vbi_cap(file,
 									fh, f);
 			break;
 		case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.sliced);
+			(void)CLEAR_AFTER_FIELD(f, fmt.sliced);
 			if (ops->vidioc_s_fmt_sliced_vbi_out)
 				ret = ops->vidioc_s_fmt_sliced_vbi_out(file,
 									fh, f);
@@ -962,7 +962,7 @@ static long __video_do_ioctl(struct file *file,
 						v4l2_type_names));
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			if (ops->vidioc_try_fmt_vid_cap) {
 				ret = ops->vidioc_try_fmt_vid_cap(file, fh, f);
 			} else if (ops->vidioc_try_fmt_vid_cap_mplane) {
@@ -977,7 +977,7 @@ static long __video_do_ioctl(struct file *file,
 					/* Drivers shouldn't adjust from 1-plane
 					 * to more than 1-plane formats */
 					ret = -EBUSY;
-					WARN_ON(1);
+					(void)WARN_ON(1);
 					break;
 				}
 				ret = fmt_mp_to_sp(&f_copy, f);
@@ -986,7 +986,7 @@ static long __video_do_ioctl(struct file *file,
 				v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			if (ops->vidioc_try_fmt_vid_cap_mplane) {
 				ret = ops->vidioc_try_fmt_vid_cap_mplane(file,
 									 fh, f);
@@ -1005,13 +1005,13 @@ static long __video_do_ioctl(struct file *file,
 				v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-			CLEAR_AFTER_FIELD(f, fmt.win);
+			(void)CLEAR_AFTER_FIELD(f, fmt.win);
 			if (ops->vidioc_try_fmt_vid_overlay)
 				ret = ops->vidioc_try_fmt_vid_overlay(file,
 					fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			if (ops->vidioc_try_fmt_vid_out) {
 				ret = ops->vidioc_try_fmt_vid_out(file, fh, f);
 			} else if (ops->vidioc_try_fmt_vid_out_mplane) {
@@ -1026,7 +1026,7 @@ static long __video_do_ioctl(struct file *file,
 					/* Drivers shouldn't adjust from 1-plane
 					 * to more than 1-plane formats */
 					ret = -EBUSY;
-					WARN_ON(1);
+					(void)WARN_ON(1);
 					break;
 				}
 				ret = fmt_mp_to_sp(&f_copy, f);
@@ -1035,7 +1035,7 @@ static long __video_do_ioctl(struct file *file,
 				v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			if (ops->vidioc_try_fmt_vid_out_mplane) {
 				ret = ops->vidioc_try_fmt_vid_out_mplane(file,
 									 fh, f);
@@ -1054,29 +1054,29 @@ static long __video_do_ioctl(struct file *file,
 				v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
-			CLEAR_AFTER_FIELD(f, fmt.win);
+			(void)CLEAR_AFTER_FIELD(f, fmt.win);
 			if (ops->vidioc_try_fmt_vid_out_overlay)
 				ret = ops->vidioc_try_fmt_vid_out_overlay(file,
 				       fh, f);
 			break;
 		case V4L2_BUF_TYPE_VBI_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.vbi);
+			(void)CLEAR_AFTER_FIELD(f, fmt.vbi);
 			if (ops->vidioc_try_fmt_vbi_cap)
 				ret = ops->vidioc_try_fmt_vbi_cap(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_VBI_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.vbi);
+			(void)CLEAR_AFTER_FIELD(f, fmt.vbi);
 			if (ops->vidioc_try_fmt_vbi_out)
 				ret = ops->vidioc_try_fmt_vbi_out(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.sliced);
+			(void)CLEAR_AFTER_FIELD(f, fmt.sliced);
 			if (ops->vidioc_try_fmt_sliced_vbi_cap)
 				ret = ops->vidioc_try_fmt_sliced_vbi_cap(file,
 								fh, f);
 			break;
 		case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.sliced);
+			(void)CLEAR_AFTER_FIELD(f, fmt.sliced);
 			if (ops->vidioc_try_fmt_sliced_vbi_out)
 				ret = ops->vidioc_try_fmt_sliced_vbi_out(file,
 								fh, f);
@@ -1106,7 +1106,7 @@ static long __video_do_ioctl(struct file *file,
 			break;
 
 		if (p->type < V4L2_BUF_TYPE_PRIVATE)
-			CLEAR_AFTER_FIELD(p, memory);
+			(void)CLEAR_AFTER_FIELD(p, memory);
 
 		ret = ops->vidioc_reqbufs(file, fh, p);
 		dbgarg(cmd, "count=%d, type=%s, memory=%s\n",
@@ -1889,7 +1889,7 @@ static long __video_do_ioctl(struct file *file,
 			break;
 
 		/* Clear up to type, everything after type is zerod already */
-		memset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));
+		(void)memset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));
 
 		dbgarg(cmd, "type=%s\n", prt_names(p->type, v4l2_type_names));
 		ret = ops->vidioc_g_sliced_vbi_cap(file, fh, p);
@@ -2336,10 +2336,10 @@ video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
 
 			/* zero out anything we don't copy from userspace */
 			if (n < _IOC_SIZE(cmd))
-				memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
+				(void)memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
 		} else {
 			/* read-only ioctl */
-			memset(parg, 0, _IOC_SIZE(cmd));
+			(void)memset(parg, 0, _IOC_SIZE(cmd));
 		}
 	}
 
diff --git a/drivers/media/video/videobuf2-core.c b/drivers/media/video/videobuf2-core.c
index 9889b63..ed9b565 100644
--- a/drivers/media/video/videobuf2-core.c
+++ b/drivers/media/video/videobuf2-core.c
@@ -523,8 +523,8 @@ int vb2_reqbufs(struct vb2_queue *q, struct v4l2_requestbuffers *req)
 	 * Make sure the requested values and current defaults are sane.
 	 */
 	num_buffers = min_t(unsigned int, req->count, VIDEO_MAX_FRAME);
-	memset(plane_sizes, 0, sizeof(plane_sizes));
-	memset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));
+	(void)memset(plane_sizes, 0, sizeof(plane_sizes));
+	(void)memset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));
 	q->memory = req->memory;
 
 	/*
@@ -883,7 +883,7 @@ int vb2_qbuf(struct vb2_queue *q, struct v4l2_buffer *b)
 	else if (q->memory == V4L2_MEMORY_USERPTR)
 		ret = __qbuf_userptr(vb, b);
 	else {
-		WARN(1, "Invalid queue type\n");
+		(void)WARN(1, "Invalid queue type\n");
 		return -EINVAL;
 	}
 
@@ -1588,7 +1588,7 @@ static int __vb2_init_fileio(struct vb2_queue *q, int read)
 		 */
 		for (i = 0; i < q->num_buffers; i++) {
 			struct v4l2_buffer *b = &fileio->b;
-			memset(b, 0, sizeof(*b));
+			(void)memset(b, 0, sizeof(*b));
 			b->type = q->type;
 			b->memory = q->memory;
 			b->index = i;
@@ -1694,7 +1694,7 @@ static size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_
 		/*
 		 * Call vb2_dqbuf to get buffer back.
 		 */
-		memset(&fileio->b, 0, sizeof(fileio->b));
+		(void)memset(&fileio->b, 0, sizeof(fileio->b));
 		fileio->b.type = q->type;
 		fileio->b.memory = q->memory;
 		fileio->b.index = index;
@@ -1762,7 +1762,7 @@ static size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_
 		/*
 		 * Call vb2_qbuf and give buffer to the driver.
 		 */
-		memset(&fileio->b, 0, sizeof(fileio->b));
+		(void)memset(&fileio->b, 0, sizeof(fileio->b));
 		fileio->b.type = q->type;
 		fileio->b.memory = q->memory;
 		fileio->b.index = index;
diff --git a/drivers/media/video/videobuf2-dma-sg.c b/drivers/media/video/videobuf2-dma-sg.c
index 10a20d9..6938f42 100644
--- a/drivers/media/video/videobuf2-dma-sg.c
+++ b/drivers/media/video/videobuf2-dma-sg.c
@@ -52,7 +52,7 @@ static void *vb2_dma_sg_alloc(void *alloc_ctx, unsigned long size)
 				      sizeof(*buf->sg_desc.sglist));
 	if (!buf->sg_desc.sglist)
 		goto fail_sglist_alloc;
-	memset(buf->sg_desc.sglist, 0, buf->sg_desc.num_pages *
+	(void)memset(buf->sg_desc.sglist, 0, buf->sg_desc.num_pages *
 	       sizeof(*buf->sg_desc.sglist));
 	sg_init_table(buf->sg_desc.sglist, buf->sg_desc.num_pages);
 
@@ -141,7 +141,7 @@ static void *vb2_dma_sg_get_userptr(void *alloc_ctx, unsigned long vaddr,
 	if (!buf->sg_desc.sglist)
 		goto userptr_fail_sglist_alloc;
 
-	memset(buf->sg_desc.sglist, 0,
+	(void)memset(buf->sg_desc.sglist, 0,
 		buf->sg_desc.num_pages * sizeof(*buf->sg_desc.sglist));
 	sg_init_table(buf->sg_desc.sglist, buf->sg_desc.num_pages);
 
diff --git a/drivers/media/video/videobuf2-msm-mem.c b/drivers/media/video/videobuf2-msm-mem.c
index 37b935b..3530c3f 100644
--- a/drivers/media/video/videobuf2-msm-mem.c
+++ b/drivers/media/video/videobuf2-msm-mem.c
@@ -165,7 +165,7 @@ int videobuf2_pmem_contig_mmap_get(struct videobuf2_contig_pmem *mem,
 	if (offset)
 		mem->offset = *offset;
 	else
-		memset(&mem->offset, 0, sizeof(struct videobuf2_msm_offset));
+		(void)memset(&mem->offset, 0, sizeof(struct videobuf2_msm_offset));
 	mem->buffer_type = buffer_type;
 	mem->path = path;
 	return 0;
@@ -220,7 +220,7 @@ int videobuf2_pmem_contig_user_get(struct videobuf2_contig_pmem *mem,
 	if (offset)
 		mem->offset = *offset;
 	else
-		memset(&mem->offset, 0, sizeof(struct videobuf2_msm_offset));
+		(void)memset(&mem->offset, 0, sizeof(struct videobuf2_msm_offset));
 	mem->path = path;
 	mem->buffer_type = buffer_type;
 	paddr = mem->phyaddr;
@@ -348,7 +348,7 @@ void videobuf2_queue_pmem_contig_init(struct vb2_queue *q,
 					unsigned int size,
 					void *priv)
 {
-	memset(q, 0, sizeof(struct vb2_queue));
+	(void)memset(q, 0, sizeof(struct vb2_queue));
 	q->mem_ops = &msm_vb2_mem_ops;
 	q->ops = ops;
 	q->drv_priv = priv;
diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c
index 0902523..0b6ce8b 100644
--- a/drivers/mfd/mfd-core.c
+++ b/drivers/mfd/mfd-core.c
@@ -49,7 +49,7 @@ int mfd_cell_disable(struct platform_device *pdev)
 		atomic_inc(cell->usage_count);
 
 	/* sanity check; did someone call disable too many times? */
-	WARN_ON(atomic_read(cell->usage_count) < 0);
+	(void)WARN_ON(atomic_read(cell->usage_count) < 0);
 
 	return err;
 }
@@ -219,7 +219,7 @@ int mfd_clone_cell(const char *cell, const char **clones, size_t n_clones)
 	pdev = to_platform_device(dev);
 	memcpy(&cell_entry, mfd_get_cell(pdev), sizeof(cell_entry));
 
-	WARN_ON(!cell_entry.enable);
+	(void)WARN_ON(!cell_entry.enable);
 
 	for (i = 0; i < n_clones; i++) {
 		cell_entry.name = clones[i];
diff --git a/drivers/mfd/pm8xxx-batt-alarm.c b/drivers/mfd/pm8xxx-batt-alarm.c
index 1d30db9..f6b28d0 100644
--- a/drivers/mfd/pm8xxx-batt-alarm.c
+++ b/drivers/mfd/pm8xxx-batt-alarm.c
@@ -582,7 +582,7 @@ int pm8xxx_batt_alarm_unregister_notifier(struct notifier_block *nb)
 			disable_irq(chip->irq);
 		}
 
-		WARN_ON(chip->notifier_count < 0);
+		(void)WARN_ON(chip->notifier_count < 0);
 
 		mutex_unlock(&chip->lock);
 	}
diff --git a/drivers/misc/pmem.c b/drivers/misc/pmem.c
index 7ee7c11..1c6d5af 100644
--- a/drivers/misc/pmem.c
+++ b/drivers/misc/pmem.c
@@ -623,7 +623,7 @@ static void pmem_put_region(int id)
 			if (pmem[id].mem_release) {
 				int ret = pmem[id].mem_release(
 						pmem[id].region_data);
-				WARN(ret, "mem_release failed");
+				(void)WARN(ret, "mem_release failed");
 			}
 
 		}
@@ -791,7 +791,7 @@ static void bitmap_bits_clear_all(uint32_t *bitp, int bit_start, int bit_end)
 				total_words -= 2;
 				total_bytes = total_words << 2;
 
-				memset(&bitp[word_index], 0, total_bytes);
+				(void)memset(&bitp[word_index], 0, total_bytes);
 				word_index += total_words;
 			}
 			bitp[word_index] &= ~end_mask(bit_end);
@@ -1132,7 +1132,7 @@ static void bitmap_bits_set_all(uint32_t *bitp, int bit_start, int bit_end)
 				total_words -= 2;
 				total_bytes = total_words << 2;
 
-				memset(&bitp[word_index], ~0, total_bytes);
+				(void)memset(&bitp[word_index], ~0, total_bytes);
 				word_index += total_words;
 			}
 			bitp[word_index] |= end_mask(bit_end);
@@ -2648,7 +2648,7 @@ int pmem_setup(struct android_pmem_platform_data *pdata,
 
 	pmem[id].num_entries = pmem[id].size / pmem[id].quantum;
 
-	memset(&pmem[id].kobj, 0, sizeof(pmem[0].kobj));
+	(void)memset(&pmem[id].kobj, 0, sizeof(pmem[0].kobj));
 	pmem[id].kobj.kset = pmem_kset;
 
 	switch (pmem[id].allocator_type) {
@@ -2676,7 +2676,7 @@ int pmem_setup(struct android_pmem_platform_data *pdata,
 		if (!pmem[id].allocator.buddy_bestfit.buddy_bitmap)
 			goto err_reset_pmem_info;
 
-		memset(pmem[id].allocator.buddy_bestfit.buddy_bitmap, 0,
+		(void)memset(pmem[id].allocator.buddy_bestfit.buddy_bitmap, 0,
 			sizeof(struct pmem_bits) * pmem[id].num_entries);
 
 		for (i = sizeof(pmem[id].num_entries) * 8 - 1; i >= 0; i--)
diff --git a/drivers/misc/tzcom.c b/drivers/misc/tzcom.c
index e662f43..e7066a8 100644
--- a/drivers/misc/tzcom.c
+++ b/drivers/misc/tzcom.c
@@ -442,7 +442,7 @@ static int __tzcom_send_cmd(struct tzcom_data_t *data,
 	resp.sb_in_rsp_len = req->resp_len;
 	memcpy(req->resp_buf, resp.sb_in_rsp_addr, resp.sb_in_rsp_len);
 	/* Zero out memory for security purpose */
-	memset(sb_in_virt, 0, reqd_len_sb_in);
+	(void)memset(sb_in_virt, 0, reqd_len_sb_in);
 	mutex_unlock(&sb_in_lock);
 
 	return ret;
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 48f3f2d..07dfb04 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -477,7 +477,7 @@ static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 	if (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))
 		return (u32)-1;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 
 	cmd.opcode = SD_APP_SEND_NUM_WR_BLKS;
 	cmd.arg = 0;
@@ -847,7 +847,7 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 	do {
 		u32 readcmd, writecmd;
 
-		memset(&brq, 0, sizeof(struct mmc_blk_request));
+		(void)memset(&brq, 0, sizeof(struct mmc_blk_request));
 		brq.mrq.cmd = &brq.cmd;
 		brq.mrq.data = &brq.data;
 
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 1985745..6057c8d 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -266,7 +266,7 @@ static inline void mmc_host_clk_exit(struct mmc_host *host)
 	if (host->clk_gated)
 		mmc_host_clk_hold(host);
 	/* There should be only one user now */
-	WARN_ON(host->clk_requests > 1);
+	(void)WARN_ON(host->clk_requests > 1);
 }
 
 static inline void mmc_host_clk_sysfs_init(struct mmc_host *host)
@@ -402,7 +402,7 @@ set_perf(struct device *dev, struct device_attribute *attr,
 	sscanf(buf, "%lld", &value);
 	if (!value) {
 		spin_lock(&host->lock);
-		memset(&host->perf, 0, sizeof(host->perf));
+		(void)memset(&host->perf, 0, sizeof(host->perf));
 		spin_unlock(&host->lock);
 	}
 
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 79d6e97..4f1567e 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -546,7 +546,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	u8 *ext_csd = NULL;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/*
 	 * Since we're changing the OCR value, we seem to
@@ -1034,7 +1034,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	u32 ocr;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	err = mmc_send_op_cond(host, 0, &ocr);
 	if (err)
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index f087d87..aa68f4e 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -129,8 +129,8 @@ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 	BUG_ON(!card);
 	BUG_ON(fn > 7);
 	BUG_ON(blocks == 1 && blksz > 512);
-	WARN_ON(blocks == 0);
-	WARN_ON(blksz == 0);
+	(void)WARN_ON(blocks == 0);
+	(void)WARN_ON(blksz == 0);
 
 	/* sanity check */
 	if (addr & ~0x1FFFF)
diff --git a/drivers/mmc/host/msm_sdcc.c b/drivers/mmc/host/msm_sdcc.c
index 57e5696..8d78706 100644
--- a/drivers/mmc/host/msm_sdcc.c
+++ b/drivers/mmc/host/msm_sdcc.c
@@ -1017,7 +1017,7 @@ msmsdcc_start_data(struct msmsdcc_host *host, struct mmc_data *data,
 	host->curr.got_dataend = 0;
 	host->curr.got_auto_prog_done = 0;
 
-	memset(&host->pio, 0, sizeof(host->pio));
+	(void)memset(&host->pio, 0, sizeof(host->pio));
 
 	datactrl = MCI_DPSM_ENABLE | (data->blksz << 4);
 
@@ -1070,7 +1070,7 @@ msmsdcc_start_data(struct msmsdcc_host *host, struct mmc_data *data,
 		datactrl |= (MCI_DPSM_DIRECTION | MCI_RX_DATA_PEND);
 
 	clks = (unsigned long long)data->timeout_ns * host->clk_rate;
-	do_div(clks, 1000000000UL);
+	(void)do_div(clks, 1000000000UL);
 	timeout = data->timeout_clks + (unsigned int)clks*2 ;
 
 	if (host->is_dma_mode && (datactrl & MCI_DPSM_DMAENABLE)) {
@@ -1285,7 +1285,7 @@ msmsdcc_pio_irq(int irq, void *dev_id)
 			flush_dcache_page(sg_page(host->pio.sg));
 
 		if (!--host->pio.sg_len) {
-			memset(&host->pio, 0, sizeof(host->pio));
+			(void)memset(&host->pio, 0, sizeof(host->pio));
 			break;
 		}
 
@@ -1499,7 +1499,7 @@ msmsdcc_irq(int irq, void *dev_id)
 					msmsdcc_stop_data(host);
 					msmsdcc_request_end(host, data->mrq);
 				}
-				WARN(!data, "No data cmd for dummy CMD52\n");
+				(void)WARN(!data, "No data cmd for dummy CMD52\n");
 				spin_unlock(&host->lock);
 				return IRQ_HANDLED;
 			}
@@ -1643,7 +1643,7 @@ msmsdcc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	/*
 	 * Get the SDIO AL client out of LPM.
 	 */
-	WARN(host->dummy_52_sent, "Dummy CMD52 in progress\n");
+	(void)WARN(host->dummy_52_sent, "Dummy CMD52 in progress\n");
 	if (host->plat->is_sdio_al_client)
 		msmsdcc_sdio_al_lpm(mmc, false);
 
@@ -1654,10 +1654,10 @@ msmsdcc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	}
 
 	spin_lock_irqsave(&host->lock, flags);
-	WARN(host->curr.mrq, "Request in progress\n");
-	WARN(!host->pwr, "SDCC power is turned off\n");
-	WARN(!host->clks_on, "SDCC clocks are turned off\n");
-	WARN(host->sdcc_irq_disabled, "SDCC IRQ is disabled\n");
+	(void)WARN(host->curr.mrq, "Request in progress\n");
+	(void)WARN(!host->pwr, "SDCC power is turned off\n");
+	(void)WARN(!host->clks_on, "SDCC clocks are turned off\n");
+	(void)WARN(host->sdcc_irq_disabled, "SDCC IRQ is disabled\n");
 
 	if (host->eject) {
 		if (mrq->data && !(mrq->data->flags & MMC_DATA_READ)) {
@@ -2367,7 +2367,7 @@ msmsdcc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	}
 
 	if (host->cmd19_tuning_in_progress)
-		WARN(!host->clks_on,
+		(void)WARN(!host->clks_on,
 			"cmd19_tuning_in_progress but SDCC clocks are OFF\n");
 
 	spin_unlock_irqrestore(&host->lock, flags);
@@ -2893,9 +2893,9 @@ static int msmsdcc_execute_tuning(struct mmc_host *mmc)
 	}
 
 	spin_lock_irqsave(&host->lock, flags);
-	WARN(!host->pwr, "SDCC power is turned off\n");
-	WARN(!host->clks_on, "SDCC clocks are turned off\n");
-	WARN(host->sdcc_irq_disabled, "SDCC IRQ is disabled\n");
+	(void)WARN(!host->pwr, "SDCC power is turned off\n");
+	(void)WARN(!host->clks_on, "SDCC clocks are turned off\n");
+	(void)WARN(host->sdcc_irq_disabled, "SDCC IRQ is disabled\n");
 
 	host->cmd19_tuning_in_progress = 1;
 	msmsdcc_delay(host);
@@ -2938,7 +2938,7 @@ static int msmsdcc_execute_tuning(struct mmc_host *mmc)
 		data.sg = &sg;
 		data.sg_len = 1;
 		sg_init_one(&sg, data_buf, 64);
-		memset(data_buf, 0, 64);
+		(void)memset(data_buf, 0, 64);
 		mmc_wait_for_req(mmc, &mrq);
 
 		if (!cmd.error && !data.error &&
@@ -3113,7 +3113,7 @@ msmsdcc_status_notify_cb(int card_present, void *dev_id)
 static int
 msmsdcc_init_dma(struct msmsdcc_host *host)
 {
-	memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
+	(void)memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
 	host->dma.host = host;
 	host->dma.channel = -1;
 	host->dma.crci = -1;
@@ -3129,7 +3129,7 @@ msmsdcc_init_dma(struct msmsdcc_host *host)
 		pr_err("Unable to allocate DMA buffer\n");
 		return -ENOMEM;
 	}
-	memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
+	(void)memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
 	host->dma.cmd_busaddr = host->dma.nc_busaddr;
 	host->dma.cmdptr_busaddr = host->dma.nc_busaddr +
 				offsetof(struct msmsdcc_nc_dmadata, cmdptr);
diff --git a/drivers/net/ppp_generic.c b/drivers/net/ppp_generic.c
index 4609bc0..d9f927e 100644
--- a/drivers/net/ppp_generic.c
+++ b/drivers/net/ppp_generic.c
@@ -998,7 +998,7 @@ ppp_net_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 
 	case SIOCGPPPCSTATS:
-		memset(&cstats, 0, sizeof(cstats));
+		(void)memset(&cstats, 0, sizeof(cstats));
 		if (ppp->xc_state)
 			ppp->xcomp->comp_stat(ppp->xc_state, &cstats.c);
 		if (ppp->rc_state)
@@ -2540,7 +2540,7 @@ ppp_get_stats(struct ppp *ppp, struct ppp_stats *st)
 {
 	struct slcompress *vj = ppp->vj;
 
-	memset(st, 0, sizeof(*st));
+	(void)memset(st, 0, sizeof(*st));
 	st->p.ppp_ipackets = ppp->dev->stats.rx_packets;
 	st->p.ppp_ierrors = ppp->dev->stats.rx_errors;
 	st->p.ppp_ibytes = ppp->dev->stats.rx_bytes;
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
index 053863a..6bcc60e 100644
--- a/drivers/net/smc911x.c
+++ b/drivers/net/smc911x.c
@@ -1346,7 +1346,7 @@ static void smc911x_set_multicast_list(struct net_device *dev)
 		mcr |= MAC_CR_HPFILT_;
 
 		/* start with a table of all zeros: reject all */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 
 		netdev_for_each_mc_addr(ha, dev) {
 			u32 position;
@@ -1376,7 +1376,7 @@ static void smc911x_set_multicast_list(struct net_device *dev)
 		 * since I'm disabling all multicast entirely, I need to
 		 * clear the multicast list
 		 */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 		update_multicast = 1;
 	}
 
diff --git a/drivers/net/smc91x.c b/drivers/net/smc91x.c
index f628574..af3d495 100644
--- a/drivers/net/smc91x.c
+++ b/drivers/net/smc91x.c
@@ -1420,7 +1420,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		static const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};
 
 		/* start with a table of all zeros: reject all */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 
 		netdev_for_each_mc_addr(ha, dev) {
 			int position;
@@ -1451,7 +1451,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		 * since I'm disabling all multicast entirely, I need to
 		 * clear the multicast list
 		 */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 		update_multicast = 1;
 	}
 
@@ -2110,7 +2110,7 @@ static int smc_enable_device(struct platform_device *pdev)
 	local_irq_save(flags);
 	ecor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;
 	writeb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));
-	readb(addr + (ECOR << SMC_IO_SHIFT));
+	(void)readb(addr + (ECOR << SMC_IO_SHIFT));
 
 	/*
 	 * Wait 100us for the chip to reset.
diff --git a/drivers/net/smsc911x.c b/drivers/net/smsc911x.c
index a3c32b9..0136f83 100644
--- a/drivers/net/smsc911x.c
+++ b/drivers/net/smsc911x.c
@@ -364,7 +364,7 @@ static int smsc911x_mac_complete(struct smsc911x_data *pdata)
 	int i;
 	u32 val;
 
-	SMSC_ASSERT_MAC_LOCK(pdata);
+	(void)SMSC_ASSERT_MAC_LOCK(pdata);
 
 	for (i = 0; i < 40; i++) {
 		val = smsc911x_reg_read(pdata, MAC_CSR_CMD);
@@ -381,7 +381,7 @@ static u32 smsc911x_mac_read(struct smsc911x_data *pdata, unsigned int offset)
 {
 	unsigned int temp;
 
-	SMSC_ASSERT_MAC_LOCK(pdata);
+	(void)SMSC_ASSERT_MAC_LOCK(pdata);
 
 	temp = smsc911x_reg_read(pdata, MAC_CSR_CMD);
 	if (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {
@@ -410,7 +410,7 @@ static void smsc911x_mac_write(struct smsc911x_data *pdata,
 {
 	unsigned int temp;
 
-	SMSC_ASSERT_MAC_LOCK(pdata);
+	(void)SMSC_ASSERT_MAC_LOCK(pdata);
 
 	temp = smsc911x_reg_read(pdata, MAC_CSR_CMD);
 	if (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {
@@ -604,7 +604,7 @@ static int smsc911x_phy_check_loopbackpkt(struct smsc911x_data *pdata)
 		unsigned int i;
 
 		/* Zero-out rx packet memory */
-		memset(pdata->loopback_rx_pkt, 0, MIN_PACKET_SIZE);
+		(void)memset(pdata->loopback_rx_pkt, 0, MIN_PACKET_SIZE);
 
 		/* Write tx packet to 118 */
 		txcmd_a = (u32)((ulong)pdata->loopback_tx_pkt & 0x03) << 16;
@@ -733,7 +733,7 @@ static int smsc911x_phy_loopbacktest(struct net_device *dev)
 	unsigned long flags;
 
 	/* Initialise tx packet using broadcast destination address */
-	memset(pdata->loopback_tx_pkt, 0xff, ETH_ALEN);
+	(void)memset(pdata->loopback_tx_pkt, 0xff, ETH_ALEN);
 
 	/* Use incrementing source address */
 	for (i = 6; i < 12; i++)
@@ -1196,7 +1196,7 @@ static void smsc911x_rx_multicast_update(struct smsc911x_data *pdata)
 	 * safe on the current hardware, and with the mac_lock held */
 	unsigned int mac_cr;
 
-	SMSC_ASSERT_MAC_LOCK(pdata);
+	(void)SMSC_ASSERT_MAC_LOCK(pdata);
 
 	mac_cr = smsc911x_mac_read(pdata, MAC_CR);
 	mac_cr |= pdata->set_bits_mask;
@@ -1266,7 +1266,7 @@ smsc911x_set_hw_mac_address(struct smsc911x_data *pdata, u8 dev_addr[6])
 	u32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
 	    (dev_addr[1] << 8) | dev_addr[0];
 
-	SMSC_ASSERT_MAC_LOCK(pdata);
+	(void)SMSC_ASSERT_MAC_LOCK(pdata);
 
 	smsc911x_mac_write(pdata, ADDRH, mac_high16);
 	smsc911x_mac_write(pdata, ADDRL, mac_low32);
diff --git a/drivers/oprofile/oprofilefs.c b/drivers/oprofile/oprofilefs.c
index e9ff6f7..60dbde7 100644
--- a/drivers/oprofile/oprofilefs.c
+++ b/drivers/oprofile/oprofilefs.c
@@ -71,7 +71,7 @@ int oprofilefs_ulong_from_user(unsigned long *val, char const __user *buf, size_
 	if (count > TMPBUFSIZE - 1)
 		return -EINVAL;
 
-	memset(tmpbuf, 0x0, TMPBUFSIZE);
+	(void)memset(tmpbuf, 0x0, TMPBUFSIZE);
 
 	if (copy_from_user(tmpbuf, buf, count))
 		return -EFAULT;
diff --git a/drivers/power/bq27520_fuelgauger.c b/drivers/power/bq27520_fuelgauger.c
index 3c191cd..0451add 100644
--- a/drivers/power/bq27520_fuelgauger.c
+++ b/drivers/power/bq27520_fuelgauger.c
@@ -230,7 +230,7 @@ static int bq27520_i2c_txsubcmd(u8 reg, unsigned short subcmd,
 	if (!di->client)
 		return -ENODEV;
 
-	memset(data, 0, sizeof(data));
+	(void)memset(data, 0, sizeof(data));
 	data[0] = reg;
 	data[1] = subcmd & 0x00FF;
 	data[2] = (subcmd & 0xFF00) >> 8;
@@ -379,7 +379,7 @@ static void update_current_battery_status(int data)
 	int status[4], ret = 0;
 	unsigned long flag;
 
-	memset(status, 0, sizeof status);
+	(void)memset(status, 0, sizeof status);
 	ret = bq27520_battery_rsoc(bq27520_di);
 	status[GET_BATTERY_CAPACITY] = (ret < 0) ? 0 : ret;
 
diff --git a/drivers/power/bq27541_fuelgauger.c b/drivers/power/bq27541_fuelgauger.c
index 516a861..27a1287 100644
--- a/drivers/power/bq27541_fuelgauger.c
+++ b/drivers/power/bq27541_fuelgauger.c
@@ -190,7 +190,7 @@ static int bq27541_i2c_txsubcmd(u8 reg, unsigned short subcmd,
 	if (!di->client)
 		return -ENODEV;
 
-	memset(data, 0, sizeof(data));
+	(void)memset(data, 0, sizeof(data));
 	data[0] = reg;
 	data[1] = subcmd & 0x00FF;
 	data[2] = (subcmd & 0xFF00) >> 8;
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5b2328d..d7396f2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3066,9 +3066,9 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 		return ERR_PTR(-EINVAL);
 
 	/* Only one of each should be implemented */
-	WARN_ON(regulator_desc->ops->get_voltage &&
+	(void)WARN_ON(regulator_desc->ops->get_voltage &&
 		regulator_desc->ops->get_voltage_sel);
-	WARN_ON(regulator_desc->ops->set_voltage &&
+	(void)WARN_ON(regulator_desc->ops->set_voltage &&
 		regulator_desc->ops->set_voltage_sel);
 
 	/* If we're using selectors we must implement list_voltage. */
@@ -3202,7 +3202,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 #ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(rdev->debugfs);
 #endif
-	WARN_ON(rdev->open_count);
+	(void)WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	if (rdev->supply)
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 2583137..3734c6b 100644
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -446,7 +446,7 @@ static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 			rtc_delta.tv_sec, rtc_delta.tv_nsec);
 		if (rtc_current_time + 1 >= rtc_alarm_time) {
 			pr_alarm(SUSPEND, "alarm about to go off\n");
-			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
+			(void)memset(&rtc_alarm, 0, sizeof(rtc_alarm));
 			rtc_alarm.enabled = 0;
 			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 
@@ -471,7 +471,7 @@ static int alarm_resume(struct platform_device *pdev)
 
 	pr_alarm(SUSPEND, "alarm_resume(%p)\n", pdev);
 
-	memset(&alarm, 0, sizeof(alarm));
+	(void)memset(&alarm, 0, sizeof(alarm));
 	alarm.enabled = 0;
 	rtc_set_alarm(alarm_rtc_dev, &alarm);
 
diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index eb4c883..7d528b6 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -27,7 +27,7 @@ static int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)
 	else if (!rtc->ops->read_time)
 		err = -EINVAL;
 	else {
-		memset(tm, 0, sizeof(struct rtc_time));
+		(void)memset(tm, 0, sizeof(struct rtc_time));
 		err = rtc->ops->read_time(rtc->dev.parent, tm);
 	}
 	return err;
@@ -129,7 +129,7 @@ static int rtc_read_alarm_internal(struct rtc_device *rtc, struct rtc_wkalrm *al
 	else if (!rtc->ops->read_alarm)
 		err = -EINVAL;
 	else {
-		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		(void)memset(alarm, 0, sizeof(struct rtc_wkalrm));
 		err = rtc->ops->read_alarm(rtc->dev.parent, alarm);
 	}
 
@@ -308,7 +308,7 @@ int rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
 	else if (!rtc->ops->read_alarm)
 		err = -EINVAL;
 	else {
-		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		(void)memset(alarm, 0, sizeof(struct rtc_wkalrm));
 		alarm->enabled = rtc->aie_timer.enabled;
 		alarm->time = rtc_ktime_to_tm(rtc->aie_timer.node.expires);
 	}
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index a4b9cdb..52226c0 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -683,8 +683,8 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 
 	scmd->prot_op = SCSI_PROT_NORMAL;
 	scmd->cmnd = ses->eh_cmnd;
-	memset(scmd->cmnd, 0, BLK_MAX_CDB);
-	memset(&scmd->sdb, 0, sizeof(scmd->sdb));
+	(void)memset(scmd->cmnd, 0, BLK_MAX_CDB);
+	(void)memset(&scmd->sdb, 0, sizeof(scmd->sdb));
 	scmd->request->next_rq = NULL;
 
 	if (sense_bytes) {
@@ -717,7 +717,7 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 	 * Zero the sense buffer.  The scsi spec mandates that any
 	 * untransferred sense data should be interpreted as being zero.
 	 */
-	memset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+	(void)memset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 }
 EXPORT_SYMBOL(scsi_eh_prep_cmnd);
 
@@ -1939,7 +1939,7 @@ scsi_reset_provider(struct scsi_device *dev, int flag)
 	scmd->cmnd = req.cmd;
 
 	scmd->scsi_done		= scsi_reset_provider_done_command;
-	memset(&scmd->sdb, 0, sizeof(scmd->sdb));
+	(void)memset(&scmd->sdb, 0, sizeof(scmd->sdb));
 
 	scmd->cmd_len			= 0;
 
@@ -2019,7 +2019,7 @@ int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
 	if (!sense_buffer || !sb_len)
 		return 0;
 
-	memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
+	(void)memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
 
 	sshdr->response_code = (sense_buffer[0] & 0x7f);
 
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 28d9c9d..f03eca8 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -241,7 +241,7 @@ int scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 	 * and prevent security leaks by zeroing out the excess data.
 	 */
 	if (unlikely(req->resid_len > 0 && req->resid_len <= bufflen))
-		memset(buffer + (bufflen - req->resid_len), 0, req->resid_len);
+		(void)memset(buffer + (bufflen - req->resid_len), 0, req->resid_len);
 
 	if (resid)
 		*resid = req->resid_len;
@@ -292,7 +292,7 @@ static void scsi_init_cmd_errh(struct scsi_cmnd *cmd)
 {
 	cmd->serial_number = 0;
 	scsi_set_resid(cmd, 0);
-	memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+	(void)memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 	if (cmd->cmd_len == 0)
 		cmd->cmd_len = scsi_command_size(cmd->cmnd);
 }
@@ -634,7 +634,7 @@ static void __scsi_release_buffers(struct scsi_cmnd *cmd, int do_bidi_check)
 	if (cmd->sdb.table.nents)
 		scsi_free_sgtable(&cmd->sdb);
 
-	memset(&cmd->sdb, 0, sizeof(cmd->sdb));
+	(void)memset(&cmd->sdb, 0, sizeof(cmd->sdb));
 
 	if (do_bidi_check && scsi_bidi_cmnd(cmd)) {
 		struct scsi_data_buffer *bidi_sdb =
@@ -1107,7 +1107,7 @@ int scsi_setup_blk_pc_cmnd(struct scsi_device *sdev, struct request *req)
 	} else {
 		BUG_ON(blk_rq_bytes(req));
 
-		memset(&cmd->sdb, 0, sizeof(cmd->sdb));
+		(void)memset(&cmd->sdb, 0, sizeof(cmd->sdb));
 		req->buffer = NULL;
 	}
 
@@ -1154,7 +1154,7 @@ int scsi_setup_fs_cmnd(struct scsi_device *sdev, struct request *req)
 	if (unlikely(!cmd))
 		return BLKPREP_DEFER;
 
-	memset(cmd->cmnd, 0, BLK_MAX_CDB);
+	(void)memset(cmd->cmnd, 0, BLK_MAX_CDB);
 	return scsi_init_io(cmd, GFP_ATOMIC);
 }
 EXPORT_SYMBOL(scsi_setup_fs_cmnd);
@@ -1837,7 +1837,7 @@ scsi_mode_select(struct scsi_device *sdev, int pf, int sp, int modepage,
 	unsigned char *real_buffer;
 	int ret;
 
-	memset(cmd, 0, sizeof(cmd));
+	(void)memset(cmd, 0, sizeof(cmd));
 	cmd[1] = (pf ? 0x10 : 0) | (sp ? 0x01 : 0);
 
 	if (sdev->use_10_for_ms) {
@@ -1915,8 +1915,8 @@ scsi_mode_sense(struct scsi_device *sdev, int dbd, int modepage,
 	int result;
 	struct scsi_sense_hdr my_sshdr;
 
-	memset(data, 0, sizeof(*data));
-	memset(&cmd[0], 0, 12);
+	(void)memset(data, 0, sizeof(*data));
+	(void)memset(&cmd[0], 0, 12);
 	cmd[1] = dbd & 0x18;	/* allows DBD and LLBA bits */
 	cmd[2] = modepage;
 
@@ -1943,7 +1943,7 @@ scsi_mode_sense(struct scsi_device *sdev, int dbd, int modepage,
 		header_length = 4;
 	}
 
-	memset(buffer, 0, len);
+	(void)memset(buffer, 0, len);
 
 	result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer, len,
 				  sshdr, timeout, retries, NULL);
@@ -2531,7 +2531,7 @@ void *scsi_kmap_atomic_sg(struct scatterlist *sgl, int sg_count,
 	struct scatterlist *sg;
 	struct page *page;
 
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	for_each_sg(sgl, sg, sg_count, i) {
 		len_complete = sg_len; /* Complete sg-entries */
@@ -2544,7 +2544,7 @@ void *scsi_kmap_atomic_sg(struct scatterlist *sgl, int sg_count,
 		printk(KERN_ERR "%s: Bytes in sg: %zu, requested offset %zu, "
 			"elements %d\n",
 		       __func__, sg_len, *offset, sg_count);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return NULL;
 	}
 
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 44e8ca3..277a924 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -580,11 +580,11 @@ static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 	for (count = 0; count < 3; ++count) {
 		int resid;
 
-		memset(scsi_cmd, 0, 6);
+		(void)memset(scsi_cmd, 0, 6);
 		scsi_cmd[0] = INQUIRY;
 		scsi_cmd[4] = (unsigned char) try_inquiry_len;
 
-		memset(inq_result, 0, try_inquiry_len);
+		(void)memset(inq_result, 0, try_inquiry_len);
 
 		result = scsi_execute_req(sdev,  scsi_cmd, DMA_FROM_DEVICE,
 					  inq_result, try_inquiry_len, &sshdr,
@@ -1274,7 +1274,7 @@ void int_to_scsilun(unsigned int lun, struct scsi_lun *scsilun)
 {
 	int i;
 
-	memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
+	(void)memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
 
 	for (i = 0; i < sizeof(lun); i += 2) {
 		scsilun->scsi_lun[i] = (lun >> 8) & 0xFF;
@@ -1372,7 +1372,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 	/*
 	 * bytes 1 - 5: reserved, set to zero.
 	 */
-	memset(&scsi_cmd[1], 0, 5);
+	(void)memset(&scsi_cmd[1], 0, 5);
 
 	/*
 	 * bytes 6 - 9: length of the command.
diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
index 0172de1..320e5ab 100644
--- a/drivers/scsi/scsi_tgt_if.c
+++ b/drivers/scsi/scsi_tgt_if.c
@@ -110,7 +110,7 @@ int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, u64 itn_id,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.cmd_req.host_no = shost->host_no;
 	ev.p.cmd_req.itn_id = itn_id;
 	ev.p.cmd_req.data_len = scsi_bufflen(cmd);
@@ -136,7 +136,7 @@ int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 itn_id, u64 tag)
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.cmd_done.host_no = shost->host_no;
 	ev.p.cmd_done.itn_id = itn_id;
 	ev.p.cmd_done.tag = tag;
@@ -159,7 +159,7 @@ int scsi_tgt_uspace_send_tsk_mgmt(int host_no, u64 itn_id, int function,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.tsk_mgmt_req.host_no = host_no;
 	ev.p.tsk_mgmt_req.itn_id = itn_id;
 	ev.p.tsk_mgmt_req.function = function;
@@ -183,7 +183,7 @@ int scsi_tgt_uspace_send_it_nexus_request(int host_no, u64 itn_id,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.it_nexus_req.host_no = host_no;
 	ev.p.it_nexus_req.function = function;
 	ev.p.it_nexus_req.itn_id = itn_id;
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 953773c..b79dd66 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -553,7 +553,7 @@ static int scsi_setup_discard_cmnd(struct scsi_device *sdp, struct request *rq)
 
 	rq->timeout = SD_TIMEOUT;
 
-	memset(rq->cmd, 0, rq->cmd_len);
+	(void)memset(rq->cmd, 0, rq->cmd_len);
 
 	page = alloc_page(GFP_ATOMIC | __GFP_ZERO);
 	if (!page)
@@ -806,7 +806,7 @@ static int sd_prep_fn(struct request_queue *q, struct request *rq)
 		}
 
 		SCpnt->cmd_len = SD_EXT_CDB_SIZE;
-		memset(SCpnt->cmnd, 0, SCpnt->cmd_len);
+		(void)memset(SCpnt->cmnd, 0, SCpnt->cmd_len);
 		SCpnt->cmnd[0] = VARIABLE_LENGTH_CMD;
 		SCpnt->cmnd[7] = 0x18;
 		SCpnt->cmnd[9] = (rq_data_dir(rq) == READ) ? READ_32 : WRITE_32;
@@ -1336,8 +1336,8 @@ static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)
 	} else {
 		/* be careful ... don't want any overflows */
 		u64 factor = scmd->device->sector_size / 512;
-		do_div(start_lba, factor);
-		do_div(end_lba, factor);
+		(void)do_div(start_lba, factor);
+		(void)do_div(end_lba, factor);
 	}
 
 	/* The bad lba was reported incorrectly, we have no idea where
@@ -1408,7 +1408,7 @@ static int sd_done(struct scsi_cmnd *SCpnt)
 		 */
 		scsi_print_sense("sd", SCpnt);
 		SCpnt->result = 0;
-		memset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		(void)memset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 		break;
 	case ABORTED_COMMAND:
 		if (sshdr.asc == 0x10)  /* DIF: Target detected corruption */
@@ -1469,7 +1469,7 @@ sd_spinup_disk(struct scsi_disk *sdkp)
 
 		do {
 			cmd[0] = TEST_UNIT_READY;
-			memset((void *) &cmd[1], 0, 9);
+			(void)memset((void *) &cmd[1], 0, 9);
 
 			the_result = scsi_execute_req(sdkp->device, cmd,
 						      DMA_NONE, NULL, 0,
@@ -1522,7 +1522,7 @@ sd_spinup_disk(struct scsi_disk *sdkp)
 				sd_printk(KERN_NOTICE, sdkp, "Spinning up disk...");
 				cmd[0] = START_STOP;
 				cmd[1] = 1;	/* Return immediately */
-				memset((void *) &cmd[2], 0, 8);
+				(void)memset((void *) &cmd[2], 0, 8);
 				cmd[4] = 1;	/* Start spin cycle */
 				if (sdkp->device->start_stop_pwr_cond)
 					cmd[4] |= 1 << 4;
@@ -1654,11 +1654,11 @@ static int read_capacity_16(struct scsi_disk *sdkp, struct scsi_device *sdp,
 		return -EINVAL;
 
 	do {
-		memset(cmd, 0, 16);
+		(void)memset(cmd, 0, 16);
 		cmd[0] = SERVICE_ACTION_IN;
 		cmd[1] = SAI_READ_CAPACITY_16;
 		cmd[13] = RC16_LEN;
-		memset(buffer, 0, RC16_LEN);
+		(void)memset(buffer, 0, RC16_LEN);
 
 		the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
 					buffer, RC16_LEN, &sshdr,
@@ -1744,8 +1744,8 @@ static int read_capacity_10(struct scsi_disk *sdkp, struct scsi_device *sdp,
 
 	do {
 		cmd[0] = READ_CAPACITY;
-		memset(&cmd[1], 0, 9);
-		memset(buffer, 0, 8);
+		(void)memset(&cmd[1], 0, 9);
+		(void)memset(buffer, 0, 8);
 
 		the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
 					buffer, 8, &sshdr,
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index 909ed9e..3dc03cc 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -427,7 +427,7 @@ sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)
 			goto free_old_hdr;
 		}
 	}
-	memset(old_hdr, 0, SZ_SG_HEADER);
+	(void)memset(old_hdr, 0, SZ_SG_HEADER);
 	old_hdr->reply_len = (int) hp->timeout;
 	old_hdr->pack_len = old_hdr->reply_len; /* old, strange behaviour */
 	old_hdr->pack_id = hp->pack_id;
@@ -972,7 +972,7 @@ sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 			read_lock_irqsave(&sfp->rq_list_lock, iflags);
 			for (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE;
 			     ++val, srp = srp ? srp->nextrp : srp) {
-				memset(&rinfo[val], 0, SZ_SG_REQ_INFO);
+				(void)memset(&rinfo[val], 0, SZ_SG_REQ_INFO);
 				if (srp) {
 					rinfo[val].req_state = srp->done + 1;
 					rinfo[val].problem =
@@ -1855,7 +1855,7 @@ sg_remove_scat(Sg_scatter_hold * schp)
 			kfree(schp->pages);
 		}
 	}
-	memset(schp, 0, sizeof (*schp));
+	(void)memset(schp, 0, sizeof (*schp));
 }
 
 static int
@@ -1983,7 +1983,7 @@ sg_add_request(Sg_fd * sfp)
 	write_lock_irqsave(&sfp->rq_list_lock, iflags);
 	resp = sfp->headrp;
 	if (!resp) {
-		memset(rp, 0, sizeof (Sg_request));
+		(void)memset(rp, 0, sizeof (Sg_request));
 		rp->parentfp = sfp;
 		resp = rp;
 		sfp->headrp = resp;
@@ -1996,7 +1996,7 @@ sg_add_request(Sg_fd * sfp)
 					break;
 			}
 			if (k < SG_MAX_QUEUE) {
-				memset(rp, 0, sizeof (Sg_request));
+				(void)memset(rp, 0, sizeof (Sg_request));
 				rp->parentfp = sfp;
 				while (resp->nextrp)
 					resp = resp->nextrp;
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2e13a14..85b3c77 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -426,7 +426,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	if (!proxy)
 		return NULL;
 
-	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
+	(void)WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
 
 	proxy->chip_select = chip->chip_select;
 	proxy->max_speed_hz = chip->max_speed_hz;
@@ -1065,7 +1065,7 @@ int spi_write_then_read(struct spi_device *spi,
 		return -EINVAL;
 
 	spi_message_init(&message);
-	memset(x, 0, sizeof x);
+	(void)memset(x, 0, sizeof x);
 	if (n_tx) {
 		x[0].len = n_tx;
 		spi_message_add_tail(&x[0], &message);
diff --git a/drivers/spi/spi_qsd.c b/drivers/spi/spi_qsd.c
index 17b9f0d..0f8336e 100644
--- a/drivers/spi/spi_qsd.c
+++ b/drivers/spi/spi_qsd.c
@@ -454,8 +454,8 @@ static void msm_spi_setup_dm_transfer(struct msm_spi *dd)
 		dd->tx_dmov_cmd->box.cmd &= ~CMD_LC;
 		dd->rx_dmov_cmd->box.cmd &= ~CMD_LC;
 
-		memset(dd->tx_padding, 0, dd->burst_size);
-		memset(dd->rx_padding, 0, dd->burst_size);
+		(void)memset(dd->tx_padding, 0, dd->burst_size);
+		(void)memset(dd->rx_padding, 0, dd->burst_size);
 		if (dd->write_buf)
 			memcpy(dd->tx_padding, dd->write_buf + offset,
 			       dd->unaligned_len);
@@ -2057,7 +2057,7 @@ static int msm_spi_suspend(struct platform_device *pdev, pm_message_t state)
 	spin_unlock_irqrestore(&dd->queue_lock, flags);
 
 	/* Wait for transactions to end, or time out */
-	wait_event_interruptible(dd->continue_suspend, !dd->transfer_pending);
+	(void)wait_event_interruptible(dd->continue_suspend, !dd->transfer_pending);
 	msm_spi_free_gpios(dd);
 
 suspend_exit:
diff --git a/drivers/thermal/thermal_sys.c b/drivers/thermal/thermal_sys.c
index 7970e89..f90eb80 100644
--- a/drivers/thermal/thermal_sys.c
+++ b/drivers/thermal/thermal_sys.c
@@ -1370,7 +1370,7 @@ int generate_netlink_event(u32 orig, enum events event)
 		return -EINVAL;
 	}
 
-	memset(thermal_event, 0, sizeof(struct thermal_genl_event));
+	(void)memset(thermal_event, 0, sizeof(struct thermal_genl_event));
 
 	thermal_event->orig = orig;
 	thermal_event->event = event;
diff --git a/drivers/tty/serial/msm_serial_hs.c b/drivers/tty/serial/msm_serial_hs.c
index 84cb3f5..c9e7819 100644
--- a/drivers/tty/serial/msm_serial_hs.c
+++ b/drivers/tty/serial/msm_serial_hs.c
@@ -1124,7 +1124,7 @@ static void msm_hs_dmov_tx_callback(struct msm_dmov_cmd *cmd_ptr,
 {
 	struct msm_hs_port *msm_uport;
 
-	WARN_ON(result != 0x80000002);  /* DMA did not finish properly */
+	(void)WARN_ON(result != 0x80000002);  /* DMA did not finish properly */
 
 	msm_uport = container_of(cmd_ptr, struct msm_hs_port, tx.xfer);
 
diff --git a/drivers/tty/tty_ldisc.c b/drivers/tty/tty_ldisc.c
index ef925d5..63a5c81 100644
--- a/drivers/tty/tty_ldisc.c
+++ b/drivers/tty/tty_ldisc.c
@@ -450,7 +450,7 @@ static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)
 	if (ld->ops->open) {
 		int ret;
                 /* BTM here locks versus a hangup event */
-		WARN_ON(!tty_locked());
+		(void)WARN_ON(!tty_locked());
 		ret = ld->ops->open(tty);
 		if (ret)
 			clear_bit(TTY_LDISC_OPEN, &tty->flags);
@@ -763,7 +763,7 @@ static int tty_ldisc_reinit(struct tty_struct *tty, int ldisc)
 	if (IS_ERR(ld))
 		return -1;
 
-	WARN_ON_ONCE(tty_ldisc_wait_idle(tty));
+	(void)WARN_ON_ONCE(tty_ldisc_wait_idle(tty));
 
 	tty_ldisc_close(tty, tty->ldisc);
 	tty_ldisc_put(tty->ldisc);
diff --git a/drivers/tty/tty_mutex.c b/drivers/tty/tty_mutex.c
index 3b2bb77..6c062e6 100644
--- a/drivers/tty/tty_mutex.c
+++ b/drivers/tty/tty_mutex.c
@@ -25,7 +25,7 @@ void __lockfunc tty_lock(void)
 {
 	struct task_struct *task = current;
 
-	WARN_ON(__big_tty_mutex_owner == task);
+	(void)WARN_ON(__big_tty_mutex_owner == task);
 
 	mutex_lock(&big_tty_mutex);
 	__big_tty_mutex_owner = task;
@@ -36,7 +36,7 @@ void __lockfunc tty_unlock(void)
 {
 	struct task_struct *task = current;
 
-	WARN_ON(__big_tty_mutex_owner != task);
+	(void)WARN_ON(__big_tty_mutex_owner != task);
 	__big_tty_mutex_owner = NULL;
 
 	mutex_unlock(&big_tty_mutex);
diff --git a/drivers/tty/vt/selection.c b/drivers/tty/vt/selection.c
index fb864e7..a767445 100644
--- a/drivers/tty/vt/selection.c
+++ b/drivers/tty/vt/selection.c
@@ -311,7 +311,7 @@ int paste_selection(struct tty_struct *tty)
 	DECLARE_WAITQUEUE(wait, current);
 
 	/* always called with BTM from vt_ioctl */
-	WARN_ON(!tty_locked());
+	(void)WARN_ON(!tty_locked());
 
 	console_lock();
 	poke_blanked_console();
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index dac7676..da939e3 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -179,7 +179,7 @@ static int acm_write_start(struct acm *acm, int wbn)
 		return -ENODEV;
 	}
 
-	dev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,
+	(void)dev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,
 							acm->susp_count);
 	usb_autopm_get_interface_async(acm->control);
 	if (acm->susp_count) {
@@ -331,7 +331,7 @@ static int acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)
 	if (!test_and_clear_bit(index, &acm->read_urbs_free))
 		return 0;
 
-	dev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);
+	(void)dev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);
 
 	res = usb_submit_urb(acm->read_urbs[index], mem_flags);
 	if (res) {
@@ -384,7 +384,7 @@ static void acm_read_bulk_callback(struct urb *urb)
 	struct acm *acm = rb->instance;
 	unsigned long flags;
 
-	dev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,
+	(void)dev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,
 					rb->index, urb->actual_length);
 	set_bit(rb->index, &acm->read_urbs_free);
 
@@ -420,7 +420,7 @@ static void acm_write_bulk(struct urb *urb)
 	unsigned long flags;
 
 	if (urb->status	|| (urb->actual_length != urb->transfer_buffer_length))
-		dev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",
+		(void)dev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",
 			__func__,
 			urb->actual_length,
 			urb->transfer_buffer_length,
@@ -438,7 +438,7 @@ static void acm_softint(struct work_struct *work)
 	struct acm *acm = container_of(work, struct acm, work);
 	struct tty_struct *tty;
 
-	dev_vdbg(&acm->data->dev, "%s\n", __func__);
+	(void)dev_vdbg(&acm->data->dev, "%s\n", __func__);
 
 	if (!ACM_READY(acm))
 		return;
@@ -598,7 +598,7 @@ static int acm_tty_write(struct tty_struct *tty,
 	if (!count)
 		return 0;
 
-	dev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);
+	(void)dev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);
 
 	spin_lock_irqsave(&acm->write_lock, flags);
 	wbn = acm_wb_alloc(acm);
@@ -609,7 +609,7 @@ static int acm_tty_write(struct tty_struct *tty,
 	wb = &acm->wb[wbn];
 
 	count = (count > acm->writesize) ? acm->writesize : count;
-	dev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);
+	(void)dev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);
 	memcpy(wb->buf, buf, count);
 	wb->len = count;
 	spin_unlock_irqrestore(&acm->write_lock, flags);
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 37518df..608ea78 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1211,7 +1211,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		 * that the gaps don't leak kernel data to userspace.
 		 */
 		if (is_in && uurb->type == USBDEVFS_URB_TYPE_ISO)
-			memset(as->urb->transfer_buffer, 0,
+			(void)memset(as->urb->transfer_buffer, 0,
 					uurb->buffer_length);
 	}
 	as->urb->dev = ps->dev;
@@ -1631,7 +1631,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 				return -EFAULT;
 			}
 		} else {
-			memset(buf, 0, size);
+			(void)memset(buf, 0, size);
 		}
 	}
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 97c5690..828a82c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1025,7 +1025,7 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver->suspend(udev, msg);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1058,7 +1058,7 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver->resume(udev, msg);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1086,7 +1086,7 @@ static int usb_suspend_interface(struct usb_device *udev,
 	}
 
  done:
-	dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1145,7 +1145,7 @@ static int usb_resume_interface(struct usb_device *udev,
 	}
 
 done:
-	dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
 
 	/* Later we will unbind the driver and/or reprobe, if necessary */
 	return status;
@@ -1223,7 +1223,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	}
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1272,7 +1272,7 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	usb_mark_last_busy(udev);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	if (!status)
 		udev->reset_resume = 0;
 	return status;
@@ -1444,7 +1444,7 @@ void usb_autosuspend_device(struct usb_device *udev)
 
 	usb_mark_last_busy(udev);
 	status = pm_runtime_put_sync_autosuspend(&udev->dev);
-	dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&udev->dev.power.usage_count),
 			status);
 }
@@ -1474,7 +1474,7 @@ int usb_autoresume_device(struct usb_device *udev)
 	status = pm_runtime_get_sync(&udev->dev);
 	if (status < 0)
 		pm_runtime_put_sync(&udev->dev);
-	dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&udev->dev.power.usage_count),
 			status);
 	if (status > 0)
@@ -1505,7 +1505,7 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	usb_mark_last_busy(udev);
 	atomic_dec(&intf->pm_usage_cnt);
 	status = pm_runtime_put_sync(&intf->dev);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 }
@@ -1534,7 +1534,7 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 	usb_mark_last_busy(udev);
 	atomic_dec(&intf->pm_usage_cnt);
 	status = pm_runtime_put(&intf->dev);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 }
@@ -1585,7 +1585,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 		pm_runtime_put_sync(&intf->dev);
 	else
 		atomic_inc(&intf->pm_usage_cnt);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 	if (status > 0)
@@ -1618,7 +1618,7 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 		pm_runtime_put_noidle(&intf->dev);
 	else
 		atomic_inc(&intf->pm_usage_cnt);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 	if (status > 0)
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 54338fc..21709c9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -861,7 +861,7 @@ static struct attribute_group usb_bus_attr_group = {
  */
 static void usb_bus_init (struct usb_bus *bus)
 {
-	memset (&bus->devmap, 0, sizeof(struct usb_devmap));
+	(void)memset (&bus->devmap, 0, sizeof(struct usb_devmap));
 
 	bus->devnum_next = 1;
 
@@ -965,7 +965,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 
 	usb_dev->devnum = devnum;
 	usb_dev->bus->devnum_next = devnum + 1;
-	memset (&usb_dev->bus->devmap.devicemap, 0,
+	(void)memset (&usb_dev->bus->devmap.devicemap, 0,
 			sizeof usb_dev->bus->devmap.devicemap);
 	set_bit (devnum, usb_dev->bus->devmap.devicemap);
 	usb_set_device_state(usb_dev, USB_STATE_ADDRESS);
@@ -1228,7 +1228,7 @@ static int hcd_alloc_coherent(struct usb_bus *bus,
 	unsigned char *vaddr;
 
 	if (*vaddr_handle == NULL) {
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return -EFAULT;
 	}
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5442297..968b0a0 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -4033,7 +4033,7 @@ static int hub_thread(void *__unused)
 
 	do {
 		hub_events();
-		wait_event_freezable(khubd_wait,
+		(void)wait_event_freezable(khubd_wait,
 				!list_empty(&hub_event_list) ||
 				kthread_should_stop());
 	} while (!kthread_should_stop() || !list_empty(&hub_event_list));
diff --git a/drivers/usb/gadget/msm72k_udc.c b/drivers/usb/gadget/msm72k_udc.c
index ea62262..f7fb847 100644
--- a/drivers/usb/gadget/msm72k_udc.c
+++ b/drivers/usb/gadget/msm72k_udc.c
@@ -957,7 +957,7 @@ static void handle_setup(struct usb_info *ui)
 				u16 temp = 0;
 
 				if (num == 0) {
-					memset(req->buf, 0, 2);
+					(void)memset(req->buf, 0, 2);
 					break;
 				}
 				if (ctl.wIndex & USB_ENDPOINT_DIR_MASK)
@@ -995,7 +995,7 @@ static void handle_setup(struct usb_info *ui)
 				break;
 			}
 			case USB_RECIP_INTERFACE:
-				memset(req->buf, 0, 2);
+				(void)memset(req->buf, 0, 2);
 				break;
 			default:
 				goto stall;
@@ -1371,11 +1371,11 @@ static void usb_prepare(struct usb_info *ui)
 {
 	spin_lock_init(&ui->lock);
 
-	memset(ui->buf, 0, 4096);
+	(void)memset(ui->buf, 0, 4096);
 	ui->head = (void *) (ui->buf + 0);
 
 	/* only important for reset/reinit */
-	memset(ui->ept, 0, sizeof(ui->ept));
+	(void)memset(ui->ept, 0, sizeof(ui->ept));
 	ui->next_item = 0;
 	ui->next_ifc_num = 0;
 
@@ -1853,7 +1853,7 @@ static ssize_t debug_read_release_wlocks(struct file *file, char __user *ubuf,
 	char kbuf[10];
 	size_t c = 0;
 
-	memset(kbuf, 0, 10);
+	(void)memset(kbuf, 0, 10);
 
 	c = scnprintf(kbuf, 10, "%d", release_wlocks);
 
@@ -1868,7 +1868,7 @@ static ssize_t debug_write_release_wlocks(struct file *file,
 	char kbuf[10];
 	long temp;
 
-	memset(kbuf, 0, 10);
+	(void)memset(kbuf, 0, 10);
 
 	if (copy_from_user(kbuf, buf, count > 10 ? 10 : count))
 		return -EFAULT;
@@ -1904,7 +1904,7 @@ static ssize_t debug_reprime_ep(struct file *file, const char __user *ubuf,
 	unsigned long flags;
 	unsigned n, i;
 
-	memset(kbuf, 0, 10);
+	(void)memset(kbuf, 0, 10);
 
 	if (copy_from_user(kbuf, ubuf, count > 10 ? 10 : count))
 		return -EFAULT;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index dc11eaf..f932c37 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1152,7 +1152,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (qh) {
 		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
-			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
+			(void)WARN_ONCE(1, "clear_halt for a busy endpoint\n");
 		} else if (qh->qh_state == QH_STATE_LINKED ||
 				qh->qh_state == QH_STATE_COMPLETING) {
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index d438555..288fa6e 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -717,8 +717,8 @@ ehci_hub_descriptor (
 	desc->bDescLength = 7 + 2 * temp;
 
 	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
-	memset(&desc->u.hs.DeviceRemovable[0], 0, temp);
-	memset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);
+	(void)memset(&desc->u.hs.DeviceRemovable[0], 0, temp);
+	(void)memset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);
 
 	temp = 0x0008;			/* per-port overcurrent reporting */
 	if (HCS_PPC (ehci->hcs_params))
@@ -1009,7 +1009,7 @@ static int ehci_hub_control (
 		break;
 	case GetHubStatus:
 		/* no hub-wide feature/status flags */
-		memset (buf, 0, 4);
+		(void)memset (buf, 0, 4);
 		//cpu_to_le32s ((u32 *) buf);
 		break;
 	case GetPortStatus:
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9c24ff4..5baf24a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -965,7 +965,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (unlikely(qh->clearing_tt))
 		return;
 
-	WARN_ON(qh->qh_state != QH_STATE_IDLE);
+	(void)WARN_ON(qh->qh_state != QH_STATE_IDLE);
 
 	/* (re)start the async schedule? */
 	head = ehci->async;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 6c9fbe3..aad701d 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1261,7 +1261,7 @@ itd_urb_transaction (
 			}
 		}
 
-		memset (itd, 0, sizeof *itd);
+		(void)memset (itd, 0, sizeof *itd);
 		itd->itd_dma = itd_dma;
 		list_add (&itd->itd_list, &sched->td_list);
 	}
@@ -1954,7 +1954,7 @@ sitd_urb_transaction (
 			}
 		}
 
-		memset (sitd, 0, sizeof *sitd);
+		(void)memset (sitd, 0, sizeof *sitd);
 		sitd->sitd_dma = sitd_dma;
 		list_add (&sitd->sitd_list, &iso_sched->td_list);
 	}
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 05c7faf..caf90ab 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -185,7 +185,7 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 static inline void
 iaa_watchdog_start(struct ehci_hcd *ehci)
 {
-	WARN_ON(timer_pending(&ehci->iaa_watchdog));
+	(void)WARN_ON(timer_pending(&ehci->iaa_watchdog));
 	mod_timer(&ehci->iaa_watchdog,
 			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
 }
diff --git a/drivers/usb/otg/msm72k_otg.c b/drivers/usb/otg/msm72k_otg.c
index 59d9769..9f2b19b 100644
--- a/drivers/usb/otg/msm72k_otg.c
+++ b/drivers/usb/otg/msm72k_otg.c
@@ -2805,7 +2805,7 @@ static int __init msm_otg_probe(struct platform_device *pdev)
 	dev->reset = otg_reset;
 	dev->otg.io_ops = &msm_otg_io_ops;
 	if (otg_set_transceiver(&dev->otg)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto free_otg_irq;
 	}
 #ifdef CONFIG_USB_MSM_ACA
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
index ec9ac24..276b435 100644
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -400,7 +400,7 @@ static void ulpi_init(struct msm_otg *motg)
 		return;
 
 	while (seq[0] >= 0) {
-		dev_vdbg(motg->otg.dev, "ulpi: write 0x%02x to 0x%02x\n",
+		(void)dev_vdbg(motg->otg.dev, "ulpi: write 0x%02x to 0x%02x\n",
 				seq[0], seq[1]);
 		ulpi_write(&motg->otg, seq[0], seq[1]);
 		seq += 2;
@@ -2035,7 +2035,7 @@ static ssize_t msm_otg_mode_write(struct file *file, const char __user *ubuf,
 	int status = count;
 	enum usb_mode_type req_mode;
 
-	memset(buf, 0x00, sizeof(buf));
+	(void)memset(buf, 0x00, sizeof(buf));
 
 	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count))) {
 		status = -EFAULT;
@@ -2144,7 +2144,7 @@ static ssize_t msm_otg_aca_write(struct file *file, const char __user *ubuf,
 {
 	char buf[8];
 
-	memset(buf, 0x00, sizeof(buf));
+	(void)memset(buf, 0x00, sizeof(buf));
 
 	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
 		return -EFAULT;
diff --git a/drivers/usb/otg/otg_id.c b/drivers/usb/otg/otg_id.c
index 7c38390..ee0bf72 100644
--- a/drivers/usb/otg/otg_id.c
+++ b/drivers/usb/otg/otg_id.c
@@ -66,7 +66,7 @@ static void __otg_id_notify(void)
 
 	}
 
-	WARN(1, "otg id event not handled");
+	(void)WARN(1, "otg id event not handled");
 	otg_id_active = NULL;
 }
 
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e8ae21b..d3aaee9 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -1074,7 +1074,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	bcb->Length = srb->cmd_len;
 
 	/* copy the command payload */
-	memset(bcb->CDB, 0, sizeof(bcb->CDB));
+	(void)memset(bcb->CDB, 0, sizeof(bcb->CDB));
 	memcpy(bcb->CDB, srb->cmnd, bcb->Length);
 
 	/* send it to out endpoint */
@@ -1263,7 +1263,7 @@ static int usb_stor_reset_common(struct us_data *us,
 
 	/* Give the device some time to recover from the reset,
 	 * but don't delay disconnect processing. */
-	wait_event_interruptible_timeout(us->delay_wait,
+	(void)wait_event_interruptible_timeout(us->delay_wait,
 			test_bit(US_FLIDX_DISCONNECTING, &us->dflags),
 			HZ*6);
 	if (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {
@@ -1295,7 +1295,7 @@ int usb_stor_CB_reset(struct us_data *us)
 {
 	US_DEBUGP("%s called\n", __func__);
 
-	memset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);
+	(void)memset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);
 	us->iobuf[0] = SEND_DIAGNOSTIC;
 	us->iobuf[1] = 4;
 	return usb_stor_reset_common(us, US_CBI_ADSC, 
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 0ca0958..d00f44a 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -232,7 +232,7 @@ void fill_inquiry_response(struct us_data *us, unsigned char *data,
 	if (data_len<36) // You lose.
 		return;
 
-	memset(data+8, ' ', 28);
+	(void)memset(data+8, ' ', 28);
 	if(data[0]&0x20) { /* USB device currently not connected. Return
 			      peripheral qualifier 001b ("...however, the
 			      physical device is not currently connected
@@ -836,7 +836,7 @@ static int usb_stor_scan_thread(void * __us)
 	if (delay_use > 0) {
 		dev_dbg(dev, "waiting for device to settle "
 				"before scanning\n");
-		wait_event_freezable_timeout(us->delay_wait,
+		(void)wait_event_freezable_timeout(us->delay_wait,
 				test_bit(US_FLIDX_DONT_SCAN, &us->dflags),
 				delay_use * HZ);
 	}
@@ -900,7 +900,7 @@ int usb_stor_probe1(struct us_data **pus,
 	host->max_cmd_len = 16;
 	host->sg_tablesize = usb_stor_sg_tablesize(intf);
 	*pus = us = host_to_us(host);
-	memset(us, 0, sizeof(struct us_data));
+	(void)memset(us, 0, sizeof(struct us_data));
 	mutex_init(&(us->dev_mutex));
 	init_completion(&us->cmnd_ready);
 	init_completion(&(us->notify));
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index cb175fe..bd68c84 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -657,7 +657,7 @@ done:
 		    "", (margins) ? " with margins" : "", (interlace) ?
 		    " interlaced" : "");
 
-	    memset(&cvt_mode, 0, sizeof(cvt_mode));
+	    (void)memset(&cvt_mode, 0, sizeof(cvt_mode));
 	    cvt_mode.xres = xres;
 	    cvt_mode.yres = yres;
 	    cvt_mode.refresh = (refresh) ? refresh : 60;
@@ -1096,7 +1096,7 @@ const struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,
 	if (specs->max_x && specs->max_y) {
 		struct fb_var_screeninfo var;
 
-		memset(&var, 0, sizeof(struct fb_var_screeninfo));
+		(void)memset(&var, 0, sizeof(struct fb_var_screeninfo));
 		var.xres = (specs->max_x * 7200)/254;
 		var.yres = (specs->max_y * 7200)/254;
 		m = fb_find_best_mode(&var, head);
diff --git a/drivers/video/msm/external_common.c b/drivers/video/msm/external_common.c
index 7fd4c56..10739bf 100644
--- a/drivers/video/msm/external_common.c
+++ b/drivers/video/msm/external_common.c
@@ -1332,9 +1332,9 @@ int hdmi_common_read_edid(void)
 	uint8 edid_buf[0x80 * 4];
 
 	external_common_state->present_3d = 0;
-	memset(&external_common_state->disp_mode_list, 0,
+	(void)memset(&external_common_state->disp_mode_list, 0,
 		sizeof(external_common_state->disp_mode_list));
-	memset(edid_buf, 0, sizeof(edid_buf));
+	(void)memset(edid_buf, 0, sizeof(edid_buf));
 
 	status = hdmi_common_read_edid_block(0, edid_buf);
 	if (status || !check_edid_header(edid_buf)) {
diff --git a/drivers/video/msm/hdmi_msm.c b/drivers/video/msm/hdmi_msm.c
index 60a40b2..ce06f20 100644
--- a/drivers/video/msm/hdmi_msm.c
+++ b/drivers/video/msm/hdmi_msm.c
@@ -1728,7 +1728,7 @@ again:
 	HDMI_OUTP_ND(0x0238, 0x1 | (3 << 16) | (1 << 31));
 
 	/* Discard first byte */
-	HDMI_INP_ND(0x0238);
+	(void)HDMI_INP_ND(0x0238);
 	for (ndx = 0; ndx < data_len; ++ndx) {
 		reg_val = HDMI_INP_ND(0x0238);
 		data_buf[ndx] = (uint8) ((reg_val & 0x0000FF00) >> 8);
@@ -1989,7 +1989,7 @@ again:
 	HDMI_OUTP_ND(0x0238, 0x1 | (5 << 16) | (1 << 31));
 
 	/* Discard first byte */
-	HDMI_INP_ND(0x0238);
+	(void)HDMI_INP_ND(0x0238);
 
 	for (ndx = 0; ndx < data_len; ++ndx) {
 		reg_val = HDMI_INP_ND(0x0238);
@@ -2284,7 +2284,7 @@ static int hdcp_authentication_part1(void)
 
 
 	static uint8 buf[0xFF];
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 
 	if (!is_part1_done) {
 		is_part1_done = TRUE;
@@ -2667,8 +2667,8 @@ static int hdcp_authentication_part2(void)
 
 	boolean ksv_done = FALSE;
 
-	memset(buf, 0, sizeof(buf));
-	memset(kvs_fifo, 0, sizeof(kvs_fifo));
+	(void)memset(buf, 0, sizeof(buf));
+	(void)memset(kvs_fifo, 0, sizeof(kvs_fifo));
 
 	/* wait until READY bit is set in bcaps */
 	timeout_count = 50;
diff --git a/drivers/video/msm/lcdc_auo_wvga.c b/drivers/video/msm/lcdc_auo_wvga.c
index 6b0733f..4e4d8f5 100644
--- a/drivers/video/msm/lcdc_auo_wvga.c
+++ b/drivers/video/msm/lcdc_auo_wvga.c
@@ -129,7 +129,7 @@ static int auo_serigo(u8 *input_data, int input_len)
 		return -EINVAL;
 	}
 
-	memset(&t, 0, sizeof t);
+	(void)memset(&t, 0, sizeof t);
 
 	t.tx_buf = input_data;
 	t.len = input_len;
diff --git a/drivers/video/msm/lcdc_nt35582_wvga.c b/drivers/video/msm/lcdc_nt35582_wvga.c
index 9ecf4b9..d447b93 100644
--- a/drivers/video/msm/lcdc_nt35582_wvga.c
+++ b/drivers/video/msm/lcdc_nt35582_wvga.c
@@ -53,7 +53,7 @@ static int spi_write_2bytes(struct spi_device *spi,
 	struct spi_message m;
 	struct spi_transfer t;
 
-	memset(&t, 0, sizeof t);
+	(void)memset(&t, 0, sizeof t);
 	t.tx_buf = tx_buf;
 
 	spi_setup(spi);
@@ -82,7 +82,7 @@ static int spi_write_3bytes(struct spi_device *spi, unsigned char reg_high_addr,
 	struct spi_message  m;
 	struct spi_transfer t;
 
-	memset(&t, 0, sizeof t);
+	(void)memset(&t, 0, sizeof t);
 	t.tx_buf = tx_buf;
 
 	spi_setup(spi);
@@ -115,7 +115,7 @@ static int spi_read_bytes(struct spi_device *spi, unsigned char reg_high_addr,
 	struct spi_message m;
 	struct spi_transfer t;
 
-	memset(&t, 0, sizeof t);
+	(void)memset(&t, 0, sizeof t);
 	t.tx_buf = tx_buf;
 
 	spi_setup(spi);
diff --git a/drivers/video/msm/lcdc_samsung_oled_pt.c b/drivers/video/msm/lcdc_samsung_oled_pt.c
index 16790f3..4ed54ad 100644
--- a/drivers/video/msm/lcdc_samsung_oled_pt.c
+++ b/drivers/video/msm/lcdc_samsung_oled_pt.c
@@ -199,8 +199,8 @@ static int samsung_serigo(struct samsung_spi_data data)
 		return -EINVAL;
 	}
 
-	memset(&t, 0, sizeof t);
-	memset(tx_buf, 0, sizeof tx_buf);
+	(void)memset(&t, 0, sizeof t);
+	(void)memset(tx_buf, 0, sizeof tx_buf);
 	t.tx_buf = tx_buf;
 	spi_setup(lcdc_spi_client);
 	spi_message_init(&m);
@@ -262,8 +262,8 @@ static int samsung_write_cmd(u8 cmd)
 		return -EINVAL;
 	}
 
-	memset(&t, 0, sizeof t);
-	memset(tx_buf, 0, sizeof tx_buf);
+	(void)memset(&t, 0, sizeof t);
+	(void)memset(tx_buf, 0, sizeof tx_buf);
 	t.tx_buf = tx_buf;
 	spi_setup(lcdc_spi_client);
 	spi_message_init(&m);
diff --git a/drivers/video/msm/mdp.c b/drivers/video/msm/mdp.c
index db60546..e26edea 100644
--- a/drivers/video/msm/mdp.c
+++ b/drivers/video/msm/mdp.c
@@ -657,7 +657,7 @@ void mdp_pipe_ctrl(MDP_BLOCK_TYPE block, MDP_BLOCK_POWER_STATE state,
 	 * could turn off the clocks while the interrupt is updating the
 	 * power to ON
 	 */
-	WARN_ON(isr == TRUE && state == MDP_BLOCK_POWER_ON);
+	(void)WARN_ON(isr == TRUE && state == MDP_BLOCK_POWER_ON);
 
 	spin_lock_irqsave(&mdp_spin_lock, flag);
 	if (MDP_BLOCK_POWER_ON == state) {
@@ -1405,8 +1405,8 @@ static int mdp_probe(struct platform_device *pdev)
 
 	mfd->ov0_wb_buf = MDP_ALLOC(sizeof(struct mdp_buf_type));
 	mfd->ov1_wb_buf = MDP_ALLOC(sizeof(struct mdp_buf_type));
-	memset((void *)mfd->ov0_wb_buf, 0, sizeof(struct mdp_buf_type));
-	memset((void *)mfd->ov1_wb_buf, 0, sizeof(struct mdp_buf_type));
+	(void)memset((void *)mfd->ov0_wb_buf, 0, sizeof(struct mdp_buf_type));
+	(void)memset((void *)mfd->ov1_wb_buf, 0, sizeof(struct mdp_buf_type));
 
 	if (mdp_pdata) {
 		mfd->ov0_wb_buf->size = mdp_pdata->ov0_wb_size;
diff --git a/drivers/video/msm/mdp4_hsic.c b/drivers/video/msm/mdp4_hsic.c
index 5735f45..bb49613 100644
--- a/drivers/video/msm/mdp4_hsic.c
+++ b/drivers/video/msm/mdp4_hsic.c
@@ -378,8 +378,8 @@ void _hsic_generate_csc_matrix(struct mdp4_overlay_pipe *pipe)
 	int32_t con_sat_matrix[3][3];
 	struct mdp4_hsic_regs *regs = &(pipe->hsic_regs);
 
-	memset(con_sat_matrix, 0x0, sizeof(con_sat_matrix));
-	memset(hue_matrix, 0x0, sizeof(hue_matrix));
+	(void)memset(con_sat_matrix, 0x0, sizeof(con_sat_matrix));
+	(void)memset(hue_matrix, 0x0, sizeof(hue_matrix));
 
 	/*
 	 * HSIC control require matrix multiplication of these two tables
diff --git a/drivers/video/msm/mdp4_overlay.c b/drivers/video/msm/mdp4_overlay.c
index ecb0a24..09be1e0 100644
--- a/drivers/video/msm/mdp4_overlay.c
+++ b/drivers/video/msm/mdp4_overlay.c
@@ -1585,7 +1585,7 @@ void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe)
 	ndx = pipe->pipe_ndx;
 	mixer = pipe->mixer_num;
 
-	memset(pipe, 0, sizeof(*pipe));
+	(void)memset(pipe, 0, sizeof(*pipe));
 
 	pipe->pipe_type = ptype;
 	pipe->pipe_num = num;
diff --git a/drivers/video/msm/mipi_novatek.c b/drivers/video/msm/mipi_novatek.c
index caa4114..12ae32c 100644
--- a/drivers/video/msm/mipi_novatek.c
+++ b/drivers/video/msm/mipi_novatek.c
@@ -50,8 +50,8 @@ static void novatek_fpga_write(uint8 addr, uint16 value)
 	data[2] = ((value >> 8) & 0xFF);
 	data[3] = (value & 0xFF);
 
-	memset(&t, 0, sizeof t);
-	memset(tx_buf, 0, sizeof tx_buf);
+	(void)memset(&t, 0, sizeof t);
+	(void)memset(tx_buf, 0, sizeof tx_buf);
 	t.tx_buf = data;
 	t.len = 4;
 	spi_setup(panel_3d_spi_client);
@@ -83,10 +83,10 @@ static void novatek_fpga_read(uint8 addr)
 	data[0] = HPCI_FPGA_READ_CMD;
 	data[1] = addr;
 
-	memset(&t, 0, sizeof t);
-	memset(tx_buf, 0, sizeof tx_buf);
-	memset(&rx, 0, sizeof rx);
-	memset(rx_value, 0, sizeof rx_value);
+	(void)memset(&t, 0, sizeof t);
+	(void)memset(tx_buf, 0, sizeof tx_buf);
+	(void)memset(&rx, 0, sizeof rx);
+	(void)memset(rx_value, 0, sizeof rx_value);
 	t.tx_buf = data;
 	t.len = 2;
 	rx.rx_buf = rx_value;
diff --git a/drivers/video/msm/msm_fb.c b/drivers/video/msm/msm_fb.c
index 89ccbb9..a26415a 100644
--- a/drivers/video/msm/msm_fb.c
+++ b/drivers/video/msm/msm_fb.c
@@ -1162,7 +1162,7 @@ static int msm_fb_register(struct msm_fb_data_type *mfd)
 	fbi->screen_base = fbram;
 	fbi->fix.smem_start = (unsigned long)fbram_phys;
 
-	memset(fbi->screen_base, 0x0, fix->smem_len);
+	(void)memset(fbi->screen_base, 0x0, fix->smem_len);
 
 	mfd->op_enable = TRUE;
 	mfd->panel_power_on = FALSE;
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
index 1e02a2c..4716b07 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
@@ -39,7 +39,7 @@ u32 ddl_device_init(struct ddl_init_config *ddl_init_config,
 		DDL_MSG_ERROR("ddl_dev_init:Ddl_busy");
 		return VCD_ERR_BUSY;
 	}
-	memset(ddl_context, 0, sizeof(struct ddl_context));
+	(void)memset(ddl_context, 0, sizeof(struct ddl_context));
 	DDL_BUSY(ddl_context);
 	if (res_trk_get_enable_ion()) {
 		DDL_MSG_LOW("ddl_dev_init:ION framework enabled");
@@ -180,11 +180,11 @@ u32 ddl_open(u32 **ddl_handle, u32 decoding)
 		}
 	}
 	if (!status) {
-		memset(ddl->shared_mem[0].align_virtual_addr, 0,
+		(void)memset(ddl->shared_mem[0].align_virtual_addr, 0,
 			DDL_FW_AUX_HOST_CMD_SPACE_SIZE);
 		if (ddl_context->frame_channel_depth ==
 			VCD_DUAL_FRAME_COMMAND_CHANNEL) {
-			memset(ddl->shared_mem[1].align_virtual_addr, 0,
+			(void)memset(ddl->shared_mem[1].align_virtual_addr, 0,
 				DDL_FW_AUX_HOST_CMD_SPACE_SIZE);
 		}
 		DDL_MSG_LOW("ddl_state_transition: %s ~~> DDL_CLIENT_OPEN",
@@ -607,6 +607,6 @@ u32 ddl_reset_hw(u32 mode)
 		}
 	}
 	ddl_release_context_buffers(ddl_context);
-	memset(ddl_context, 0, sizeof(struct ddl_context));
+	(void)memset(ddl_context, 0, sizeof(struct ddl_context));
 	return true;
 }
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
index d54c01e..93daf9c 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
@@ -105,7 +105,7 @@ u32 ddl_client_transact(u32 operation,
 				if (!*pddl_client)
 					ret_status = VCD_ERR_ALLOC_FAIL;
 				else {
-					memset(*pddl_client, 0,
+					(void)memset(*pddl_client, 0,
 						sizeof(struct
 						ddl_client_context));
 					ddl_context->ddl_clients
@@ -248,9 +248,9 @@ u32 ddl_decoder_dpb_init(struct ddl_client_context *ddl)
 	for (i = 0; i < dpb; i++) {
 		if (frame[i].vcd_frm.virtual) {
 			if (luma_size <= frame[i].vcd_frm.alloc_len) {
-				memset(frame[i].vcd_frm.virtual,
+				(void)memset(frame[i].vcd_frm.virtual,
 					 0x10101010, luma_size);
-				memset(frame[i].vcd_frm.virtual + luma_size,
+				(void)memset(frame[i].vcd_frm.virtual + luma_size,
 					 0x80808080,
 					frame[i].vcd_frm.alloc_len - luma_size);
 			} else {
@@ -494,7 +494,7 @@ void ddl_free_dec_hw_buffers(struct ddl_client_context *ddl)
 	ddl_pmem_free(&dec_bufs->stx_parser);
 	ddl_pmem_free(&dec_bufs->desc);
 	ddl_pmem_free(&dec_bufs->context);
-	memset(dec_bufs, 0, sizeof(struct ddl_dec_buffers));
+	(void)memset(dec_bufs, 0, sizeof(struct ddl_dec_buffers));
 }
 
 void ddl_free_enc_hw_buffers(struct ddl_client_context *ddl)
@@ -514,7 +514,7 @@ void ddl_free_enc_hw_buffers(struct ddl_client_context *ddl)
 	ddl_pmem_free(&enc_bufs->nbor_info);
 	ddl_pmem_free(&enc_bufs->acdc_coef);
 	ddl_pmem_free(&enc_bufs->context);
-	memset(enc_bufs, 0, sizeof(struct ddl_enc_buffers));
+	(void)memset(enc_bufs, 0, sizeof(struct ddl_enc_buffers));
 }
 
 u32 ddl_get_input_frame_from_pool(struct ddl_client_context *ddl,
@@ -527,7 +527,7 @@ u32 ddl_get_input_frame_from_pool(struct ddl_client_context *ddl,
 			ddl->input_frame_pool[i].vcd_frm.physical) {
 			found = true;
 			ddl->input_frame = ddl->input_frame_pool[i];
-			memset(&ddl->input_frame_pool[i], 0,
+			(void)memset(&ddl->input_frame_pool[i], 0,
 				sizeof(struct ddl_frame_data_tag));
 		}
 	}
@@ -716,7 +716,7 @@ u32 ddl_allocate_dec_hw_buffers(struct ddl_client_context *ddl)
 		if (!ptr)
 			status = VCD_ERR_ALLOC_FAIL;
 		else
-			memset(dec_bufs->desc.align_virtual_addr,
+			(void)memset(dec_bufs->desc.align_virtual_addr,
 				   0, buf_size.sz_desc);
 	}
 	if (status)
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
index 8eba8bd..54b3da7 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
@@ -559,7 +559,7 @@ static void ddl_encoder_frame_run_callback(
 					output_frame =
 					&ddl->output_frame.\
 					vcd_frm;
-					memset(&enc_param, 0,
+					(void)memset(&enc_param, 0,
 						sizeof(enc_param));
 					enc_param.cmd_seq_num =
 						++ddl_context->cmd_seq_num;
@@ -766,7 +766,7 @@ static u32 ddl_eos_frame_done_callback(
 					DDL_DPB_OP_SET_MASK);
 				ddl->cmd_state = DDL_CMD_EOS;
 
-				memset(&dec_param, 0, sizeof(dec_param));
+				(void)memset(&dec_param, 0, sizeof(dec_param));
 
 				dec_param.cmd_seq_num =
 					++ddl_context->cmd_seq_num;
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
index d2969b6..442cd8c 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
@@ -365,7 +365,7 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 	break;
 	case VCD_I_FREE_H264_MV_BUFFER:
 		{
-			memset(&decoder->hw_bufs.h264_mv, 0, sizeof(struct
+			(void)memset(&decoder->hw_bufs.h264_mv, 0, sizeof(struct
 					ddl_buf_addr) * DDL_MAX_BUFFER_COUNT);
 			vcd_status = VCD_S_SUCCESS;
 		}
@@ -906,9 +906,9 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 	break;
 	case VCD_I_FREE_RECON_BUFFERS:
 	{
-		memset(&encoder->hw_bufs.dpb_y, 0,
+		(void)memset(&encoder->hw_bufs.dpb_y, 0,
 			sizeof(struct ddl_buf_addr) * 4);
-		memset(&encoder->hw_bufs.dpb_c, 0,
+		(void)memset(&encoder->hw_bufs.dpb_c, 0,
 			sizeof(struct ddl_buf_addr) * 4);
 		vcd_status = VCD_S_SUCCESS;
 		break;
@@ -1664,8 +1664,8 @@ static void ddl_set_default_enc_rc_params(
 void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
 {
 	u32 y_cb_cr_size, y_size;
-	memset(&encoder->hw_bufs.dpb_y, 0, sizeof(struct ddl_buf_addr) * 4);
-	memset(&encoder->hw_bufs.dpb_c, 0, sizeof(struct ddl_buf_addr) * 4);
+	(void)memset(&encoder->hw_bufs.dpb_y, 0, sizeof(struct ddl_buf_addr) * 4);
+	(void)memset(&encoder->hw_bufs.dpb_c, 0, sizeof(struct ddl_buf_addr) * 4);
 
 	y_cb_cr_size = ddl_get_yuv_buffer_size(&encoder->frame_size,
 				&encoder->buf_format, false,
@@ -1673,7 +1673,7 @@ void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
 	encoder->input_buf_size.size_yuv = y_cb_cr_size;
 	encoder->input_buf_size.size_y   = y_size;
 	encoder->input_buf_size.size_c   = y_cb_cr_size - y_size;
-	memset(&encoder->input_buf_req , 0 ,
+	(void)memset(&encoder->input_buf_req , 0 ,
 		sizeof(struct vcd_buffer_requirement));
 	encoder->input_buf_req.min_count    = 3;
 	encoder->input_buf_req.actual_count =
@@ -1688,7 +1688,7 @@ void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
 		encoder->buf_format.buffer_format)
 		encoder->input_buf_req.align = DDL_TILE_BUFFER_ALIGN_BYTES;
 	encoder->client_input_buf_req = encoder->input_buf_req;
-	memset(&encoder->output_buf_req , 0 ,
+	(void)memset(&encoder->output_buf_req , 0 ,
 		sizeof(struct vcd_buffer_requirement));
 	encoder->output_buf_req.min_count    =
 		encoder->i_period.b_frames + 2;
@@ -1733,7 +1733,7 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 		min_dpb = decoder->min_dpb_num;
 		y_cb_cr_size = decoder->y_cb_cr_size;
 	}
-	memset(output_buf_req, 0,
+	(void)memset(output_buf_req, 0,
 		sizeof(struct vcd_buffer_requirement));
 	if (!estimate && !decoder->idr_only_decoding && !decoder->cont_mode)
 		output_buf_req->actual_count = min_dpb + 4;
@@ -1751,7 +1751,7 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 		output_buf_req);
 
 	decoder->min_output_buf_req = *output_buf_req;
-	memset(input_buf_req, 0,
+	(void)memset(input_buf_req, 0,
 		sizeof(struct vcd_buffer_requirement));
 	input_buf_req->min_count = 1;
 	input_buf_req->actual_count = input_buf_req->min_count + 1;
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
index 7ccf4c2..9663541 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
@@ -156,7 +156,7 @@ void ddl_pmem_free(struct ddl_buf_addr *addr)
 	}
 	if (addr->mapped_buffer)
 		msm_subsystem_unmap_buffer(addr->mapped_buffer);
-	memset(addr, 0, sizeof(struct ddl_buf_addr));
+	(void)memset(addr, 0, sizeof(struct ddl_buf_addr));
 }
 
 #ifdef DDL_BUF_LOG
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
index ab50258..c00bae9 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
@@ -942,7 +942,7 @@ void ddl_vidc_decode_eos_run(struct ddl_client_context *ddl)
 	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_SET_MASK);
 	decoder->dynmic_prop_change_req = true;
 	ddl->cmd_state = DDL_CMD_EOS;
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void)memset(&dec_param, 0, sizeof(dec_param));
 	dec_param.cmd_seq_num = ++ddl_context->cmd_seq_num;
 	dec_param.inst_id = ddl->instance_id;
 	dec_param.shared_mem_addr_offset = DDL_ADDR_OFFSET(
diff --git a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
index 795d1e3..fb73dc2 100644
--- a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
+++ b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
@@ -549,7 +549,7 @@ void res_trk_init(struct device *device, u32 irq)
 		VCDRES_MSG_ERROR("%s() Resource Tracker Init error\n",
 			__func__);
 	} else {
-		memset(&resource_context, 0, sizeof(resource_context));
+		(void)memset(&resource_context, 0, sizeof(resource_context));
 		mutex_init(&resource_context.lock);
 		mutex_init(&resource_context.secure_lock);
 		resource_context.device = device;
@@ -595,7 +595,7 @@ void res_trk_init(struct device *device, u32 irq)
 			VIDC_FW_SIZE, DDL_KILO_BYTE(128))) {
 			pr_err("%s() Firmware buffer allocation failed",
 				   __func__);
-			memset(&resource_context.firmware_addr, 0,
+			(void)memset(&resource_context.firmware_addr, 0,
 			   sizeof(resource_context.firmware_addr));
 		}
 	}
diff --git a/drivers/video/msm/vidc/common/dec/vdec.c b/drivers/video/msm/vidc/common/dec/vdec.c
index 980ec21..88b69ab 100644
--- a/drivers/video/msm/vidc/common/dec/vdec.c
+++ b/drivers/video/msm/vidc/common/dec/vdec.c
@@ -812,7 +812,7 @@ static u32 vid_dec_set_h264_mv_buffers(struct video_client_ctx *client_ctx,
 	vcd_property_hdr.sz = sizeof(struct vcd_property_h264_mv_buffer);
 	vcd_h264_mv_buffer = &client_ctx->vcd_h264_mv_buffer;
 
-	memset(&client_ctx->vcd_h264_mv_buffer, 0,
+	(void)memset(&client_ctx->vcd_h264_mv_buffer, 0,
 		   sizeof(struct vcd_property_h264_mv_buffer));
 	vcd_h264_mv_buffer->size = mv_data->size;
 	vcd_h264_mv_buffer->count = mv_data->count;
@@ -1183,7 +1183,7 @@ static u32 vid_dec_decode_frame(struct video_client_ctx *client_ctx,
 				      &buffer_index)) {
 
 		/* kernel_vaddr  is found. send the frame to VCD */
-		memset((void *)&vcd_input_buffer, 0,
+		(void)memset((void *)&vcd_input_buffer, 0,
 		       sizeof(struct vcd_frame_data));
 		vcd_input_buffer.virtual =
 		    (u8 *) (kernel_vaddr + input_frame_info->pmem_offset);
@@ -1236,7 +1236,7 @@ static u32 vid_dec_fill_output_buffer(struct video_client_ctx *client_ctx,
 				      &phy_addr, &pmem_fd, &file,
 				      &buffer_index)) {
 
-		memset((void *)&vcd_frame, 0,
+		(void)memset((void *)&vcd_frame, 0,
 		       sizeof(struct vcd_frame_data));
 		vcd_frame.virtual = (u8 *) kernel_vaddr;
 		vcd_frame.frm_clnt_data = (u32) fill_buffer_cmd->client_data;
@@ -1955,7 +1955,7 @@ static u32 vid_dec_close_client(struct video_client_ctx *client_ctx)
 		return false;
 	}
 	client_ctx->user_ion_client = NULL;
-	memset((void *)client_ctx, 0, sizeof(struct video_client_ctx));
+	(void)memset((void *)client_ctx, 0, sizeof(struct video_client_ctx));
 	vid_dec_device_p->num_clients--;
 	mutex_unlock(&vid_dec_device_p->lock);
 	return true;
@@ -2137,7 +2137,7 @@ static int vid_dec_vcd_init(void)
 	vid_dec_device_p->num_clients = 0;
 
 	for (i = 0; i < VIDC_MAX_NUM_CLIENTS; i++) {
-		memset((void *)&vid_dec_device_p->vdec_clients[i], 0,
+		(void)memset((void *)&vid_dec_device_p->vdec_clients[i], 0,
 		       sizeof(vid_dec_device_p->vdec_clients[i]));
 	}
 
diff --git a/drivers/video/msm/vidc/common/enc/venc.c b/drivers/video/msm/vidc/common/enc/venc.c
index 97fc758..0ece278 100644
--- a/drivers/video/msm/vidc/common/enc/venc.c
+++ b/drivers/video/msm/vidc/common/enc/venc.c
@@ -494,7 +494,7 @@ static u32 vid_enc_close_client(struct video_client_ctx *client_ctx)
 		mutex_unlock(&vid_enc_device_p->lock);
 		return false;
 	}
-	memset((void *)client_ctx, 0,
+	(void)memset((void *)client_ctx, 0,
 		sizeof(struct video_client_ctx));
 
 	vid_enc_device_p->num_clients--;
@@ -624,7 +624,7 @@ static int vid_enc_vcd_init(void)
 	vid_enc_device_p->num_clients = 0;
 
 	for (i = 0; i < VIDC_MAX_NUM_CLIENTS; i++) {
-		memset((void *)&vid_enc_device_p->venc_clients[i], 0,
+		(void)memset((void *)&vid_enc_device_p->venc_clients[i], 0,
 		sizeof(vid_enc_device_p->venc_clients[i]));
 	}
 
diff --git a/drivers/video/msm/vidc/common/enc/venc_internal.c b/drivers/video/msm/vidc/common/enc/venc_internal.c
index 1dbd170..fed868e 100644
--- a/drivers/video/msm/vidc/common/enc/venc_internal.c
+++ b/drivers/video/msm/vidc/common/enc/venc_internal.c
@@ -1623,7 +1623,7 @@ u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
 			&buffer_index)) {
 
 		/* kernel_vaddr  is found. send the frame to VCD */
-		memset((void *)&vcd_input_buffer, 0,
+		(void)memset((void *)&vcd_input_buffer, 0,
 					sizeof(struct vcd_frame_data));
 
 		vcd_input_buffer.virtual =
@@ -1678,7 +1678,7 @@ u32 vid_enc_fill_output_buffer(struct video_client_ctx *client_ctx,
 			&phy_addr, &pmem_fd, &file,
 			&buffer_index)) {
 
-		memset((void *)&vcd_frame, 0,
+		(void)memset((void *)&vcd_frame, 0,
 					 sizeof(struct vcd_frame_data));
 		vcd_frame.virtual = (u8 *) kernel_vaddr;
 		vcd_frame.frm_clnt_data = (u32) output_frame_info->clientdata;
@@ -1851,7 +1851,7 @@ u32 vid_enc_free_recon_buffers(struct video_client_ctx *client_ctx,
 			client_ctx->recon_buffer_ion_handle[i] = NULL;
 		}
 	}
-	memset(control, 0, sizeof(struct vcd_property_enc_recon_buffer));
+	(void)memset(control, 0, sizeof(struct vcd_property_enc_recon_buffer));
 	return true;
 }
 
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
index 4c477cb..54f9013 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
@@ -297,7 +297,7 @@ void vcd_term_driver_context(struct vcd_drv_ctxt *drv_ctxt)
 
 	kfree(dev_ctxt->trans_tbl);
 
-	memset(dev_ctxt, 0, sizeof(struct vcd_dev_ctxt));
+	(void)memset(dev_ctxt, 0, sizeof(struct vcd_dev_ctxt));
 
 	vcd_do_device_state_transition(drv_ctxt,
 					   VCD_DEVICE_STATE_NULL,
@@ -740,7 +740,7 @@ static u32 vcd_open_cmn
 		return VCD_ERR_ALLOC_FAIL;
 	}
 
-	memset(cctxt, 0, sizeof(struct vcd_clnt_ctxt));
+	(void)memset(cctxt, 0, sizeof(struct vcd_clnt_ctxt));
 	cctxt->dev_ctxt = dev_ctxt;
 	cctxt->driver_id = driver_handle - 1;
 	cctxt->decoding = decoding;
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c b/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
index 34a3445..5483d14 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
@@ -107,7 +107,7 @@ u32 vcd_sched_add_client(struct vcd_clnt_ctxt *cctxt)
 				cctxt->frm_rate.fps_denominator;
 
 			cctxt->sched_clnt_hdl = sched_cctxt;
-			memset(sched_cctxt, 0,
+			(void)memset(sched_cctxt, 0,
 				sizeof(struct vcd_sched_clnt_ctx));
 			sched_cctxt->tkns = 0;
 			sched_cctxt->round_perfrm = NORMALIZATION_FACTOR *
@@ -139,7 +139,7 @@ u32 vcd_sched_remove_client(struct vcd_sched_clnt_ctx *sched_cctxt)
 	} else {
 		cctxt = sched_cctxt->clnt_data;
 		list_del(&sched_cctxt->list);
-		memset(sched_cctxt, 0,
+		(void)memset(sched_cctxt, 0,
 			sizeof(struct vcd_sched_clnt_ctx));
 		kfree(sched_cctxt);
 	}
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_sub.c b/drivers/video/msm/vidc/common/vcd/vcd_sub.c
index b5fcc1c..93c7a56 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_sub.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_sub.c
@@ -680,7 +680,7 @@ u32 vcd_free_one_buffer_internal(
 		buf_pool->allocated--;
 	}
 
-	memset(buf_entry, 0, sizeof(struct vcd_buffer_entry));
+	(void)memset(buf_entry, 0, sizeof(struct vcd_buffer_entry));
 	buf_pool->validated--;
 	if (buf_pool->validated == 0)
 		vcd_free_buffer_pool_entries(buf_pool);
@@ -748,7 +748,7 @@ void vcd_free_buffer_pool_entries(struct vcd_buffer_pool *buf_pool)
 {
 	VCD_MSG_LOW("vcd_free_buffer_pool_entries:");
 	kfree(buf_pool->entries);
-	memset(buf_pool, 0, sizeof(struct vcd_buffer_pool));
+	(void)memset(buf_pool, 0, sizeof(struct vcd_buffer_pool));
 	INIT_LIST_HEAD(&buf_pool->queue);
 }
 
@@ -780,7 +780,7 @@ void vcd_reset_buffer_pool_for_reuse(struct vcd_buffer_pool *buf_pool)
 	VCD_MSG_LOW("vcd_reset_buffer_pool_for_reuse:");
 
 	if (buf_pool->entries) {
-		memset(&buf_pool->entries[1], 0,
+		(void)memset(&buf_pool->entries[1], 0,
 			sizeof(struct vcd_buffer_entry) *
 			VCD_MAX_BUFFER_ENTRIES);
 	}
@@ -1428,8 +1428,8 @@ u32 vcd_submit_frame(struct vcd_dev_ctxt *dev_ctxt,
 	transc->time_stamp = ip_frm_entry->time_stamp;
 	transc->flags = ip_frm_entry->flags;
 	ip_frm_entry->ip_frm_tag = (u32) transc;
-	memset(&ddl_ip_frm, 0, sizeof(ddl_ip_frm));
-	memset(&ddl_op_frm, 0, sizeof(ddl_op_frm));
+	(void)memset(&ddl_ip_frm, 0, sizeof(ddl_ip_frm));
+	(void)memset(&ddl_op_frm, 0, sizeof(ddl_op_frm));
 	if (cctxt->decoding) {
 		evcode = CLIENT_STATE_EVENT_NUMBER(decode_frame);
 		ddl_ip_frm.vcd_frm = *ip_frm_entry;
@@ -1552,7 +1552,7 @@ void vcd_send_frame_done_in_eos(struct vcd_clnt_ctxt *cctxt,
 				  sizeof(struct vcd_frame_data),
 				  cctxt, cctxt->client_data);
 
-		memset(&cctxt->out_buf_pool.entries[0].frame,
+		(void)memset(&cctxt->out_buf_pool.entries[0].frame,
 			   0, sizeof(struct vcd_frame_data));
 	} else if (!input_frame->data_len) {
 		if (cctxt->decoding) {
@@ -1577,7 +1577,7 @@ void vcd_send_frame_done_in_eos_for_dec(
 
 	prop_hdr.prop_id = DDL_I_DPB_RETRIEVE;
 	prop_hdr.sz = sizeof(struct ddl_frame_data_tag);
-	memset(&ddl_frm, 0, sizeof(ddl_frm));
+	(void)memset(&ddl_frm, 0, sizeof(ddl_frm));
 	rc = ddl_get_property(cctxt->ddl_handle, &prop_hdr, &ddl_frm);
 
 	if (VCD_FAILED(rc) || !ddl_frm.vcd_frm.virtual) {
@@ -1789,7 +1789,7 @@ struct vcd_transc *vcd_get_free_trans_tbl_entry
 	if (i == dev_ctxt->trans_tbl_size) {
 		return NULL;
 	} else {
-		memset(&dev_ctxt->trans_tbl[i], 0,
+		(void)memset(&dev_ctxt->trans_tbl[i], 0,
 			   sizeof(struct vcd_transc));
 
 		dev_ctxt->trans_tbl[i].in_use = true;
@@ -2403,7 +2403,7 @@ void vcd_handle_eos_done(struct vcd_clnt_ctxt *cctxt,
 			vcd_send_frame_done_in_eos(cctxt,
 				&transc->ip_buf_entry->frame, false);
 		} else {
-			memset(&vcd_frm, 0, sizeof(struct vcd_frame_data));
+			(void)memset(&vcd_frm, 0, sizeof(struct vcd_frame_data));
 			vcd_frm.ip_frm_tag = transc->ip_frm_tag;
 			vcd_frm.time_stamp = transc->time_stamp;
 			vcd_frm.flags = VCD_FRAME_FLAG_EOS;
@@ -2489,7 +2489,7 @@ void vcd_handle_stop_done(struct vcd_clnt_ctxt *cctxt,
 	cctxt->callback(VCD_EVT_RESP_STOP, status, NULL, 0, cctxt,
 					  cctxt->client_data);
 
-	memset(&cctxt->status, 0, sizeof(struct vcd_clnt_status));
+	(void)memset(&cctxt->status, 0, sizeof(struct vcd_clnt_status));
 }
 
 void vcd_handle_stop_done_in_starting(struct vcd_clnt_ctxt
@@ -3144,7 +3144,7 @@ u32 vcd_return_op_buffer_to_hw(struct vcd_clnt_ctxt *cctxt,
 		Prop_hdr.prop_id = DDL_I_DPB_RELEASE;
 		Prop_hdr.sz =
 			sizeof(struct ddl_frame_data_tag);
-		memset(&ddl_frm, 0, sizeof(ddl_frm));
+		(void)memset(&ddl_frm, 0, sizeof(ddl_frm));
 		ddl_frm.vcd_frm = *frm_entry;
 		rc = ddl_set_property(cctxt->ddl_handle, &Prop_hdr,
 				      &ddl_frm);
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
index 2fe3cf1..1753ccc 100644
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -715,7 +715,7 @@ static ssize_t cifs_security_flags_proc_write(struct file *file,
 	if ((count < 1) || (count > 11))
 		return -EINVAL;
 
-	memset(flags_string, 0, 12);
+	(void)memset(flags_string, 0, 12);
 
 	if (copy_from_user(flags_string, buffer, count))
 		return -EFAULT;
diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c
index 5a0ee7f..164767e 100644
--- a/fs/cifs/cifsencrypt.c
+++ b/fs/cifs/cifsencrypt.c
@@ -89,7 +89,7 @@ int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,
 
 	rc = cifs_calculate_signature(cifs_pdu, server, smb_signature);
 	if (rc)
-		memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
+		(void)memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
 	else
 		memcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);
 
@@ -166,7 +166,7 @@ int cifs_sign_smb2(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,
 
 	rc = cifs_calc_signature2(iov, n_vec, server, smb_signature);
 	if (rc)
-		memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
+		(void)memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
 	else
 		memcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);
 
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 07132c4..ec3a741 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -142,7 +142,7 @@ cifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)
 	 * greater than cifs socket timeout which is 7 seconds
 	 */
 	while (server->tcpStatus == CifsNeedReconnect) {
-		wait_event_interruptible_timeout(server->response_q,
+		(void)wait_event_interruptible_timeout(server->response_q,
 			(server->tcpStatus != CifsNeedReconnect), 10 * HZ);
 
 		/* are we still trying to reconnect? */
@@ -3576,7 +3576,7 @@ QInfRetry:
 
 		/* decode response */
 		/* BB FIXME - add time zone adjustment BB */
-		memset(pFinfo, 0, sizeof(FILE_ALL_INFO));
+		(void)memset(pFinfo, 0, sizeof(FILE_ALL_INFO));
 		ts.tv_nsec = 0;
 		ts.tv_sec = time;
 		/* decode time fields */
@@ -5665,7 +5665,7 @@ setPermsRetry:
 	data_offset =
 	    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +
 				      offset);
-	memset(data_offset, 0, count);
+	(void)memset(data_offset, 0, count);
 	pSMB->DataOffset = cpu_to_le16(offset);
 	pSMB->ParameterOffset = cpu_to_le16(param_offset);
 	pSMB->SetupCount = 1;
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 2451627..7864633 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -360,7 +360,7 @@ cifs_demultiplex_thread(struct TCP_Server_Info *server)
 			}
 		} else if (isLargeBuf) {
 			/* we are reusing a dirty large buf, clear its start */
-			memset(bigbuf, 0, sizeof(struct smb_hdr));
+			(void)memset(bigbuf, 0, sizeof(struct smb_hdr));
 		}
 
 		if (smallbuf == NULL) {
@@ -373,7 +373,7 @@ cifs_demultiplex_thread(struct TCP_Server_Info *server)
 			}
 			/* beginning of smb buffer is cleared in our buf_get */
 		} else /* if existing small buf clear beginning */
-			memset(smallbuf, 0, sizeof(struct smb_hdr));
+			(void)memset(smallbuf, 0, sizeof(struct smb_hdr));
 
 		isLargeBuf = false;
 		isMultiRsp = false;
@@ -803,7 +803,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 	 * informational, only used for servers that do not support
 	 * port 445 and it can be overridden at mount time
 	 */
-	memset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
+	(void)memset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
 	for (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)
 		vol->source_rfc1001_name[i] = toupper(nodename[i]);
 
@@ -1195,7 +1195,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 			if (!value || !*value || (*value == ' ')) {
 				cFYI(1, "invalid (empty) netbiosname");
 			} else {
-				memset(vol->source_rfc1001_name, 0x20,
+				(void)memset(vol->source_rfc1001_name, 0x20,
 					RFC1001_NAME_LEN);
 				/*
 				 * FIXME: are there cases in which a comma can
@@ -1220,7 +1220,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 				cFYI(1, "empty server netbiosname specified");
 			} else {
 				/* last byte, type, is 0x20 for servr type */
-				memset(vol->target_rfc1001_name, 0x20,
+				(void)memset(vol->target_rfc1001_name, 0x20,
 					RFC1001_NAME_LEN_WITH_NULL);
 
 				for (i = 0; i < 15; i++) {
@@ -1484,7 +1484,7 @@ srcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)
 		return ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);
 	}
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false; /* don't expect to be here */
 	}
 }
@@ -1509,7 +1509,7 @@ match_port(struct TCP_Server_Info *server, struct sockaddr *addr)
 		port = ((struct sockaddr_in6 *) addr)->sin6_port;
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false;
 	}
 
@@ -1551,7 +1551,7 @@ match_address(struct TCP_Server_Info *server, struct sockaddr *addr,
 		break;
 	}
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false; /* don't expect to be here */
 	}
 
@@ -1690,7 +1690,7 @@ cifs_get_tcp_session(struct smb_vol *volume_info)
 	struct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;
 	int rc;
 
-	memset(&addr, 0, sizeof(struct sockaddr_storage));
+	(void)memset(&addr, 0, sizeof(struct sockaddr_storage));
 
 	cFYI(1, "UNC: %s ip: %s", volume_info->UNC, volume_info->UNCip);
 
@@ -2208,7 +2208,7 @@ cifs_match_super(struct super_block *sb, void *data)
 	struct sockaddr_storage addr;
 	int rc = 0;
 
-	memset(&addr, 0, sizeof(struct sockaddr_storage));
+	(void)memset(&addr, 0, sizeof(struct sockaddr_storage));
 
 	spin_lock(&cifs_tcp_ses_lock);
 	cifs_sb = CIFS_SB(sb);
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index a9b4a24..d524e58 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -1970,7 +1970,7 @@ static void cifs_copy_cache_pages(struct address_space *mapping,
 		if (PAGE_CACHE_SIZE > bytes_read) {
 			memcpy(target, data, bytes_read);
 			/* zero the tail end of this partial page */
-			memset(target + bytes_read, 0,
+			(void)memset(target + bytes_read, 0,
 			       PAGE_CACHE_SIZE - bytes_read);
 			bytes_read = 0;
 		} else {
@@ -2173,7 +2173,7 @@ static int cifs_readpage_worker(struct file *file, struct page *page,
 		current_fs_time(file->f_path.dentry->d_inode->i_sb);
 
 	if (PAGE_CACHE_SIZE > rc)
-		memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
+		(void)memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
 
 	flush_dcache_page(page);
 	SetPageUptodate(page);
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index a7b2dcd..f20450f 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -192,7 +192,7 @@ void
 cifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,
 			 struct cifs_sb_info *cifs_sb)
 {
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_uniqueid = le64_to_cpu(info->UniqueId);
 	fattr->cf_bytes = le64_to_cpu(info->NumOfBytes);
 	fattr->cf_eof = le64_to_cpu(info->EndOfFile);
@@ -275,7 +275,7 @@ cifs_create_dfs_fattr(struct cifs_fattr *fattr, struct super_block *sb)
 
 	cFYI(1, "creating fake fattr for DFS referral");
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;
 	fattr->cf_uid = cifs_sb->mnt_uid;
 	fattr->cf_gid = cifs_sb->mnt_gid;
@@ -509,7 +509,7 @@ cifs_all_info_to_fattr(struct cifs_fattr *fattr, FILE_ALL_INFO *info,
 {
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_cifsattrs = le32_to_cpu(info->Attributes);
 	if (info->DeletePending)
 		fattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;
@@ -1398,7 +1398,7 @@ mkdir_get_info:
 				struct cifsInodeInfo *cifsInode;
 				u32 dosattrs;
 
-				memset(&pInfo, 0, sizeof(pInfo));
+				(void)memset(&pInfo, 0, sizeof(pInfo));
 				cifsInode = CIFS_I(newinode);
 				dosattrs = cifsInode->cifsAttrs|ATTR_READONLY;
 				pInfo.Attributes = cpu_to_le32(dosattrs);
diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
index 6751e74..8498154 100644
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@ -151,7 +151,7 @@ static void
 cifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,
 		       struct cifs_sb_info *cifs_sb)
 {
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);
 	fattr->cf_eof = le64_to_cpu(info->EndOfFile);
 	fattr->cf_bytes = le64_to_cpu(info->AllocationSize);
@@ -169,7 +169,7 @@ cifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,
 {
 	int offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,
 					    info->LastAccessTime, offset);
 	fattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index d3e6196..0e872a0 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -416,7 +416,7 @@ static void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
 	NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;
 	__u32 flags;
 
-	memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
+	(void)memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
 	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
 	sec_blob->MessageType = NtLmNegotiate;
 
diff --git a/fs/cifs/smbencrypt.c b/fs/cifs/smbencrypt.c
index 1c5b770..3bad34f 100644
--- a/fs/cifs/smbencrypt.c
+++ b/fs/cifs/smbencrypt.c
@@ -178,9 +178,9 @@ SMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)
 	int rc;
 	unsigned char p14[14], p16[16], p21[21];
 
-	memset(p14, '\0', 14);
-	memset(p16, '\0', 16);
-	memset(p21, '\0', 21);
+	(void)memset(p14, '\0', 14);
+	(void)memset(p16, '\0', 16);
+	(void)memset(p21, '\0', 21);
 
 	memcpy(p14, passwd, 14);
 	rc = E_P16(p14, p16);
@@ -254,7 +254,7 @@ E_md4hash(const unsigned char *passwd, unsigned char *p16)
 	len = _my_wcslen(wpwd) * sizeof(__u16);
 
 	rc = mdfour(p16, (unsigned char *) wpwd, len);
-	memset(wpwd, 0, 129 * 2);
+	(void)memset(wpwd, 0, 129 * 2);
 
 	return rc;
 }
@@ -351,8 +351,8 @@ SMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24)
 	int rc;
 	unsigned char p16[16], p21[21];
 
-	memset(p16, '\0', 16);
-	memset(p21, '\0', 21);
+	(void)memset(p16, '\0', 16);
+	(void)memset(p21, '\0', 21);
 
 	rc = E_md4hash(passwd, p16);
 	if (rc) {
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index c1b9c4b..fc41b70 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -56,7 +56,7 @@ AllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)
 	if (temp == NULL)
 		return temp;
 	else {
-		memset(temp, 0, sizeof(struct mid_q_entry));
+		(void)memset(temp, 0, sizeof(struct mid_q_entry));
 		temp->mid = smb_buffer->Mid;	/* always LE */
 		temp->pid = current->pid;
 		temp->command = smb_buffer->Command;
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index 5299706..a7ed031 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -532,7 +532,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 		size_t size = EXT2_XATTR_LEN(name_len);
 		size_t rest = (char *)last - (char *)here;
 		memmove((char *)here + size, here, rest);
-		memset(here, 0, size);
+		(void)memset(here, 0, size);
 		here->e_name_index = name_index;
 		here->e_name_len = name_len;
 		memcpy(here->e_name, name, name_len);
@@ -548,7 +548,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 				/* The old and the new value have the same
 				   size. Just replace. */
 				here->e_value_size = cpu_to_le32(value_len);
-				memset(val + size - EXT2_XATTR_PAD, 0,
+				(void)memset(val + size - EXT2_XATTR_PAD, 0,
 				       EXT2_XATTR_PAD); /* Clear pad bytes. */
 				memcpy(val, value, value_len);
 				goto skip_replace;
@@ -556,7 +556,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 
 			/* Remove the old value. */
 			memmove(first_val + size, first_val, val - first_val);
-			memset(first_val, 0, size);
+			(void)memset(first_val, 0, size);
 			here->e_value_offs = 0;
 			min_offs += size;
 
@@ -576,7 +576,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 			last = ENTRY((char *)last - size);
 			memmove(here, (char*)here + size,
 				(char*)last - (char*)here);
-			memset(last, 0, size);
+			(void)memset(last, 0, size);
 		}
 	}
 
@@ -588,7 +588,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 			char *val = (char *)header + min_offs - size;
 			here->e_value_offs =
 				cpu_to_le16((char *)val - (char *)header);
-			memset(val + size - EXT2_XATTR_PAD, 0,
+			(void)memset(val + size - EXT2_XATTR_PAD, 0,
 			       EXT2_XATTR_PAD); /* Clear the pad bytes. */
 			memcpy(val, value, value_len);
 		}
diff --git a/fs/ext3/ialloc.c b/fs/ext3/ialloc.c
index bfc2dc4..48eacc1 100644
--- a/fs/ext3/ialloc.c
+++ b/fs/ext3/ialloc.c
@@ -540,7 +540,7 @@ got:
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index 3451d23..6ea207e 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -665,7 +665,7 @@ static int ext3_alloc_branch(handle_t *handle, struct inode *inode,
 			goto failed;
 		}
 
-		memset(bh->b_data, 0, blocksize);
+		(void)memset(bh->b_data, 0, blocksize);
 		branch[n].p = (__le32 *) bh->b_data + offsets[n];
 		branch[n].key = cpu_to_le32(new_blocks[n]);
 		*branch[n].p = branch[n].key;
@@ -1044,7 +1044,7 @@ struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,
 	 */
 	if (err > 0) {
 		if (err > 1)
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		err = 0;
 	}
 	*errp = err;
@@ -1070,7 +1070,7 @@ struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,
 			BUFFER_TRACE(bh, "call get_create_access");
 			fatal = ext3_journal_get_create_access(handle, bh);
 			if (!fatal && !buffer_uptodate(bh)) {
-				memset(bh->b_data,0,inode->i_sb->s_blocksize);
+				(void)memset(bh->b_data,0,inode->i_sb->s_blocksize);
 				set_buffer_uptodate(bh);
 			}
 			unlock_buffer(bh);
@@ -1568,7 +1568,7 @@ static int ext3_ordered_writepage(struct page *page,
 	int err;
 
 	J_ASSERT(PageLocked(page));
-	WARN_ON_ONCE(IS_RDONLY(inode));
+	(void)WARN_ON_ONCE(IS_RDONLY(inode));
 
 	/*
 	 * We give up here if we're reentered, because it might be for a
@@ -1642,7 +1642,7 @@ static int ext3_writeback_writepage(struct page *page,
 	int err;
 
 	J_ASSERT(PageLocked(page));
-	WARN_ON_ONCE(IS_RDONLY(inode));
+	(void)WARN_ON_ONCE(IS_RDONLY(inode));
 
 	if (ext3_journal_current_handle())
 		goto out_fail;
@@ -1684,7 +1684,7 @@ static int ext3_journalled_writepage(struct page *page,
 	int err;
 
 	J_ASSERT(PageLocked(page));
-	WARN_ON_ONCE(IS_RDONLY(inode));
+	(void)WARN_ON_ONCE(IS_RDONLY(inode));
 
 	if (ext3_journal_current_handle())
 		goto no_write;
@@ -1766,7 +1766,7 @@ static int ext3_releasepage(struct page *page, gfp_t wait)
 {
 	journal_t *journal = EXT3_JOURNAL(page->mapping->host);
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	return journal_try_to_free_buffers(journal, page, wait);
@@ -2733,7 +2733,7 @@ static int __ext3_get_inode_loc(struct inode *inode,
 			brelse(bitmap_bh);
 			if (i == start + inodes_per_buffer) {
 				/* all other inodes are free, so skip I/O */
-				memset(bh->b_data, 0, bh->b_size);
+				(void)memset(bh->b_data, 0, bh->b_size);
 				set_buffer_uptodate(bh);
 				unlock_buffer(bh);
 				goto has_buffer;
@@ -3003,7 +3003,7 @@ again:
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ext3_test_inode_state(inode, EXT3_STATE_NEW))
-		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
 
 	ext3_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index e5a7111..74afa37 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -1397,7 +1397,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	/* Initialize the root; the dot dirents already exist */
 	de = (struct ext3_dir_entry_2 *) (&root->dotdot);
 	de->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));
-	memset (&root->info, 0, sizeof(root->info));
+	(void)memset (&root->info, 0, sizeof(root->info));
 	root->info.info_length = sizeof(root->info);
 	root->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;
 	entries = root->entries;
@@ -1549,7 +1549,7 @@ static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			goto cleanup;
 		node2 = (struct dx_node *)(bh2->b_data);
 		entries2 = node2->entries;
-		memset(&node2->fake, 0, sizeof(struct fake_dirent));
+		(void)memset(&node2->fake, 0, sizeof(struct fake_dirent));
 		node2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);
 		BUFFER_TRACE(frame->bh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, frame->bh);
diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index aad153e..4633200 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -736,7 +736,7 @@ static int bdev_try_to_free_page(struct super_block *sb, struct page *page,
 {
 	journal_t *journal = EXT3_SB(sb)->s_journal;
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index 264f694..5a7e3c6 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -104,10 +104,10 @@ unsigned ext4_init_block_bitmap(struct super_block *sb, struct buffer_head *bh,
 			ext4_free_blks_set(sb, gdp, 0);
 			ext4_free_inodes_set(sb, gdp, 0);
 			ext4_itable_unused_set(sb, gdp, 0);
-			memset(bh->b_data, 0xff, sb->s_blocksize);
+			(void)memset(bh->b_data, 0xff, sb->s_blocksize);
 			return 0;
 		}
-		memset(bh->b_data, 0, sb->s_blocksize);
+		(void)memset(bh->b_data, 0, sb->s_blocksize);
 	}
 
 	/* Check for superblock and gdt backups in this group */
@@ -457,7 +457,7 @@ ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,
 	struct ext4_allocation_request ar;
 	ext4_fsblk_t ret;
 
-	memset(&ar, 0, sizeof(ar));
+	(void)memset(&ar, 0, sizeof(ar));
 	/* Fill with neighbour allocated blocks */
 	ar.inode = inode;
 	ar.goal = goal;
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index f3aacb3..5d60e9a 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1615,7 +1615,7 @@ static int ext4_ext_try_to_merge_right(struct inode *inode,
 		}
 		le16_add_cpu(&eh->eh_entries, -1);
 		merge_done = 1;
-		WARN_ON(eh->eh_entries == 0);
+		(void)WARN_ON(eh->eh_entries == 0);
 		if (!eh->eh_entries)
 			EXT4_ERROR_INODE(inode, "eh->eh_entries = 0!");
 	}
@@ -2488,7 +2488,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 					sizeof(struct ext4_extent));
 
 				/* Now get rid of the one at the end */
-				memset(EXT_LAST_EXTENT(eh), 0,
+				(void)memset(EXT_LAST_EXTENT(eh), 0,
 					sizeof(struct ext4_extent));
 			}
 			le16_add_cpu(&eh->eh_entries, -1);
@@ -2609,7 +2609,7 @@ again:
 			/* go to the next level */
 			ext_debug("move to level %d (block %llu)\n",
 				  i + 1, ext4_idx_pblock(path[i].p_idx));
-			memset(path + i + 1, 0, sizeof(*path));
+			(void)memset(path + i + 1, 0, sizeof(*path));
 			bh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));
 			if (!bh) {
 				/* should we reset i_size? */
@@ -2967,7 +2967,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 	ee_len = ext4_ext_get_actual_len(ex);
 	allocated = ee_len - (map->m_lblk - ee_block);
 
-	WARN_ON(map->m_lblk < ee_block);
+	(void)WARN_ON(map->m_lblk < ee_block);
 	/*
 	 * It is safe to convert extent to initialized via explicit
 	 * zeroout only if extent is fully insde i_size or new_size.
@@ -3898,7 +3898,7 @@ int ext4_convert_unwritten_extents(struct inode *inode, loff_t offset,
 		ret = ext4_map_blocks(handle, inode, &map,
 				      EXT4_GET_BLOCKS_IO_CONVERT_EXT);
 		if (ret <= 0) {
-			WARN_ON(ret <= 0);
+			(void)WARN_ON(ret <= 0);
 			printk(KERN_ERR "%s: ext4_ext_map_blocks "
 				    "returned error inode#%lu, block=%u, "
 				    "max_blocks=%u", __func__,
@@ -4261,7 +4261,7 @@ int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 	while (iblock < last_block) {
 		max_blocks = last_block - iblock;
 		num_blocks = 1;
-		memset(&map, 0, sizeof(map));
+		(void)memset(&map, 0, sizeof(map));
 		map.m_lblk = iblock;
 		map.m_len = max_blocks;
 		ret = ext4_ext_map_blocks(handle, inode, &map,
@@ -4278,7 +4278,7 @@ int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 			 * put it in the cache.  So we can get the hole
 			 * out of the cache
 			 */
-			memset(&cache_ex, 0, sizeof(cache_ex));
+			(void)memset(&cache_ex, 0, sizeof(cache_ex));
 			if ((ext4_ext_check_cache(inode, iblock, &cache_ex)) &&
 				!cache_ex.ec_start) {
 
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index ce66d2f..bc3a086 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -141,7 +141,7 @@ static int ext4_sync_parent(struct inode *inode)
 		ret = sync_mapping_buffers(inode->i_mapping);
 		if (ret)
 			break;
-		memset(&wbc, 0, sizeof(wbc));
+		(void)memset(&wbc, 0, sizeof(wbc));
 		wbc.sync_mode = WB_SYNC_ALL;
 		wbc.nr_to_write = 0;         /* only write out the inode */
 		ret = sync_inode(inode, &wbc);
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 21bb2f6..1c687f0 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -61,7 +61,7 @@ void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 	for (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)
 		ext4_set_bit(i, bitmap);
 	if (i < end_bit)
-		memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
+		(void)memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
 }
 
 /* Initializes an uninitialized inode bitmap */
@@ -81,11 +81,11 @@ static unsigned ext4_init_inode_bitmap(struct super_block *sb,
 		ext4_free_blks_set(sb, gdp, 0);
 		ext4_free_inodes_set(sb, gdp, 0);
 		ext4_itable_unused_set(sb, gdp, 0);
-		memset(bh->b_data, 0xff, sb->s_blocksize);
+		(void)memset(bh->b_data, 0xff, sb->s_blocksize);
 		return 0;
 	}
 
-	memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
+	(void)memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
 	ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8,
 			bh->b_data);
 
@@ -492,7 +492,7 @@ static int find_group_orlov(struct super_block *sb, struct inode *parent,
 	avefreei = freei / ngroups;
 	freeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	avefreeb = freeb;
-	do_div(avefreeb, ngroups);
+	(void)do_div(avefreeb, ngroups);
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
 	if (S_ISDIR(mode) &&
@@ -1001,7 +1001,7 @@ got:
 	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
 						       ext4_current_time(inode);
 
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index c94774c..347ea0a 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -673,7 +673,7 @@ static int ext4_alloc_blocks(handle_t *handle, struct inode *inode,
 			new_blocks[index] = current_block;
 			printk(KERN_INFO "%s returned more blocks than "
 						"requested\n", __func__);
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			break;
 		}
 	}
@@ -683,7 +683,7 @@ static int ext4_alloc_blocks(handle_t *handle, struct inode *inode,
 	if (!target)
 		goto allocated;
 	/* Now allocate data blocks */
-	memset(&ar, 0, sizeof(ar));
+	(void)memset(&ar, 0, sizeof(ar));
 	ar.inode = inode;
 	ar.goal = goal;
 	ar.len = target;
@@ -802,7 +802,7 @@ static int ext4_alloc_branch(handle_t *handle, struct inode *inode,
 			goto failed;
 		}
 
-		memset(bh->b_data, 0, blocksize);
+		(void)memset(bh->b_data, 0, blocksize);
 		branch[n].p = (__le32 *) bh->b_data + offsets[n];
 		branch[n].key = cpu_to_le32(new_blocks[n]);
 		*branch[n].p = branch[n].key;
@@ -1133,7 +1133,7 @@ void ext4_da_update_reserve_space(struct inode *inode,
 			 "with only %d reserved data blocks\n",
 			 __func__, inode->i_ino, used,
 			 ei->i_reserved_data_blocks);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		used = ei->i_reserved_data_blocks;
 	}
 
@@ -1477,7 +1477,7 @@ struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
 		BUFFER_TRACE(bh, "call get_create_access");
 		fatal = ext4_journal_get_create_access(handle, bh);
 		if (!fatal && !buffer_uptodate(bh)) {
-			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
+			(void)memset(bh->b_data, 0, inode->i_sb->s_blocksize);
 			set_buffer_uptodate(bh);
 		}
 		unlock_buffer(bh);
@@ -1976,7 +1976,7 @@ static void ext4_da_release_space(struct inode *inode, int to_free)
 			 "ino %lu, to_free %d with only %d reserved "
 			 "data blocks\n", inode->i_ino, to_free,
 			 ei->i_reserved_data_blocks);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		to_free = ei->i_reserved_data_blocks;
 	}
 	ei->i_reserved_data_blocks -= to_free;
@@ -2055,7 +2055,7 @@ static int mpage_da_submit_io(struct mpage_da_data *mpd,
 	struct ext4_io_submit io_submit;
 
 	BUG_ON(mpd->next_page <= mpd->first_page);
-	memset(&io_submit, 0, sizeof(io_submit));
+	(void)memset(&io_submit, 0, sizeof(io_submit));
 	/*
 	 * We need to start from the first_page to the next_page - 1
 	 * to make sure we also write the mapped dirty buffer_heads.
@@ -2749,7 +2749,7 @@ static int write_cache_pages_da(struct address_space *mapping,
 	long			nr_to_write = wbc->nr_to_write;
 	int			i, tag, ret = 0;
 
-	memset(mpd, 0, sizeof(struct mpage_da_data));
+	(void)memset(mpd, 0, sizeof(struct mpage_da_data));
 	mpd->wbc = wbc;
 	mpd->inode = inode;
 	pagevec_init(&pvec, 0);
@@ -3455,7 +3455,7 @@ static int ext4_releasepage(struct page *page, gfp_t wait)
 
 	trace_ext4_releasepage(page);
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
@@ -4753,7 +4753,7 @@ static int __ext4_get_inode_loc(struct inode *inode,
 			brelse(bitmap_bh);
 			if (i == start + inodes_per_block) {
 				/* all other inodes are free, so skip I/O */
-				memset(bh->b_data, 0, bh->b_size);
+				(void)memset(bh->b_data, 0, bh->b_size);
 				set_buffer_uptodate(bh);
 				unlock_buffer(bh);
 				goto has_buffer;
@@ -5133,7 +5133,7 @@ static int ext4_do_update_inode(handle_t *handle,
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ext4_test_inode_state(inode, EXT4_STATE_NEW))
-		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
 
 	ext4_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
@@ -5664,7 +5664,7 @@ static int ext4_expand_extra_isize(struct inode *inode,
 	/* No extended attributes present */
 	if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||
 	    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {
-		memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,
+		(void)memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,
 			new_extra_isize);
 		EXT4_I(inode)->i_extra_isize = new_extra_isize;
 		return 0;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 0f1be7f..006f9dd 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -927,7 +927,7 @@ static int ext4_mb_init_cache(struct page *page, char *incore)
 			trace_ext4_mb_buddy_bitmap_load(sb, group);
 			grinfo = ext4_get_group_info(sb, group);
 			grinfo->bb_fragments = 0;
-			memset(grinfo->bb_counters, 0,
+			(void)memset(grinfo->bb_counters, 0,
 			       sizeof(*grinfo->bb_counters) *
 				(sb->s_blocksize_bits+2));
 			/*
@@ -935,7 +935,7 @@ static int ext4_mb_init_cache(struct page *page, char *incore)
 			 */
 			ext4_lock_group(sb, group);
 			/* init the buddy */
-			memset(data, 0xff, blocksize);
+			(void)memset(data, 0xff, blocksize);
 			ext4_mb_generate_buddy(sb, data, incore, group);
 			ext4_unlock_group(sb, group);
 			incore = NULL;
@@ -1882,7 +1882,7 @@ void ext4_mb_scan_aligned(struct ext4_allocation_context *ac,
 	first_group_block = ext4_group_first_block_no(sb, e4b->bd_group);
 
 	a = first_group_block + sbi->s_stripe - 1;
-	do_div(a, sbi->s_stripe);
+	(void)do_div(a, sbi->s_stripe);
 	i = (a * sbi->s_stripe) - first_group_block;
 
 	while (i < EXT4_BLOCKS_PER_GROUP(sb)) {
@@ -2240,7 +2240,7 @@ int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
 		printk(KERN_ERR "EXT4-fs: can't allocate buddy mem\n");
 		goto exit_group_info;
 	}
-	memset(meta_group_info[i], 0, kmem_cache_size(cachep));
+	(void)memset(meta_group_info[i], 0, kmem_cache_size(cachep));
 	set_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,
 		&(meta_group_info[i]->bb_state));
 
@@ -3776,7 +3776,7 @@ repeat:
 			spin_unlock(&pa->pa_lock);
 			spin_unlock(&ei->i_prealloc_lock);
 			printk(KERN_ERR "uh-oh! used pa while discarding\n");
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			schedule_timeout_uninterruptible(HZ);
 			goto repeat;
 
@@ -3986,7 +3986,7 @@ ext4_mb_initialize_context(struct ext4_allocation_context *ac,
 	ext4_get_group_no_and_offset(sb, goal, &group, &block);
 
 	/* set up allocation goals */
-	memset(ac, 0, sizeof(struct ext4_allocation_context));
+	(void)memset(ac, 0, sizeof(struct ext4_allocation_context));
 	ac->ac_b_ex.fe_logical = ar->logical;
 	ac->ac_status = AC_STATUS_CONTINUE;
 	ac->ac_sb = sb;
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index b57b98f..ea3fb8c 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -547,7 +547,7 @@ int ext4_ext_migrate(struct inode *inode)
 
 	ei = EXT4_I(inode);
 	i_data = ei->i_data;
-	memset(&lb, 0, sizeof(lb));
+	(void)memset(&lb, 0, sizeof(lb));
 
 	/* 32 bit block address 4 bytes */
 	max_entries = inode->i_sb->s_blocksize >> 2;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 458a394..dd2f484 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -1394,7 +1394,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	de = (struct ext4_dir_entry_2 *) (&root->dotdot);
 	de->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),
 					   blocksize);
-	memset (&root->info, 0, sizeof(root->info));
+	(void)memset (&root->info, 0, sizeof(root->info));
 	root->info.info_length = sizeof(root->info);
 	root->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;
 	entries = root->entries;
@@ -1554,7 +1554,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			goto cleanup;
 		node2 = (struct dx_node *)(bh2->b_data);
 		entries2 = node2->entries;
-		memset(&node2->fake, 0, sizeof(struct fake_dirent));
+		(void)memset(&node2->fake, 0, sizeof(struct fake_dirent));
 		node2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,
 							   sb->s_blocksize);
 		BUFFER_TRACE(frame->bh, "get_write_access");
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 80bbc9c..6acfc40 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -119,7 +119,7 @@ static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,
 		bh = ERR_PTR(err);
 	} else {
 		lock_buffer(bh);
-		memset(bh->b_data, 0, sb->s_blocksize);
+		(void)memset(bh->b_data, 0, sb->s_blocksize);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 	}
@@ -475,7 +475,7 @@ static int add_new_gdb(handle_t *handle, struct inode *inode,
 	}
 	inode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;
 	ext4_mark_iloc_dirty(handle, inode, &iloc);
-	memset((*primary)->b_data, 0, sb->s_blocksize);
+	(void)memset((*primary)->b_data, 0, sb->s_blocksize);
 	err = ext4_handle_dirty_metadata(handle, NULL, *primary);
 	if (unlikely(err)) {
 		ext4_std_error(sb, err);
@@ -684,7 +684,7 @@ static void update_backups(struct super_block *sb,
 		lock_buffer(bh);
 		memcpy(bh->b_data, data, size);
 		if (rest)
-			memset(bh->b_data + size, 0, rest);
+			(void)memset(bh->b_data + size, 0, rest);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 		err = ext4_handle_dirty_metadata(handle, NULL, bh);
@@ -849,7 +849,7 @@ int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)
 	gdp = (struct ext4_group_desc *)((char *)primary->b_data +
 					 gdb_off * EXT4_DESC_SIZE(sb));
 
-	memset(gdp, 0, EXT4_DESC_SIZE(sb));
+	(void)memset(gdp, 0, EXT4_DESC_SIZE(sb));
 	ext4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */
 	ext4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */
 	ext4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 111ed9d..00a1012 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -852,7 +852,7 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 
 	ei->vfs_inode.i_version = 1;
 	ei->vfs_inode.i_data.writeback_index = 0;
-	memset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));
+	(void)memset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));
 	INIT_LIST_HEAD(&ei->i_prealloc_list);
 	spin_lock_init(&ei->i_prealloc_lock);
 	ei->i_reserved_data_blocks = 0;
@@ -1177,7 +1177,7 @@ static int bdev_try_to_free_page(struct super_block *sb, struct page *page,
 {
 	journal_t *journal = EXT4_SB(sb)->s_journal;
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
@@ -3392,7 +3392,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	blocks_count = (ext4_blocks_count(es) -
 			le32_to_cpu(es->s_first_data_block) +
 			EXT4_BLOCKS_PER_GROUP(sb) - 1);
-	do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
+	(void)do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
 	if (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {
 		ext4_msg(sb, KERN_WARNING, "groups count too large: %u "
 		       "(block count %llu, first data block %u, "
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index c757adc..8f2b28c 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -572,7 +572,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 		size_t size = EXT4_XATTR_LEN(name_len);
 		size_t rest = (void *)last - (void *)s->here + sizeof(__u32);
 		memmove((void *)s->here + size, s->here, rest);
-		memset(s->here, 0, size);
+		(void)memset(s->here, 0, size);
 		s->here->e_name_index = i->name_index;
 		s->here->e_name_len = name_len;
 		memcpy(s->here->e_name, i->name, name_len);
@@ -589,7 +589,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 				   size. Just replace. */
 				s->here->e_value_size =
 					cpu_to_le32(i->value_len);
-				memset(val + size - EXT4_XATTR_PAD, 0,
+				(void)memset(val + size - EXT4_XATTR_PAD, 0,
 				       EXT4_XATTR_PAD); /* Clear pad bytes. */
 				memcpy(val, i->value, i->value_len);
 				return 0;
@@ -597,7 +597,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 
 			/* Remove the old value. */
 			memmove(first_val + size, first_val, val - first_val);
-			memset(first_val, 0, size);
+			(void)memset(first_val, 0, size);
 			s->here->e_value_size = 0;
 			s->here->e_value_offs = 0;
 			min_offs += size;
@@ -619,7 +619,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 			last = ENTRY((void *)last - size);
 			memmove(s->here, (void *)s->here + size,
 				(void *)last - (void *)s->here + sizeof(__u32));
-			memset(last, 0, size);
+			(void)memset(last, 0, size);
 		}
 	}
 
@@ -630,7 +630,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 			size_t size = EXT4_XATTR_SIZE(i->value_len);
 			void *val = s->base + min_offs - size;
 			s->here->e_value_offs = cpu_to_le16(min_offs - size);
-			memset(val + size - EXT4_XATTR_PAD, 0,
+			(void)memset(val + size - EXT4_XATTR_PAD, 0,
 			       EXT4_XATTR_PAD); /* Clear the pad bytes. */
 			memcpy(val, i->value, i->value_len);
 		}
@@ -995,7 +995,7 @@ ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,
 
 	if (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {
 		struct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);
-		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
 		ext4_clear_inode_state(inode, EXT4_STATE_NEW);
 	}
 
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 49c8c98..c4e0102 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -612,7 +612,7 @@ void writeback_inodes_wb(struct bdi_writeback *wb,
 static void __writeback_inodes_sb(struct super_block *sb,
 		struct bdi_writeback *wb, struct writeback_control *wbc)
 {
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	spin_lock(&inode_wb_list_lock);
 	if (!wbc->for_kupdate || list_empty(&wb->b_io))
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index fb6fc95..5e65607 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -37,7 +37,7 @@ static struct fuse_conn *fuse_get_conn(struct file *file)
 
 static void fuse_request_init(struct fuse_req *req)
 {
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 	INIT_LIST_HEAD(&req->list);
 	INIT_LIST_HEAD(&req->intr_entry);
 	init_waitqueue_head(&req->waitq);
@@ -332,7 +332,7 @@ __acquires(fc->lock)
 		return;
 
 	spin_unlock(&fc->lock);
-	wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
+	(void)wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
 	spin_lock(&fc->lock);
 }
 
@@ -390,7 +390,7 @@ __acquires(fc->lock)
 	spin_unlock(&fc->lock);
 
 	while (req->state != FUSE_REQ_FINISHED)
-		wait_event_freezable(req->waitq,
+		(void)wait_event_freezable(req->waitq,
 				     req->state == FUSE_REQ_FINISHED);
 	spin_lock(&fc->lock);
 
@@ -553,7 +553,7 @@ static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,
 			   int write,
 			   const struct iovec *iov, unsigned long nr_segs)
 {
-	memset(cs, 0, sizeof(*cs));
+	(void)memset(cs, 0, sizeof(*cs));
 	cs->fc = fc;
 	cs->write = write;
 	cs->iov = iov;
@@ -961,8 +961,8 @@ __releases(fc->lock)
 
 	list_del_init(&req->intr_entry);
 	req->intr_unique = fuse_get_unique(fc);
-	memset(&ih, 0, sizeof(ih));
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&ih, 0, sizeof(ih));
+	(void)memset(&arg, 0, sizeof(arg));
 	ih.len = reqsize;
 	ih.opcode = FUSE_INTERRUPT;
 	ih.unique = req->intr_unique;
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index d5016071..3cdab88 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -116,7 +116,7 @@ static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_req *req,
 			     u64 nodeid, struct qstr *name,
 			     struct fuse_entry_out *outarg)
 {
-	memset(outarg, 0, sizeof(struct fuse_entry_out));
+	(void)memset(outarg, 0, sizeof(struct fuse_entry_out));
 	req->in.h.opcode = FUSE_LOOKUP;
 	req->in.h.nodeid = nodeid;
 	req->in.numargs = 1;
@@ -408,8 +408,8 @@ static int fuse_create_open(struct inode *dir, struct dentry *entry, int mode,
 		mode &= ~current_umask();
 
 	flags &= ~O_NOCTTY;
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outentry, 0, sizeof(outentry));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outentry, 0, sizeof(outentry));
 	inarg.flags = flags;
 	inarg.mode = mode;
 	inarg.umask = current_umask();
@@ -493,7 +493,7 @@ static int create_new_entry(struct fuse_conn *fc, struct fuse_req *req,
 		return -ENOMEM;
 	}
 
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	req->in.h.nodeid = get_node_id(dir);
 	req->out.numargs = 1;
 	if (fc->minor < 9)
@@ -559,7 +559,7 @@ static int fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
 	if (!fc->dont_mask)
 		mode &= ~current_umask();
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
 	inarg.rdev = new_encode_dev(rdev);
 	inarg.umask = current_umask();
@@ -596,7 +596,7 @@ static int fuse_mkdir(struct inode *dir, struct dentry *entry, int mode)
 	if (!fc->dont_mask)
 		mode &= ~current_umask();
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
 	inarg.umask = current_umask();
 	req->in.h.opcode = FUSE_MKDIR;
@@ -695,7 +695,7 @@ static int fuse_rename(struct inode *olddir, struct dentry *oldent,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.newdir = get_node_id(newdir);
 	req->in.h.opcode = FUSE_RENAME;
 	req->in.h.nodeid = get_node_id(olddir);
@@ -747,7 +747,7 @@ static int fuse_link(struct dentry *entry, struct inode *newdir,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.oldnodeid = get_node_id(inode);
 	req->in.h.opcode = FUSE_LINK;
 	req->in.numargs = 2;
@@ -804,8 +804,8 @@ static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
 
 	attr_version = fuse_get_attr_version(fc);
 
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	/* Directories have separate file-handle space */
 	if (file && S_ISREG(inode->i_mode)) {
 		struct fuse_file *ff = file->private_data;
@@ -954,7 +954,7 @@ static int fuse_access(struct inode *inode, int mask)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);
 	req->in.h.opcode = FUSE_ACCESS;
 	req->in.h.nodeid = get_node_id(inode);
@@ -1314,8 +1314,8 @@ static int fuse_do_setattr(struct dentry *entry, struct iattr *attr,
 	if (is_truncate)
 		fuse_set_nowrite(inode);
 
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	iattr_to_fattr(attr, &inarg);
 	if (file) {
 		struct fuse_file *ff = file->private_data;
@@ -1419,7 +1419,7 @@ static int fuse_setxattr(struct dentry *entry, const char *name,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	inarg.flags = flags;
 	req->in.h.opcode = FUSE_SETXATTR;
@@ -1458,7 +1458,7 @@ static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	req->in.h.opcode = FUSE_GETXATTR;
 	req->in.h.nodeid = get_node_id(inode);
@@ -1510,7 +1510,7 @@ static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	req->in.h.opcode = FUSE_LISTXATTR;
 	req->in.h.nodeid = get_node_id(inode);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 82a6646..71e74bf 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -28,7 +28,7 @@ static int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);
 	if (!fc->atomic_o_trunc)
 		inarg.flags &= ~O_TRUNC;
@@ -276,7 +276,7 @@ static int fuse_release(struct inode *inode, struct file *file)
 
 void fuse_sync_release(struct fuse_file *ff, int flags)
 {
-	WARN_ON(atomic_read(&ff->count) > 1);
+	(void)WARN_ON(atomic_read(&ff->count) > 1);
 	fuse_prepare_release(ff, flags, FUSE_RELEASE);
 	ff->reserved_req->force = 1;
 	fuse_request_send(ff->fc, ff->reserved_req);
@@ -366,7 +366,7 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 		return 0;
 
 	req = fuse_get_req_nofail(fc, file);
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.fh = ff->fh;
 	inarg.lock_owner = fuse_lock_owner_id(fc, id);
 	req->in.h.opcode = FUSE_FLUSH;
@@ -430,7 +430,7 @@ int fuse_fsync_common(struct file *file, int datasync, int isdir)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.fh = ff->fh;
 	inarg.fsync_flags = datasync ? 1 : 0;
 	req->in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;
@@ -984,7 +984,7 @@ static ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	ssize_t err;
 	struct iov_iter i;
 
-	WARN_ON(iocb->ki_pos != pos);
+	(void)WARN_ON(iocb->ki_pos != pos);
 
 	err = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);
 	if (err)
@@ -1574,7 +1574,7 @@ static sector_t fuse_bmap(struct address_space *mapping, sector_t block)
 	if (IS_ERR(req))
 		return 0;
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.block = block;
 	inarg.blocksize = inode->i_sb->s_blocksize;
 	req->in.h.opcode = FUSE_BMAP;
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 38f84cd..cb371a1 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -380,7 +380,7 @@ static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	req->in.numargs = 0;
 	req->in.h.opcode = FUSE_STATFS;
 	req->in.h.nodeid = get_node_id(dentry->d_inode);
@@ -423,7 +423,7 @@ static const match_table_t tokens = {
 static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)
 {
 	char *p;
-	memset(d, 0, sizeof(struct fuse_mount_data));
+	(void)memset(d, 0, sizeof(struct fuse_mount_data));
 	d->max_read = ~0;
 	d->blksize = FUSE_DEFAULT_BLKSIZE;
 
@@ -518,7 +518,7 @@ static int fuse_show_options(struct seq_file *m, struct vfsmount *mnt)
 
 void fuse_conn_init(struct fuse_conn *fc)
 {
-	memset(fc, 0, sizeof(*fc));
+	(void)memset(fc, 0, sizeof(*fc));
 	spin_lock_init(&fc->lock);
 	mutex_init(&fc->inst_mutex);
 	init_rwsem(&fc->killsb);
@@ -566,7 +566,7 @@ EXPORT_SYMBOL_GPL(fuse_conn_get);
 static struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)
 {
 	struct fuse_attr attr;
-	memset(&attr, 0, sizeof(attr));
+	(void)memset(&attr, 0, sizeof(attr));
 
 	attr.mode = mode;
 	attr.ino = FUSE_ROOT_ID;
diff --git a/fs/inode.c b/fs/inode.c
index e964818..75f08cb 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -279,7 +279,7 @@ static void destroy_inode(struct inode *inode)
 
 void address_space_init_once(struct address_space *mapping)
 {
-	memset(mapping, 0, sizeof(*mapping));
+	(void)memset(mapping, 0, sizeof(*mapping));
 	INIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);
 	spin_lock_init(&mapping->tree_lock);
 	mutex_init(&mapping->i_mmap_mutex);
@@ -297,7 +297,7 @@ EXPORT_SYMBOL(address_space_init_once);
  */
 void inode_init_once(struct inode *inode)
 {
-	memset(inode, 0, sizeof(*inode));
+	(void)memset(inode, 0, sizeof(*inode));
 	INIT_HLIST_NODE(&inode->i_hash);
 	INIT_LIST_HEAD(&inode->i_dentry);
 	INIT_LIST_HEAD(&inode->i_devices);
@@ -331,7 +331,7 @@ void __iget(struct inode *inode)
  */
 void ihold(struct inode *inode)
 {
-	WARN_ON(atomic_inc_return(&inode->i_count) < 2);
+	(void)WARN_ON(atomic_inc_return(&inode->i_count) < 2);
 }
 EXPORT_SYMBOL(ihold);
 
@@ -690,7 +690,7 @@ static void prune_icache(int nr_to_scan)
 				continue;
 			}
 		}
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state |= I_FREEING;
 		spin_unlock(&inode->i_lock);
 
@@ -919,7 +919,7 @@ void unlock_new_inode(struct inode *inode)
 	}
 #endif
 	spin_lock(&inode->i_lock);
-	WARN_ON(!(inode->i_state & I_NEW));
+	(void)WARN_ON(!(inode->i_state & I_NEW));
 	inode->i_state &= ~I_NEW;
 	wake_up_bit(&inode->i_state, __I_NEW);
 	spin_unlock(&inode->i_lock);
@@ -1350,7 +1350,7 @@ static void iput_final(struct inode *inode)
 	const struct super_operations *op = inode->i_sb->s_op;
 	int drop;
 
-	WARN_ON(inode->i_state & I_NEW);
+	(void)WARN_ON(inode->i_state & I_NEW);
 
 	if (op && op->drop_inode)
 		drop = op->drop_inode(inode);
@@ -1370,7 +1370,7 @@ static void iput_final(struct inode *inode)
 		spin_unlock(&inode->i_lock);
 		write_inode_now(inode, 1);
 		spin_lock(&inode->i_lock);
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state &= ~I_WILL_FREE;
 	}
 
diff --git a/fs/jbd/checkpoint.c b/fs/jbd/checkpoint.c
index e4b87bc..db510ea 100644
--- a/fs/jbd/checkpoint.c
+++ b/fs/jbd/checkpoint.c
@@ -161,7 +161,7 @@ void __log_wait_for_space(journal_t *journal)
 				       __func__, nblocks, space_left);
 				printk(KERN_ERR "%s: no way to get more "
 				       "journal space\n", __func__);
-				WARN_ON(1);
+				(void)WARN_ON(1);
 				journal_abort(journal, 0);
 			}
 			spin_lock(&journal->j_state_lock);
diff --git a/fs/jbd/journal.c b/fs/jbd/journal.c
index e2d4285..70a2c39 100644
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -458,7 +458,7 @@ int __log_start_commit(journal_t *journal, tid_t target)
 		/* This should never happen, but if it does, preserve
 		   the evidence before kjournald goes into a loop and
 		   increments j_commit_sequence beyond all recognition. */
-		WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
+		(void)WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
 		    journal->j_commit_request, journal->j_commit_sequence,
 		    target, journal->j_running_transaction ?
 		    journal->j_running_transaction->t_tid : 0);
@@ -687,7 +687,7 @@ struct journal_head *journal_get_descriptor_buffer(journal_t *journal)
 	if (!bh)
 		return NULL;
 	lock_buffer(bh);
-	memset(bh->b_data, 0, journal->j_blocksize);
+	(void)memset(bh->b_data, 0, journal->j_blocksize);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
 	BUFFER_TRACE(bh, "return this buffer");
@@ -965,7 +965,7 @@ int journal_create(journal_t *journal)
 		if (unlikely(!bh))
 			return -ENOMEM;
 		lock_buffer(bh);
-		memset (bh->b_data, 0, journal->j_blocksize);
+		(void)memset (bh->b_data, 0, journal->j_blocksize);
 		BUFFER_TRACE(bh, "marking dirty");
 		mark_buffer_dirty(bh);
 		BUFFER_TRACE(bh, "marking uptodate");
@@ -1415,7 +1415,7 @@ static int journal_convert_superblock_v1(journal_t *journal,
 	/* Pre-initialise new fields to zero */
 	offset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);
 	blocksize = be32_to_cpu(sb->s_blocksize);
-	memset(&sb->s_feature_compat, 0, blocksize-offset);
+	(void)memset(&sb->s_feature_compat, 0, blocksize-offset);
 
 	sb->s_nr_users = cpu_to_be32(1);
 	sb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);
@@ -1836,7 +1836,7 @@ struct journal_head *journal_add_journal_head(struct buffer_head *bh)
 repeat:
 	if (!buffer_jbd(bh)) {
 		new_jh = journal_alloc_journal_head();
-		memset(new_jh, 0, sizeof(*new_jh));
+		(void)memset(new_jh, 0, sizeof(*new_jh));
 	}
 
 	jbd_lock_bh_journal_head(bh);
diff --git a/fs/jbd/transaction.c b/fs/jbd/transaction.c
index f7ee81a..ce8a1b4 100644
--- a/fs/jbd/transaction.c
+++ b/fs/jbd/transaction.c
@@ -245,7 +245,7 @@ static handle_t *new_handle(int nblocks)
 	handle_t *handle = jbd_alloc_handle(GFP_NOFS);
 	if (!handle)
 		return NULL;
-	memset(handle, 0, sizeof(*handle));
+	(void)memset(handle, 0, sizeof(*handle));
 	handle->h_buffer_credits = nblocks;
 	handle->h_ref = 1;
 
@@ -709,7 +709,7 @@ done:
 		int offset;
 		char *source;
 
-		J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
+		(void)J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
 			    "Possible IO failure.\n");
 		page = jh2bh(jh)->b_page;
 		offset = offset_in_page(jh2bh(jh)->b_data);
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 0dfa5b5..110c031 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -500,7 +500,7 @@ int __jbd2_log_start_commit(journal_t *journal, tid_t target)
 		/* This should never happen, but if it does, preserve
 		   the evidence before kjournald goes into a loop and
 		   increments j_commit_sequence beyond all recognition. */
-		WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
+		(void)WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
 			  journal->j_commit_request,
 			  journal->j_commit_sequence,
 			  target, journal->j_running_transaction ? 
@@ -737,7 +737,7 @@ struct journal_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)
 	if (!bh)
 		return NULL;
 	lock_buffer(bh);
-	memset(bh->b_data, 0, journal->j_blocksize);
+	(void)memset(bh->b_data, 0, journal->j_blocksize);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
 	BUFFER_TRACE(bh, "return this buffer");
@@ -1582,7 +1582,7 @@ static int journal_convert_superblock_v1(journal_t *journal,
 	/* Pre-initialise new fields to zero */
 	offset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);
 	blocksize = be32_to_cpu(sb->s_blocksize);
-	memset(&sb->s_feature_compat, 0, blocksize-offset);
+	(void)memset(&sb->s_feature_compat, 0, blocksize-offset);
 
 	sb->s_nr_users = cpu_to_be32(1);
 	sb->s_header.h_blocktype = cpu_to_be32(JBD2_SUPERBLOCK_V2);
@@ -2113,7 +2113,7 @@ struct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh)
 repeat:
 	if (!buffer_jbd(bh)) {
 		new_jh = journal_alloc_journal_head();
-		memset(new_jh, 0, sizeof(*new_jh));
+		(void)memset(new_jh, 0, sizeof(*new_jh));
 	}
 
 	jbd_lock_bh_journal_head(bh);
diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 2d71094..0bfd834 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -295,7 +295,7 @@ static handle_t *new_handle(int nblocks)
 	handle_t *handle = jbd2_alloc_handle(GFP_NOFS);
 	if (!handle)
 		return NULL;
-	memset(handle, 0, sizeof(*handle));
+	(void)memset(handle, 0, sizeof(*handle));
 	handle->h_buffer_credits = nblocks;
 	handle->h_ref = 1;
 
@@ -777,7 +777,7 @@ done:
 		int offset;
 		char *source;
 
-		J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
+		(void)J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
 			    "Possible IO failure.\n");
 		page = jh2bh(jh)->b_page;
 		offset = offset_in_page(jh2bh(jh)->b_data);
diff --git a/fs/namespace.c b/fs/namespace.c
index 7b4fa8f..6ac668b 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -767,7 +767,7 @@ static inline void mntfree(struct vfsmount *mnt)
 	 * The locking used to deal with mnt_count decrement provides barriers,
 	 * so mnt_get_writers() below is safe.
 	 */
-	WARN_ON(mnt_get_writers(mnt));
+	(void)WARN_ON(mnt_get_writers(mnt));
 	fsnotify_vfsmount_delete(mnt);
 	dput(mnt->mnt_root);
 	free_vfsmnt(mnt);
@@ -2211,7 +2211,7 @@ static long exact_copy_from_user(void *to, const void __user * from,
 
 	while (n) {
 		if (__get_user(c, f)) {
-			memset(t, 0, n);
+			(void)memset(t, 0, n);
 			break;
 		}
 		*t++ = c;
@@ -2249,7 +2249,7 @@ int copy_mount_options(const void __user * data, unsigned long *where)
 		return -EFAULT;
 	}
 	if (i != PAGE_SIZE)
-		memset((char *)page + i, 0, PAGE_SIZE - i);
+		(void)memset((char *)page + i, 0, PAGE_SIZE - i);
 	*where = page;
 	return 0;
 }
diff --git a/fs/nfs/idmap.c b/fs/nfs/idmap.c
index 79664a1..9d0fee5 100644
--- a/fs/nfs/idmap.c
+++ b/fs/nfs/idmap.c
@@ -500,13 +500,13 @@ nfs_idmap_id(struct idmap *idmap, struct idmap_hashtable *h,
 		goto out;
 	}
 
-	memset(im, 0, sizeof(*im));
+	(void)memset(im, 0, sizeof(*im));
 	memcpy(im->im_name, name, namelen);
 
 	im->im_type = h->h_type;
 	im->im_conv = IDMAP_CONV_NAMETOID;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 	msg.data = im;
 	msg.len = sizeof(*im);
 
@@ -529,7 +529,7 @@ nfs_idmap_id(struct idmap *idmap, struct idmap_hashtable *h,
 	}
 
  out:
-	memset(im, 0, sizeof(*im));
+	(void)memset(im, 0, sizeof(*im));
 	mutex_unlock(&idmap->idmap_im_lock);
 	mutex_unlock(&idmap->idmap_lock);
 	return ret;
@@ -561,12 +561,12 @@ nfs_idmap_name(struct idmap *idmap, struct idmap_hashtable *h,
 		goto out;
 	}
 
-	memset(im, 0, sizeof(*im));
+	(void)memset(im, 0, sizeof(*im));
 	im->im_type = h->h_type;
 	im->im_conv = IDMAP_CONV_IDTONAME;
 	im->im_id = id;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 	msg.data = im;
 	msg.len = sizeof(*im);
 
@@ -592,7 +592,7 @@ nfs_idmap_name(struct idmap *idmap, struct idmap_hashtable *h,
 	}
 
  out:
-	memset(im, 0, sizeof(*im));
+	(void)memset(im, 0, sizeof(*im));
 	mutex_unlock(&idmap->idmap_im_lock);
 	mutex_unlock(&idmap->idmap_lock);
 	return ret;
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 6f4850d..437790f 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -315,16 +315,16 @@ nfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)
 		else
 			init_special_inode(inode, inode->i_mode, fattr->rdev);
 
-		memset(&inode->i_atime, 0, sizeof(inode->i_atime));
-		memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
-		memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
+		(void)memset(&inode->i_atime, 0, sizeof(inode->i_atime));
+		(void)memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
+		(void)memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
 		nfsi->change_attr = 0;
 		inode->i_size = 0;
 		inode->i_nlink = 0;
 		inode->i_uid = -2;
 		inode->i_gid = -2;
 		inode->i_blocks = 0;
-		memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
+		(void)memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
 
 		nfsi->read_cache_jiffies = fattr->time_start;
 		nfsi->attr_gencount = fattr->gencount;
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 92cfd2e..5188af2 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -177,7 +177,7 @@ static void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dent
 	}
 
 	readdir->cookie = 0;
-	memset(&readdir->verifier, 0, sizeof(readdir->verifier));
+	(void)memset(&readdir->verifier, 0, sizeof(readdir->verifier));
 	if (cookie == 2)
 		return;
 	
@@ -1145,8 +1145,8 @@ static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmod
 
 	opendata->o_arg.open_flags = 0;
 	opendata->o_arg.fmode = fmode;
-	memset(&opendata->o_res, 0, sizeof(opendata->o_res));
-	memset(&opendata->c_res, 0, sizeof(opendata->c_res));
+	(void)memset(&opendata->o_res, 0, sizeof(opendata->o_res));
+	(void)memset(&opendata->c_res, 0, sizeof(opendata->c_res));
 	nfs4_init_opendata_res(opendata);
 	ret = _nfs4_recover_proc_open(opendata);
 	if (ret != 0)
@@ -2300,7 +2300,7 @@ static int nfs4_get_referral(struct inode *dir, const struct qstr *name,
 
 	/* replace the lookup nfs_fattr with the locations nfs_fattr */
 	memcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));
-	memset(fhandle, 0, sizeof(struct nfs_fh));
+	(void)memset(fhandle, 0, sizeof(struct nfs_fh));
 out:
 	if (page)
 		__free_page(page);
@@ -2451,7 +2451,7 @@ static int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,
 
 void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr, struct nfs_fh *fh)
 {
-	memset(fh, 0, sizeof(struct nfs_fh));
+	(void)memset(fh, 0, sizeof(struct nfs_fh));
 	fattr->fsid.major = 1;
 	fattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |
 		NFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_FSID | NFS_ATTR_FATTR_MOUNTPOINT;
@@ -3161,7 +3161,7 @@ static int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle
 
 	/* None of the pathconf attributes are mandatory to implement */
 	if ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {
-		memset(pathconf, 0, sizeof(*pathconf));
+		(void)memset(pathconf, 0, sizeof(*pathconf));
 		return 0;
 	}
 
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index e97dd21..d2543ab 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -1170,7 +1170,7 @@ restart:
 				 * Open state on this file cannot be recovered
 				 * All we can do is revert to using the zero stateid.
 				 */
-				memset(state->stateid.data, 0,
+				(void)memset(state->stateid.data, 0,
 					sizeof(state->stateid.data));
 				/* Mark the file as being 'closed' */
 				state->state = 0;
diff --git a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c
index fc97fd5..1254bb5 100644
--- a/fs/nfs/nfs4xdr.c
+++ b/fs/nfs/nfs4xdr.c
@@ -3123,7 +3123,7 @@ static int decode_attr_filehandle(struct xdr_stream *xdr, uint32_t *bitmap, stru
 	int len;
 
 	if (fh != NULL)
-		memset(fh, 0, sizeof(*fh));
+		(void)memset(fh, 0, sizeof(*fh));
 
 	if (unlikely(bitmap[0] & (FATTR4_WORD0_FILEHANDLE - 1U)))
 		return -EIO;
@@ -4313,7 +4313,7 @@ static int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)
 	int status;
 
 	/* Zero handle first to allow comparisons */
-	memset(fh, 0, sizeof(*fh));
+	(void)memset(fh, 0, sizeof(*fh));
 
 	status = decode_op_hdr(xdr, OP_GETFH);
 	if (status)
diff --git a/fs/nfs/read.c b/fs/nfs/read.c
index 20a7f95..548b639 100644
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@ -45,7 +45,7 @@ struct nfs_read_data *nfs_readdata_alloc(unsigned int pagecount)
 	struct nfs_read_data *p = mempool_alloc(nfs_rdata_mempool, GFP_KERNEL);
 
 	if (p) {
-		memset(p, 0, sizeof(*p));
+		(void)memset(p, 0, sizeof(*p));
 		INIT_LIST_HEAD(&p->pages);
 		p->npages = pagecount;
 		if (pagecount <= ARRAY_SIZE(p->page_array))
diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index a0a041d..dd48014 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -180,7 +180,7 @@ check_partition(struct gendisk *hd, struct block_device *bdev)
 	state->limit = disk_max_parts(hd);
 	i = res = err = 0;
 	while (!res && check_part[i]) {
-		memset(&state->parts, 0, sizeof(state->parts));
+		(void)memset(&state->parts, 0, sizeof(state->parts));
 		res = check_part[i++](state);
 		if (res < 0) {
 			/* We have hit an I/O error which we don't report now.
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index f1637f1..93fb4b8 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -619,7 +619,7 @@ static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
 	ent = kmalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
 	if (!ent) goto out;
 
-	memset(ent, 0, sizeof(struct proc_dir_entry));
+	(void)memset(ent, 0, sizeof(struct proc_dir_entry));
 	memcpy(((char *) ent) + sizeof(struct proc_dir_entry), fn, len + 1);
 	ent->name = ((char *) ent) + sizeof(*ent);
 	ent->namelen = len;
diff --git a/fs/super.c b/fs/super.c
index ab3d672..c9042ad 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -855,7 +855,7 @@ void kill_block_super(struct super_block *sb)
 	bdev->bd_super = NULL;
 	generic_shutdown_super(sb);
 	sync_blockdev(bdev);
-	WARN_ON_ONCE(!(mode & FMODE_EXCL));
+	(void)WARN_ON_ONCE(!(mode & FMODE_EXCL));
 	blkdev_put(bdev, mode | FMODE_EXCL);
 }
 
@@ -939,8 +939,8 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	}
 	sb = root->d_sb;
 	BUG_ON(!sb);
-	WARN_ON(!sb->s_bdi);
-	WARN_ON(sb->s_bdi == &default_backing_dev_info);
+	(void)WARN_ON(!sb->s_bdi);
+	(void)WARN_ON(sb->s_bdi == &default_backing_dev_info);
 	sb->s_flags |= MS_BORN;
 
 	error = security_sb_kern_mount(sb, flags, secdata);
@@ -953,7 +953,7 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	 * this warning for a little while to try and catch filesystems that
 	 * violate this rule.
 	 */
-	WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
+	(void)WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
 		"negative value (%lld)\n", type->name, sb->s_maxbytes);
 
 	up_write(&sb->s_umount);
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index ea9120a..e7ab7be 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -354,7 +354,7 @@ struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)
 void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 		       struct sysfs_dirent *parent_sd)
 {
-	memset(acxt, 0, sizeof(*acxt));
+	(void)memset(acxt, 0, sizeof(*acxt));
 	acxt->parent_sd = parent_sd;
 
 	mutex_lock(&sysfs_mutex);
@@ -448,7 +448,7 @@ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
 	ret = __sysfs_add_one(acxt, sd);
 	if (ret == -EEXIST) {
 		char *path = kzalloc(PATH_MAX, GFP_KERNEL);
-		WARN(1, KERN_WARNING
+		(void)WARN(1, KERN_WARNING
 		     "sysfs: cannot create duplicate filename '%s'\n",
 		     (path == NULL) ? sd->s_name :
 		     strcat(strcat(sysfs_pathname(acxt->parent_sd, path), "/"),
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 18a1baf..62ad876 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -226,7 +226,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 	u64 tmp = ((u64)1000000) << shift_constant;
 
 	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
+	(void)do_div(tmp, khz);
 
 	return (u32)tmp;
 }
@@ -252,7 +252,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	u64 tmp = ((u64)1000000000) << shift_constant;
 
 	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
+	(void)do_div(tmp, hz);
 
 	return (u32)tmp;
 }
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index bb4f5fb..80bdb71 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -510,7 +510,7 @@ struct spi_message {
 
 static inline void spi_message_init(struct spi_message *m)
 {
-	memset(m, 0, sizeof *m);
+	(void)memset(m, 0, sizeof *m);
 	INIT_LIST_HEAD(&m->transfers);
 }
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 583ceb8..b835717 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1588,10 +1588,10 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 	unsigned			epnum = usb_pipeendpoint(pipe);
 
 	if (is_out) {
-		WARN_ON(usb_pipein(pipe));
+		(void)WARN_ON(usb_pipein(pipe));
 		ep = udev->ep_out[epnum];
 	} else {
-		WARN_ON(usb_pipeout(pipe));
+		(void)WARN_ON(usb_pipeout(pipe));
 		ep = udev->ep_in[epnum];
 	}
 	if (!ep)
diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 60536c7..986dd96 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -182,7 +182,7 @@ struct ir_raw_event {
 
 static inline void init_ir_raw_event(struct ir_raw_event *ev)
 {
-	memset(ev, 0, sizeof(*ev));
+	(void)memset(ev, 0, sizeof(*ev));
 }
 
 #define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
diff --git a/include/net/ip.h b/include/net/ip.h
index 66dd491..827205f 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -360,8 +360,8 @@ static __inline__ void inet_reset_saddr(struct sock *sk)
 	if (sk->sk_family == PF_INET6) {
 		struct ipv6_pinfo *np = inet6_sk(sk);
 
-		memset(&np->saddr, 0, sizeof(np->saddr));
-		memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));
+		(void)memset(&np->saddr, 0, sizeof(np->saddr));
+		(void)memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));
 	}
 #endif
 }
diff --git a/include/net/sock.h b/include/net/sock.h
index c0b938c..eb9a65e 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -450,7 +450,7 @@ static __inline__ int sk_del_node_init(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 241b74a..019c0ec 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -1092,7 +1092,7 @@ static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
 	mask = ~(1UL << cpuset_subsys_id);
 #endif
 
-	memset(opts, 0, sizeof(*opts));
+	(void)memset(opts, 0, sizeof(*opts));
 
 	while ((token = strsep(&o, ",")) != NULL) {
 		if (!*token)
@@ -4750,7 +4750,7 @@ void __css_put(struct cgroup_subsys_state *css, int count)
 		cgroup_wakeup_rmdir_waiter(cgrp);
 	}
 	rcu_read_unlock();
-	WARN_ON_ONCE(val < 1);
+	(void)WARN_ON_ONCE(val < 1);
 }
 EXPORT_SYMBOL_GPL(__css_put);
 
diff --git a/kernel/exit.c b/kernel/exit.c
index f2b321b..c66a8af 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -906,8 +906,8 @@ NORET_TYPE void do_exit(long code)
 
 	profile_task_exit(tsk);
 
-	WARN_ON(atomic_read(&tsk->fs_excl));
-	WARN_ON(blk_needs_flush_plug(tsk));
+	(void)WARN_ON(atomic_read(&tsk->fs_excl));
+	(void)WARN_ON(blk_needs_flush_plug(tsk));
 
 	if (unlikely(in_interrupt()))
 		panic("Aiee, killing interrupt handler!");
diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index 1ef4ffc..60132ed 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -88,7 +88,7 @@ void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 	struct irq_devres match_data = { irq, dev_id };
 
 	free_irq(irq, dev_id);
-	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
+	(void)WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
 			       &match_data));
 }
 EXPORT_SYMBOL(devm_free_irq);
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index 3b5340b..b3c7155 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -90,12 +90,12 @@ void irq_domain_register_irq(struct irq_domain *domain, int hwirq)
 
 	d = irq_get_irq_data(irq_domain_to_irq(domain, hwirq));
 	if (!d) {
-		WARN(1, "error: assigning domain to non existant irq_desc");
+		(void)WARN(1, "error: assigning domain to non existant irq_desc");
 		return;
 	}
 	if (d->domain) {
 		/* things are broken; just report, don't clean up */
-		WARN(1, "error: irq_desc already assigned to a domain");
+		(void)WARN(1, "error: irq_desc already assigned to a domain");
 		return;
 	}
 	d->domain = domain;
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 7798181..3a12e04 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -167,7 +167,7 @@ static kprobe_opcode_t __kprobes *__get_insn_slot(struct kprobe_insn_cache *c)
 			}
 			/* kip->nused is broken. Fix it. */
 			kip->nused = slots_per_page(c);
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		}
 	}
 
@@ -191,7 +191,7 @@ static kprobe_opcode_t __kprobes *__get_insn_slot(struct kprobe_insn_cache *c)
 		return NULL;
 	}
 	INIT_LIST_HEAD(&kip->list);
-	memset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));
+	(void)memset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));
 	kip->slot_used[0] = SLOT_USED;
 	kip->nused = 1;
 	kip->ngarbage = 0;
@@ -264,7 +264,7 @@ static void __kprobes __free_insn_slot(struct kprobe_insn_cache *c,
 		long idx = ((long)slot - (long)kip->insns) /
 				(c->insn_size * sizeof(kprobe_opcode_t));
 		if (idx >= 0 && idx < slots_per_page(c)) {
-			WARN_ON(kip->slot_used[idx] != SLOT_USED);
+			(void)WARN_ON(kip->slot_used[idx] != SLOT_USED);
 			if (dirty) {
 				kip->slot_used[idx] = SLOT_DIRTY;
 				kip->ngarbage++;
@@ -276,7 +276,7 @@ static void __kprobes __free_insn_slot(struct kprobe_insn_cache *c,
 		}
 	}
 	/* Could not free this slot. */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 void __kprobes free_insn_slot(kprobe_opcode_t * slot, int dirty)
@@ -1464,7 +1464,7 @@ static int __kprobes __unregister_kprobe_top(struct kprobe *p)
 		goto disarmed;
 
 	/* Following process expects this probe is an aggrprobe */
-	WARN_ON(!kprobe_aggrprobe(ap));
+	(void)WARN_ON(!kprobe_aggrprobe(ap));
 
 	if (list_is_singular(&ap->list) && kprobe_disarmed(ap))
 		/*
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index 298c927..db30488 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -687,7 +687,7 @@ look_up_lock_class(struct lockdep_map *lock, unsigned int subclass)
 	 */
 	list_for_each_entry(class, hash_head, hash_entry) {
 		if (class->key == key) {
-			WARN_ON_ONCE(class->name != lock->name);
+			(void)WARN_ON_ONCE(class->name != lock->name);
 			return class;
 		}
 	}
@@ -926,7 +926,7 @@ static inline void mark_lock_accessed(struct lock_list *lock,
 	unsigned long nr;
 
 	nr = lock - list_entries;
-	WARN_ON(nr >= nr_list_entries);
+	(void)WARN_ON(nr >= nr_list_entries);
 	lock->parent = parent;
 	lock->class->dep_gen_id = lockdep_dependency_gen_id;
 }
@@ -936,7 +936,7 @@ static inline unsigned long lock_accessed(struct lock_list *lock)
 	unsigned long nr;
 
 	nr = lock - list_entries;
-	WARN_ON(nr >= nr_list_entries);
+	(void)WARN_ON(nr >= nr_list_entries);
 	return lock->class->dep_gen_id == lockdep_dependency_gen_id;
 }
 
@@ -1196,7 +1196,7 @@ static noinline int print_bfs_bug(int ret)
 	if (!debug_locks_off_graph_unlock())
 		return 0;
 
-	WARN(1, "lockdep bfs error:%d\n", ret);
+	(void)WARN(1, "lockdep bfs error:%d\n", ret);
 
 	return 0;
 }
@@ -1944,7 +1944,7 @@ out_bug:
 	if (!debug_locks_off_graph_unlock())
 		return 0;
 
-	WARN_ON(1);
+	(void)WARN_ON(1);
 
 	return 0;
 }
@@ -2834,7 +2834,7 @@ static int mark_lock(struct task_struct *curr, struct held_lock *this,
 	default:
 		if (!debug_locks_off_graph_unlock())
 			return 0;
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
@@ -3637,7 +3637,7 @@ void lockdep_reset(void)
 	current->curr_chain_key = 0;
 	current->lockdep_depth = 0;
 	current->lockdep_recursion = 0;
-	memset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));
+	(void)memset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));
 	nr_hardirq_chains = 0;
 	nr_softirq_chains = 0;
 	nr_process_chains = 0;
@@ -3742,7 +3742,7 @@ void lockdep_reset_lock(struct lockdep_map *lock)
 
 			if (unlikely(match)) {
 				if (debug_locks_off_graph_unlock())
-					WARN_ON(1);
+					(void)WARN_ON(1);
 				goto out_restore;
 			}
 		}
diff --git a/kernel/pm_qos_params.c b/kernel/pm_qos_params.c
index b6ff61a..54ad0d3 100644
--- a/kernel/pm_qos_params.c
+++ b/kernel/pm_qos_params.c
@@ -248,7 +248,7 @@ void pm_qos_add_request(struct pm_qos_request_list *dep,
 	int new_value;
 
 	if (pm_qos_request_active(dep)) {
-		WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
+		(void)WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
 		return;
 	}
 	if (value == PM_QOS_DEFAULT_VALUE)
@@ -281,7 +281,7 @@ void pm_qos_update_request(struct pm_qos_request_list *pm_qos_req,
 		return;
 
 	if (!pm_qos_request_active(pm_qos_req)) {
-		WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
 		return;
 	}
 
@@ -314,13 +314,13 @@ void pm_qos_remove_request(struct pm_qos_request_list *pm_qos_req)
 		/* silent return to keep pcm code cleaner */
 
 	if (!pm_qos_request_active(pm_qos_req)) {
-		WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
 		return;
 	}
 
 	o = pm_qos_array[pm_qos_req->pm_qos_class];
 	update_target(o, &pm_qos_req->list, 1, PM_QOS_DEFAULT_VALUE);
-	memset(pm_qos_req, 0, sizeof(*pm_qos_req));
+	(void)memset(pm_qos_req, 0, sizeof(*pm_qos_req));
 }
 EXPORT_SYMBOL_GPL(pm_qos_remove_request);
 
diff --git a/kernel/power/userwakelock.c b/kernel/power/userwakelock.c
index a28a8db..6fb7bcb 100644
--- a/kernel/power/userwakelock.c
+++ b/kernel/power/userwakelock.c
@@ -69,7 +69,7 @@ static struct user_wake_lock *lookup_wake_lock_name(
 			goto bad_arg;
 		/* convert timeout from nanoseconds to jiffies > 0 */
 		timeout += (NSEC_PER_SEC / HZ) - 1;
-		do_div(timeout, (NSEC_PER_SEC / HZ));
+		(void)do_div(timeout, (NSEC_PER_SEC / HZ));
 		if (timeout <= 0)
 			timeout = 1;
 		*timeoutptr = timeout;
diff --git a/kernel/printk.c b/kernel/printk.c
index dbaa948..208f4ee 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -365,7 +365,7 @@ static int check_syslog_permissions(int type, bool from_file)
 			return 0;
 		/* For historical reasons, accept CAP_SYS_ADMIN too, with a warning */
 		if (capable(CAP_SYS_ADMIN)) {
-			WARN_ONCE(1, "Attempt to access syslog with CAP_SYS_ADMIN "
+			(void)WARN_ONCE(1, "Attempt to access syslog with CAP_SYS_ADMIN "
 				 "but no CAP_SYSLOG (deprecated).\n");
 			return 0;
 		}
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 2df1157..45f00d4 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -118,7 +118,7 @@ int ptrace_check_attach(struct task_struct *child, int kill)
 		 * does ptrace_unlink() before __exit_signal().
 		 */
 		spin_lock_irq(&child->sighand->siglock);
-		WARN_ON_ONCE(task_is_stopped(child));
+		(void)WARN_ON_ONCE(task_is_stopped(child));
 		if (task_is_traced(child) || kill)
 			ret = 0;
 		spin_unlock_irq(&child->sighand->siglock);
diff --git a/kernel/rcutree.c b/kernel/rcutree.c
index ba06207..9b00534 100644
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -358,7 +358,7 @@ void rcu_enter_nohz(void)
 	smp_mb__before_atomic_inc();  /* See above. */
 	atomic_inc(&rdtp->dynticks);
 	smp_mb__after_atomic_inc();  /* Force ordering with next sojourn. */
-	WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
+	(void)WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
 	local_irq_restore(flags);
 
 	/* If the interrupt queued a callback, get out of dyntick mode. */
@@ -390,7 +390,7 @@ void rcu_exit_nohz(void)
 	atomic_inc(&rdtp->dynticks);
 	/* CPUs seeing atomic_inc() must see later RCU read-side crit sects */
 	smp_mb__after_atomic_inc();  /* See above. */
-	WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
+	(void)WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
 	local_irq_restore(flags);
 }
 
@@ -413,7 +413,7 @@ void rcu_nmi_enter(void)
 	atomic_inc(&rdtp->dynticks);
 	/* CPUs seeing atomic_inc() must see later RCU read-side crit sects */
 	smp_mb__after_atomic_inc();  /* See above. */
-	WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
+	(void)WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
 }
 
 /**
@@ -434,7 +434,7 @@ void rcu_nmi_exit(void)
 	smp_mb__before_atomic_inc();  /* See above. */
 	atomic_inc(&rdtp->dynticks);
 	smp_mb__after_atomic_inc();  /* Force delay to next write. */
-	WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
+	(void)WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
 }
 
 /**
@@ -851,7 +851,7 @@ rcu_start_gp(struct rcu_state *rsp, unsigned long flags)
 
 	/* Advance to a new grace period and initialize state. */
 	rsp->gpnum++;
-	WARN_ON_ONCE(rsp->signaled == RCU_GP_INIT);
+	(void)WARN_ON_ONCE(rsp->signaled == RCU_GP_INIT);
 	rsp->signaled = RCU_GP_INIT; /* Hold off force_quiescent_state. */
 	rsp->jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;
 	record_gp_stall_check_time(rsp);
@@ -923,7 +923,7 @@ static void rcu_report_qs_rsp(struct rcu_state *rsp, unsigned long flags)
 {
 	unsigned long gp_duration;
 
-	WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
+	(void)WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
 
 	/*
 	 * Ensure that all grace-period and pre-grace-period activity
@@ -979,7 +979,7 @@ rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,
 		rnp_c = rnp;
 		rnp = rnp->parent;
 		raw_spin_lock_irqsave(&rnp->lock, flags);
-		WARN_ON_ONCE(rnp_c->qsmask);
+		(void)WARN_ON_ONCE(rnp_c->qsmask);
 	}
 
 	/*
@@ -1438,7 +1438,7 @@ __rcu_process_callbacks(struct rcu_state *rsp, struct rcu_data *rdp)
 {
 	unsigned long flags;
 
-	WARN_ON_ONCE(rdp->beenonline == 0);
+	(void)WARN_ON_ONCE(rdp->beenonline == 0);
 
 	/*
 	 * If an RCU GP has gone long enough, go check for dyntick
@@ -1967,8 +1967,8 @@ static int __cpuinit rcu_cpu_notify(struct notifier_block *self,
  */
 void rcu_scheduler_starting(void)
 {
-	WARN_ON(num_online_cpus() != 1);
-	WARN_ON(nr_context_switches() > 0);
+	(void)WARN_ON(num_online_cpus() != 1);
+	(void)WARN_ON(nr_context_switches() > 0);
 	rcu_scheduler_active = 1;
 }
 
diff --git a/kernel/rcutree_plugin.h b/kernel/rcutree_plugin.h
index 8aafbb8..1033d9b 100644
--- a/kernel/rcutree_plugin.h
+++ b/kernel/rcutree_plugin.h
@@ -176,8 +176,8 @@ static void rcu_preempt_note_context_switch(int cpu)
 		 * But first, note that the current CPU must still be
 		 * on line!
 		 */
-		WARN_ON_ONCE((rdp->grpmask & rnp->qsmaskinit) == 0);
-		WARN_ON_ONCE(!list_empty(&t->rcu_node_entry));
+		(void)WARN_ON_ONCE((rdp->grpmask & rnp->qsmaskinit) == 0);
+		(void)WARN_ON_ONCE(!list_empty(&t->rcu_node_entry));
 		if ((rnp->qsmask & rdp->grpmask) && rnp->gp_tasks != NULL) {
 			list_add(&t->rcu_node_entry, rnp->gp_tasks->prev);
 			rnp->gp_tasks = &t->rcu_node_entry;
@@ -414,7 +414,7 @@ void __rcu_read_unlock(void)
 	{
 		int rrln = ACCESS_ONCE(t->rcu_read_lock_nesting);
 
-		WARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);
+		(void)WARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);
 	}
 #endif /* #ifdef CONFIG_PROVE_LOCKING */
 }
@@ -500,10 +500,10 @@ static void rcu_preempt_stall_reset(void)
  */
 static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)
 {
-	WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp));
+	(void)WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp));
 	if (!list_empty(&rnp->blkd_tasks))
 		rnp->gp_tasks = rnp->blkd_tasks.next;
-	WARN_ON_ONCE(rnp->qsmask);
+	(void)WARN_ON_ONCE(rnp->qsmask);
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -533,12 +533,12 @@ static int rcu_preempt_offline_tasks(struct rcu_state *rsp,
 	struct task_struct *t;
 
 	if (rnp == rnp_root) {
-		WARN_ONCE(1, "Last CPU thought to be offlined?");
+		(void)WARN_ONCE(1, "Last CPU thought to be offlined?");
 		return 0;  /* Shouldn't happen: at least one CPU online. */
 	}
 
 	/* If we are on an internal node, complain bitterly. */
-	WARN_ON_ONCE(rnp != rdp->mynode);
+	(void)WARN_ON_ONCE(rnp != rdp->mynode);
 
 	/*
 	 * Move tasks up to root rcu_node.  Don't try to get fancy for
@@ -1728,7 +1728,7 @@ static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)
 
 static void invoke_rcu_callbacks_kthread(void)
 {
-	WARN_ON_ONCE(1);
+	(void)WARN_ON_ONCE(1);
 }
 
 static void rcu_preempt_boost_start_gp(struct rcu_node *rnp)
diff --git a/kernel/sched.c b/kernel/sched.c
index b85f675..daa5851 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -940,7 +940,7 @@ static inline struct rq *__task_rq_lock(struct task_struct *p)
 {
 	struct rq *rq;
 
-	lockdep_assert_held(&p->pi_lock);
+	(void)lockdep_assert_held(&p->pi_lock);
 
 	for (;;) {
 		rq = task_rq(p);
@@ -2198,7 +2198,7 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 	 * We should never call set_task_cpu() on a blocked task,
 	 * ttwu() will sort out the placement.
 	 */
-	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&
+	(void)WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&
 			!(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE));
 
 #ifdef CONFIG_LOCKDEP
@@ -2212,7 +2212,7 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 	 * Furthermore, all task_rq users should acquire both locks, see
 	 * task_rq_lock().
 	 */
-	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||
+	(void)WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||
 				      lockdep_is_held(&task_rq(p)->lock)));
 #endif
 #endif
@@ -2749,7 +2749,7 @@ static void try_to_wake_up_local(struct task_struct *p)
 
 	BUG_ON(rq != this_rq());
 	BUG_ON(p == current);
-	lockdep_assert_held(&rq->lock);
+	(void)lockdep_assert_held(&rq->lock);
 
 	if (!raw_spin_trylock(&p->pi_lock)) {
 		raw_spin_unlock(&rq->lock);
@@ -2810,7 +2810,7 @@ static void __sched_fork(struct task_struct *p)
 	INIT_LIST_HEAD(&p->se.group_node);
 
 #ifdef CONFIG_SCHEDSTATS
-	memset(&p->se.statistics, 0, sizeof(p->se.statistics));
+	(void)memset(&p->se.statistics, 0, sizeof(p->se.statistics));
 #endif
 
 	INIT_LIST_HEAD(&p->rt.run_list);
@@ -2882,7 +2882,7 @@ void sched_fork(struct task_struct *p)
 
 #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
 	if (likely(sched_info_on()))
-		memset(&p->sched_info, 0, sizeof(p->sched_info));
+		(void)memset(&p->sched_info, 0, sizeof(p->sched_info));
 #endif
 #if defined(CONFIG_SMP)
 	p->on_cpu = 0;
@@ -4012,7 +4012,7 @@ void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = rtime;
 
 		temp *= utime;
-		do_div(temp, total);
+		(void)do_div(temp, total);
 		utime = (cputime_t)temp;
 	} else
 		utime = rtime;
@@ -4045,7 +4045,7 @@ void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = rtime;
 
 		temp *= cputime.utime;
-		do_div(temp, total);
+		(void)do_div(temp, total);
 		utime = (cputime_t)temp;
 	} else
 		utime = rtime;
@@ -5589,7 +5589,7 @@ int __cond_resched_lock(spinlock_t *lock)
 	int resched = should_resched();
 	int ret = 0;
 
-	lockdep_assert_held(lock);
+	(void)lockdep_assert_held(lock);
 
 	if (spin_needbreak(lock) || resched) {
 		spin_unlock(lock);
@@ -6367,7 +6367,7 @@ static void register_sched_domain_sysctl(void)
 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1);
 	char buf[32];
 
-	WARN_ON(sd_ctl_dir[0].child);
+	(void)WARN_ON(sd_ctl_dir[0].child);
 	sd_ctl_dir[0].child = entry;
 
 	if (entry == NULL)
@@ -6381,7 +6381,7 @@ static void register_sched_domain_sysctl(void)
 		entry++;
 	}
 
-	WARN_ON(sd_sysctl_header);
+	(void)WARN_ON(sd_sysctl_header);
 	sd_sysctl_header = register_sysctl_table(sd_ctl_root);
 }
 
@@ -6765,7 +6765,7 @@ static void rq_attach_root(struct rq *rq, struct root_domain *rd)
 
 static int init_rootdomain(struct root_domain *rd)
 {
-	memset(rd, 0, sizeof(*rd));
+	(void)memset(rd, 0, sizeof(*rd));
 
 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL))
 		goto out;
@@ -7136,7 +7136,7 @@ build_sched_groups(struct sched_domain *sd, int cpu)
 	if (cpu != cpumask_first(sched_domain_span(sd)))
 		return 0;
 
-	lockdep_assert_held(&sched_domains_mutex);
+	(void)lockdep_assert_held(&sched_domains_mutex);
 	covered = sched_domains_tmpmask;
 
 	cpumask_clear(covered);
@@ -7185,7 +7185,7 @@ static void init_sched_groups_power(int cpu, struct sched_domain *sd)
 {
 	struct sched_group *sg = sd->groups;
 
-	WARN_ON(!sd || !sg);
+	(void)WARN_ON(!sd || !sg);
 
 	do {
 		sg->group_weight = cpumask_weight(sched_group_cpus(sg));
@@ -7293,7 +7293,7 @@ static void __free_domain_allocs(struct s_data *d, enum s_alloc what,
 static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,
 						   const struct cpumask *cpu_map)
 {
-	memset(d, 0, sizeof(*d));
+	(void)memset(d, 0, sizeof(*d));
 
 	if (__sdt_alloc(cpu_map))
 		return sa_sd_storage;
@@ -7315,7 +7315,7 @@ static void claim_allocations(int cpu, struct sched_domain *sd)
 {
 	struct sd_data *sdd = sd->private;
 
-	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);
+	(void)WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);
 	*per_cpu_ptr(sdd->sd, cpu) = NULL;
 
 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))
@@ -7681,7 +7681,7 @@ match1:
 		ndoms_cur = 0;
 		doms_new = &fallback_doms;
 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);
-		WARN_ON_ONCE(dattr_new);
+		(void)WARN_ON_ONCE(dattr_new);
 	}
 
 	/* Build new domains */
@@ -8532,7 +8532,7 @@ struct task_group *sched_create_group(struct task_group *parent)
 	spin_lock_irqsave(&task_group_lock, flags);
 	list_add_rcu(&tg->list, &task_groups);
 
-	WARN_ON(!parent); /* root should already exist */
+	(void)WARN_ON(!parent); /* root should already exist */
 
 	tg->parent = parent;
 	INIT_LIST_HEAD(&tg->children);
@@ -8803,7 +8803,7 @@ long sched_group_rt_runtime(struct task_group *tg)
 		return -1;
 
 	rt_runtime_us = tg->rt_bandwidth.rt_runtime;
-	do_div(rt_runtime_us, NSEC_PER_USEC);
+	(void)do_div(rt_runtime_us, NSEC_PER_USEC);
 	return rt_runtime_us;
 }
 
@@ -8825,7 +8825,7 @@ long sched_group_rt_period(struct task_group *tg)
 	u64 rt_period_us;
 
 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);
-	do_div(rt_period_us, NSEC_PER_USEC);
+	(void)do_div(rt_period_us, NSEC_PER_USEC);
 	return rt_period_us;
 }
 
diff --git a/kernel/sched_cpupri.c b/kernel/sched_cpupri.c
index 2722dc1..066f376 100644
--- a/kernel/sched_cpupri.c
+++ b/kernel/sched_cpupri.c
@@ -170,7 +170,7 @@ int cpupri_init(struct cpupri *cp)
 {
 	int i;
 
-	memset(cp, 0, sizeof(*cp));
+	(void)memset(cp, 0, sizeof(*cp));
 
 	for (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {
 		struct cpupri_vec *vec = &cp->pri_to_cpu[i];
diff --git a/kernel/sched_debug.c b/kernel/sched_debug.c
index a6710a1..ab8a550 100644
--- a/kernel/sched_debug.c
+++ b/kernel/sched_debug.c
@@ -37,10 +37,10 @@ static long long nsec_high(unsigned long long nsec)
 {
 	if ((long long)nsec < 0) {
 		nsec = -nsec;
-		do_div(nsec, 1000000);
+		(void)do_div(nsec, 1000000);
 		return -nsec;
 	}
-	do_div(nsec, 1000000);
+	(void)do_div(nsec, 1000000);
 
 	return nsec;
 }
@@ -459,7 +459,7 @@ void proc_sched_show_task(struct task_struct *p, struct seq_file *m)
 
 		avg_atom = p->se.sum_exec_runtime;
 		if (nr_switches)
-			do_div(avg_atom, nr_switches);
+			(void)do_div(avg_atom, nr_switches);
 		else
 			avg_atom = -1LL;
 
@@ -503,6 +503,6 @@ void proc_sched_show_task(struct task_struct *p, struct seq_file *m)
 void proc_sched_set_task(struct task_struct *p)
 {
 #ifdef CONFIG_SCHEDSTATS
-	memset(&p->se.statistics, 0, sizeof(p->se.statistics));
+	(void)memset(&p->se.statistics, 0, sizeof(p->se.statistics));
 #endif
 }
diff --git a/kernel/sched_fair.c b/kernel/sched_fair.c
index c768588..cf25d12 100644
--- a/kernel/sched_fair.c
+++ b/kernel/sched_fair.c
@@ -109,7 +109,7 @@ static inline struct rq *rq_of(struct cfs_rq *cfs_rq)
 static inline struct task_struct *task_of(struct sched_entity *se)
 {
 #ifdef CONFIG_SCHED_DEBUG
-	WARN_ON_ONCE(!entity_is_task(se));
+	(void)WARN_ON_ONCE(!entity_is_task(se));
 #endif
 	return container_of(se, struct task_struct, se);
 }
@@ -2869,7 +2869,7 @@ static inline void update_sd_lb_stats(struct sched_domain *sd, int this_cpu,
 		int local_group;
 
 		local_group = cpumask_test_cpu(this_cpu, sched_group_cpus(sg));
-		memset(&sgs, 0, sizeof(sgs));
+		(void)memset(&sgs, 0, sizeof(sgs));
 		update_sg_lb_stats(sd, sg, this_cpu, idle, load_idx,
 				local_group, cpus, balance, &sgs);
 
@@ -3138,7 +3138,7 @@ find_busiest_group(struct sched_domain *sd, int this_cpu,
 {
 	struct sd_lb_stats sds;
 
-	memset(&sds, 0, sizeof(sds));
+	(void)memset(&sds, 0, sizeof(sds));
 
 	/*
 	 * Compute the various statistics relavent for load balancing at
diff --git a/kernel/sched_rt.c b/kernel/sched_rt.c
index 17f2319..983521d 100644
--- a/kernel/sched_rt.c
+++ b/kernel/sched_rt.c
@@ -10,7 +10,7 @@
 static inline struct task_struct *rt_task_of(struct sched_rt_entity *rt_se)
 {
 #ifdef CONFIG_SCHED_DEBUG
-	WARN_ON_ONCE(!rt_entity_is_task(rt_se));
+	(void)WARN_ON_ONCE(!rt_entity_is_task(rt_se));
 #endif
 	return container_of(rt_se, struct task_struct, rt);
 }
@@ -769,7 +769,7 @@ dec_rt_prio(struct rt_rq *rt_rq, int prio)
 
 	if (rt_rq->rt_nr_running) {
 
-		WARN_ON(prio < prev_prio);
+		(void)WARN_ON(prio < prev_prio);
 
 		/*
 		 * This may have been our highest task, and therefore
@@ -813,7 +813,7 @@ dec_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 	if (rt_se_boosted(rt_se))
 		rt_rq->rt_nr_boosted--;
 
-	WARN_ON(!rt_rq->rt_nr_running && rt_rq->rt_nr_boosted);
+	(void)WARN_ON(!rt_rq->rt_nr_running && rt_rq->rt_nr_boosted);
 }
 
 #else /* CONFIG_RT_GROUP_SCHED */
@@ -834,7 +834,7 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
 	int prio = rt_se_prio(rt_se);
 
-	WARN_ON(!rt_prio(prio));
+	(void)WARN_ON(!rt_prio(prio));
 	rt_rq->rt_nr_running++;
 
 	inc_rt_prio(rt_rq, prio);
@@ -845,8 +845,8 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 static inline
 void dec_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
-	WARN_ON(!rt_prio(rt_se_prio(rt_se)));
-	WARN_ON(!rt_rq->rt_nr_running);
+	(void)WARN_ON(!rt_prio(rt_se_prio(rt_se)));
+	(void)WARN_ON(!rt_rq->rt_nr_running);
 	rt_rq->rt_nr_running--;
 
 	dec_rt_prio(rt_rq, rt_se_prio(rt_se));
@@ -1392,7 +1392,7 @@ static int push_rt_task(struct rq *rq)
 
 retry:
 	if (unlikely(next_task == rq->curr)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
@@ -1512,8 +1512,8 @@ static int pull_rt_task(struct rq *this_rq)
 		 * the to-be-scheduled task?
 		 */
 		if (p && (p->prio < this_rq->rt.highest_prio.curr)) {
-			WARN_ON(p == src_rq->curr);
-			WARN_ON(!p->on_rq);
+			(void)WARN_ON(p == src_rq->curr);
+			(void)WARN_ON(!p->on_rq);
 
 			/*
 			 * There's a chance that p is higher in priority
diff --git a/kernel/signal.c b/kernel/signal.c
index 415d85d..c3f9ad6 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -279,7 +279,7 @@ static bool task_participate_group_stop(struct task_struct *task)
 	struct signal_struct *sig = task->signal;
 	bool consume = task->group_stop & GROUP_STOP_CONSUME;
 
-	WARN_ON_ONCE(!(task->group_stop & GROUP_STOP_PENDING));
+	(void)WARN_ON_ONCE(!(task->group_stop & GROUP_STOP_PENDING));
 
 	task_clear_group_stop_pending(task);
 
@@ -1841,7 +1841,7 @@ void ptrace_notify(int exit_code)
 
 	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
 
-	memset(&info, 0, sizeof info);
+	(void)memset(&info, 0, sizeof info);
 	info.si_signo = SIGTRAP;
 	info.si_code = exit_code;
 	info.si_pid = task_pid_vnr(current);
@@ -1868,7 +1868,7 @@ static int do_signal_stop(int signr)
 		struct task_struct *t;
 
 		/* signr will be recorded in task->group_stop for retries */
-		WARN_ON_ONCE(signr & ~GROUP_STOP_SIGMASK);
+		(void)WARN_ON_ONCE(signr & ~GROUP_STOP_SIGMASK);
 
 		if (!likely(current->group_stop & GROUP_STOP_DEQUEUED) ||
 		    unlikely(signal_group_exit(sig)))
@@ -1895,7 +1895,7 @@ static int do_signal_stop(int signr)
 		if (!(sig->flags & SIGNAL_STOP_STOPPED))
 			sig->group_exit_code = signr;
 		else
-			WARN_ON_ONCE(!task_ptrace(current));
+			(void)WARN_ON_ONCE(!task_ptrace(current));
 
 		current->group_stop &= ~GROUP_STOP_SIGMASK;
 		current->group_stop |= signr | gstop;
@@ -1961,7 +1961,7 @@ retry:
 	 * between TASK_STOPPED and TRACED.  Retry group stop.
 	 */
 	if (current->group_stop & GROUP_STOP_PENDING) {
-		WARN_ON_ONCE(!(current->group_stop & GROUP_STOP_SIGMASK));
+		(void)WARN_ON_ONCE(!(current->group_stop & GROUP_STOP_SIGMASK));
 		goto retry;
 	}
 
@@ -2729,7 +2729,7 @@ SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,
 	 */
 	if (info.si_code >= 0 || info.si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info.si_code < 0);
+		(void)WARN_ON_ONCE(info.si_code < 0);
 		return -EPERM;
 	}
 	info.si_signo = sig;
@@ -2749,7 +2749,7 @@ long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 	 */
 	if (info->si_code >= 0 || info->si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info->si_code < 0);
+		(void)WARN_ON_ONCE(info->si_code < 0);
 		return -EPERM;
 	}
 	info->si_signo = sig;
diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index 0cae1cc..0feaabe 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -44,7 +44,7 @@ static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);
 
 static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)
 {
-	memset(done, 0, sizeof(*done));
+	(void)memset(done, 0, sizeof(*done));
 	atomic_set(&done->nr_todo, nr_todo);
 	init_completion(&done->completion);
 }
@@ -275,7 +275,7 @@ repeat:
 
 		/* restore preemption and check it's still balanced */
 		preempt_enable();
-		WARN_ONCE(preempt_count(),
+		(void)WARN_ONCE(preempt_count(),
 			  "cpu_stop: %s(%p) leaked preempt count\n",
 			  kallsyms_lookup((unsigned long)fn, NULL, NULL, NULL,
 					  ksym_buf), arg);
diff --git a/kernel/sys.c b/kernel/sys.c
index f88dadc..275a81b 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1246,7 +1246,7 @@ SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->nodename, tmp, len);
-		memset(u->nodename + len, 0, sizeof(u->nodename) - len);
+		(void)memset(u->nodename + len, 0, sizeof(u->nodename) - len);
 		errno = 0;
 	}
 	up_write(&uts_sem);
@@ -1296,7 +1296,7 @@ SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->domainname, tmp, len);
-		memset(u->domainname + len, 0, sizeof(u->domainname) - len);
+		(void)memset(u->domainname + len, 0, sizeof(u->domainname) - len);
 		errno = 0;
 	}
 	up_write(&uts_sem);
@@ -1564,7 +1564,7 @@ static void k_getrusage(struct task_struct *p, int who, struct rusage *r)
 	cputime_t tgutime, tgstime, utime, stime;
 	unsigned long maxrss = 0;
 
-	memset((char *) r, 0, sizeof *r);
+	(void)memset((char *) r, 0, sizeof *r);
 	utime = stime = cputime_zero;
 
 	if (who == RUSAGE_THREAD) {
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 4c5eac4..9866abc 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1991,7 +1991,7 @@ void unregister_sysctl_table(struct ctl_table_header * header)
 	spin_lock(&sysctl_lock);
 	start_unregistering(header);
 	if (!--header->parent->count) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		call_rcu(&header->parent->rcu, free_head);
 	}
 	if (!--header->count)
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index e0980f0..0b706fb 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -153,7 +153,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)
 	for (sft = 32; sft > 0; sft--) {
 		tmp = (u64) to << sft;
 		tmp += from / 2;
-		do_div(tmp, from);
+		(void)do_div(tmp, from);
 		if ((tmp >> sftacc) == 0)
 			break;
 	}
@@ -654,8 +654,8 @@ void __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq)
 	 * margin as we do in clocksource_max_deferment()
 	 */
 	sec = (cs->mask - (cs->mask >> 5));
-	do_div(sec, freq);
-	do_div(sec, scale);
+	(void)do_div(sec, freq);
+	(void)do_div(sec, scale);
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && cs->mask > UINT_MAX)
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index e8f9cce..b2ec5e5 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -736,7 +736,7 @@ static void update_rq_stats(void)
 			rq_avg = (rq_avg * jiffy_gap) +
 				(rq_info.rq_avg *
 				 rq_info.rq_poll_total_jiffies);
-			do_div(rq_avg,
+			(void)do_div(rq_avg,
 			       rq_info.rq_poll_total_jiffies + jiffy_gap);
 		}
 
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 342408c..71390f7b 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -74,7 +74,7 @@ static void timekeeper_setup_internals(struct clocksource *clock)
 	tmp <<= clock->shift;
 	ntpinterval = tmp;
 	tmp += clock->mult/2;
-	do_div(tmp, clock->mult);
+	(void)do_div(tmp, clock->mult);
 	if (tmp == 0)
 		tmp = 1;
 
@@ -219,7 +219,7 @@ void getnstimeofday(struct timespec *ts)
 	unsigned long seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -242,7 +242,7 @@ ktime_t ktime_get(void)
 	unsigned int seq;
 	s64 secs, nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -273,7 +273,7 @@ void ktime_get_ts(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -980,7 +980,7 @@ void get_monotonic_boottime(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
diff --git a/kernel/timer.c b/kernel/timer.c
index 8cff361..52ba7e9 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -562,7 +562,7 @@ static void __init_timer(struct timer_list *timer,
 #ifdef CONFIG_TIMER_STATS
 	timer->start_site = NULL;
 	timer->start_pid = -1;
-	memset(timer->start_comm, 0, TASK_COMM_LEN);
+	(void)memset(timer->start_comm, 0, TASK_COMM_LEN);
 #endif
 	lockdep_init_map(&timer->lockdep_map, name, key, 0);
 }
@@ -1008,7 +1008,7 @@ int del_timer_sync(struct timer_list *timer)
 	 * don't use it in hardirq context, because it
 	 * could lead to deadlock.
 	 */
-	WARN_ON(in_irq());
+	(void)WARN_ON(in_irq());
 	for (;;) {
 		int ret = try_to_del_timer_sync(timer);
 		if (ret >= 0)
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index b0c7aa4..23a077d 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -839,7 +839,7 @@ rb_set_head_page(struct ring_buffer_per_cpu *cpu_buffer)
 		} while (page != head);
 	}
 
-	RB_WARN_ON(cpu_buffer, 1);
+	(void)RB_WARN_ON(cpu_buffer, 1);
 
 	return NULL;
 }
@@ -1001,7 +1001,7 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 	LIST_HEAD(pages);
 	unsigned i;
 
-	WARN_ON(!nr_pages);
+	(void)WARN_ON(!nr_pages);
 
 	for (i = 0; i < nr_pages; i++) {
 		bpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),
@@ -1547,7 +1547,7 @@ rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)
 
 		local_set(&cpu_buffer->commit_page->page->commit,
 			  rb_page_write(cpu_buffer->commit_page));
-		RB_WARN_ON(cpu_buffer,
+		(void)RB_WARN_ON(cpu_buffer,
 			   local_read(&cpu_buffer->commit_page->page->commit) &
 			   ~RB_WRITE_MASK);
 		barrier();
@@ -1724,7 +1724,7 @@ rb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,
 		 */
 		return 1;
 	default:
-		RB_WARN_ON(cpu_buffer, 1); /* WTF??? */
+		(void)RB_WARN_ON(cpu_buffer, 1); /* WTF??? */
 		return -1;
 	}
 
@@ -1762,7 +1762,7 @@ rb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,
 		/* OK */
 		break;
 	default:
-		RB_WARN_ON(cpu_buffer, 1);
+		(void)RB_WARN_ON(cpu_buffer, 1);
 		return -1;
 	}
 
@@ -2176,7 +2176,7 @@ rb_reserve_next_event(struct ring_buffer *buffer,
 #ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
 			local_clock_stable = sched_clock_stable;
 #endif
-			WARN_ONCE(delta > (1ULL << 59),
+			(void)WARN_ONCE(delta > (1ULL << 59),
 				  KERN_WARNING "Delta way too big! %llu ts=%llu write stamp = %llu\n%s",
 				  (unsigned long long)delta,
 				  (unsigned long long)ts,
@@ -2221,7 +2221,7 @@ static noinline void trace_recursive_fail(void)
 		    softirq_count() >> SOFTIRQ_SHIFT,
 		    in_nmi());
 
-	WARN_ON_ONCE(1);
+	(void)WARN_ON_ONCE(1);
 }
 
 static inline int trace_recursive_lock(void)
@@ -2238,7 +2238,7 @@ static inline int trace_recursive_lock(void)
 
 static inline void trace_recursive_unlock(void)
 {
-	WARN_ON_ONCE(!trace_recursion_buffer());
+	(void)WARN_ON_ONCE(!trace_recursion_buffer());
 
 	trace_recursion_dec();
 }
@@ -2425,7 +2425,7 @@ rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,
 	} while (bpage != start);
 
 	/* commit not part of this buffer?? */
-	RB_WARN_ON(cpu_buffer, 1);
+	(void)RB_WARN_ON(cpu_buffer, 1);
 }
 
 /**
@@ -2464,7 +2464,7 @@ void ring_buffer_discard_commit(struct ring_buffer *buffer,
 	 * committed yet. Thus we can assume that preemption
 	 * is still disabled.
 	 */
-	RB_WARN_ON(buffer, !local_read(&cpu_buffer->committing));
+	(void)RB_WARN_ON(buffer, !local_read(&cpu_buffer->committing));
 
 	rb_decrement_entry(cpu_buffer, event);
 	if (rb_try_to_discard(cpu_buffer, event))
@@ -3093,7 +3093,7 @@ rb_buffer_peek(struct ring_buffer_per_cpu *cpu_buffer, u64 *ts,
 	switch (event->type_len) {
 	case RINGBUF_TYPE_PADDING:
 		if (rb_null_event(event))
-			RB_WARN_ON(cpu_buffer, 1);
+			(void)RB_WARN_ON(cpu_buffer, 1);
 		/*
 		 * Because the writer could be discarding every
 		 * event it creates (which would probably be bad)
@@ -3946,7 +3946,7 @@ int ring_buffer_read_page(struct ring_buffer *buffer,
 	 * This page may be off to user land. Zero it out here.
 	 */
 	if (commit < BUF_PAGE_SIZE)
-		memset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);
+		(void)memset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);
 
  out_unlock:
 	spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
@@ -4044,7 +4044,7 @@ static int rb_cpu_notify(struct notifier_block *self,
 		buffer->buffers[cpu] =
 			rb_allocate_cpu_buffer(buffer, cpu);
 		if (!buffer->buffers[cpu]) {
-			WARN(1, "failed to allocate ring buffer on CPU %ld\n",
+			(void)WARN(1, "failed to allocate ring buffer on CPU %ld\n",
 			     cpu);
 			return NOTIFY_OK;
 		}
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index ee9c921..d1fd512 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -153,7 +153,7 @@ __setup("ftrace_dump_on_oops", set_ftrace_dump_on_oops);
 unsigned long long ns2usecs(cycle_t nsec)
 {
 	nsec += 500;
-	do_div(nsec, 1000);
+	(void)do_div(nsec, 1000);
 	return nsec;
 }
 
@@ -442,7 +442,7 @@ int trace_clock_id;
  */
 int trace_parser_get_init(struct trace_parser *parser, int size)
 {
-	memset(parser, 0, sizeof(*parser));
+	(void)memset(parser, 0, sizeof(*parser));
 
 	parser->buffer = kmalloc(size, GFP_KERNEL);
 	if (!parser->buffer)
@@ -919,8 +919,8 @@ static atomic_t trace_record_cmdline_disabled __read_mostly;
 
 static void trace_init_cmdlines(void)
 {
-	memset(&map_pid_to_cmdline, NO_CMDLINE_MAP, sizeof(map_pid_to_cmdline));
-	memset(&map_cmdline_to_pid, NO_CMDLINE_MAP, sizeof(map_cmdline_to_pid));
+	(void)memset(&map_pid_to_cmdline, NO_CMDLINE_MAP, sizeof(map_pid_to_cmdline));
+	(void)memset(&map_cmdline_to_pid, NO_CMDLINE_MAP, sizeof(map_cmdline_to_pid));
 	cmdline_idx = 0;
 }
 
@@ -962,7 +962,7 @@ void tracing_start(void)
 	if (--trace_stop_count) {
 		if (trace_stop_count < 0) {
 			/* Someone screwed up their debugging */
-			WARN_ON_ONCE(1);
+			(void)WARN_ON_ONCE(1);
 			trace_stop_count = 0;
 		}
 		goto out;
@@ -1248,7 +1248,7 @@ static void __ftrace_trace_stack(struct ring_buffer *buffer,
 	if (!event)
 		return;
 	entry	= ring_buffer_event_data(event);
-	memset(&entry->caller, 0, sizeof(entry->caller));
+	(void)memset(&entry->caller, 0, sizeof(entry->caller));
 
 	trace.nr_entries	= 0;
 	trace.max_entries	= FTRACE_STACK_ENTRIES;
@@ -1328,7 +1328,7 @@ ftrace_trace_userstack(struct ring_buffer *buffer, unsigned long flags, int pc)
 	entry	= ring_buffer_event_data(event);
 
 	entry->tgid		= current->tgid;
-	memset(&entry->caller, 0, sizeof(entry->caller));
+	(void)memset(&entry->caller, 0, sizeof(entry->caller));
 
 	trace.nr_entries	= 0;
 	trace.max_entries	= FTRACE_STACK_ENTRIES;
@@ -1629,7 +1629,7 @@ static void *s_next(struct seq_file *m, void *v, loff_t *pos)
 	int i = (int)*pos;
 	void *ent;
 
-	WARN_ON_ONCE(iter->leftover);
+	(void)WARN_ON_ONCE(iter->leftover);
 
 	(*pos)++;
 
@@ -2723,7 +2723,7 @@ tracing_ctrl_write(struct file *filp, const char __user *ubuf,
 	if (tracer_enabled ^ val) {
 
 		/* Only need to warn if this is used to change the state */
-		WARN_ONCE(1, "tracing_enabled is deprecated. Use tracing_on");
+		(void)WARN_ONCE(1, "tracing_enabled is deprecated. Use tracing_on");
 
 		if (val) {
 			tracer_enabled = 1;
@@ -2806,7 +2806,7 @@ static int tracing_resize_ring_buffer(unsigned long size)
 			 * happen, but if it does, warn and kill all
 			 * tracing.
 			 */
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			tracing_disabled = 1;
 		}
 		return ret;
@@ -3209,7 +3209,7 @@ waitagain:
 		cnt = PAGE_SIZE - 1;
 
 	/* reset all but tr, trace, and overruns */
-	memset(&iter->seq, 0,
+	(void)memset(&iter->seq, 0,
 	       sizeof(struct trace_iterator) -
 	       offsetof(struct trace_iterator, seq));
 	iter->pos = -1;
@@ -3237,7 +3237,7 @@ waitagain:
 		 * size and we should leave by partial output condition above.
 		 * One of the trace_seq_* functions is not used properly.
 		 */
-		WARN_ONCE(iter->seq.full, "full flag set for trace type %d",
+		(void)WARN_ONCE(iter->seq.full, "full flag set for trace type %d",
 			  iter->ent->type);
 	}
 	trace_access_unlock(iter->cpu_file);
@@ -3826,13 +3826,13 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos,
 		return -ENOMEM;
 
 	if (*ppos & (PAGE_SIZE - 1)) {
-		WARN_ONCE(1, "Ftrace: previous read must page-align\n");
+		(void)WARN_ONCE(1, "Ftrace: previous read must page-align\n");
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (len & (PAGE_SIZE - 1)) {
-		WARN_ONCE(1, "Ftrace: splice_read should page-align\n");
+		(void)WARN_ONCE(1, "Ftrace: splice_read should page-align\n");
 		if (len < PAGE_SIZE) {
 			ret = -EINVAL;
 			goto out;
@@ -3874,7 +3874,7 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos,
 		 */
 		size = ring_buffer_page_len(ref->page);
 		if (size < PAGE_SIZE)
-			memset(ref->page + size, 0, PAGE_SIZE - size);
+			(void)memset(ref->page + size, 0, PAGE_SIZE - size);
 
 		page = virt_to_page(ref->page);
 
@@ -4527,7 +4527,7 @@ __ftrace_dump(bool disable_tracing, enum ftrace_dump_mode oops_dump_mode)
 		cnt++;
 
 		/* reset all but tr, trace, and overruns */
-		memset(&iter.seq, 0,
+		(void)memset(&iter.seq, 0,
 		       sizeof(struct trace_iterator) -
 		       offsetof(struct trace_iterator, seq));
 		iter.iter_flags |= TRACE_FILE_LAT_FMT;
@@ -4600,7 +4600,7 @@ __init static int tracer_alloc_buffers(void)
 	global_trace.buffer = ring_buffer_alloc(ring_buf_size, rb_flags);
 	if (!global_trace.buffer) {
 		printk(KERN_ERR "tracer: failed to allocate ring buffer!\n");
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out_free_cpumask;
 	}
 	global_trace.entries = ring_buffer_size(global_trace.buffer);
diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c
index 256764e..71ea8b1 100644
--- a/kernel/trace/trace_events_filter.c
+++ b/kernel/trace/trace_events_filter.c
@@ -563,7 +563,7 @@ static void append_filter_err(struct filter_parse_state *ps,
 		return;
 
 	append_filter_string(filter, "\n");
-	memset(buf, ' ', PAGE_SIZE);
+	(void)memset(buf, ' ', PAGE_SIZE);
 	if (pos > PAGE_SIZE - 128)
 		pos = 0;
 	buf[pos] = '^';
@@ -1011,7 +1011,7 @@ static void parse_init(struct filter_parse_state *ps,
 		       struct filter_op *ops,
 		       char *infix_string)
 {
-	memset(ps, '\0', sizeof(*ps));
+	(void)memset(ps, '\0', sizeof(*ps));
 
 	ps->infix.string = infix_string;
 	ps->infix.cnt = strlen(infix_string);
@@ -1089,7 +1089,7 @@ static int infix_get_op(struct filter_parse_state *ps, char firstc)
 
 static inline void clear_operand_string(struct filter_parse_state *ps)
 {
-	memset(ps->operand.string, '\0', MAX_FILTER_STR_VAL);
+	(void)memset(ps->operand.string, '\0', MAX_FILTER_STR_VAL);
 	ps->operand.tail = 0;
 }
 
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index e37de49..4cc9502 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -797,7 +797,7 @@ int register_ftrace_event(struct trace_event *event)
 
 	} else if (event->type > __TRACE_LAST_TYPE) {
 		printk(KERN_WARNING "Need to add type to trace.h\n");
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out;
 	} else {
 		/* Is this event already used */
@@ -1299,7 +1299,7 @@ __init static int init_events(void)
 		if (!ret) {
 			printk(KERN_WARNING "event %d failed to register\n",
 			       event->type);
-			WARN_ON_ONCE(1);
+			(void)WARN_ON_ONCE(1);
 		}
 	}
 
diff --git a/kernel/tracepoint.c b/kernel/tracepoint.c
index b219f14..5e0b208 100644
--- a/kernel/tracepoint.c
+++ b/kernel/tracepoint.c
@@ -107,7 +107,7 @@ tracepoint_entry_add_probe(struct tracepoint_entry *entry,
 	int nr_probes = 0;
 	struct tracepoint_func *old, *new;
 
-	WARN_ON(!probe);
+	(void)WARN_ON(!probe);
 
 	debug_print_probes(entry);
 	old = entry->funcs;
@@ -249,7 +249,7 @@ static inline void remove_tracepoint(struct tracepoint_entry *e)
 static void set_tracepoint(struct tracepoint_entry **entry,
 	struct tracepoint *elem, int active)
 {
-	WARN_ON(strcmp((*entry)->name, elem->name) != 0);
+	(void)WARN_ON(strcmp((*entry)->name, elem->name) != 0);
 
 	if (elem->regfunc && !jump_label_enabled(&elem->key) && active)
 		elem->regfunc();
diff --git a/kernel/watchdog.c b/kernel/watchdog.c
index 3d0c56a..81d142b 100644
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@ -419,7 +419,7 @@ static void watchdog_prepare_cpu(int cpu)
 {
 	struct hrtimer *hrtimer = &per_cpu(watchdog_hrtimer, cpu);
 
-	WARN_ON(per_cpu(softlockup_watchdog, cpu));
+	(void)WARN_ON(per_cpu(softlockup_watchdog, cpu));
 	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	hrtimer->function = watchdog_timer_fn;
 }
@@ -581,7 +581,7 @@ void __init lockup_detector_init(void)
 	int err;
 
 	err = cpu_callback(&cpu_nfb, CPU_UP_PREPARE, cpu);
-	WARN_ON(notifier_to_errno(err));
+	(void)WARN_ON(notifier_to_errno(err));
 
 	cpu_callback(&cpu_nfb, CPU_ONLINE, cpu);
 	register_cpu_notifier(&cpu_nfb);
diff --git a/lib/devres.c b/lib/devres.c
index 6efddf5..3bb47bb 100644
--- a/lib/devres.c
+++ b/lib/devres.c
@@ -80,7 +80,7 @@ EXPORT_SYMBOL(devm_ioremap_nocache);
 void devm_iounmap(struct device *dev, void __iomem *addr)
 {
 	iounmap(addr);
-	WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
+	(void)WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
 			       (void *)addr));
 }
 EXPORT_SYMBOL(devm_iounmap);
@@ -140,7 +140,7 @@ EXPORT_SYMBOL(devm_ioport_map);
 void devm_ioport_unmap(struct device *dev, void __iomem *addr)
 {
 	ioport_unmap(addr);
-	WARN_ON(devres_destroy(dev, devm_ioport_map_release,
+	(void)WARN_ON(devres_destroy(dev, devm_ioport_map_release,
 			       devm_ioport_map_match, (void *)addr));
 }
 EXPORT_SYMBOL(devm_ioport_unmap);
diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c
index 75ca78f..71f878d 100644
--- a/lib/dynamic_debug.c
+++ b/lib/dynamic_debug.c
@@ -303,7 +303,7 @@ static int ddebug_parse_query(char *words[], int nwords,
 	/* check we have an even number of words */
 	if (nwords % 2 != 0)
 		return -EINVAL;
-	memset(query, 0, sizeof(*query));
+	(void)memset(query, 0, sizeof(*query));
 
 	for (i = 0 ; i < nwords ; i += 2) {
 		if (!strcmp(words[i], "func"))
diff --git a/lib/kref.c b/lib/kref.c
index 3efb882..80c5753 100644
--- a/lib/kref.c
+++ b/lib/kref.c
@@ -31,7 +31,7 @@ void kref_init(struct kref *kref)
  */
 void kref_get(struct kref *kref)
 {
-	WARN_ON(!atomic_read(&kref->refcount));
+	(void)WARN_ON(!atomic_read(&kref->refcount));
 	atomic_inc(&kref->refcount);
 	smp_mb__after_atomic_inc();
 }
@@ -52,8 +52,8 @@ void kref_get(struct kref *kref)
  */
 int kref_put(struct kref *kref, void (*release)(struct kref *kref))
 {
-	WARN_ON(release == NULL);
-	WARN_ON(release == (void (*)(struct kref *))kfree);
+	(void)WARN_ON(release == NULL);
+	(void)WARN_ON(release == (void (*)(struct kref *))kfree);
 
 	if (atomic_dec_and_test(&kref->refcount)) {
 		release(kref);
@@ -81,8 +81,8 @@ int kref_put(struct kref *kref, void (*release)(struct kref *kref))
 int kref_sub(struct kref *kref, unsigned int count,
 	     void (*release)(struct kref *kref))
 {
-	WARN_ON(release == NULL);
-	WARN_ON(release == (void (*)(struct kref *))kfree);
+	(void)WARN_ON(release == NULL);
+	(void)WARN_ON(release == (void (*)(struct kref *))kfree);
 
 	if (atomic_sub_and_test((int) count, &kref->refcount)) {
 		release(kref);
diff --git a/lib/memory_alloc.c b/lib/memory_alloc.c
index d931e14..75d6caf 100644
--- a/lib/memory_alloc.c
+++ b/lib/memory_alloc.c
@@ -126,7 +126,7 @@ static int add_alloc(struct alloc *node)
 		else if (node->vaddr > tmp->vaddr)
 			p = &(*p)->rb_right;
 		else {
-			WARN(1, "memory at %p already allocated", tmp->vaddr);
+			(void)WARN(1, "memory at %p already allocated", tmp->vaddr);
 			mutex_unlock(&alloc_mutex);
 			return -EINVAL;
 		}
diff --git a/mm/bounce.c b/mm/bounce.c
index 1481de6..a5a5e49 100644
--- a/mm/bounce.c
+++ b/mm/bounce.c
@@ -201,7 +201,7 @@ static void __blk_queue_bounce(struct request_queue *q, struct bio **bio_orig,
 			unsigned int cnt = (*bio_orig)->bi_vcnt;
 
 			bio = bio_alloc(GFP_NOIO, cnt);
-			memset(bio->bi_io_vec, 0, cnt * sizeof(struct bio_vec));
+			(void)memset(bio->bi_io_vec, 0, cnt * sizeof(struct bio_vec));
 		}
 			
 
diff --git a/mm/debug-pagealloc.c b/mm/debug-pagealloc.c
index a1e3324..0173019 100644
--- a/mm/debug-pagealloc.c
+++ b/mm/debug-pagealloc.c
@@ -39,7 +39,7 @@ static void poison_page(struct page *page)
 	}
 	set_page_poison(page);
 	addr = page_address(page);
-	memset(addr, PAGE_POISON, PAGE_SIZE);
+	(void)memset(addr, PAGE_POISON, PAGE_SIZE);
 }
 
 static void poison_pages(struct page *page, int n)
diff --git a/mm/dmapool.c b/mm/dmapool.c
index 03bf3bb..bb4b87f 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -223,7 +223,7 @@ static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)
 					 &page->dma, mem_flags);
 	if (page->vaddr) {
 #ifdef	DMAPOOL_DEBUG
-		memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
+		(void)memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
 #endif
 		pool_initialise_page(pool, page);
 		list_add(&page->page_list, &pool->page_list);
@@ -246,7 +246,7 @@ static void pool_free_page(struct dma_pool *pool, struct dma_page *page)
 	dma_addr_t dma = page->dma;
 
 #ifdef	DMAPOOL_DEBUG
-	memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
+	(void)memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
 #endif
 	dma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);
 	list_del(&page->page_list);
@@ -345,7 +345,7 @@ void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 	retval = offset + page->vaddr;
 	*handle = offset + page->dma;
 #ifdef	DMAPOOL_DEBUG
-	memset(retval, POOL_POISON_ALLOCATED, pool->size);
+	(void)memset(retval, POOL_POISON_ALLOCATED, pool->size);
 #endif
  done:
 	spin_unlock_irqrestore(&pool->lock, flags);
@@ -428,7 +428,7 @@ void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t dma)
 			return;
 		}
 	}
-	memset(vaddr, POOL_POISON_FREED, pool->size);
+	(void)memset(vaddr, POOL_POISON_FREED, pool->size);
 #endif
 
 	page->in_use--;
@@ -501,6 +501,6 @@ void dmam_pool_destroy(struct dma_pool *pool)
 	struct device *dev = pool->dev;
 
 	dma_pool_destroy(pool);
-	WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
+	(void)WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
 }
 EXPORT_SYMBOL(dmam_pool_destroy);
diff --git a/mm/filemap.c b/mm/filemap.c
index a8251a8..14823ec 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -855,7 +855,7 @@ repeat:
 		 * of or back to the root: none yet gotten, safe to restart.
 		 */
 		if (radix_tree_deref_retry(page)) {
-			WARN_ON(start | i);
+			(void)WARN_ON(start | i);
 			goto restart;
 		}
 
diff --git a/mm/memblock.c b/mm/memblock.c
index 5338237..55ba996 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -249,7 +249,7 @@ static int __init_memblock memblock_double_array(struct memblock_type *type)
 	 * array itself that is full.
 	 */
 	memcpy(new_array, type->regions, old_size);
-	memset(new_array + type->max, 0, old_size);
+	(void)memset(new_array + type->max, 0, old_size);
 	old_array = type->regions;
 	type->regions = new_array;
 	type->max <<= 1;
@@ -312,7 +312,7 @@ static long __init_memblock memblock_add_region(struct memblock_type *type,
 				 * exclusive, if you do that, be prepared
 				 * for trouble
 				 */
-				WARN_ON(end != rgn->base);
+				(void)WARN_ON(end != rgn->base);
 				goto new_block;
 			}
 			/* We extend the bottom of the block down to our
@@ -346,7 +346,7 @@ static long __init_memblock memblock_add_region(struct memblock_type *type,
 				 * exclusive, if you do that, be prepared
 				 * for trouble
 				 */
-				WARN_ON(rend != base);
+				(void)WARN_ON(rend != base);
 				goto new_block;
 			}
 			/* We adjust our base down to enclose the
@@ -447,7 +447,7 @@ static long __init_memblock __memblock_remove(struct memblock_type *type,
 			 * restore the block before erroring
 			 */
 			rgn->size = rend - rgn->base;
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			return -1;
 		}
 
@@ -765,9 +765,9 @@ void __init memblock_analyze(void)
 	int i;
 
 	/* Check marker in the unused last array entry */
-	WARN_ON(memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS].base
+	(void)WARN_ON(memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS].base
 		!= (phys_addr_t)RED_INACTIVE);
-	WARN_ON(memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS].base
+	(void)WARN_ON(memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS].base
 		!= (phys_addr_t)RED_INACTIVE);
 
 	memblock.memory_size = 0;
diff --git a/mm/mmap.c b/mm/mmap.c
index d49736f..51533cc 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2126,7 +2126,7 @@ static inline void verify_mm_writelocked(struct mm_struct *mm)
 {
 #ifdef CONFIG_DEBUG_VM
 	if (unlikely(down_read_trylock(&mm->mmap_sem))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		up_read(&mm->mmap_sem);
 	}
 #endif
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 955fe35..2382061 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -283,7 +283,7 @@ static unsigned long task_dirty_limit(struct task_struct *tsk,
 
 	task_dirties_fraction(tsk, &numerator, &denominator);
 	inv *= numerator;
-	do_div(inv, denominator);
+	(void)do_div(inv, denominator);
 
 	dirty -= inv;
 
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index ea53496..edafddd 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -14,7 +14,7 @@ static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,
 				    unsigned int cpu, int page_idx)
 {
 	/* must not be used on pre-mapped chunk */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	return vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));
 }
@@ -57,7 +57,7 @@ static struct page **pcpu_get_pages_and_bitmap(struct pcpu_chunk *chunk,
 			return NULL;
 	}
 
-	memset(pages, 0, pages_size);
+	(void)memset(pages, 0, pages_size);
 	bitmap_copy(bitmap, chunk->populated, pcpu_unit_pages);
 
 	*bitmapp = bitmap;
@@ -178,7 +178,7 @@ static void pcpu_unmap_pages(struct pcpu_chunk *chunk,
 			struct page *page;
 
 			page = pcpu_chunk_page(chunk, cpu, i);
-			WARN_ON(!page);
+			(void)WARN_ON(!page);
 			pages[pcpu_page_idx(cpu, i)] = page;
 		}
 		__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),
@@ -317,7 +317,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 		goto clear;
 
 	/* need to allocate and map pages, this chunk can't be immutable */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	pages = pcpu_get_pages_and_bitmap(chunk, &populated, true);
 	if (!pages)
@@ -343,7 +343,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 	bitmap_copy(chunk->populated, populated, pcpu_unit_pages);
 clear:
 	for_each_possible_cpu(cpu)
-		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
+		(void)memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 	return 0;
 
 err_unmap:
@@ -386,7 +386,7 @@ static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk, int off, int size)
 		return;
 
 	/* immutable chunks can't be depopulated */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	/*
 	 * If control reaches here, there must have been at least one
diff --git a/mm/percpu.c b/mm/percpu.c
index bf80e55..eed0173 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -1426,8 +1426,8 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
 	unsigned int *cpu_map;
 
 	/* this function may be called multiple times */
-	memset(group_map, 0, sizeof(group_map));
-	memset(group_cnt, 0, sizeof(group_cnt));
+	(void)memset(group_map, 0, sizeof(group_map));
+	(void)memset(group_cnt, 0, sizeof(group_cnt));
 
 	/* calculate size_sum and ensure dyn_size is enough for early alloc */
 	size_sum = PFN_ALIGN(static_size + reserved_size +
diff --git a/mm/shmem.c b/mm/shmem.c
index 883e98f..012c49c 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -2441,7 +2441,7 @@ static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,
 			if (*rest == '%') {
 				size <<= PAGE_SHIFT;
 				size *= totalram_pages;
-				do_div(size, 100);
+				(void)do_div(size, 100);
 				rest++;
 			}
 			if (*rest)
diff --git a/mm/slub.c b/mm/slub.c
index 03bc30b..212101d 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -448,7 +448,7 @@ static void set_track(struct kmem_cache *s, void *object,
 		p->pid = current->pid;
 		p->when = jiffies;
 	} else
-		memset(p, 0, sizeof(struct track));
+		(void)memset(p, 0, sizeof(struct track));
 }
 
 static void init_tracking(struct kmem_cache *s, void *object)
@@ -582,12 +582,12 @@ static void init_object(struct kmem_cache *s, void *object, u8 val)
 	u8 *p = object;
 
 	if (s->flags & __OBJECT_POISON) {
-		memset(p, POISON_FREE, s->objsize - 1);
+		(void)memset(p, POISON_FREE, s->objsize - 1);
 		p[s->objsize - 1] = POISON_END;
 	}
 
 	if (s->flags & SLAB_RED_ZONE)
-		memset(p + s->objsize, val, s->inuse - s->objsize);
+		(void)memset(p + s->objsize, val, s->inuse - s->objsize);
 }
 
 static u8 *check_bytes8(u8 *start, u8 value, unsigned int bytes)
@@ -637,7 +637,7 @@ static void restore_bytes(struct kmem_cache *s, char *message, u8 data,
 						void *from, void *to)
 {
 	slab_fix(s, "Restoring 0x%p-0x%p=0x%x\n", from, to - 1, data);
-	memset(from, data, to - from);
+	(void)memset(from, data, to - from);
 }
 
 static int check_bytes_and_report(struct kmem_cache *s, struct page *page,
@@ -1328,7 +1328,7 @@ static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)
 	start = page_address(page);
 
 	if (unlikely(s->flags & SLAB_POISON))
-		memset(start, POISON_INUSE, PAGE_SIZE << compound_order(page));
+		(void)memset(start, POISON_INUSE, PAGE_SIZE << compound_order(page));
 
 	last = start;
 	for_each_object(p, s, start, page->objects) {
@@ -2021,7 +2021,7 @@ redo:
 	}
 
 	if (unlikely(gfpflags & __GFP_ZERO) && object)
-		memset(object, 0, s->objsize);
+		(void)memset(object, 0, s->objsize);
 
 	slab_post_alloc_hook(s, gfpflags, object);
 
@@ -2628,7 +2628,7 @@ static int kmem_cache_open(struct kmem_cache *s,
 		size_t align, unsigned long flags,
 		void (*ctor)(void *))
 {
-	memset(s, 0, kmem_size);
+	(void)memset(s, 0, kmem_size);
 	s->name = name;
 	s->ctor = ctor;
 	s->objsize = size;
@@ -2985,7 +2985,7 @@ size_t ksize(const void *object)
 	page = virt_to_head_page(object);
 
 	if (unlikely(!PageSlab(page))) {
-		WARN_ON(!PageCompound(page));
+		(void)WARN_ON(!PageCompound(page));
 		return PAGE_SIZE << compound_order(page);
 	}
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index c33d2ae..24d9932 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -2328,7 +2328,7 @@ struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,
 	last_end = offsets[last_area] + sizes[last_area];
 
 	if (vmalloc_end - vmalloc_start < last_end) {
-		WARN_ON(true);
+		(void)WARN_ON(true);
 		return NULL;
 	}
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 6072d74..3e649cd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -254,7 +254,7 @@ unsigned long shrink_slab(struct shrink_control *shrink,
 		max_pass = do_shrinker_shrink(shrinker, shrink, 0);
 		delta = (4 * nr_pages_scanned) / shrinker->seeks;
 		delta *= max_pass;
-		do_div(delta, lru_pages + 1);
+		(void)do_div(delta, lru_pages + 1);
 		shrinker->nr += delta;
 		if (shrinker->nr < 0) {
 			printk(KERN_ERR "shrink_slab: %pF negative objects to "
diff --git a/net/bluetooth/amp.c b/net/bluetooth/amp.c
index 4918caa..d17b2c9 100644
--- a/net/bluetooth/amp.c
+++ b/net/bluetooth/amp.c
@@ -661,7 +661,7 @@ int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize,
 	unsigned char hash_result[64];
 	int i;
 
-	memset(output, 0, outlen);
+	(void)memset(output, 0, outlen);
 
 	init_completion(&tresult.completion);
 
@@ -690,7 +690,7 @@ int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize,
 		goto err_hash_buf;
 	}
 
-	memset(hash_result, 0, 64);
+	(void)memset(hash_result, 0, 64);
 	memcpy(hash_buff, plaintext, psize);
 	sg_init_one(&sg, hash_buff, psize);
 
@@ -1631,7 +1631,7 @@ static int send_a2mp(struct socket *sock, u8 *data, int len)
 	struct kvec iv = { data, len };
 	struct msghdr msg;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
@@ -1744,7 +1744,7 @@ static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst)
 	sk->sk_data_ready = data_ready;
 	sk->sk_state_change = state_change;
 
-	memset(&addr, 0, sizeof(addr));
+	(void)memset(&addr, 0, sizeof(addr));
 	bacpy(&addr.l2_bdaddr, src);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_cid = L2CAP_CID_A2MP;
@@ -1757,7 +1757,7 @@ static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst)
 
 	l2cap_fixed_channel_config(sk, &opts);
 
-	memset(&addr, 0, sizeof(addr));
+	(void)memset(&addr, 0, sizeof(addr));
 	bacpy(&addr.l2_bdaddr, dst);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_cid = L2CAP_CID_A2MP;
diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c
index 61c946c..940119b 100644
--- a/net/bluetooth/bnep/core.c
+++ b/net/bluetooth/bnep/core.c
@@ -155,7 +155,7 @@ static int bnep_ctrl_set_netfilter(struct bnep_session *s, __be16 *data, int len
 		}
 
 		if (i < BNEP_MAX_PROTO_FILTERS)
-			memset(f + i, 0, sizeof(*f));
+			(void)memset(f + i, 0, sizeof(*f));
 
 		if (n == 0)
 			bnep_set_default_proto_filter(s);
@@ -657,7 +657,7 @@ int bnep_del_connection(struct bnep_conndel_req *req)
 
 static void __bnep_copy_ci(struct bnep_conninfo *ci, struct bnep_session *s)
 {
-	memset(ci, 0, sizeof(*ci));
+	(void)memset(ci, 0, sizeof(*ci));
 	memcpy(ci->dst, s->eh.h_source, ETH_ALEN);
 	strcpy(ci->device, s->dev->name);
 	ci->flags = s->flags;
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ccf3623..5c23e43 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -58,7 +58,7 @@ static void hci_le_connect(struct hci_conn *conn)
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->type = LE_LINK;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 	cp.scan_interval = cpu_to_le16(0x0004);
 	cp.scan_window = cpu_to_le16(0x0004);
 	bacpy(&cp.peer_addr, &conn->dst);
@@ -94,7 +94,7 @@ void hci_acl_connect(struct hci_conn *conn)
 
 	conn->link_policy = hdev->link_policy;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;
 
@@ -211,7 +211,7 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	struct hci_cp_le_conn_update cp;
 	struct hci_dev *hdev = conn->hdev;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle		= cpu_to_le16(conn->handle);
 	cp.conn_interval_min	= cpu_to_le16(min);
@@ -233,7 +233,7 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
@@ -251,7 +251,7 @@ void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 	memcpy(cp.ltk, ltk, sizeof(ltk));
@@ -267,7 +267,7 @@ void hci_le_ltk_neg_reply(struct hci_conn *conn)
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 47bfde5..0bcb143 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -193,7 +193,7 @@ static void hci_reset_req(struct hci_dev *hdev, unsigned long opt)
 
 	/* Reset device */
 	set_bit(HCI_RESET, &hdev->flags);
-	memset(&hdev->features, 0, sizeof(hdev->features));
+	(void)memset(&hdev->features, 0, sizeof(hdev->features));
 	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 }
 
@@ -756,7 +756,7 @@ int hci_dev_reset_stat(__u16 dev)
 	if (!hdev)
 		return -ENODEV;
 
-	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
+	(void)memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	hci_dev_put(hdev);
 
@@ -1496,7 +1496,7 @@ int hci_register_dev(struct hci_dev *hdev)
 	INIT_WORK(&hdev->power_off, hci_power_off);
 	setup_timer(&hdev->off_timer, hci_auto_off, (unsigned long) hdev);
 
-	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
+	(void)memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	atomic_set(&hdev->promisc, 0);
 
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index f98a90e..ea40d94 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1941,7 +1941,7 @@ static inline void hci_remote_features_evt(struct hci_dev *hdev, struct sk_buff
 
 	if (!ev->status) {
 		struct hci_cp_remote_name_req cp;
-		memset(&cp, 0, sizeof(cp));
+		(void)memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
@@ -2721,7 +2721,7 @@ static inline void hci_remote_ext_features_evt(struct hci_dev *hdev, struct sk_b
 
 	if (!ev->status) {
 		struct hci_cp_remote_name_req cp;
-		memset(&cp, 0, sizeof(cp));
+		(void)memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 92d72b7..6380b83 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -385,7 +385,7 @@ static int hci_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_le
 	if (!addr)
 		return -EINVAL;
 
-	memset(&haddr, 0, sizeof(haddr));
+	(void)memset(&haddr, 0, sizeof(haddr));
 	len = min_t(unsigned int, sizeof(haddr), addr_len);
 	memcpy(&haddr, addr, len);
 
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index 04f7784..c3cf682 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -109,7 +109,7 @@ static void __hidp_unlink_session(struct hidp_session *session)
 
 static void __hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)
 {
-	memset(ci, 0, sizeof(*ci));
+	(void)memset(ci, 0, sizeof(*ci));
 	bacpy(&ci->bdaddr, &session->bdaddr);
 
 	ci->flags = session->flags;
@@ -508,7 +508,7 @@ static int hidp_send_frame(struct socket *sock, unsigned char *data, int len)
 	if (!len)
 		return 0;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
@@ -621,7 +621,7 @@ static int hidp_session(void *arg)
 
 	fput(session->intr_sock->file);
 
-	wait_event_timeout(*(sk_sleep(ctrl_sk)),
+	(void)wait_event_timeout(*(sk_sleep(ctrl_sk)),
 		(ctrl_sk->sk_state == BT_CLOSED), msecs_to_jiffies(500));
 
 	fput(session->ctrl_sock->file);
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index cf6cf59..33f0fa5 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -1949,7 +1949,7 @@ static void l2cap_ertm_send_ack(struct sock *sk)
 	BT_DBG("last_acked_seq %d, buffer_seq %d", (int)pi->last_acked_seq,
 		(int)pi->buffer_seq);
 
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 
 	if ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
@@ -1998,7 +1998,7 @@ static void l2cap_ertm_send_rr_or_rnr(struct sock *sk, bool poll)
 
 	pi = l2cap_pi(sk);
 
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 	control.poll = poll;
 
@@ -2020,7 +2020,7 @@ static void l2cap_ertm_send_i_or_rr_or_rnr(struct sock *sk)
 
 	pi = l2cap_pi(sk);
 
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 	control.final = 1;
 	control.reqseq = pi->buffer_seq;
@@ -2058,7 +2058,7 @@ static void l2cap_ertm_send_srej(struct sock *sk, u16 txseq)
 	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
 
 	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 	control.super = L2CAP_SFRAME_SREJ;
 
@@ -2086,7 +2086,7 @@ static void l2cap_ertm_send_srej_tail(struct sock *sk)
 	if (pi->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)
 		return;
 
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 	control.super = L2CAP_SFRAME_SREJ;
 	control.reqseq = pi->srej_list.tail;
@@ -2103,7 +2103,7 @@ static void l2cap_ertm_send_srej_list(struct sock *sk, u16 txseq)
 	BT_DBG("sk %p, txseq %d", sk, (int) txseq);
 
 	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.frame_type = 's';
 	control.super = L2CAP_SFRAME_SREJ;
 
@@ -2193,7 +2193,7 @@ static int l2cap_ertm_tx_state_xmit(struct sock *sk,
 			(pi->conn_state & L2CAP_CONN_SENT_RNR)) {
 			struct bt_l2cap_control local_control;
 
-			memset(&local_control, 0, sizeof(local_control));
+			(void)memset(&local_control, 0, sizeof(local_control));
 			local_control.frame_type = 's';
 			local_control.super = L2CAP_SFRAME_RR;
 			local_control.poll = 1;
@@ -2269,7 +2269,7 @@ static int l2cap_ertm_tx_state_wait_f(struct sock *sk,
 
 		if (pi->conn_state & L2CAP_CONN_SENT_RNR) {
 			struct bt_l2cap_control local_control;
-			memset(&local_control, 0, sizeof(local_control));
+			(void)memset(&local_control, 0, sizeof(local_control));
 			local_control.frame_type = 's';
 			local_control.super = L2CAP_SFRAME_RR;
 			local_control.poll = 1;
@@ -2457,7 +2457,7 @@ int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue)
 	if (skb_queue_empty(queue))
 		return 0;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = (struct iovec *) &iv;
 
 	buflen = pi->omtu + L2CAP_FCS_SIZE;
@@ -3580,7 +3580,7 @@ done:
 		default:
 			result = L2CAP_CONF_UNACCEPT;
 
-			memset(&rfc, 0, sizeof(rfc));
+			(void)memset(&rfc, 0, sizeof(rfc));
 			rfc.mode = pi->mode;
 		}
 
@@ -5662,7 +5662,7 @@ static inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,
 	BT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",
 						min, max, latency, to_multiplier);
 
-	memset(&rsp, 0, sizeof(rsp));
+	(void)memset(&rsp, 0, sizeof(rsp));
 
 	err = l2cap_check_conn_param(min, max, latency, to_multiplier);
 	if (err)
@@ -6628,7 +6628,7 @@ static int l2cap_ertm_rx_state_srej_sent(struct sock *sk,
 			l2cap_ertm_send_srej_tail(sk);
 		else {
 			struct bt_l2cap_control rr_control;
-			memset(&rr_control, 0, sizeof(rr_control));
+			(void)memset(&rr_control, 0, sizeof(rr_control));
 			rr_control.frame_type = 's';
 			rr_control.super = L2CAP_SFRAME_RR;
 			rr_control.reqseq = pi->buffer_seq;
@@ -6745,7 +6745,7 @@ static int l2cap_answer_move_poll(struct sock *sk)
 	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
 	l2cap_ertm_send_i_or_rr_or_rnr(sk);
 
-	memset(&control, 0, sizeof(control));
+	(void)memset(&control, 0, sizeof(control));
 	control.reqseq = pi->amp_move_reqseq;
 
 	if (pi->amp_move_event == L2CAP_ERTM_EVENT_RECV_IFRAME)
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index 93e7b04..8387b85 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -101,7 +101,7 @@ static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&la, 0, sizeof(la));
+	(void)memset(&la, 0, sizeof(la));
 	len = min_t(unsigned int, sizeof(la), alen);
 	memcpy(&la, addr, len);
 
@@ -170,7 +170,7 @@ static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int al
 	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&la, 0, sizeof(la));
+	(void)memset(&la, 0, sizeof(la));
 	len = min_t(unsigned int, sizeof(la), alen);
 	memcpy(&la, addr, len);
 
@@ -403,7 +403,7 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 
 	switch (optname) {
 	case L2CAP_OPTIONS:
-		memset(&opts, 0, sizeof(opts));
+		(void)memset(&opts, 0, sizeof(opts));
 		opts.imtu     = l2cap_pi(sk)->imtu;
 		opts.omtu     = l2cap_pi(sk)->omtu;
 		opts.flush_to = l2cap_pi(sk)->flush_to;
@@ -502,7 +502,7 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 			break;
 		}
 
-		memset(&sec, 0, sizeof(sec));
+		(void)memset(&sec, 0, sizeof(sec));
 		sec.level = l2cap_pi(sk)->sec_level;
 
 		if (sk->sk_state == BT_CONNECTED)
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 67a2900..23cccbe 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -202,7 +202,7 @@ static int read_controller_info(struct sock *sk, u16 index)
 
 	set_bit(HCI_MGMT, &hdev->flags);
 
-	memset(&rp, 0, sizeof(rp));
+	(void)memset(&rp, 0, sizeof(rp));
 
 	rp.type = hdev->dev_type;
 
@@ -485,7 +485,7 @@ static int set_limited_discoverable(struct sock *sk, u16 index,
 		goto failed;
 	}
 
-	memset(&dcp, 0, sizeof(dcp));
+	(void)memset(&dcp, 0, sizeof(dcp));
 	dcp.num_current_iac = cp->val ? 2 : 1;
 	memcpy(&dcp.lap, lap, dcp.num_current_iac * 3);
 	update_cod = 1;
@@ -781,7 +781,7 @@ static void create_eir(struct hci_dev *hdev, u8 *data)
 		ptr += (name_len + 2);
 	}
 
-	memset(uuid16_list, 0, sizeof(uuid16_list));
+	(void)memset(uuid16_list, 0, sizeof(uuid16_list));
 
 	/* Group all UUID16 types */
 	list_for_each(p, &hdev->uuids) {
@@ -847,7 +847,7 @@ static int update_eir(struct hci_dev *hdev)
 	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
 		return 0;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	create_eir(hdev, cp.data);
 
@@ -1740,7 +1740,7 @@ static int resolve_name(struct sock *sk, u16 index, unsigned char *data,
 		goto failed;
 	}
 
-	memset(&hci_cp, 0, sizeof(hci_cp));
+	(void)memset(&hci_cp, 0, sizeof(hci_cp));
 	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
 	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(hci_cp),
 								&hci_cp);
@@ -2022,7 +2022,7 @@ static int start_discovery(struct sock *sk, u16 index)
 		cp.length /= 2;
 
 		/* Setup LE scan params */
-		memset(&le_cp, 0, sizeof(le_cp));
+		(void)memset(&le_cp, 0, sizeof(le_cp));
 		le_cp.type = 0x01;		/* Active scanning */
 		/* The recommended value for scan interval and window is
 		 * 11.25 msec. It is calculated by: time = n * 0.625 msec */
@@ -2730,7 +2730,7 @@ int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status)
 	struct mgmt_cp_set_local_name ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
 
 	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, index);
@@ -2802,7 +2802,7 @@ int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
 
 	BT_DBG("le: %d", le);
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 
 	bacpy(&ev.bdaddr, bdaddr);
 	ev.rssi = rssi;
@@ -2860,7 +2860,7 @@ int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name)
 {
 	struct mgmt_ev_remote_name ev;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 
 	bacpy(&ev.bdaddr, bdaddr);
 	ev.status = status;
@@ -2886,7 +2886,7 @@ int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3])
 {
 	struct mgmt_ev_remote_class ev;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 
 	bacpy(&ev.bdaddr, bdaddr);
 	memcpy(ev.dev_class, dev_class, 3);
diff --git a/net/bluetooth/rfcomm/core.c b/net/bluetooth/rfcomm/core.c
index c4b9950..d4fc82f 100644
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -814,7 +814,7 @@ static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 
 	BT_DBG("session %p len %d", s, len);
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
@@ -1127,7 +1127,7 @@ static int rfcomm_send_test(struct rfcomm_session *s, int cr, u8 *pattern, int l
 	iv[2].iov_base = crc;
 	iv[2].iov_len  = 1;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, iv, 3, 6 + len);
 }
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 3b1e54c..b40203e 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -481,7 +481,7 @@ static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
+	(void)memset(&sa, 0, sizeof(sa));
 	len = min_t(unsigned int, sizeof(sa), alen);
 	memcpy(&sa, addr, len);
 
@@ -521,7 +521,7 @@ static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
+	(void)memset(&sa, 0, sizeof(sa));
 	len = min_t(unsigned int, sizeof(sa), alen);
 	memcpy(&sa, addr, len);
 
@@ -733,7 +733,7 @@ static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user
 			break;
 		}
 
-		memset(&cinfo, 0, sizeof(cinfo));
+		(void)memset(&cinfo, 0, sizeof(cinfo));
 		cinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;
 		memcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);
 
diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c
index e301edf..719abf2 100644
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@ -82,7 +82,7 @@ static int smp_e(struct crypto_blkcipher *tfm, const u8 *k, u8 *r)
 
 	iv_len = crypto_blkcipher_ivsize(tfm);
 	if (iv_len) {
-		memset(&iv, 0xff, iv_len);
+		(void)memset(&iv, 0xff, iv_len);
 		crypto_blkcipher_set_iv(tfm, iv, iv_len);
 	}
 
@@ -100,7 +100,7 @@ static int smp_c1(struct crypto_blkcipher *tfm, u8 k[16], u8 r[16],
 	u8 p1[16], p2[16];
 	int err;
 
-	memset(p1, 0, 16);
+	(void)memset(p1, 0, 16);
 
 	/* p1 = pres || preq || _rat || _iat */
 	swap56(pres, p1);
@@ -108,7 +108,7 @@ static int smp_c1(struct crypto_blkcipher *tfm, u8 k[16], u8 r[16],
 	p1[14] = _rat;
 	p1[15] = _iat;
 
-	memset(p2, 0, 16);
+	(void)memset(p2, 0, 16);
 
 	/* p2 = padding || ia || ra */
 	baswap((bdaddr_t *) (p2 + 4), ia);
@@ -300,7 +300,7 @@ static int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,
 	int ret = 0;
 
 	/* Initialize key to JUST WORKS */
-	memset(hcon->tk, 0, sizeof(hcon->tk));
+	(void)memset(hcon->tk, 0, sizeof(hcon->tk));
 	hcon->tk_valid = FALSE;
 	hcon->auth = auth;
 
@@ -353,7 +353,7 @@ static int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,
 		/* Generate a passkey for display. It is not valid until
 		 * confirmed.
 		 */
-		memset(key, 0, sizeof(key));
+		(void)memset(key, 0, sizeof(key));
 		get_random_bytes(&passkey, sizeof(passkey));
 		passkey %= 1000000;
 		put_unaligned_le32(passkey, key);
@@ -427,7 +427,7 @@ int le_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, void *cp)
 	case MGMT_OP_USER_CONFIRM_REPLY:
 		break;
 	case MGMT_OP_USER_PASSKEY_REPLY:
-		memset(key, 0, sizeof(key));
+		(void)memset(key, 0, sizeof(key));
 		BT_DBG("PassKey: %d", psk_reply->passkey);
 		put_unaligned_le32(psk_reply->passkey, key);
 		swap128(key, hcon->tk);
@@ -615,13 +615,13 @@ static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 		u8 stk[16], rand[8];
 		__le16 ediv;
 
-		memset(rand, 0, sizeof(rand));
+		(void)memset(rand, 0, sizeof(rand));
 		ediv = 0;
 
 		smp_s1(tfm, hcon->tk, random, hcon->prnd, key);
 		swap128(key, stk);
 
-		memset(stk + hcon->smp_key_size, 0,
+		(void)memset(stk + hcon->smp_key_size, 0,
 				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
 
 		hci_le_start_enc(hcon, ediv, rand, stk);
@@ -630,7 +630,7 @@ static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 		u8 stk[16], r[16], rand[8];
 		__le16 ediv;
 
-		memset(rand, 0, sizeof(rand));
+		(void)memset(rand, 0, sizeof(rand));
 		ediv = 0;
 
 		swap128(hcon->prnd, r);
@@ -639,7 +639,7 @@ static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 		smp_s1(tfm, hcon->tk, hcon->prnd, random, key);
 		swap128(key, stk);
 
-		memset(stk + hcon->smp_key_size, 0,
+		(void)memset(stk + hcon->smp_key_size, 0,
 				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
 
 		hci_add_ltk(conn->hcon->hdev, 0, conn->dst, hcon->dst_type,
@@ -657,7 +657,7 @@ static int smp_encrypt_link(struct hci_conn *hcon, struct link_key *key)
 	if (!hcon || !key || !key->data)
 		return -EINVAL;
 
-	memset(zerobuf, 0, sizeof(zerobuf));
+	(void)memset(zerobuf, 0, sizeof(zerobuf));
 
 	master = (void *) key->data;
 
@@ -707,7 +707,7 @@ invalid_key:
 
 	skb_pull(skb, sizeof(*rp));
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 	build_pairing_cmd(conn, &cp, NULL, rp->auth_req);
 
 	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
@@ -809,7 +809,7 @@ static int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)
 
 	BT_DBG("conn %p", conn);
 
-	memset(rand, 0, sizeof(rand));
+	(void)memset(rand, 0, sizeof(rand));
 
 	err = hci_add_ltk(hcon->hdev, 0, conn->dst, hcon->dst_type,
 						0, 0, 0, rand, rp->ltk);
@@ -1000,7 +1000,7 @@ static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 		smp_send_cmd(conn, SMP_CMD_IDENT_INFO, sizeof(idinfo), &idinfo);
 
 		/* Just public address */
-		memset(&addrinfo, 0, sizeof(addrinfo));
+		(void)memset(&addrinfo, 0, sizeof(addrinfo));
 		bacpy(&addrinfo.bdaddr, conn->src);
 
 		smp_send_cmd(conn, SMP_CMD_IDENT_ADDR_INFO, sizeof(addrinfo),
diff --git a/net/core/dev.c b/net/core/dev.c
index 9c58c1e..e8a34eb 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -485,7 +485,7 @@ static int netdev_boot_setup_add(char *name, struct ifmap *map)
 	s = dev_boot_setup;
 	for (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++) {
 		if (s[i].name[0] == '\0' || s[i].name[0] == ' ') {
-			memset(s[i].name, 0, sizeof(s[i].name));
+			(void)memset(s[i].name, 0, sizeof(s[i].name));
 			strlcpy(s[i].name, name, IFNAMSIZ);
 			memcpy(&s[i].map, map, sizeof(s[i].map));
 			break;
@@ -568,7 +568,7 @@ int __init netdev_boot_setup(char *str)
 		return 0;
 
 	/* Save settings */
-	memset(&map, 0, sizeof(map));
+	(void)memset(&map, 0, sizeof(map));
 	if (ints[0] > 0)
 		map.irq = ints[1];
 	if (ints[0] > 1)
@@ -1325,7 +1325,7 @@ void dev_disable_lro(struct net_device *dev)
 
 	__ethtool_set_flags(dev, flags & ~ETH_FLAG_LRO);
 	if (unlikely(dev->features & NETIF_F_LRO))
-		netdev_WARN(dev, "failed to disable LRO!\n");
+		(void)netdev_WARN(dev, "failed to disable LRO!\n");
 }
 EXPORT_SYMBOL(dev_disable_lro);
 
@@ -1880,7 +1880,7 @@ struct sk_buff *skb_gso_segment(struct sk_buff *skb, u32 features)
 		if (dev && dev->ethtool_ops && dev->ethtool_ops->get_drvinfo)
 			dev->ethtool_ops->get_drvinfo(dev, &info);
 
-		WARN(1, "%s: caps=(0x%lx, 0x%lx) len=%d data_len=%d ip_summed=%d\n",
+		(void)WARN(1, "%s: caps=(0x%lx, 0x%lx) len=%d data_len=%d ip_summed=%d\n",
 		     info.driver, dev ? dev->features : 0L,
 		     skb->sk ? skb->sk->sk_route_caps : 0L,
 		     skb->len, skb->data_len, skb->ip_summed);
@@ -2650,7 +2650,7 @@ static int get_rps_cpu(struct net_device *dev, struct sk_buff *skb,
 	if (skb_rx_queue_recorded(skb)) {
 		u16 index = skb_get_rx_queue(skb);
 		if (unlikely(index >= dev->real_num_rx_queues)) {
-			WARN_ONCE(dev->real_num_rx_queues > 1,
+			(void)WARN_ONCE(dev->real_num_rx_queues > 1,
 				  "%s received packet on queue %u, but number "
 				  "of RX queues is %u\n",
 				  dev->name, index, dev->real_num_rx_queues);
@@ -2928,7 +2928,7 @@ static void net_tx_action(struct softirq_action *h)
 			struct sk_buff *skb = clist;
 			clist = clist->next;
 
-			WARN_ON(atomic_read(&skb->users));
+			(void)WARN_ON(atomic_read(&skb->users));
 			trace_kfree_skb(skb, net_tx_action);
 			__kfree_skb(skb);
 		}
@@ -3314,7 +3314,7 @@ static int napi_gro_complete(struct sk_buff *skb)
 	rcu_read_unlock();
 
 	if (err) {
-		WARN_ON(&ptype->list == head);
+		(void)WARN_ON(&ptype->list == head);
 		kfree_skb(skb);
 		return NET_RX_SUCCESS;
 	}
@@ -3806,7 +3806,7 @@ static void net_rx_action(struct softirq_action *h)
 			trace_napi_poll(n);
 		}
 
-		WARN_ON_ONCE(work > weight);
+		(void)WARN_ON_ONCE(work > weight);
 
 		budget -= work;
 
@@ -4523,7 +4523,7 @@ int dev_ethtool_get_settings(struct net_device *dev,
 	if (!dev->ethtool_ops || !dev->ethtool_ops->get_settings)
 		return -EOPNOTSUPP;
 
-	memset(cmd, 0, sizeof(struct ethtool_cmd));
+	(void)memset(cmd, 0, sizeof(struct ethtool_cmd));
 	cmd->cmd = ETHTOOL_GSET;
 	return dev->ethtool_ops->get_settings(dev, cmd);
 }
@@ -4760,7 +4760,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 
 	case SIOCGIFHWADDR:
 		if (!dev->addr_len)
-			memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
+			(void)memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
 		else
 			memcpy(ifr->ifr_hwaddr.sa_data, dev->dev_addr,
 			       min(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));
@@ -4792,7 +4792,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 		/* dev_ioctl() should ensure this case
 		 * is never reached
 		 */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		err = -ENOTTY;
 		break;
 
@@ -5130,7 +5130,7 @@ static void rollback_registered_many(struct list_head *head)
 			pr_debug("unregister_netdevice: device %s/%p never "
 				 "was registered\n", dev->name, dev);
 
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			list_del(&dev->unreg_list);
 			continue;
 		}
@@ -5174,7 +5174,7 @@ static void rollback_registered_many(struct list_head *head)
 			dev->netdev_ops->ndo_uninit(dev);
 
 		/* Notifier chain MUST detach us from master device. */
-		WARN_ON(dev->master);
+		(void)WARN_ON(dev->master);
 
 		/* Remove entries from kobject tree */
 		netdev_unregister_kobject(dev);
@@ -5549,7 +5549,7 @@ int init_dummy_netdev(struct net_device *dev)
 	 * NAPI code and this dummy netdev is supposed to be
 	 * only ever used for NAPI polls
 	 */
-	memset(dev, 0, sizeof(struct net_device));
+	(void)memset(dev, 0, sizeof(struct net_device));
 
 	/* make sure we BUG if trying to hit standard
 	 * register/unregister code path
@@ -5720,9 +5720,9 @@ void netdev_run_todo(void)
 
 		/* paranoia */
 		BUG_ON(netdev_refcnt_read(dev));
-		WARN_ON(rcu_dereference_raw(dev->ip_ptr));
-		WARN_ON(rcu_dereference_raw(dev->ip6_ptr));
-		WARN_ON(dev->dn_ptr);
+		(void)WARN_ON(rcu_dereference_raw(dev->ip_ptr));
+		(void)WARN_ON(rcu_dereference_raw(dev->ip6_ptr));
+		(void)WARN_ON(dev->dn_ptr);
 
 		if (dev->destructor)
 			dev->destructor(dev);
@@ -5769,7 +5769,7 @@ struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,
 	const struct net_device_ops *ops = dev->netdev_ops;
 
 	if (ops->ndo_get_stats64) {
-		memset(storage, 0, sizeof(*storage));
+		(void)memset(storage, 0, sizeof(*storage));
 		ops->ndo_get_stats64(dev, storage);
 	} else if (ops->ndo_get_stats) {
 		netdev_stats_to_stats64(storage, ops->ndo_get_stats(dev));
@@ -6125,7 +6125,7 @@ int dev_change_net_namespace(struct net_device *dev, struct net *net, const char
 
 	/* Fixup kobjects */
 	err = device_rename(&dev->dev, dev->name);
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 	/* Add the device back in the hashes */
 	list_netdevice(dev);
@@ -6460,7 +6460,7 @@ static int __init net_dev_init(void)
 	for_each_possible_cpu(i) {
 		struct softnet_data *sd = &per_cpu(softnet_data, i);
 
-		memset(sd, 0, sizeof(*sd));
+		(void)memset(sd, 0, sizeof(*sd));
 		skb_queue_head_init(&sd->input_pkt_queue);
 		skb_queue_head_init(&sd->process_queue);
 		sd->completion_queue = NULL;
diff --git a/net/core/fib_rules.c b/net/core/fib_rules.c
index f39ef5c..351d48d 100644
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@ -659,7 +659,7 @@ static void notify_rule_change(int event, struct fib_rule *rule,
 	err = fib_nl_fill_rule(skb, rule, pid, nlh->nlmsg_seq, event, 0, ops);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in fib_rule_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 16db887..c6f3b62 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -2848,7 +2848,7 @@ int neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,
 	if (dev) {
 		dev_name_source = dev->name;
 		/* Terminate the table early */
-		memset(&t->neigh_vars[14], 0, sizeof(t->neigh_vars[14]));
+		(void)memset(&t->neigh_vars[14], 0, sizeof(t->neigh_vars[14]));
 	} else {
 		dev_name_source = neigh_path[NEIGH_CTL_PATH_DEV].procname;
 		t->neigh_vars[14].data = (int *)(p + 1);
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 33d2a1f..01e661c 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -726,7 +726,7 @@ static void rx_queue_release(struct kobject *kobj)
 		call_rcu(&flow_table->rcu, rps_dev_flow_table_release);
 	}
 
-	memset(kobj, 0, sizeof(*kobj));
+	(void)memset(kobj, 0, sizeof(*kobj));
 	dev_put(queue->dev);
 }
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 46cbd28..e2fb170 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -196,7 +196,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	 * actually initialise below. Hence, don't put any more fields after
 	 * the tail pointer in struct sk_buff!
 	 */
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->truesize = size + sizeof(struct sk_buff);
 	atomic_set(&skb->users, 1);
 	skb->head = data;
@@ -209,7 +209,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -377,7 +377,7 @@ static void skb_release_head_state(struct sk_buff *skb)
 	secpath_put(skb->sp);
 #endif
 	if (skb->destructor) {
-		WARN_ON(in_irq());
+		(void)WARN_ON(in_irq());
 		skb->destructor(skb);
 	}
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
@@ -494,10 +494,10 @@ bool skb_recycle_check(struct sk_buff *skb, int skb_size)
 	skb_release_head_state(skb);
 
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->data = skb->head + NET_SKB_PAD;
 	skb_reset_tail_pointer(skb);
 
@@ -965,7 +965,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 
 	/* If the skbuff is non linear tailroom is always zero.. */
 	if (!skb_cloned(skb) && skb_tailroom(skb) >= pad) {
-		memset(skb->data+skb->len, 0, pad);
+		(void)memset(skb->data+skb->len, 0, pad);
 		return 0;
 	}
 
@@ -983,7 +983,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 	if (unlikely(err))
 		goto free_skb;
 
-	memset(skb->data + skb->len, 0, pad);
+	(void)memset(skb->data + skb->len, 0, pad);
 	return 0;
 
 free_skb:
@@ -1313,7 +1313,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_shinfo(skb)->frags[i].size;
 		if ((copy = end - offset) > 0) {
@@ -1339,7 +1339,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1620,7 +1620,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag->size;
 		if ((copy = end - offset) > 0) {
@@ -1645,7 +1645,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1693,7 +1693,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_shinfo(skb)->frags[i].size;
 		if ((copy = end - offset) > 0) {
@@ -1719,7 +1719,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1768,7 +1768,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_shinfo(skb)->frags[i].size;
 		if ((copy = end - offset) > 0) {
@@ -1798,7 +1798,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 		__wsum csum2;
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -2814,7 +2814,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_shinfo(skb)->frags[i].size;
 		if ((copy = end - offset) > 0) {
@@ -2835,7 +2835,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -3032,7 +3032,7 @@ void skb_tstamp_tx(struct sk_buff *orig_skb,
 	}
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	(void)memset(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 
diff --git a/net/ipv4/inet_diag.c b/net/ipv4/inet_diag.c
index 3267d38..1d728d7 100644
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@ -304,7 +304,7 @@ static int inet_diag_get_exact(struct sk_buff *in_skb,
 			   NETLINK_CB(in_skb).pid,
 			   nlh->nlmsg_seq, 0, nlh);
 	if (err < 0) {
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(rep);
 		goto out;
 	}
diff --git a/net/ipv4/inetpeer.c b/net/ipv4/inetpeer.c
index 6877645..779a1f5 100644
--- a/net/ipv4/inetpeer.c
+++ b/net/ipv4/inetpeer.c
@@ -525,7 +525,7 @@ found:		/* The existing node has been found.
 		p->rate_last = 0;
 		p->pmtu_expires = 0;
 		p->pmtu_orig = 0;
-		memset(&p->redirect_learned, 0, sizeof(p->redirect_learned));
+		(void)memset(&p->redirect_learned, 0, sizeof(p->redirect_learned));
 		INIT_LIST_HEAD(&p->unused);
 
 
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 0c99db4..2c7c4c2 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -121,7 +121,7 @@ static int ip_dev_loopback_xmit(struct sk_buff *newskb)
 	__skb_pull(newskb, skb_network_offset(newskb));
 	newskb->pkt_type = PACKET_LOOPBACK;
 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
-	WARN_ON(!skb_dst(newskb));
+	(void)WARN_ON(!skb_dst(newskb));
 	netif_rx_ni(newskb);
 	return 0;
 }
diff --git a/net/ipv4/netfilter/nf_nat_core.c b/net/ipv4/netfilter/nf_nat_core.c
index 3346de5..6ba0cbd 100644
--- a/net/ipv4/netfilter/nf_nat_core.c
+++ b/net/ipv4/netfilter/nf_nat_core.c
@@ -631,7 +631,7 @@ nfnetlink_parse_nat(const struct nlattr *nat,
 	struct nlattr *tb[CTA_NAT_MAX+1];
 	int err;
 
-	memset(range, 0, sizeof(*range));
+	(void)memset(range, 0, sizeof(*range));
 
 	err = nla_parse_nested(tb, CTA_NAT_MAX, nat, nat_nla_policy);
 	if (err < 0)
@@ -699,7 +699,7 @@ static int clean_nat(struct nf_conn *i, void *data)
 
 	if (!nat)
 		return 0;
-	memset(nat, 0, sizeof(*nat));
+	(void)memset(nat, 0, sizeof(*nat));
 	i->status &= ~(IPS_NAT_MASK | IPS_NAT_DONE_MASK | IPS_SEQ_ADJUST);
 	return 0;
 }
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 713e09d..f0c0898 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -321,8 +321,8 @@ void in6_dev_finish_destroy(struct inet6_dev *idev)
 {
 	struct net_device *dev = idev->dev;
 
-	WARN_ON(!list_empty(&idev->addr_list));
-	WARN_ON(idev->mc_list != NULL);
+	(void)WARN_ON(!list_empty(&idev->addr_list));
+	(void)WARN_ON(idev->mc_list != NULL);
 
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "in6_dev_finish_destroy: %s\n", dev ? dev->name : "NIL");
@@ -532,7 +532,7 @@ static int addrconf_fixup_forwarding(struct ctl_table *table, int *p, int old)
 /* Nobody refers to this ifaddr, destroy it */
 void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)
 {
-	WARN_ON(!hlist_unhashed(&ifp->addr_lst));
+	(void)WARN_ON(!hlist_unhashed(&ifp->addr_lst));
 
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "inet6_ifa_finish_destroy\n");
@@ -1521,7 +1521,7 @@ static int addrconf_ifid_arcnet(u8 *eui, struct net_device *dev)
 	/* XXX: inherit EUI-64 from other interface -- yoshfuji */
 	if (dev->addr_len != ARCNET_ALEN)
 		return -1;
-	memset(eui, 0, 7);
+	(void)memset(eui, 0, 7);
 	eui[7] = *(u8*)dev->dev_addr;
 	return 0;
 }
@@ -2102,7 +2102,7 @@ int addrconf_set_dstaddr(struct net *net, void __user *arg)
 		if (!(ipv6_addr_type(&ireq.ifr6_addr) & IPV6_ADDR_COMPATv4))
 			goto err_exit;
 
-		memset(&p, 0, sizeof(p));
+		(void)memset(&p, 0, sizeof(p));
 		p.iph.daddr = ireq.ifr6_addr.s6_addr32[3];
 		p.iph.saddr = 0;
 		p.iph.version = 4;
@@ -2313,7 +2313,7 @@ static void sit_add_v4_addrs(struct inet6_dev *idev)
 
 	ASSERT_RTNL();
 
-	memset(&addr, 0, sizeof(struct in6_addr));
+	(void)memset(&addr, 0, sizeof(struct in6_addr));
 	memcpy(&addr.s6_addr32[3], idev->dev->dev_addr, 4);
 
 	if (idev->dev->flags&IFF_POINTOPOINT) {
@@ -2416,7 +2416,7 @@ static void addrconf_dev_config(struct net_device *dev)
 	if (IS_ERR(idev))
 		return;
 
-	memset(&addr, 0, sizeof(struct in6_addr));
+	(void)memset(&addr, 0, sizeof(struct in6_addr));
 	addr.s6_addr32[0] = htonl(0xFE800000);
 
 	if (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)
@@ -3760,7 +3760,7 @@ static int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr* nlh,
 				nlh->nlmsg_seq, RTM_NEWADDR, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout_ifa;
 	}
@@ -3784,7 +3784,7 @@ static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)
 	err = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -3800,7 +3800,7 @@ static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
 {
 	BUG_ON(bytes < (DEVCONF_MAX * 4));
 
-	memset(array, 0, bytes);
+	(void)memset(array, 0, bytes);
 	array[DEVCONF_FORWARDING] = cnf->forwarding;
 	array[DEVCONF_HOPLIMIT] = cnf->hop_limit;
 	array[DEVCONF_MTU6] = cnf->mtu6;
@@ -3876,7 +3876,7 @@ static inline void __snmp6_fill_statsdev(u64 *stats, atomic_long_t *mib,
 	for (i = 1; i < items; i++)
 		put_unaligned(atomic_long_read(&mib[i]), &stats[i]);
 
-	memset(&stats[items], 0, pad);
+	(void)memset(&stats[items], 0, pad);
 }
 
 static inline void __snmp6_fill_stats64(u64 *stats, void __percpu **mib,
@@ -3891,7 +3891,7 @@ static inline void __snmp6_fill_stats64(u64 *stats, void __percpu **mib,
 	for (i = 1; i < items; i++)
 		put_unaligned(snmp_fold_field64(mib, i, syncpoff), &stats[i]);
 
-	memset(&stats[items], 0, pad);
+	(void)memset(&stats[items], 0, pad);
 }
 
 static void snmp6_fill_stats(u64 *stats, struct inet6_dev *idev, int attrtype,
@@ -4062,7 +4062,7 @@ void inet6_ifinfo_notify(int event, struct inet6_dev *idev)
 	err = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_if_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -4133,7 +4133,7 @@ static void inet6_prefix_notify(int event, struct inet6_dev *idev,
 	err = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_prefix_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -4782,7 +4782,7 @@ void addrconf_cleanup(void)
 	 */
 	spin_lock_bh(&addrconf_hash_lock);
 	for (i = 0; i < IN6_ADDR_HSIZE; i++)
-		WARN_ON(!hlist_empty(&inet6_addr_lst[i]));
+		(void)WARN_ON(!hlist_empty(&inet6_addr_lst[i]));
 	spin_unlock_bh(&addrconf_hash_lock);
 
 	del_timer(&addr_chk_timer);
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 7e8340e..d80056c 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -186,7 +186,7 @@ lookup_protocol:
 	answer_flags = answer->flags;
 	rcu_read_unlock();
 
-	WARN_ON(answer_prot->slab == NULL);
+	(void)WARN_ON(answer_prot->slab == NULL);
 
 	err = -ENOBUFS;
 	sk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot);
@@ -692,7 +692,7 @@ int inet6_sk_rebuild_header(struct sock *sk)
 		struct in6_addr *final_p, final;
 		struct flowi6 fl6;
 
-		memset(&fl6, 0, sizeof(fl6));
+		(void)memset(&fl6, 0, sizeof(fl6));
 		fl6.flowi6_proto = sk->sk_protocol;
 		ipv6_addr_copy(&fl6.daddr, &np->daddr);
 		ipv6_addr_copy(&fl6.saddr, &np->saddr);
diff --git a/net/ipv6/ah6.c b/net/ipv6/ah6.c
index 2195ae6..769e1ec 100644
--- a/net/ipv6/ah6.c
+++ b/net/ipv6/ah6.c
@@ -135,7 +135,7 @@ static int zero_out_mutable_opts(struct ipv6_opt_hdr *opthdr)
 			if (len < optlen)
 				goto bad;
 			if (opt[off] & 0x20)
-				memset(&opt[off+2], 0, opt[off+1]);
+				(void)memset(&opt[off+2], 0, opt[off+1]);
 			break;
 		}
 
@@ -370,7 +370,7 @@ static int ah6_output(struct xfrm_state *x, struct sk_buff *skb)
 	sg = ah_req_sg(ahash, req);
 
 	ah = ip_auth_hdr(skb);
-	memset(ah->auth_data, 0, ahp->icv_trunc_len);
+	(void)memset(ah->auth_data, 0, ahp->icv_trunc_len);
 
 	top_iph = ipv6_hdr(skb);
 	top_iph->payload_len = htons(skb->len - sizeof(*top_iph));
@@ -559,7 +559,7 @@ static int ah6_input(struct xfrm_state *x, struct sk_buff *skb)
 
 	memcpy(work_iph, ip6h, hdr_len);
 	memcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);
-	memset(ah->auth_data, 0, ahp->icv_trunc_len);
+	(void)memset(ah->auth_data, 0, ahp->icv_trunc_len);
 
 	if (ipv6_clear_mutable_options(ip6h, hdr_len, XFRM_POLICY_IN))
 		goto out_free;
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 1656033..c201c0b 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -59,7 +59,7 @@ int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	if (usin->sin6_family != AF_INET6)
 		return -EAFNOSUPPORT;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	if (np->sndflow) {
 		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
 		if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
index 79a485e..47d1724 100644
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -813,7 +813,7 @@ ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,
 	if (!opt2)
 		return ERR_PTR(-ENOBUFS);
 
-	memset(opt2, 0, tot_len);
+	(void)memset(opt2, 0, tot_len);
 
 	opt2->tot_len = tot_len;
 	p = (char *)(opt2 + 1);
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index 1190041..a4c0906 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -442,7 +442,7 @@ void icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info)
 
 	mip6_addr_swap(skb);
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_ICMPV6;
 	ipv6_addr_copy(&fl6.daddr, &hdr->saddr);
 	if (saddr)
@@ -538,7 +538,7 @@ static void icmpv6_echo_reply(struct sk_buff *skb)
 	memcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));
 	tmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_ICMPV6;
 	ipv6_addr_copy(&fl6.daddr, &ipv6_hdr(skb)->saddr);
 	if (saddr)
@@ -790,7 +790,7 @@ void icmpv6_flow_init(struct sock *sk, struct flowi6 *fl6,
 		      const struct in6_addr *daddr,
 		      int oif)
 {
-	memset(fl6, 0, sizeof(*fl6));
+	(void)memset(fl6, 0, sizeof(*fl6));
 	ipv6_addr_copy(&fl6->saddr, saddr);
 	ipv6_addr_copy(&fl6->daddr, daddr);
 	fl6->flowi6_proto 	= IPPROTO_ICMPV6;
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index 8a58e8c..8c14251 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -63,7 +63,7 @@ struct dst_entry *inet6_csk_route_req(struct sock *sk,
 	struct dst_entry *dst;
 	struct flowi6 fl6;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_TCP;
 	ipv6_addr_copy(&fl6.daddr, &treq->rmt_addr);
 	final_p = fl6_update_dst(&fl6, np->opt, &final);
@@ -124,7 +124,7 @@ struct request_sock *inet6_csk_search_req(const struct sock *sk,
 		    ipv6_addr_equal(&treq->rmt_addr, raddr) &&
 		    ipv6_addr_equal(&treq->loc_addr, laddr) &&
 		    (!treq->iif || treq->iif == iif)) {
-			WARN_ON(req->sk != NULL);
+			(void)WARN_ON(req->sk != NULL);
 			*prevp = prev;
 			return req;
 		}
@@ -212,7 +212,7 @@ int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)
 	struct dst_entry *dst;
 	struct in6_addr *final_p, final;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = sk->sk_protocol;
 	ipv6_addr_copy(&fl6.daddr, &np->daddr);
 	ipv6_addr_copy(&fl6.saddr, &np->saddr);
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 4076a0b..3ec6ec3 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -285,7 +285,7 @@ static int fib6_dump_node(struct fib6_walker_t *w)
 			w->leaf = rt;
 			return 1;
 		}
-		WARN_ON(res == 0);
+		(void)WARN_ON(res == 0);
 	}
 	w->leaf = NULL;
 	return 0;
@@ -794,7 +794,7 @@ out:
 			pn->leaf = fib6_find_prefix(info->nl_net, pn);
 #if RT6_DEBUG >= 2
 			if (!pn->leaf) {
-				WARN_ON(pn->leaf == NULL);
+				(void)WARN_ON(pn->leaf == NULL);
 				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
 			}
 #endif
@@ -958,7 +958,7 @@ struct fib6_node * fib6_locate(struct fib6_node *root,
 
 #ifdef CONFIG_IPV6_SUBTREES
 	if (src_len) {
-		WARN_ON(saddr == NULL);
+		(void)WARN_ON(saddr == NULL);
 		if (fn && fn->subtree)
 			fn = fib6_locate_1(fn->subtree, saddr, src_len,
 					   offsetof(struct rt6_info, rt6i_src));
@@ -1012,9 +1012,9 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 		RT6_TRACE("fixing tree: plen=%d iter=%d\n", fn->fn_bit, iter);
 		iter++;
 
-		WARN_ON(fn->fn_flags & RTN_RTINFO);
-		WARN_ON(fn->fn_flags & RTN_TL_ROOT);
-		WARN_ON(fn->leaf != NULL);
+		(void)WARN_ON(fn->fn_flags & RTN_RTINFO);
+		(void)WARN_ON(fn->fn_flags & RTN_TL_ROOT);
+		(void)WARN_ON(fn->leaf != NULL);
 
 		children = 0;
 		child = NULL;
@@ -1030,7 +1030,7 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 			fn->leaf = fib6_find_prefix(net, fn);
 #if RT6_DEBUG >= 2
 			if (fn->leaf==NULL) {
-				WARN_ON(!fn->leaf);
+				(void)WARN_ON(!fn->leaf);
 				fn->leaf = net->ipv6.ip6_null_entry;
 			}
 #endif
@@ -1041,17 +1041,17 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 		pn = fn->parent;
 #ifdef CONFIG_IPV6_SUBTREES
 		if (FIB6_SUBTREE(pn) == fn) {
-			WARN_ON(!(fn->fn_flags & RTN_ROOT));
+			(void)WARN_ON(!(fn->fn_flags & RTN_ROOT));
 			FIB6_SUBTREE(pn) = NULL;
 			nstate = FWS_L;
 		} else {
-			WARN_ON(fn->fn_flags & RTN_ROOT);
+			(void)WARN_ON(fn->fn_flags & RTN_ROOT);
 #endif
 			if (pn->right == fn) pn->right = child;
 			else if (pn->left == fn) pn->left = child;
 #if RT6_DEBUG >= 2
 			else
-				WARN_ON(1);
+				(void)WARN_ON(1);
 #endif
 			if (child)
 				child->parent = pn;
@@ -1171,14 +1171,14 @@ int fib6_del(struct rt6_info *rt, struct nl_info *info)
 
 #if RT6_DEBUG >= 2
 	if (rt->dst.obsolete>0) {
-		WARN_ON(fn != NULL);
+		(void)WARN_ON(fn != NULL);
 		return -ENOENT;
 	}
 #endif
 	if (fn == NULL || rt == net->ipv6.ip6_null_entry)
 		return -ENOENT;
 
-	WARN_ON(!(fn->fn_flags & RTN_RTINFO));
+	(void)WARN_ON(!(fn->fn_flags & RTN_RTINFO));
 
 	if (!(rt->rt6i_flags&RTF_CACHE)) {
 		struct fib6_node *pn = fn;
@@ -1292,7 +1292,7 @@ static int fib6_walk_continue(struct fib6_walker_t *w)
 			w->node = pn;
 #ifdef CONFIG_IPV6_SUBTREES
 			if (FIB6_SUBTREE(pn) == fn) {
-				WARN_ON(!(fn->fn_flags & RTN_ROOT));
+				(void)WARN_ON(!(fn->fn_flags & RTN_ROOT));
 				w->state = FWS_L;
 				continue;
 			}
@@ -1307,7 +1307,7 @@ static int fib6_walk_continue(struct fib6_walker_t *w)
 				continue;
 			}
 #if RT6_DEBUG >= 2
-			WARN_ON(1);
+			(void)WARN_ON(1);
 #endif
 		}
 	}
@@ -1349,7 +1349,7 @@ static int fib6_clean_node(struct fib6_walker_t *w)
 			}
 			return 0;
 		}
-		WARN_ON(res != 0);
+		(void)WARN_ON(res != 0);
 	}
 	w->leaf = rt;
 	return 0;
diff --git a/net/ipv6/ip6_flowlabel.c b/net/ipv6/ip6_flowlabel.c
index f3caf1b..4095f07 100644
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -350,7 +350,7 @@ fl_create(struct net *net, struct in6_flowlabel_req *freq, char __user *optval,
 		if (fl->opt == NULL)
 			goto done;
 
-		memset(fl->opt, 0, sizeof(*fl->opt));
+		(void)memset(fl->opt, 0, sizeof(*fl->opt));
 		fl->opt->tot_len = sizeof(*fl->opt) + olen;
 		err = -EFAULT;
 		if (copy_from_user(fl->opt+1, optval+CMSG_ALIGN(sizeof(*freq)), olen))
@@ -358,7 +358,7 @@ fl_create(struct net *net, struct in6_flowlabel_req *freq, char __user *optval,
 
 		msg.msg_controllen = olen;
 		msg.msg_control = (void*)(fl->opt+1);
-		memset(&flowi6, 0, sizeof(flowi6));
+		(void)memset(&flowi6, 0, sizeof(flowi6));
 
 		err = datagram_send_ctl(net, &msg, &flowi6, fl->opt, &junk,
 					&junk, &junk);
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 79d6e82..9897987 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -90,7 +90,7 @@ static int ip6_dev_loopback_xmit(struct sk_buff *newskb)
 	__skb_pull(newskb, skb_network_offset(newskb));
 	newskb->pkt_type = PACKET_LOOPBACK;
 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
-	WARN_ON(!skb_dst(newskb));
+	(void)WARN_ON(!skb_dst(newskb));
 
 	netif_rx_ni(newskb);
 	return 0;
@@ -996,7 +996,7 @@ static int ip6_dst_lookup_tail(struct sock *sk,
 			 */
 			dst_release(*dst);
 			memcpy(&fl_gw6, fl6, sizeof(struct flowi6));
-			memset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));
+			(void)memset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));
 			*dst = ip6_route_output(net, sk, &fl_gw6);
 			if ((err = (*dst)->error))
 				goto out_err_release;
@@ -1535,7 +1535,7 @@ static void ip6_cork_release(struct inet_sock *inet, struct ipv6_pinfo *np)
 		inet->cork.base.dst = NULL;
 		inet->cork.base.flags &= ~IPCORK_ALLFRAG;
 	}
-	memset(&inet->cork.fl, 0, sizeof(inet->cork.fl));
+	(void)memset(&inet->cork.fl, 0, sizeof(inet->cork.fl));
 }
 
 int ip6_push_pending_frames(struct sock *sk)
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index 36c2842..1179d0e 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -755,7 +755,7 @@ static int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,
 		skb_reset_network_header(skb);
 		skb->protocol = htons(protocol);
 		skb->pkt_type = PACKET_HOST;
-		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
+		(void)memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
 
 		tstats = this_cpu_ptr(t->dev->tstats);
 		tstats->rx_packets++;
@@ -797,7 +797,7 @@ struct ipv6_tel_txoption {
 
 static void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)
 {
-	memset(opt, 0, sizeof(struct ipv6_tel_txoption));
+	(void)memset(opt, 0, sizeof(struct ipv6_tel_txoption));
 
 	opt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;
 	opt->dst_opt[3] = 1;
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index 147ede38..942bea8 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -447,7 +447,7 @@ sticky_done:
 		struct flowi6 fl6;
 		int junk;
 
-		memset(&fl6, 0, sizeof(fl6));
+		(void)memset(&fl6, 0, sizeof(fl6));
 		fl6.flowi6_oif = sk->sk_bound_dev_if;
 		fl6.flowi6_mark = sk->sk_mark;
 
@@ -466,7 +466,7 @@ sticky_done:
 		if (opt == NULL)
 			break;
 
-		memset(opt, 0, sizeof(*opt));
+		(void)memset(opt, 0, sizeof(*opt));
 		opt->tot_len = sizeof(*opt) + optlen;
 		retv = -EFAULT;
 		if (copy_from_user(opt+1, optval, optlen))
@@ -1104,7 +1104,7 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
 			return -EINVAL;
 
 		len = sizeof(mtuinfo);
-		memset(&mtuinfo, 0, sizeof(mtuinfo));
+		(void)memset(&mtuinfo, 0, sizeof(mtuinfo));
 
 		rcu_read_lock();
 		dst = __sk_dst_get(sk);
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index ee7839f..ce96086 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -594,7 +594,7 @@ int ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,
 		struct sockaddr_storage ss;
 
 		psin6 = (struct sockaddr_in6 *)&ss;
-		memset(&ss, 0, sizeof(ss));
+		(void)memset(&ss, 0, sizeof(ss));
 		psin6->sin6_family = AF_INET6;
 		psin6->sin6_addr = psl->sl_addr[i];
 		if (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))
@@ -1770,7 +1770,7 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 	memcpy(skb_put(skb, sizeof(ra)), ra, sizeof(ra));
 
 	hdr = (struct mld_msg *) skb_put(skb, sizeof(struct mld_msg));
-	memset(hdr, 0, sizeof(struct mld_msg));
+	(void)memset(hdr, 0, sizeof(struct mld_msg));
 	hdr->mld_type = type;
 	ipv6_addr_copy(&hdr->mld_mca, addr);
 
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 7596f07..e9c048b 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -208,7 +208,7 @@ static u8 *ndisc_fill_addr_option(u8 *opt, int type, void *data, int data_len,
 	opt[0] = type;
 	opt[1] = space>>3;
 
-	memset(opt + 2, 0, pad);
+	(void)memset(opt + 2, 0, pad);
 	opt   += pad;
 	space -= pad;
 
@@ -216,7 +216,7 @@ static u8 *ndisc_fill_addr_option(u8 *opt, int type, void *data, int data_len,
 	data_len += 2;
 	opt += data_len;
 	if ((space -= data_len) > 0)
-		memset(opt, 0, space);
+		(void)memset(opt, 0, space);
 	return opt + space;
 }
 
@@ -256,7 +256,7 @@ static struct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,
 
 	if (!nd_opt || opt_len < 0 || !ndopts)
 		return NULL;
-	memset(ndopts, 0, sizeof(*ndopts));
+	(void)memset(ndopts, 0, sizeof(*ndopts));
 	while (opt_len) {
 		int l;
 		if (opt_len < sizeof(struct nd_opt_hdr))
@@ -1619,7 +1619,7 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
 	skb_put(buff, len);
 	icmph = icmp6_hdr(buff);
 
-	memset(icmph, 0, sizeof(struct icmp6hdr));
+	(void)memset(icmph, 0, sizeof(struct icmp6hdr));
 	icmph->icmp6_type = NDISC_REDIRECT;
 
 	/*
@@ -1645,7 +1645,7 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
 	 *	build redirect option and copy skb over to the new packet.
 	 */
 
-	memset(opt, 0, 8);
+	(void)memset(opt, 0, 8);
 	*(opt++) = ND_OPT_REDIRECT_HDR;
 	*(opt++) = (rd_len >> 3);
 	opt += 6;
@@ -1705,7 +1705,7 @@ int ndisc_rcv(struct sk_buff *skb)
 		return 0;
 	}
 
-	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
+	(void)memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
 	switch (msg->icmph.icmp6_type) {
 	case NDISC_NEIGHBOUR_SOLICITATION:
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 0857272..0160ed9 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -345,8 +345,8 @@ nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)
 
 	fq_kill(fq);
 
-	WARN_ON(head == NULL);
-	WARN_ON(NFCT_FRAG6_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(NFCT_FRAG6_CB(head)->offset != 0);
 
 	/* Unfragmented part is taken from the first segment. */
 	payload_len = ((head->data - skb_network_header(head)) -
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index cc7313b..038d120 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -755,7 +755,7 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 	/*
 	 *	Get and verify the address.
 	 */
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	fl6.flowi6_mark = sk->sk_mark;
 
@@ -814,7 +814,7 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 
 	if (msg->msg_controllen) {
 		opt = &opt_space;
-		memset(opt, 0, sizeof(struct ipv6_txoptions));
+		(void)memset(opt, 0, sizeof(struct ipv6_txoptions));
 		opt->tot_len = sizeof(struct ipv6_txoptions);
 
 		err = datagram_send_ctl(sock_net(sk), msg, &fl6, opt, &hlimit,
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index 7b954e2..e27a56b 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -437,8 +437,8 @@ static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,
 		fq->q.fragments = head;
 	}
 
-	WARN_ON(head == NULL);
-	WARN_ON(FRAG6_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(FRAG6_CB(head)->offset != 0);
 
 	/* Unfragmented part is taken from the first segment. */
 	payload_len = ((head->data - skb_network_header(head)) -
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 0ef1f08..1f50772 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -233,7 +233,7 @@ static inline struct rt6_info *ip6_dst_alloc(struct dst_ops *ops,
 {
 	struct rt6_info *rt = dst_alloc(ops, dev, 0, 0, flags);
 
-	memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
+	(void)memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
 
 	return rt;
 }
@@ -892,7 +892,7 @@ struct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_ori
 
 	rt = dst_alloc(&ip6_dst_blackhole_ops, ort->dst.dev, 1, 0, 0);
 	if (rt) {
-		memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
+		(void)memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
 
 		new = &rt->dst;
 
@@ -1889,7 +1889,7 @@ static void rtmsg_to_fib6_config(struct net *net,
 				 struct in6_rtmsg *rtmsg,
 				 struct fib6_config *cfg)
 {
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	cfg->fc_table = RT6_TABLE_MAIN;
 	cfg->fc_ifindex = rtmsg->rtmsg_ifindex;
@@ -2200,7 +2200,7 @@ static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	err = -EINVAL;
 	rtm = nlmsg_data(nlh);
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	cfg->fc_table = rtm->rtm_table;
 	cfg->fc_dst_len = rtm->rtm_dst_len;
@@ -2458,7 +2458,7 @@ static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void
 		goto errout;
 
 	err = -EINVAL;
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (tb[RTA_SRC]) {
 		if (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))
@@ -2535,7 +2535,7 @@ void inet6_rt_notify(int event, struct rt6_info *rt, struct nl_info *info)
 				event, info->pid, seq, 0, 0, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 1cca576..714852e 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -803,7 +803,7 @@ static netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,
 	skb->transport_header = skb->network_header;
 	skb_push(skb, sizeof(struct iphdr));
 	skb_reset_network_header(skb);
-	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
+	(void)memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
 	IPCB(skb)->flags = 0;
 	skb_dst_drop(skb);
 	skb_dst_set(skb, &rt->dst);
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 7c43e86..72add1a 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -143,7 +143,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 	if (usin->sin6_family != AF_INET6)
 		return -EAFNOSUPPORT;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (np->sndflow) {
 		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
@@ -396,7 +396,7 @@ static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 			   to handle rthdr case. Ignore this complexity
 			   for now.
 			 */
-			memset(&fl6, 0, sizeof(fl6));
+			(void)memset(&fl6, 0, sizeof(fl6));
 			fl6.flowi6_proto = IPPROTO_TCP;
 			ipv6_addr_copy(&fl6.daddr, &np->daddr);
 			ipv6_addr_copy(&fl6.saddr, &np->saddr);
@@ -440,7 +440,7 @@ static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		/* ICMPs are not backlogged, hence we cannot get
 		 * an established socket here.
 		 */
-		WARN_ON(req->sk != NULL);
+		(void)WARN_ON(req->sk != NULL);
 
 		if (seq != tcp_rsk(req)->snt_isn) {
 			NET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -487,7 +487,7 @@ static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,
 	struct dst_entry *dst;
 	int err;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_TCP;
 	ipv6_addr_copy(&fl6.daddr, &treq->rmt_addr);
 	ipv6_addr_copy(&fl6.saddr, &treq->loc_addr);
@@ -1019,7 +1019,7 @@ static void tcp_v6_send_response(struct sk_buff *skb, u32 seq, u32 ack, u32 win,
 	skb_reset_transport_header(buff);
 
 	/* Swap the send and the receive. */
-	memset(t1, 0, sizeof(*t1));
+	(void)memset(t1, 0, sizeof(*t1));
 	t1->dest = th->source;
 	t1->source = th->dest;
 	t1->doff = tot_len / 4;
@@ -1048,7 +1048,7 @@ static void tcp_v6_send_response(struct sk_buff *skb, u32 seq, u32 ack, u32 win,
 	}
 #endif
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	ipv6_addr_copy(&fl6.daddr, &ipv6_hdr(skb)->saddr);
 	ipv6_addr_copy(&fl6.saddr, &ipv6_hdr(skb)->daddr);
 
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 0d920c5..ceae3e0 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1036,7 +1036,7 @@ do_udp_sendmsg:
 	}
 	ulen += sizeof(struct udphdr);
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (sin6) {
 		if (sin6->sin6_port == 0)
@@ -1087,7 +1087,7 @@ do_udp_sendmsg:
 
 	if (msg->msg_controllen) {
 		opt = &opt_space;
-		memset(opt, 0, sizeof(struct ipv6_txoptions));
+		(void)memset(opt, 0, sizeof(struct ipv6_txoptions));
 		opt->tot_len = sizeof(*opt);
 
 		err = datagram_send_ctl(sock_net(sk), msg, &fl6, opt, &hlimit,
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index 49a91c5f..e43b24f 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -67,7 +67,7 @@ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err)
 		return err;
 
-	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+	(void)memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
 #ifdef CONFIG_NETFILTER
 	IP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;
 #endif
diff --git a/net/ipv6/xfrm6_state.c b/net/ipv6/xfrm6_state.c
index 248f0b2..7699b8b 100644
--- a/net/ipv6/xfrm6_state.c
+++ b/net/ipv6/xfrm6_state.c
@@ -62,7 +62,7 @@ __xfrm6_sort(void **dst, void **src, int n, int (*cmp)(void *p), int maxclass)
 	int class[XFRM_MAX_DEPTH];
 	int count[maxclass];
 
-	memset(count, 0, sizeof(count));
+	(void)memset(count, 0, sizeof(count));
 
 	for (i = 0; i < n; i++) {
 		int c;
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index f7af8b8..3bfde88 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -114,7 +114,7 @@ nf_ct_get_tuple(const struct sk_buff *skb,
 		const struct nf_conntrack_l3proto *l3proto,
 		const struct nf_conntrack_l4proto *l4proto)
 {
-	memset(tuple, 0, sizeof(*tuple));
+	(void)memset(tuple, 0, sizeof(*tuple));
 
 	tuple->src.l3num = l3num;
 	if (l3proto->pkt_to_tuple(skb, nhoff, tuple) == 0)
@@ -161,7 +161,7 @@ nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
 		   const struct nf_conntrack_l3proto *l3proto,
 		   const struct nf_conntrack_l4proto *l4proto)
 {
-	memset(inverse, 0, sizeof(*inverse));
+	(void)memset(inverse, 0, sizeof(*inverse));
 
 	inverse->src.l3num = orig->src.l3num;
 	if (l3proto->invert_tuple(inverse, orig) == 0)
@@ -623,7 +623,7 @@ void init_nf_conntrack_hash_rnd(void)
 	do {
 		get_random_bytes(&rand, sizeof(rand));
 	} while (!rand);
-	cmpxchg(&nf_conntrack_hash_rnd, 0, rand);
+	(void)cmpxchg(&nf_conntrack_hash_rnd, 0, rand);
 }
 
 static struct nf_conn *
@@ -669,7 +669,7 @@ __nf_conntrack_alloc(struct net *net, u16 zone,
 	 * Let ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.next
 	 * and ct->tuplehash[IP_CT_DIR_REPLY].hnnode.next unchanged.
 	 */
-	memset(&ct->tuplehash[IP_CT_DIR_MAX], 0,
+	(void)memset(&ct->tuplehash[IP_CT_DIR_MAX], 0,
 	       offsetof(struct nf_conn, proto) -
 	       offsetof(struct nf_conn, tuplehash[IP_CT_DIR_MAX]));
 	spin_lock_init(&ct->lock);
diff --git a/net/netfilter/nf_conntrack_h323_main.c b/net/netfilter/nf_conntrack_h323_main.c
index f03c2d4..9941123 100644
--- a/net/netfilter/nf_conntrack_h323_main.c
+++ b/net/netfilter/nf_conntrack_h323_main.c
@@ -242,7 +242,7 @@ static int get_h245_addr(struct nf_conn *ct, const unsigned char *data,
 	}
 
 	memcpy(addr, p, len);
-	memset((void *)addr + len, 0, sizeof(*addr) - len);
+	(void)memset((void *)addr + len, 0, sizeof(*addr) - len);
 	memcpy(port, p + len, sizeof(__be16));
 
 	return 1;
@@ -651,7 +651,7 @@ int get_h225_addr(struct nf_conn *ct, unsigned char *data,
 	}
 
 	memcpy(addr, p, len);
-	memset((void *)addr + len, 0, sizeof(*addr) - len);
+	(void)memset((void *)addr + len, 0, sizeof(*addr) - len);
 	memcpy(port, p + len, sizeof(__be16));
 
 	return 1;
@@ -725,10 +725,10 @@ static int callforward_do_filter(const union nf_inet_addr *src,
 		struct flowi4 fl1, fl2;
 		struct rtable *rt1, *rt2;
 
-		memset(&fl1, 0, sizeof(fl1));
+		(void)memset(&fl1, 0, sizeof(fl1));
 		fl1.daddr = src->ip;
 
-		memset(&fl2, 0, sizeof(fl2));
+		(void)memset(&fl2, 0, sizeof(fl2));
 		fl2.daddr = dst->ip;
 		if (!afinfo->route(&init_net, (struct dst_entry **)&rt1,
 				   flowi4_to_flowi(&fl1), false)) {
@@ -1217,7 +1217,7 @@ static struct nf_conntrack_expect *find_expect(struct nf_conn *ct,
 	struct nf_conntrack_expect *exp;
 	struct nf_conntrack_tuple tuple;
 
-	memset(&tuple.src.u3, 0, sizeof(tuple.src.u3));
+	(void)memset(&tuple.src.u3, 0, sizeof(tuple.src.u3));
 	tuple.src.u.tcp.port = 0;
 	memcpy(&tuple.dst.u3, addr, sizeof(tuple.dst.u3));
 	tuple.dst.u.tcp.port = port;
diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 482e90c..11b55b1 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -721,7 +721,7 @@ restart:
 
 				acct = nf_conn_acct_find(ct);
 				if (acct)
-					memset(acct, 0, sizeof(struct nf_conn_counter[IP_CT_DIR_MAX]));
+					(void)memset(acct, 0, sizeof(struct nf_conn_counter[IP_CT_DIR_MAX]));
 			}
 		}
 		if (cb->args[1]) {
@@ -809,7 +809,7 @@ ctnetlink_parse_tuple(const struct nlattr * const cda[],
 	struct nlattr *tb[CTA_TUPLE_MAX+1];
 	int err;
 
-	memset(tuple, 0, sizeof(*tuple));
+	(void)memset(tuple, 0, sizeof(*tuple));
 
 	nla_parse_nested(tb, CTA_TUPLE_MAX, cda[type], tuple_nla_policy);
 
@@ -1157,7 +1157,7 @@ ctnetlink_change_helper(struct nf_conn *ct, const struct nlattr * const cda[])
 		if (help->helper)
 			return -EBUSY;
 		/* need to zero data of old helper */
-		memset(&help->help, 0, sizeof(help->help));
+		(void)memset(&help->help, 0, sizeof(help->help));
 	} else {
 		/* we cannot set a helper for an existing conntrack */
 		return -EOPNOTSUPP;
@@ -1421,7 +1421,7 @@ ctnetlink_create_conntrack(struct net *net, u16 zone,
 	}
 #endif
 
-	memset(&ct->proto, 0, sizeof(ct->proto));
+	(void)memset(&ct->proto, 0, sizeof(ct->proto));
 	if (cda[CTA_PROTOINFO]) {
 		err = ctnetlink_change_protoinfo(ct, cda);
 		if (err < 0)
@@ -1605,7 +1605,7 @@ ctnetlink_exp_dump_mask(struct sk_buff *skb,
 	struct nf_conntrack_tuple m;
 	struct nlattr *nest_parms;
 
-	memset(&m, 0xFF, sizeof(m));
+	(void)memset(&m, 0xFF, sizeof(m));
 	memcpy(&m.src.u3, &mask->src.u3, sizeof(m.src.u3));
 	m.src.u.all = mask->src.u.all;
 	m.dst.protonum = tuple->dst.protonum;
diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index b0869fe..20b4890 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -781,7 +781,7 @@ static int xt_jumpstack_alloc(struct xt_table_info *i)
 		i->jumpstack = kmalloc(size, GFP_KERNEL);
 	if (i->jumpstack == NULL)
 		return -ENOMEM;
-	memset(i->jumpstack, 0, size);
+	(void)memset(i->jumpstack, 0, size);
 
 	i->stacksize *= xt_jumpstack_multiplier;
 	size = sizeof(void *) * i->stacksize;
diff --git a/net/netfilter/xt_hashlimit.c b/net/netfilter/xt_hashlimit.c
index 9228ee0..5eb760f 100644
--- a/net/netfilter/xt_hashlimit.c
+++ b/net/netfilter/xt_hashlimit.c
@@ -450,7 +450,7 @@ hashlimit_init_dst(const struct xt_hashlimit_htable *hinfo,
 	u8 nexthdr;
 	int poff;
 
-	memset(dst, 0, sizeof(*dst));
+	(void)memset(dst, 0, sizeof(*dst));
 
 	switch (hinfo->family) {
 	case NFPROTO_IPV4:
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 6ef64ad..4412542 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -1326,7 +1326,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 
 	if (NULL == siocb->scm) {
 		siocb->scm = &scm;
-		memset(&scm, 0, sizeof(scm));
+		(void)memset(&scm, 0, sizeof(scm));
 	}
 	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index c0c3cda..86769d3 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -333,8 +333,8 @@ static void packet_sock_destruct(struct sock *sk)
 {
 	skb_queue_purge(&sk->sk_error_queue);
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
 
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		pr_err("Attempt to release alive packet socket: %p\n", sk);
@@ -1347,7 +1347,7 @@ static int packet_release(struct socket *sock)
 
 	packet_flush_mclist(sk);
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 
 	if (po->rx_ring.pg_vec)
 		packet_set_ring(sk, &req, 1, 0);
@@ -1768,7 +1768,7 @@ static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,
 	if (dev)
 		strncpy(uaddr->sa_data, dev->name, 14);
 	else
-		memset(uaddr->sa_data, 0, 14);
+		(void)memset(uaddr->sa_data, 0, 14);
 	rcu_read_unlock();
 	*uaddr_len = sizeof(*uaddr);
 
@@ -1964,7 +1964,7 @@ packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv
 	{
 		struct packet_mreq_max mreq;
 		int len = optlen;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		if (len < sizeof(struct packet_mreq))
 			return -EINVAL;
 		if (len > sizeof(mreq))
@@ -2132,7 +2132,7 @@ static int packet_getsockopt(struct socket *sock, int level, int optname,
 			len = sizeof(struct tpacket_stats);
 		spin_lock_bh(&sk->sk_receive_queue.lock);
 		st = po->stats;
-		memset(&po->stats, 0, sizeof(st));
+		(void)memset(&po->stats, 0, sizeof(st));
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
 		st.tp_packets += st.tp_drops;
 
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index a606025..b192b2e 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -46,7 +46,7 @@ void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo)
 			return;
 		}
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 EXPORT_SYMBOL(tcf_hash_destroy);
 
@@ -157,7 +157,7 @@ int tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,
 	} else if (type == RTM_GETACTION) {
 		return tcf_dump_walker(skb, cb, a, hinfo);
 	} else {
-		WARN(1, "tcf_generic_walker: unknown action %d\n", type);
+		(void)WARN(1, "tcf_generic_walker: unknown action %d\n", type);
 		return -EINVAL;
 	}
 }
@@ -409,7 +409,7 @@ void tcf_action_destroy(struct tc_action *act, int bind)
 			kfree(a);
 		} else {
 			/*FIXME: Remove later - catch insertion bugs*/
-			WARN(1, "tcf_action_destroy: BUG? destroying NULL ops\n");
+			(void)WARN(1, "tcf_action_destroy: BUG? destroying NULL ops\n");
 			act = act->next;
 			kfree(a);
 		}
@@ -1070,11 +1070,11 @@ tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
 	if (a_o == NULL)
 		return 0;
 
-	memset(&a, 0, sizeof(struct tc_action));
+	(void)memset(&a, 0, sizeof(struct tc_action));
 	a.ops = a_o;
 
 	if (a_o->walk == NULL) {
-		WARN(1, "tc_dump_action: %s !capable of dumping table\n",
+		(void)WARN(1, "tc_dump_action: %s !capable of dumping table\n",
 		     a_o->kind);
 		goto nla_put_failure;
 	}
diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c
index 8ec0139..a7034e2 100644
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@ -351,7 +351,7 @@ static u32 flow_key_get(struct sk_buff *skb, int key)
 	case FLOW_KEY_RXHASH:
 		return flow_get_rxhash(skb);
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 }
diff --git a/net/sched/em_meta.c b/net/sched/em_meta.c
index 49130e8..55e685a 100644
--- a/net/sched/em_meta.c
+++ b/net/sched/em_meta.c
@@ -834,7 +834,7 @@ static int em_meta_dump(struct sk_buff *skb, struct tcf_ematch *em)
 	struct tcf_meta_hdr hdr;
 	struct meta_type_ops *ops;
 
-	memset(&hdr, 0, sizeof(hdr));
+	(void)memset(&hdr, 0, sizeof(hdr));
 	memcpy(&hdr.left, &meta->lvalue.hdr, sizeof(hdr.left));
 	memcpy(&hdr.right, &meta->rvalue.hdr, sizeof(hdr.right));
 
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index 6b86276..8644f20 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -648,7 +648,7 @@ void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)
 
 		sch = qdisc_lookup(qdisc_dev(sch), TC_H_MAJ(parentid));
 		if (sch == NULL) {
-			WARN_ON(parentid != TC_H_ROOT);
+			(void)WARN_ON(parentid != TC_H_ROOT);
 			return;
 		}
 		cops = sch->ops->cl_ops;
@@ -1572,7 +1572,7 @@ static int tc_dump_tclass_qdisc(struct Qdisc *q, struct sk_buff *skb,
 		return 0;
 	}
 	if (*t_p > s_t)
-		memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
+		(void)memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
 	arg.w.fn = qdisc_class_dump;
 	arg.skb = skb;
 	arg.cb = cb;
diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c
index 1dcfb52..0959ba4 100644
--- a/net/sched/sch_tbf.c
+++ b/net/sched/sch_tbf.c
@@ -355,7 +355,7 @@ static int tbf_dump(struct Qdisc *sch, struct sk_buff *skb)
 	if (q->P_tab)
 		opt.peakrate = q->P_tab->rate;
 	else
-		memset(&opt.peakrate, 0, sizeof(opt.peakrate));
+		(void)memset(&opt.peakrate, 0, sizeof(opt.peakrate));
 	opt.mtu = q->mtu;
 	opt.buffer = q->buffer;
 	NLA_PUT(skb, TCA_TBF_PARMS, sizeof(opt), &opt);
diff --git a/net/sunrpc/addr.c b/net/sunrpc/addr.c
index 4195233..6151186 100644
--- a/net/sunrpc/addr.c
+++ b/net/sunrpc/addr.c
@@ -207,7 +207,7 @@ static size_t rpc_pton6(const char *buf, const size_t buflen,
 	    salen < sizeof(struct sockaddr_in6))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in6));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in6));
 
 	if (in6_pton(buf, buflen, addr, IPV6_SCOPE_DELIMITER, &delim) == 0)
 		return 0;
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index 5daf6cc..6bb06db 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -1394,7 +1394,7 @@ gss_wrap_req_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,
 		iov = snd_buf->head;
 	p = iov->iov_base + iov->iov_len;
 	pad = 3 - ((snd_buf->len - offset - 1) & 3);
-	memset(p, 0, pad);
+	(void)memset(p, 0, pad);
 	iov->iov_len += pad;
 	snd_buf->len += pad;
 
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 17cd0c0..92dec79 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -87,7 +87,7 @@ int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 		wdev = NULL;
 
 	if (wdev) {
-		ASSERT_WDEV_LOCK(wdev);
+		(void)ASSERT_WDEV_LOCK(wdev);
 
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 880dbe2..5441e00 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -256,7 +256,7 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 			wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
 			err = dev_change_net_namespace(wdev->netdev, net,
 							"wlan%d");
-			WARN_ON(err);
+			(void)WARN_ON(err);
 			wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
 		}
 
@@ -266,7 +266,7 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 	wiphy_net_set(&rdev->wiphy, net);
 
 	err = device_rename(&rdev->wiphy.dev, dev_name(&rdev->wiphy.dev));
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 	return 0;
 }
@@ -330,14 +330,14 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
 	struct cfg80211_registered_device *rdev;
 	int alloc_size;
 
-	WARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));
-	WARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));
-	WARN_ON(ops->connect && !ops->disconnect);
-	WARN_ON(ops->join_ibss && !ops->leave_ibss);
-	WARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);
-	WARN_ON(ops->add_station && !ops->del_station);
-	WARN_ON(ops->add_mpath && !ops->del_mpath);
-	WARN_ON(ops->join_mesh && !ops->leave_mesh);
+	(void)WARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));
+	(void)WARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));
+	(void)WARN_ON(ops->connect && !ops->disconnect);
+	(void)WARN_ON(ops->join_ibss && !ops->leave_ibss);
+	(void)WARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);
+	(void)WARN_ON(ops->add_station && !ops->del_station);
+	(void)WARN_ON(ops->add_mpath && !ops->del_mpath);
+	(void)WARN_ON(ops->join_mesh && !ops->leave_mesh);
 
 	alloc_size = sizeof(*rdev) + sizeof_priv;
 
@@ -501,7 +501,7 @@ int wiphy_register(struct wiphy *wiphy)
 		memcpy(wiphy->perm_addr, wiphy->addresses[0].addr, ETH_ALEN);
 
 	/* sanity check ifmodes */
-	WARN_ON(!ifmodes);
+	(void)WARN_ON(!ifmodes);
 	ifmodes &= ((1 << NUM_NL80211_IFTYPES) - 1) & ~1;
 	if (WARN_ON(ifmodes != wiphy->interface_modes))
 		wiphy->interface_modes = ifmodes;
@@ -555,7 +555,7 @@ int wiphy_register(struct wiphy *wiphy)
 	}
 
 	if (!have_band) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EINVAL;
 	}
 
@@ -776,7 +776,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block * nb,
 
 	rdev = wiphy_to_dev(wdev->wiphy);
 
-	WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
+	(void)WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
 
 	switch (state) {
 	case NETDEV_POST_INIT:
@@ -986,7 +986,7 @@ static void __net_exit cfg80211_pernet_exit(struct net *net)
 	mutex_lock(&cfg80211_mutex);
 	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
 		if (net_eq(wiphy_net(&rdev->wiphy), net))
-			WARN_ON(cfg80211_switch_netns(rdev, &init_net));
+			(void)WARN_ON(cfg80211_switch_netns(rdev, &init_net));
 	}
 	mutex_unlock(&cfg80211_mutex);
 	rtnl_unlock();
diff --git a/net/wireless/core.h b/net/wireless/core.h
index a570ff9..41f9038 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -115,7 +115,7 @@ extern int cfg80211_rdev_list_generation;
 
 static inline void assert_cfg80211_lock(void)
 {
-	lockdep_assert_held(&cfg80211_mutex);
+	(void)lockdep_assert_held(&cfg80211_mutex);
 }
 
 /*
@@ -155,7 +155,7 @@ static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 {
 	int r = atomic_dec_return(&bss->hold);
-	WARN_ON(r < 0);
+	(void)WARN_ON(r < 0);
 }
 
 
diff --git a/net/wireless/ibss.c b/net/wireless/ibss.c
index f33fbb7..92f03bc 100644
--- a/net/wireless/ibss.c
+++ b/net/wireless/ibss.c
@@ -59,7 +59,7 @@ void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp)
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(!wdev->ssid_len);
+	(void)CFG80211_DEV_WARN_ON(!wdev->ssid_len);
 
 	ev = kzalloc(sizeof(*ev), gfp);
 	if (!ev)
@@ -83,7 +83,7 @@ int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->ssid_len)
 		return -EALREADY;
@@ -149,7 +149,7 @@ static void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	kfree(wdev->connect_keys);
 	wdev->connect_keys = NULL;
@@ -190,7 +190,7 @@ int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->ssid_len)
 		return -ENOLINK;
diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 5c11608..fbac6b1 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -69,7 +69,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
 		return -EOPNOTSUPP;
@@ -130,7 +130,7 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
 		return -EOPNOTSUPP;
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index 493b939..ff83705 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -151,7 +151,7 @@ void __cfg80211_send_deauth(struct net_device *dev,
 	int i;
 	bool found = false, was_current = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->current_bss &&
 	    memcmp(wdev->current_bss->pub.bssid, bssid, ETH_ALEN) == 0) {
@@ -223,7 +223,7 @@ void __cfg80211_send_disassoc(struct net_device *dev,
 	bool from_ap;
 	bool done = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	nl80211_send_disassoc(rdev, dev, buf, len, GFP_KERNEL);
 
@@ -241,9 +241,9 @@ void __cfg80211_send_disassoc(struct net_device *dev,
 			cfg80211_sme_disassoc(dev, i);
 			break;
 		}
-		WARN_ON(!done);
+		(void)WARN_ON(!done);
 	} else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 
 	reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
@@ -290,7 +290,7 @@ static void __cfg80211_auth_remove(struct wireless_dev *wdev, const u8 *addr)
 	int i;
 	bool done = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	for (i = 0; addr && i < MAX_AUTH_BSSES; i++) {
 		if (wdev->authtry_bsses[i] &&
@@ -304,7 +304,7 @@ static void __cfg80211_auth_remove(struct wireless_dev *wdev, const u8 *addr)
 		}
 	}
 
-	WARN_ON(!done);
+	(void)WARN_ON(!done);
 }
 
 void __cfg80211_auth_canceled(struct net_device *dev, const u8 *addr)
@@ -361,7 +361,7 @@ void cfg80211_send_assoc_timeout(struct net_device *dev, const u8 *addr)
 		}
 	}
 
-	WARN_ON(!done);
+	(void)WARN_ON(!done);
 
 	wdev_unlock(wdev);
 }
@@ -409,7 +409,7 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 	struct cfg80211_internal_bss *bss;
 	int i, err, slot = -1, nfree = 0;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (auth_type == NL80211_AUTHTYPE_SHARED_KEY)
 		if (!key || !key_len || key_idx < 0 || key_idx > 4)
@@ -430,7 +430,7 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 			return -EALREADY;
 	}
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 
 	req.local_state_change = local_state_change;
 	req.ie = ie;
@@ -513,9 +513,9 @@ int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 	int i, err, slot = -1;
 	bool was_connected = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 
 	if (wdev->current_bss && prev_bssid &&
 	    memcmp(wdev->current_bss->pub.bssid, prev_bssid, ETH_ALEN) == 0) {
@@ -594,9 +594,9 @@ int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 	struct cfg80211_deauth_request req;
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 	req.reason_code = reason;
 	req.local_state_change = local_state_change;
 	req.ie = ie;
@@ -647,7 +647,7 @@ static int __cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct cfg80211_disassoc_request req;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state != CFG80211_SME_CONNECTED)
 		return -ENOTCONN;
@@ -655,7 +655,7 @@ static int __cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 	if (WARN_ON(!wdev->current_bss))
 		return -ENOTCONN;
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 	req.reason_code = reason;
 	req.local_state_change = local_state_change;
 	req.ie = ie;
@@ -691,12 +691,12 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
 	struct cfg80211_deauth_request req;
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!rdev->ops->deauth)
 		return;
 
-	memset(&req, 0, sizeof(req));
+	(void)memset(&req, 0, sizeof(req));
 	req.reason_code = WLAN_REASON_DEAUTH_LEAVING;
 	req.ie = NULL;
 	req.ie_len = 0;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 0fc46b3..61b3e5b 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -460,7 +460,7 @@ static int nl80211_parse_key(struct genl_info *info, struct key_parse *k)
 {
 	int err;
 
-	memset(k, 0, sizeof(*k));
+	(void)memset(k, 0, sizeof(*k));
 	k->idx = -1;
 	k->type = -1;
 
@@ -513,7 +513,7 @@ nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,
 	result->defmgmt = -1;
 
 	nla_for_each_nested(key, keys, rem) {
-		memset(&parse, 0, sizeof(parse));
+		(void)memset(&parse, 0, sizeof(parse));
 		parse.idx = -1;
 
 		err = nl80211_parse_key_new(key, &parse);
@@ -551,7 +551,7 @@ nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,
 
 static int nl80211_key_allowed(struct wireless_dev *wdev)
 {
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	switch (wdev->iftype) {
 	case NL80211_IFTYPE_AP:
@@ -1528,7 +1528,7 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	u32 _flags, *flags = NULL;
 	bool change = false;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	otype = ntype = dev->ieee80211_ptr->iftype;
 
@@ -1600,7 +1600,7 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 	enum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;
 	u32 flags;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	if (!info->attrs[NL80211_ATTR_IFNAME])
 		return -EINVAL;
@@ -1978,7 +1978,7 @@ static int nl80211_addset_beacon(struct sk_buff *skb, struct genl_info *info)
 	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
 		return -EOPNOTSUPP;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	switch (info->genlhdr->cmd) {
 	case NL80211_CMD_NEW_BEACON:
@@ -2046,7 +2046,7 @@ static int nl80211_addset_beacon(struct sk_buff *skb, struct genl_info *info)
 		call = rdev->ops->set_beacon;
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EOPNOTSUPP;
 	}
 
@@ -2316,7 +2316,7 @@ static int nl80211_dump_station(struct sk_buff *skb,
 	}
 
 	while (1) {
-		memset(&sinfo, 0, sizeof(sinfo));
+		(void)memset(&sinfo, 0, sizeof(sinfo));
 		err = dev->ops->dump_station(&dev->wiphy, netdev, sta_idx,
 					     mac_addr, &sinfo);
 		if (err == -ENOENT)
@@ -2353,7 +2353,7 @@ static int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)
 	u8 *mac_addr = NULL;
 	int err;
 
-	memset(&sinfo, 0, sizeof(sinfo));
+	(void)memset(&sinfo, 0, sizeof(sinfo));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -2413,7 +2413,7 @@ static int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)
 	struct station_parameters params;
 	u8 *mac_addr = NULL;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	params.listen_interval = -1;
 	params.plink_state = -1;
@@ -2526,7 +2526,7 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
 	struct station_parameters params;
 	u8 *mac_addr = NULL;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -2723,7 +2723,7 @@ static int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)
 	u8 *dst = NULL;
 	u8 next_hop[ETH_ALEN];
 
-	memset(&pinfo, 0, sizeof(pinfo));
+	(void)memset(&pinfo, 0, sizeof(pinfo));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -2824,7 +2824,7 @@ static int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)
 	struct net_device *dev = info->user_ptr[1];
 	struct bss_parameters params;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 	/* default to not changing parameters */
 	params.use_cts_prot = -1;
 	params.use_short_preamble = -1;
@@ -3723,7 +3723,7 @@ static int nl80211_send_bss(struct sk_buff *msg, u32 pid, u32 seq, int flags,
 	struct nlattr *bss;
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	hdr = nl80211hdr_put(msg, pid, seq, flags,
 			     NL80211_CMD_NEW_SCAN_RESULTS);
@@ -4062,7 +4062,7 @@ static int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,
 				   struct cfg80211_crypto_settings *settings,
 				   int cipher_limit)
 {
-	memset(settings, 0, sizeof(*settings));
+	(void)memset(settings, 0, sizeof(*settings));
 
 	settings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];
 
@@ -4325,7 +4325,7 @@ static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)
 	struct cfg80211_cached_keys *connkeys = NULL;
 	int err;
 
-	memset(&ibss, 0, sizeof(ibss));
+	(void)memset(&ibss, 0, sizeof(ibss));
 
 	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
 		return -EINVAL;
@@ -4551,7 +4551,7 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
 	struct cfg80211_cached_keys *connkeys = NULL;
 	int err;
 
-	memset(&connect, 0, sizeof(connect));
+	(void)memset(&connect, 0, sizeof(connect));
 
 	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
 		return -EINVAL;
@@ -4668,7 +4668,7 @@ static int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)
 	struct net_device *dev = info->user_ptr[1];
 	struct cfg80211_pmksa pmksa;
 
-	memset(&pmksa, 0, sizeof(struct cfg80211_pmksa));
+	(void)memset(&pmksa, 0, sizeof(struct cfg80211_pmksa));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -4691,7 +4691,7 @@ static int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)
 		rdev_ops = rdev->ops->del_pmksa;
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		break;
 	}
 
@@ -4856,7 +4856,7 @@ static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
 	if (!rdev->ops->set_bitrate_mask)
 		return -EOPNOTSUPP;
 
-	memset(&mask, 0, sizeof(mask));
+	(void)memset(&mask, 0, sizeof(mask));
 	/* Default to all rates enabled */
 	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
 		sband = rdev->wiphy.bands[i];
@@ -5976,7 +5976,7 @@ static int nl80211_add_scan_req(struct sk_buff *msg,
 	struct nlattr *nest;
 	int i;
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	if (WARN_ON(!req))
 		return 0;
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index 379574c..747f090 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -84,7 +84,7 @@ static DEFINE_MUTEX(reg_mutex);
 
 static inline void assert_reg_lock(void)
 {
-	lockdep_assert_held(&reg_mutex);
+	(void)lockdep_assert_held(&reg_mutex);
 }
 
 /* Used to queue up regulatory hints */
@@ -555,7 +555,7 @@ static struct ieee80211_regdomain *regdom_intersect(
 	/* Uses the stack temporarily for counter arithmetic */
 	intersected_rule = &irule;
 
-	memset(intersected_rule, 0, sizeof(struct ieee80211_reg_rule));
+	(void)memset(intersected_rule, 0, sizeof(struct ieee80211_reg_rule));
 
 	if (!rd1 || !rd2)
 		return NULL;
@@ -575,7 +575,7 @@ static struct ieee80211_regdomain *regdom_intersect(
 			if (!reg_rules_intersect(rule1, rule2,
 					intersected_rule))
 				num_rules++;
-			memset(intersected_rule, 0,
+			(void)memset(intersected_rule, 0,
 					sizeof(struct ieee80211_reg_rule));
 		}
 	}
@@ -1221,7 +1221,7 @@ void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
 	 * no point in calling this if it won't have any effect
 	 * on your device's supportd bands.
 	 */
-	WARN_ON(!bands_set);
+	(void)WARN_ON(!bands_set);
 }
 EXPORT_SYMBOL(wiphy_apply_custom_regulatory);
 
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index cbbc927..ad5e06d 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -27,7 +27,7 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak)
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	request = rdev->scan_req;
 
@@ -86,7 +86,7 @@ void __cfg80211_scan_done(struct work_struct *wk)
 
 void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted)
 {
-	WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
+	(void)WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
 
 	request->aborted = aborted;
 	queue_work(cfg80211_wq, &wiphy_to_dev(request->wiphy)->scan_done_wk);
@@ -135,7 +135,7 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 	int err;
 	struct net_device *dev;
 
-	lockdep_assert_held(&rdev->sched_scan_mtx);
+	(void)lockdep_assert_held(&rdev->sched_scan_mtx);
 
 	if (!rdev->sched_scan_req)
 		return 0;
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index cf4be21..693ab65 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -81,8 +81,8 @@ static int cfg80211_conn_scan(struct wireless_dev *wdev)
 	int n_channels, err;
 
 	ASSERT_RTNL();
-	ASSERT_RDEV_LOCK(rdev);
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (rdev->scan_req)
 		return -EBUSY;
@@ -152,7 +152,7 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev)
 	const u8 *prev_bssid = NULL;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->conn)
 		return 0;
@@ -245,7 +245,7 @@ static struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)
 	struct cfg80211_bss *bss;
 	u16 capa = WLAN_CAPABILITY_ESS;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->conn->params.privacy)
 		capa |= WLAN_CAPABILITY_PRIVACY;
@@ -274,7 +274,7 @@ static void __cfg80211_sme_scan_done(struct net_device *dev)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	struct cfg80211_bss *bss;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state != CFG80211_SME_CONNECTING)
 		return;
@@ -323,7 +323,7 @@ void cfg80211_sme_rx_auth(struct net_device *dev,
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
 	u16 status_code = le16_to_cpu(mgmt->u.auth.status_code);
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	/* should only RX auth frames when connecting */
 	if (wdev->sme_state != CFG80211_SME_CONNECTING)
@@ -410,7 +410,7 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
@@ -514,7 +514,7 @@ void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
+	(void)CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
 
 	ev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);
 	if (!ev)
@@ -553,7 +553,7 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
@@ -620,7 +620,7 @@ void cfg80211_roamed(struct net_device *dev,
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
+	(void)CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
 
 	ev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);
 	if (!ev)
@@ -653,7 +653,7 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
@@ -697,7 +697,7 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			ret = __cfg80211_mlme_deauth(rdev, dev, bssid, NULL, 0,
 						WLAN_REASON_DEAUTH_LEAVING,
 						false);
-			WARN(ret, "deauth failed: %d\n", ret);
+			(void)WARN(ret, "deauth failed: %d\n", ret);
 		}
 	}
 
@@ -729,7 +729,7 @@ void cfg80211_disconnected(struct net_device *dev, u16 reason,
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
+	(void)CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
 
 	ev = kzalloc(sizeof(*ev) + ie_len, gfp);
 	if (!ev)
@@ -758,7 +758,7 @@ int __cfg80211_connect(struct cfg80211_registered_device *rdev,
 	struct cfg80211_bss *bss = NULL;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 #ifndef CONFIG_CFG80211_ALLOW_RECONNECT
 	if (wdev->sme_state != CFG80211_SME_IDLE)
@@ -922,7 +922,7 @@ int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state == CFG80211_SME_IDLE)
 		return -EINVAL;
@@ -992,7 +992,7 @@ void cfg80211_sme_disassoc(struct net_device *dev, int idx)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	u8 bssid[ETH_ALEN];
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->conn)
 		return;
diff --git a/net/wireless/util.c b/net/wireless/util.c
index c00a511..9fb21ef 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -103,7 +103,7 @@ static void set_mandatory_flags_band(struct ieee80211_supported_band *sband,
 				want--;
 			}
 		}
-		WARN_ON(want);
+		(void)WARN_ON(want);
 		break;
 	case IEEE80211_BAND_2GHZ:
 		want = 7;
@@ -133,10 +133,10 @@ static void set_mandatory_flags_band(struct ieee80211_supported_band *sband,
 				sband->bitrates[i].flags |=
 					IEEE80211_RATE_ERP_G;
 		}
-		WARN_ON(want != 0 && want != 3 && want != 6);
+		(void)WARN_ON(want != 0 && want != 3 && want != 6);
 		break;
 	case IEEE80211_NUM_BANDS:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		break;
 	}
 }
@@ -777,7 +777,7 @@ void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev)
 	struct wireless_dev *wdev;
 
 	ASSERT_RTNL();
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	mutex_lock(&rdev->devlist_mtx);
 
@@ -794,7 +794,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	int err;
 	enum nl80211_iftype otype = dev->ieee80211_ptr->iftype;
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	/* don't support changing VLANs, you just re-create them */
 	if (otype == NL80211_IFTYPE_AP_VLAN)
@@ -842,7 +842,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	err = rdev->ops->change_virtual_intf(&rdev->wiphy, dev,
 					     ntype, flags, params);
 
-	WARN_ON(!err && dev->ieee80211_ptr->iftype != ntype);
+	(void)WARN_ON(!err && dev->ieee80211_ptr->iftype != ntype);
 
 	if (!err && params && params->use_4addr != -1)
 		dev->ieee80211_ptr->use_4addr = params->use_4addr;
@@ -958,7 +958,7 @@ int cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
 	if (!(rdev->wiphy.flags & WIPHY_FLAG_ENFORCE_COMBINATIONS))
 		return 0;
 
-	memset(num, 0, sizeof(num));
+	(void)memset(num, 0, sizeof(num));
 
 	num[iftype] = 1;
 
diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c
index fdbc23c..35fa094 100644
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -539,7 +539,7 @@ void wireless_send_event(struct net_device *	dev,
 	event = nla_data(nla);
 
 	/* Fill event - first clear to avoid data leaking */
-	memset(event, 0, hdr_len);
+	(void)memset(event, 0, hdr_len);
 	event->len = event_len;
 	event->cmd = cmd;
 	memcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);
diff --git a/net/wireless/wext-spy.c b/net/wireless/wext-spy.c
index 6dcfe65..0b10a02 100644
--- a/net/wireless/wext-spy.c
+++ b/net/wireless/wext-spy.c
@@ -56,7 +56,7 @@ int iw_handler_set_spy(struct net_device *	dev,
 			memcpy(spydata->spy_address[i], address[i].sa_data,
 			       ETH_ALEN);
 		/* Reset stats */
-		memset(spydata->spy_stat, 0,
+		(void)memset(spydata->spy_stat, 0,
 		       sizeof(struct iw_quality) * IW_MAX_SPY);
 	}
 
@@ -123,7 +123,7 @@ int iw_handler_set_thrspy(struct net_device *	dev,
 	       2 * sizeof(struct iw_quality));
 
 	/* Clear flag */
-	memset(spydata->spy_thr_under, '\0', sizeof(spydata->spy_thr_under));
+	(void)memset(spydata->spy_thr_under, '\0', sizeof(spydata->spy_thr_under));
 
 	return 0;
 }
diff --git a/net/xfrm/xfrm_ipcomp.c b/net/xfrm/xfrm_ipcomp.c
index fc91ad7..bc7f606 100644
--- a/net/xfrm/xfrm_ipcomp.c
+++ b/net/xfrm/xfrm_ipcomp.c
@@ -249,7 +249,7 @@ static void ipcomp_free_tfms(struct crypto_comp * __percpu *tfms)
 			break;
 	}
 
-	WARN_ON(!pos);
+	(void)WARN_ON(!pos);
 
 	if (--pos->users)
 		return;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 5ce74a3..846c4c1 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -1349,7 +1349,7 @@ static inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)
 		BUG();
 	}
 	xdst = dst_alloc(dst_ops, NULL, 0, 0, 0);
-	memset(&xdst->u.rt6.rt6i_table, 0, sizeof(*xdst) - sizeof(struct dst_entry));
+	(void)memset(&xdst->u.rt6.rt6i_table, 0, sizeof(*xdst) - sizeof(struct dst_entry));
 	xfrm_policy_put_afinfo(afinfo);
 
 	if (likely(xdst))
diff --git a/security/keys/key.c b/security/keys/key.c
index f7f9d93..3676dff 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -314,7 +314,7 @@ struct key *key_alloc(struct key_type *type, const char *desc,
 	if (!(flags & KEY_ALLOC_NOT_IN_QUOTA))
 		key->flags |= 1 << KEY_FLAG_IN_QUOTA;
 
-	memset(&key->type_data, 0, sizeof(key->type_data));
+	(void)memset(&key->type_data, 0, sizeof(key->type_data));
 
 #ifdef KEY_DEBUGGING
 	key->magic = KEY_DEBUG_MAGIC;
@@ -1083,7 +1083,7 @@ void unregister_key_type(struct key_type *ktype)
 		if (key->type == ktype) {
 			if (ktype->destroy)
 				ktype->destroy(key);
-			memset(&key->payload, KEY_DESTROY, sizeof(key->payload));
+			(void)memset(&key->payload, KEY_DESTROY, sizeof(key->payload));
 		}
 	}
 
diff --git a/sound/core/control.c b/sound/core/control.c
index f8c5be4..76ac536 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -230,7 +230,7 @@ struct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,
 	
 	if (snd_BUG_ON(!ncontrol || !ncontrol->info))
 		return NULL;
-	memset(&kctl, 0, sizeof(kctl));
+	(void)memset(&kctl, 0, sizeof(kctl));
 	kctl.id.iface = ncontrol->iface;
 	kctl.id.device = ncontrol->device;
 	kctl.id.subdevice = ncontrol->subdevice;
@@ -1082,7 +1082,7 @@ static int snd_ctl_elem_add(struct snd_ctl_file *file,
 				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
 				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
 	info->id.numid = 0;
-	memset(&kctl, 0, sizeof(kctl));
+	(void)memset(&kctl, 0, sizeof(kctl));
 	down_write(&card->controls_rwsem);
 	_kctl = snd_ctl_find_id(card, &info->id);
 	err = 0;
diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index a70ee7f..996fe85 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -182,7 +182,7 @@ static int snd_hwdep_info(struct snd_hwdep *hw,
 {
 	struct snd_hwdep_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.card = hw->card->number;
 	strlcpy(info.id, hw->id, sizeof(info.id));	
 	strlcpy(info.name, hw->name, sizeof(info.name));
@@ -200,7 +200,7 @@ static int snd_hwdep_dsp_status(struct snd_hwdep *hw,
 	
 	if (! hw->ops.dsp_status)
 		return -ENXIO;
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.dsp_loaded = hw->dsp_loaded;
 	if ((err = hw->ops.dsp_status(hw, &info)) < 0)
 		return err;
@@ -217,7 +217,7 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	
 	if (! hw->ops.dsp_load)
 		return -ENXIO;
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	if (copy_from_user(&info, _info, sizeof(info)))
 		return -EFAULT;
 	/* check whether the dsp was already loaded */
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index cbbed0d..07f147c 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -555,7 +555,7 @@ static int snd_rawmidi_info(struct snd_rawmidi_substream *substream,
 	if (substream == NULL)
 		return -ENODEV;
 	rmidi = substream->rmidi;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->card = rmidi->card->number;
 	info->device = rmidi->device;
 	info->subdevice = substream->number;
@@ -684,7 +684,7 @@ static int snd_rawmidi_output_status(struct snd_rawmidi_substream *substream,
 {
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
-	memset(status, 0, sizeof(*status));
+	(void)memset(status, 0, sizeof(*status));
 	status->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;
 	spin_lock_irq(&runtime->lock);
 	status->avail = runtime->avail;
@@ -697,7 +697,7 @@ static int snd_rawmidi_input_status(struct snd_rawmidi_substream *substream,
 {
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
-	memset(status, 0, sizeof(*status));
+	(void)memset(status, 0, sizeof(*status));
 	status->stream = SNDRV_RAWMIDI_STREAM_INPUT;
 	spin_lock_irq(&runtime->lock);
 	status->avail = runtime->avail;
diff --git a/sound/soc/msm/msm-voip.c b/sound/soc/msm/msm-voip.c
index 082c840..01cdffa 100644
--- a/sound/soc/msm/msm-voip.c
+++ b/sound/soc/msm/msm-voip.c
@@ -107,7 +107,7 @@ static int msm_pcm_close(struct snd_pcm_substream *substream)
 	struct audio_mvs_release_msg release_msg;
 
 	pr_debug("%s\n", __func__);
-	memset(&release_msg, 0, sizeof(release_msg));
+	(void)memset(&release_msg, 0, sizeof(release_msg));
 	mutex_lock(&audio->lock);
 
 	audio->instance--;
@@ -138,13 +138,13 @@ static int msm_pcm_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		audio->in_write = 0;
 		audio->in_read = 0;
-		memset(audio->in[0].voc_pkt, 0,
+		(void)memset(audio->in[0].voc_pkt, 0,
 			 MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
 		audio->playback_substream = NULL;
 	} else {
 		audio->out_write = 0;
 		audio->out_read = 0;
-		memset(audio->out[0].voc_pkt, 0,
+		(void)memset(audio->out[0].voc_pkt, 0,
 			 MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
 		audio->capture_substream = NULL;
 	}
@@ -497,7 +497,7 @@ static int msm_pcm_new(struct snd_soc_pcm_runtime *rtd)
 		return -ENOMEM;
 	}
 	dma_buffer->bytes = MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN;
-	memset(dma_buffer->area, 0, MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
+	(void)memset(dma_buffer->area, 0, MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
 	audio_voip_info.in_read = 0;
 	audio_voip_info.in_write = 0;
 	audio_voip_info.out_read = 0;
@@ -522,7 +522,7 @@ static int msm_pcm_new(struct snd_soc_pcm_runtime *rtd)
 		pr_err("%s:MSM VOIP dma_alloc failed\n", __func__);
 		return -ENOMEM;
 	}
-	memset(dma_buffer->area, 0, MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
+	(void)memset(dma_buffer->area, 0, MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN);
 	dma_buffer->bytes = MVS_MAX_VOC_PKT_SIZE * VOIP_MAX_Q_LEN;
 	for (i = 0; i < VOIP_MAX_Q_LEN; i++) {
 		audio_voip_info.out[i].voc_pkt =
@@ -587,7 +587,7 @@ static struct platform_driver msm_pcm_driver = {
 
 static int __init msm_mvs_soc_platform_init(void)
 {
-	memset(&audio_voip_info, 0, sizeof(audio_voip_info));
+	(void)memset(&audio_voip_info, 0, sizeof(audio_voip_info));
 	mutex_init(&audio_voip_info.lock);
 	mutex_init(&audio_voip_info.prepare_lock);
 	init_waitqueue_head(&audio_voip_info.out_wait);
diff --git a/sound/soc/msm/msm8x60-pcm.c b/sound/soc/msm/msm8x60-pcm.c
index 6f5ad32..d8a8eb8 100644
--- a/sound/soc/msm/msm8x60-pcm.c
+++ b/sound/soc/msm/msm8x60-pcm.c
@@ -595,7 +595,7 @@ static int msm_pcm_capture_copy(struct snd_pcm_substream *substream,
 		pr_debug("%s:fbytes = %d: size=%d: xfer=%d\n",
 					__func__, fbytes, size, xfer);
 		pr_debug(" Sending next buffer to dsp\n");
-		memset(&in_frame_info[idx], 0,
+		(void)memset(&in_frame_info[idx], 0,
 			sizeof(uint32_t) * 2);
 		atomic_dec(&prtd->in_count);
 		ret = q6asm_read_nolock(prtd->audio_client);
diff --git a/sound/soc/msm/msm8x60.c b/sound/soc/msm/msm8x60.c
index 48ce610..1f317b4 100644
--- a/sound/soc/msm/msm8x60.c
+++ b/sound/soc/msm/msm8x60.c
@@ -1161,7 +1161,7 @@ static int msm_soc_dai_init(
 	init_waitqueue_head(&the_locks.eos_wait);
 	init_waitqueue_head(&the_locks.write_wait);
 	init_waitqueue_head(&the_locks.read_wait);
-	memset(&session_route, DEVICE_IGNORE, sizeof(struct pcm_session));
+	(void)memset(&session_route, DEVICE_IGNORE, sizeof(struct pcm_session));
 
 	ret = msm_new_mixer(codec);
 	if (ret < 0)
diff --git a/sound/soc/msm/qdsp6/q6asm.c b/sound/soc/msm/qdsp6/q6asm.c
index ab7f9f7..b0d74f3 100644
--- a/sound/soc/msm/qdsp6/q6asm.c
+++ b/sound/soc/msm/qdsp6/q6asm.c
@@ -3158,7 +3158,7 @@ static int __init q6asm_init(void)
 {
 	pr_debug("%s\n", __func__);
 	init_waitqueue_head(&this_mmap.cmd_wait);
-	memset(session, 0, sizeof(session));
+	(void)memset(session, 0, sizeof(session));
 #ifdef CONFIG_DEBUG_FS
 	out_buffer = kmalloc(OUT_BUFFER_SIZE, GFP_KERNEL);
 	out_dentry = debugfs_create_file("audio_out_latency_measurement_node",\
diff --git a/sound/soc/soc-cache.c b/sound/soc/soc-cache.c
index 039b953..7e1794f 100644
--- a/sound/soc/soc-cache.c
+++ b/sound/soc/soc-cache.c
@@ -553,7 +553,7 @@ static int snd_soc_rbtree_cache_sync(struct snd_soc_codec *codec)
 		rbnode = rb_entry(node, struct snd_soc_rbtree_node, node);
 		if (rbnode->value == rbnode->defval)
 			continue;
-		WARN_ON(codec->writable_register &&
+		(void)WARN_ON(codec->writable_register &&
 			codec->writable_register(codec, rbnode->reg));
 		ret = snd_soc_cache_read(codec, rbnode->reg, &val);
 		if (ret)
@@ -1075,7 +1075,7 @@ static int snd_soc_flat_cache_sync(struct snd_soc_codec *codec)
 
 	codec_drv = codec->driver;
 	for (i = 0; i < codec_drv->reg_cache_size; ++i) {
-		WARN_ON(codec->writable_register &&
+		(void)WARN_ON(codec->writable_register &&
 			codec->writable_register(codec, i));
 		ret = snd_soc_cache_read(codec, i, &val);
 		if (ret)
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 219ae10..e54a5ca 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -101,7 +101,7 @@ static int format_register_str(struct snd_soc_codec *codec,
 
 	/* since tmpbuf is allocated on the stack, warn the callers if they
 	 * try to abuse this function */
-	WARN_ON(len > 63);
+	(void)WARN_ON(len > 63);
 
 	/* +2 for ': ' and + 1 for '\n' */
 	if (wordsize + regsize + 2 + 1 != len)
@@ -109,7 +109,7 @@ static int format_register_str(struct snd_soc_codec *codec,
 
 	ret = snd_soc_read(codec , reg);
 	if (ret < 0) {
-		memset(regbuf, 'X', regsize);
+		(void)memset(regbuf, 'X', regsize);
 		regbuf[regsize] = '\0';
 	} else {
 		snprintf(regbuf, regsize + 1, "%.*x", regsize, ret);
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index f928910..275144b 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -851,7 +851,7 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 		return;
 	}
 
-	memset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);
+	(void)memset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);
 	urb->transfer_buffer_length = ep->max_transfer;
 }
 
@@ -2103,7 +2103,7 @@ int snd_usbmidi_create(struct snd_card *card,
 	umidi->error_timer.data = (unsigned long)umidi;
 
 	/* detect the endpoint(s) to use */
-	memset(endpoints, 0, sizeof(endpoints));
+	(void)memset(endpoints, 0, sizeof(endpoints));
 	switch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {
 	case QUIRK_MIDI_STANDARD_INTERFACE:
 		err = snd_usbmidi_get_ms_info(umidi, endpoints);
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index cdd19d7..7773901 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -324,7 +324,7 @@ static int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request, int v
 		size = sizeof(buf);
 	}
 
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 
 	ret = snd_usb_autoresume(chip) ? -EIO : 0;
 	if (ret)
@@ -647,7 +647,7 @@ static int check_input_term(struct mixer_build *state, int id, struct usb_audio_
 	int err;
 	void *p1;
 
-	memset(term, 0, sizeof(*term));
+	(void)memset(term, 0, sizeof(*term));
 	while ((p1 = find_audio_control_unit(state, id)) != NULL) {
 		unsigned char *hdr = p1;
 		term->id = id;
@@ -1942,7 +1942,7 @@ static int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)
 	const struct usbmix_ctl_map *map;
 	void *p;
 
-	memset(&state, 0, sizeof(state));
+	(void)memset(&state, 0, sizeof(state));
 	state.chip = mixer->chip;
 	state.mixer = mixer;
 	state.buffer = mixer->hostif->extra;
diff --git a/sound/usb/urb.c b/sound/usb/urb.c
index e184349..fbd3cfc 100644
--- a/sound/usb/urb.c
+++ b/sound/usb/urb.c
@@ -637,7 +637,7 @@ static int prepare_nodata_playback_urb(struct snd_usb_substream *subs,
 	}
 	urb->number_of_packets = ctx->packets;
 	urb->transfer_buffer_length = offs * stride;
-	memset(urb->transfer_buffer,
+	(void)memset(urb->transfer_buffer,
 	       runtime->format == SNDRV_PCM_FORMAT_U8 ? 0x80 : 0,
 	       offs * stride);
 	return 0;

