diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 0455878..b9fe543 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -375,7 +375,7 @@ static int gic_set_wake(struct irq_data *d, unsigned int on)
 	struct gic_chip_data *gic_data = irq_data_get_irq_chip_data(d);
 
 	/* per-cpu interrupts cannot be wakeup interrupts */
-	WARN_ON(gicirq < 32);
+	(void)WARN_ON(gicirq < 32);
 
 	reg_offset = gicirq / 32;
 	bit_offset = gicirq % 32;
@@ -856,7 +856,7 @@ void __init gic_init_bases(unsigned int gic_nr, int irq_start,
 	domain->ops = &gic_irq_domain_ops;
 	rc = irq_domain_add(domain);
 	if (rc) {
-		WARN(1, "Unable to create irq_domain\n");
+		(void)WARN(1, "Unable to create irq_domain\n");
 		goto init_bases_err;
 	}
 	irq_domain_register(domain);
@@ -910,13 +910,13 @@ bool gic_is_spi_pending(unsigned int irq)
 	struct gic_chip_data *gic_data = &gic_data[0];
 	u32 mask, val;
 
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 	raw_spin_lock(&irq_controller_lock);
 	mask = 1 << (gic_irq(d) % 32);
 	val = readl(gic_dist_base(d) +
 			GIC_DIST_ENABLE_SET + (gic_irq(d) / 32) * 4);
 	/* warn if the interrupt is enabled */
-	WARN_ON(val & mask);
+	(void)WARN_ON(val & mask);
 	val = readl(gic_dist_base(d) +
 			GIC_DIST_PENDING_SET + (gic_irq(d) / 32) * 4);
 	raw_spin_unlock(&irq_controller_lock);
@@ -931,13 +931,13 @@ void gic_clear_spi_pending(unsigned int irq)
 	struct irq_data *d = irq_get_irq_data(irq);
 
 	u32 mask, val;
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 	raw_spin_lock(&irq_controller_lock);
 	mask = 1 << (gic_irq(d) % 32);
 	val = readl(gic_dist_base(d) +
 			GIC_DIST_ENABLE_SET + (gic_irq(d) / 32) * 4);
 	/* warn if the interrupt is enabled */
-	WARN_ON(val & mask);
+	(void)WARN_ON(val & mask);
 	writel(mask, gic_dist_base(d) +
 			GIC_DIST_PENDING_CLEAR + (gic_irq(d) / 32) * 4);
 	raw_spin_unlock(&irq_controller_lock);
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index 016d6a0..0867f7a 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -305,7 +305,7 @@ int module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
 	struct mod_unwind_map maps[ARM_SEC_MAX];
 	int i;
 
-	memset(maps, 0, sizeof(maps));
+	(void)memset(maps, 0, sizeof(maps));
 
 	for (s = sechdrs; s < sechdrs_end; s++) {
 		const char *secname = secstrs + s->sh_name;
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 9726006..52d8ec7 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -239,7 +239,7 @@ static int thumb2_break_trap(struct pt_regs *regs, unsigned int instr)
 	if (processor_mode(regs) == SVC_MODE) {
 		instr2 = *(u16 *) pc;
 	} else {
-		get_user(instr2, (u16 __user *)pc);
+		(void)get_user(instr2, (u16 __user *)pc);
 	}
 
 	if (instr2 == 0xa000) {
@@ -426,7 +426,7 @@ static void ptrace_hbptriggered(struct perf_event *bp, int unused,
  */
 void clear_ptrace_hw_breakpoint(struct task_struct *tsk)
 {
-	memset(tsk->thread.debug.hbp, 0, sizeof(tsk->thread.debug.hbp));
+	(void)memset(tsk->thread.debug.hbp, 0, sizeof(tsk->thread.debug.hbp));
 }
 
 /*
diff --git a/arch/arm/kernel/sched_clock.c b/arch/arm/kernel/sched_clock.c
index 9a46370..3ce5269 100644
--- a/arch/arm/kernel/sched_clock.c
+++ b/arch/arm/kernel/sched_clock.c
@@ -47,7 +47,7 @@ void __init init_sched_clock(struct clock_data *cd, void (*update)(void),
 
 	/* calculate how many ns until we wrap */
 	wrap = cyc_to_ns((1ULL << clock_bits) - 1, cd->mult, cd->shift);
-	do_div(wrap, NSEC_PER_MSEC);
+	(void)do_div(wrap, NSEC_PER_MSEC);
 	w = wrap;
 
 	/* calculate the ns resolution of this counter */
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 4328ac3..136d533 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -659,7 +659,7 @@ void smp_send_reschedule(int cpu)
 {
 
 	if (unlikely(cpu_is_offline(cpu))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 738a166..573d1aa 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -382,9 +382,9 @@ asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
 	if (processor_mode(regs) == SVC_MODE) {
 		instr = *(u32 *) pc;
 	} else if (thumb_mode(regs)) {
-		get_user(instr, (u16 __user *)pc);
+		(void)get_user(instr, (u16 __user *)pc);
 	} else {
-		get_user(instr, (u32 __user *)pc);
+		(void)get_user(instr, (u32 __user *)pc);
 	}
 
 	if (call_undef_hook(regs, instr) == 0)
diff --git a/arch/arm/mach-msm/clock-8x60.c b/arch/arm/mach-msm/clock-8x60.c
index d61547fa..42eb0cb 100644
--- a/arch/arm/mach-msm/clock-8x60.c
+++ b/arch/arm/mach-msm/clock-8x60.c
@@ -3531,7 +3531,7 @@ static unsigned long measure_clk_get_rate(struct clk *c)
 	else {
 		/* Compute rate in Hz. */
 		raw_count_full = ((raw_count_full * 10) + 15) * 4800000;
-		do_div(raw_count_full,
+		(void)do_div(raw_count_full,
 		       (((clk->sample_ticks * 10) + 35) * clk->divider));
 		ret = (raw_count_full * clk->multiplier);
 	}
diff --git a/arch/arm/mach-msm/clock-local.c b/arch/arm/mach-msm/clock-local.c
index 2a1c013..db271a8 100644
--- a/arch/arm/mach-msm/clock-local.c
+++ b/arch/arm/mach-msm/clock-local.c
@@ -315,7 +315,7 @@ void __branch_clk_enable_reg(const struct branch *clk, const char *name)
 		for (count = HALT_CHECK_MAX_LOOPS; branch_clk_is_halted(clk)
 					&& count > 0; count--)
 			udelay(1);
-		WARN(count == 0, "%s status stuck at 'off'", name);
+		(void)WARN(count == 0, "%s status stuck at 'off'", name);
 	}
 }
 
@@ -325,7 +325,7 @@ static void __rcg_clk_enable_reg(struct rcg_clk *clk)
 	u32 reg_val;
 	void __iomem *const reg = clk->b.ctl_reg;
 
-	WARN(clk->current_freq == &rcg_dummy_freq,
+	(void)WARN(clk->current_freq == &rcg_dummy_freq,
 		"Attempting to enable %s before setting its rate. "
 		"Set the rate first!\n", clk->c.dbg_name);
 
@@ -389,7 +389,7 @@ u32 __branch_clk_disable_reg(const struct branch *clk, const char *name)
 		for (count = HALT_CHECK_MAX_LOOPS; !branch_clk_is_halted(clk)
 					&& count > 0; count--)
 			udelay(1);
-		WARN(count == 0, "%s status stuck at 'on'", name);
+		(void)WARN(count == 0, "%s status stuck at 'on'", name);
 	}
 
 	return reg_val;
diff --git a/arch/arm/mach-msm/dal.c b/arch/arm/mach-msm/dal.c
index 94c02f0..51e7b3e 100644
--- a/arch/arm/mach-msm/dal.c
+++ b/arch/arm/mach-msm/dal.c
@@ -523,7 +523,7 @@ int daldevice_attach(uint32_t device_id, char *port, int cpu,
 		h->msg.hdr.to = 0;
 		h->msg.param[0] = device_id;
 
-		memset(&h->msg.param[1], 0,
+		(void)memset(&h->msg.param[1], 0,
 		       DALRPC_MAX_ATTACH_PARAM_LEN +
 		       DALRPC_MAX_SERVICE_NAME_LEN);
 
diff --git a/arch/arm/mach-msm/dal_remotetest.c b/arch/arm/mach-msm/dal_remotetest.c
index d7a3f34..a63fc5c 100644
--- a/arch/arm/mach-msm/dal_remotetest.c
+++ b/arch/arm/mach-msm/dal_remotetest.c
@@ -173,7 +173,7 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_7 */
 	init_data(&in_data);
-	memset(&out_data, 0, sizeof(out_data));
+	(void)memset(&out_data, 0, sizeof(out_data));
 	ret = remote_unittest_7(dev_handle, &in_data, sizeof(in_data),
 				&out_data.test, sizeof(out_data.test),
 				&oalen);
@@ -186,7 +186,7 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_8 */
 	init_bytebuf(in_bytebuf);
-	memset(&out_data, 0, sizeof(out_data));
+	(void)memset(&out_data, 0, sizeof(out_data));
 	ret = remote_unittest_8(dev_handle, in_bytebuf, sizeof(in_bytebuf),
 				&out_data, sizeof(out_data));
 	if (ret)
@@ -195,7 +195,7 @@ static int remotetest_exec(int dest, u64 *val)
 		verify_error(8, "obuf");
 
 	/* test remote_unittest_9 */
-	memset(&out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(&out_bytebuf, 0, sizeof(out_bytebuf));
 	ret = remote_unittest_9(dev_handle, out_bytebuf, sizeof(out_bytebuf));
 	if (ret)
 		rpc_error(9);
@@ -204,7 +204,7 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_10 */
 	init_bytebuf(in_bytebuf);
-	memset(&out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(&out_bytebuf, 0, sizeof(out_bytebuf));
 	ret = remote_unittest_10(dev_handle, REMOTE_UNITTEST_INARG_1,
 				 in_bytebuf, sizeof(in_bytebuf),
 				 out_bytebuf, sizeof(out_bytebuf), &oalen);
@@ -216,7 +216,7 @@ static int remotetest_exec(int dest, u64 *val)
 		verify_error(10, "obuf");
 
 	/* test remote_unittest_11 */
-	memset(&out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(&out_bytebuf, 0, sizeof(out_bytebuf));
 	ret = remote_unittest_11(dev_handle, REMOTE_UNITTEST_INARG_1,
 				 out_bytebuf, sizeof(out_bytebuf));
 	if (ret)
@@ -225,7 +225,7 @@ static int remotetest_exec(int dest, u64 *val)
 		verify_error(11, "obuf");
 
 	/* test remote_unittest_12 */
-	memset(&out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(&out_bytebuf, 0, sizeof(out_bytebuf));
 	ret = remote_unittest_12(dev_handle, REMOTE_UNITTEST_INARG_1,
 				 out_bytebuf, sizeof(out_bytebuf), &oalen);
 	if (ret)
@@ -237,7 +237,7 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_13 */
 	init_data(&in_data);
-	memset(&out_data, 0, sizeof(out_data));
+	(void)memset(&out_data, 0, sizeof(out_data));
 	ret = remote_unittest_13(dev_handle, in_data.test, sizeof(in_data.test),
 				 &in_data, sizeof(in_data),
 				 &out_data, sizeof(out_data));
@@ -248,8 +248,8 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_14 */
 	init_data(&in_data);
-	memset(out_bytebuf, 0, sizeof(out_bytebuf));
-	memset(out_bytebuf2, 0, sizeof(out_bytebuf2));
+	(void)memset(out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(out_bytebuf2, 0, sizeof(out_bytebuf2));
 	ret = remote_unittest_14(dev_handle,
 				 in_data.test, sizeof(in_data.test),
 				 out_bytebuf, sizeof(out_bytebuf),
@@ -265,8 +265,8 @@ static int remotetest_exec(int dest, u64 *val)
 
 	/* test remote_unittest_15 */
 	init_data(&in_data);
-	memset(out_bytebuf, 0, sizeof(out_bytebuf));
-	memset(&out_data, 0, sizeof(out_data));
+	(void)memset(out_bytebuf, 0, sizeof(out_bytebuf));
+	(void)memset(&out_data, 0, sizeof(out_data));
 	ret = remote_unittest_15(dev_handle,
 				 in_data.test, sizeof(in_data.test),
 				 &in_data, sizeof(in_data),
diff --git a/arch/arm/mach-msm/etm.c b/arch/arm/mach-msm/etm.c
index bee0975..8311c8f 100644
--- a/arch/arm/mach-msm/etm.c
+++ b/arch/arm/mach-msm/etm.c
@@ -324,7 +324,7 @@ static void __cpu_enable_trace(void *unused)
 	uint32_t etm_trigger;
 	uint32_t etm_external_output;
 
-	get_cpu();
+	(void)get_cpu();
 
 	__cpu_disable_etb();
 	/* vote for ETM power/clock enable */
@@ -408,7 +408,7 @@ static void __cpu_enable_trace(void *unused)
 
 static void __cpu_disable_trace(void *unused)
 {
-	get_cpu();
+	(void)get_cpu();
 
 	__cpu_disable_etm();
 
@@ -435,7 +435,7 @@ static void enable_trace(void)
 		asm volatile("isb");
 	}
 
-	get_cpu();
+	(void)get_cpu();
 	__cpu_enable_trace(NULL);
 	smp_call_function(__cpu_enable_trace, NULL, 1);
 	put_cpu();
@@ -458,7 +458,7 @@ static void disable_trace(void)
 	wake_lock(&etm_wake_lock);
 	pm_qos_update_request(&etm_qos_req, 0);
 
-	get_cpu();
+	(void)get_cpu();
 	__cpu_disable_trace(NULL);
 	smp_call_function(__cpu_disable_trace, NULL, 1);
 	put_cpu();
@@ -587,7 +587,7 @@ static void generate_etm_dump(void)
 
 static void dump_all(void *unused)
 {
-	get_cpu();
+	(void)get_cpu();
 	__cpu_disable_etb();
 	generate_etm_dump();
 	generate_etb_dump();
@@ -598,7 +598,7 @@ static void dump_all(void *unused)
 
 static void dump_trace(void)
 {
-	get_cpu();
+	(void)get_cpu();
 	dump_all(NULL);
 	smp_call_function(dump_all, NULL, 1);
 	put_cpu();
@@ -979,7 +979,7 @@ static struct miscdevice etm_dev = {
 
 static void __cpu_clear_sticky(void *unused)
 {
-	etm_read(ETMPDSR); /* clear sticky bit in PDSR */
+	(void)etm_read(ETMPDSR); /* clear sticky bit in PDSR */
 	isb();
 }
 
diff --git a/arch/arm/mach-msm/idle_stats.c b/arch/arm/mach-msm/idle_stats.c
index f4d3a27..639571d 100644
--- a/arch/arm/mach-msm/idle_stats.c
+++ b/arch/arm/mach-msm/idle_stats.c
@@ -133,7 +133,7 @@ static void msm_idle_stats_pre_idle(struct msm_idle_stats_device *stats_dev)
 	int64_t interval;
 
 	if (smp_processor_id() != stats_dev->cpu) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -159,7 +159,7 @@ static void msm_idle_stats_post_idle(struct msm_idle_stats_device *stats_dev)
 	int rc;
 
 	if (smp_processor_id() != stats_dev->cpu) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -193,7 +193,7 @@ static void msm_idle_stats_post_idle(struct msm_idle_stats_device *stats_dev)
 
 	rc = hrtimer_start(&stats_dev->timer,
 		ktime_set(0, timer_interval * 1000), HRTIMER_MODE_REL_PINNED);
-	WARN_ON(rc);
+	(void)WARN_ON(rc);
 
 	return;
 
@@ -280,7 +280,7 @@ static int msm_idle_stats_collect(struct file *filp,
 		rc = hrtimer_start(&stats_dev->timer,
 			ktime_set(0, stats->busy_timer * 1000),
 			HRTIMER_MODE_REL_PINNED);
-		WARN_ON(rc);
+		(void)WARN_ON(rc);
 	}
 
 	put_cpu();
@@ -394,7 +394,7 @@ static int msm_idle_stats_release(struct inode *inode, struct file *filp)
 	stats_dev = (struct msm_idle_stats_device *) filp->private_data;
 	rc = msm_cpuidle_unregister_notifier(stats_dev->cpu,
 						&stats_dev->notifier);
-	WARN_ON(rc);
+	(void)WARN_ON(rc);
 
 	spin_lock(&msm_idle_stats_devs_lock);
 	per_cpu(msm_idle_stats_devs, stats_dev->cpu) = NULL;
diff --git a/arch/arm/mach-msm/jtag.c b/arch/arm/mach-msm/jtag.c
index f720fa9..9c276db 100644
--- a/arch/arm/mach-msm/jtag.c
+++ b/arch/arm/mach-msm/jtag.c
@@ -457,7 +457,7 @@ static inline void dbg_restore_state(int cpu)
 	case ARM_DEBUG_ARCH_V7B:
 	case ARM_DEBUG_ARCH_V7:
 		/* Clear sticky bit */
-		dbg_read(DBGPRSR);
+		(void)dbg_read(DBGPRSR);
 		isb();
 
 		/* Set OS lock. Lock will already be set after power collapse
@@ -467,7 +467,7 @@ static inline void dbg_restore_state(int cpu)
 		dbg_write(OSLOCK_MAGIC, DBGOSLAR);
 		isb();
 
-		dbg_read(DBGOSSRR); /* dummy read of OSSRR */
+		(void)dbg_read(DBGOSSRR); /* dummy read of OSSRR */
 		cnt = dbg.state[i++];
 		for (j = 0; j < cnt; j++) {
 			/* DBGDSCR special case
@@ -967,7 +967,7 @@ static inline void etm_restore_state(int cpu)
 		 */
 
 		/* Clear sticky bit */
-		etm_read(ETMPDSR);
+		(void)etm_read(ETMPDSR);
 		isb();
 
 		/* Set OS lock. Lock will already be set after power collapse
@@ -977,7 +977,7 @@ static inline void etm_restore_state(int cpu)
 		etm_write(OSLOCK_MAGIC, ETMOSLAR);
 		isb();
 
-		etm_read(ETMOSSRR); /* dummy read of OSSRR */
+		(void)etm_read(ETMOSSRR); /* dummy read of OSSRR */
 		cnt = etm.state[i++];
 		for (j = 0; j < cnt; j++)
 			etm_write(etm.state[i++], ETMOSSRR);
@@ -1073,7 +1073,7 @@ static int __init msm_jtag_etm_init(void)
 	etm_clk_enable();
 
 	/* Clear sticky bit in PDSR - required for ETMv3.3 (8660) */
-	etm_read(ETMPDSR);
+	(void)etm_read(ETMPDSR);
 	isb();
 
 	/* Populate etm_ctx data */
diff --git a/arch/arm/mach-msm/msm_rq_stats.c b/arch/arm/mach-msm/msm_rq_stats.c
index 492612f..c2c3ec3 100644
--- a/arch/arm/mach-msm/msm_rq_stats.c
+++ b/arch/arm/mach-msm/msm_rq_stats.c
@@ -36,7 +36,7 @@ static void def_work_fn(struct work_struct *work)
 	int64_t diff;
 
 	diff = ktime_to_ns(ktime_get()) - rq_info.def_start_time;
-	do_div(diff, 1000 * 1000);
+	(void)do_div(diff, 1000 * 1000);
 	rq_info.def_interval = (unsigned int) diff;
 
 	/* Notify polling threads on change of value */
diff --git a/arch/arm/mach-msm/oem_rapi_client.c b/arch/arm/mach-msm/oem_rapi_client.c
index f2b93ce..ec02586 100644
--- a/arch/arm/mach-msm/oem_rapi_client.c
+++ b/arch/arm/mach-msm/oem_rapi_client.c
@@ -277,7 +277,7 @@ static ssize_t debug_write(struct file *fp, const char __user *buf,
 		oem_rapi_client_test_res = oem_rapi_client_null(rpc_client,
 								NULL, NULL);
 	} else if (!strncmp(cmd, "streaming_func", 64)) {
-		memset(input, 5, 16);
+		(void)memset(input, 5, 16);
 		arg.event = 0;
 		arg.cb_func = oem_rapi_client_test_streaming_cb_func;
 		arg.handle = (void *)20;
diff --git a/arch/arm/mach-msm/peripheral-loader.c b/arch/arm/mach-msm/peripheral-loader.c
index b16b687..62c86ae 100644
--- a/arch/arm/mach-msm/peripheral-loader.c
+++ b/arch/arm/mach-msm/peripheral-loader.c
@@ -132,7 +132,7 @@ static int load_segment(const struct elf32_phdr *phdr, unsigned num,
 			ret = -ENOMEM;
 			goto release_fw;
 		}
-		memset(buf, 0, size);
+		(void)memset(buf, 0, size);
 		iounmap(buf);
 
 		count -= size;
@@ -293,7 +293,7 @@ void pil_put(void *peripheral_handle)
 		return;
 
 	mutex_lock(&pil->lock);
-	WARN(!pil->count, "%s: Reference count mismatch\n", __func__);
+	(void)WARN(!pil->count, "%s: Reference count mismatch\n", __func__);
 	/* TODO: Peripheral shutdown support */
 	if (pil->count == 1)
 		goto unlock;
diff --git a/arch/arm/mach-msm/platsmp.c b/arch/arm/mach-msm/platsmp.c
index f1c6c48..ef95601 100644
--- a/arch/arm/mach-msm/platsmp.c
+++ b/arch/arm/mach-msm/platsmp.c
@@ -121,7 +121,7 @@ static int __cpuinit release_secondary(unsigned int cpu)
 	if (cpu_is_msm8960() || cpu_is_msm8930() || cpu_is_apq8064())
 		return krait_release_secondary(cpu);
 
-	WARN(1, "unknown CPU case in release_secondary\n");
+	(void)WARN(1, "unknown CPU case in release_secondary\n");
 	return -EINVAL;
 }
 
@@ -194,7 +194,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 {
 	pr_debug("CPU%u: Booted secondary processor\n", cpu);
 
-	WARN_ON(msm_platform_secondary_init(cpu));
+	(void)WARN_ON(msm_platform_secondary_init(cpu));
 
 	trace_hardirqs_off();
 
diff --git a/arch/arm/mach-msm/pm-8x60.c b/arch/arm/mach-msm/pm-8x60.c
index 754d76f..2541e54 100644
--- a/arch/arm/mach-msm/pm-8x60.c
+++ b/arch/arm/mach-msm/pm-8x60.c
@@ -378,7 +378,7 @@ static void msm_pm_add_stat(enum msm_pm_time_stats_id id, int64_t t)
 	stats[id].count++;
 
 	bt = t;
-	do_div(bt, stats[id].first_bucket_time);
+	(void)do_div(bt, stats[id].first_bucket_time);
 
 	if (bt < 1ULL << (CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT *
 				(CONFIG_MSM_IDLE_STATS_BUCKET_COUNT - 1)))
@@ -521,11 +521,11 @@ static int msm_pm_write_proc(struct file *file, const char __user *buffer,
 
 		stats = per_cpu(msm_pm_stats, cpu).stats;
 		for (i = 0; i < MSM_PM_STAT_COUNT; i++) {
-			memset(stats[i].bucket,
+			(void)memset(stats[i].bucket,
 				0, sizeof(stats[i].bucket));
-			memset(stats[i].min_time,
+			(void)memset(stats[i].min_time,
 				0, sizeof(stats[i].min_time));
-			memset(stats[i].max_time,
+			(void)memset(stats[i].max_time,
 				0, sizeof(stats[i].max_time));
 			stats[i].count = 0;
 			stats[i].total_time = 0;
@@ -592,7 +592,7 @@ static uint32_t msm_pm_max_sleep_time;
  */
 static int64_t msm_pm_convert_and_cap_time(int64_t time_ns, int64_t limit)
 {
-	do_div(time_ns, NSEC_PER_SEC / SCLK_HZ);
+	(void)do_div(time_ns, NSEC_PER_SEC / SCLK_HZ);
 	return (time_ns > limit) ? limit : time_ns;
 }
 
@@ -661,7 +661,7 @@ static bool msm_pm_spm_power_collapse(
 
 	ret = msm_spm_set_low_power_mode(
 			MSM_SPM_MODE_POWER_COLLAPSE, notify_rpm);
-	WARN_ON(ret);
+	(void)WARN_ON(ret);
 
 	entry = (!cpu || from_idle) ?
 		msm_pm_collapse_exit : msm_secondary_startup;
@@ -694,7 +694,7 @@ static bool msm_pm_spm_power_collapse(
 			cpu, __func__, collapsed);
 
 	ret = msm_spm_set_low_power_mode(MSM_SPM_MODE_CLOCK_GATING, false);
-	WARN_ON(ret);
+	(void)WARN_ON(ret);
 	return collapsed;
 }
 
@@ -948,7 +948,7 @@ int msm_pm_idle_enter(enum msm_pm_sleep_mode sleep_mode)
 	msm_pm_add_stat(exit_stat, time);
 #endif
 
-	do_div(time, 1000);
+	(void)do_div(time, 1000);
 	return (int) time;
 
 cpuidle_enter_bail:
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_acdb.c b/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
index 37a6900..73046d1 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
@@ -854,7 +854,7 @@ struct miscdevice acdb_misc = {
 
 static int __init acdb_init(void)
 {
-	memset(&acdb_data, 0, sizeof(acdb_data));
+	(void)memset(&acdb_data, 0, sizeof(acdb_data));
 	mutex_init(&acdb_data.acdb_mutex);
 	atomic_set(&usage_count, 0);
 	return misc_register(&acdb_misc);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c b/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c
index 0a5acce..41a2c25 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_dev_ctl.c
@@ -374,7 +374,7 @@ int msm_snddev_set_dec(int popp_id, int copp_id, int set,
 		msm_set_copp_id(popp_id, copp_id);
 		pr_debug("%s:Session id=%d copp_id=%d\n",
 			__func__, popp_id, copp_id);
-		memset(payload.copp_ids, COPP_IGNORE,
+		(void)memset(payload.copp_ids, COPP_IGNORE,
 				(sizeof(unsigned int) * AFE_MAX_PORTS));
 		num_copps = msm_check_multicopp_per_stream(popp_id, &payload);
 		/* Multiple streams per copp is handled, one stream at a time */
@@ -1387,7 +1387,7 @@ void broadcast_event(u32 evt_id, u32 dev_id, u64 session_id)
 			}
 		}
 		clnt_id = callback->clnt_id;
-		memset(evt_payload, 0, sizeof(union auddev_evt_data));
+		(void)memset(evt_payload, 0, sizeof(union auddev_evt_data));
 
 		if ((evt_id == AUDDEV_EVT_START_VOICE)
 			|| (evt_id == AUDDEV_EVT_END_VOICE)
@@ -1573,7 +1573,7 @@ voc_events:
 				}
 			} else if ((evt_id == AUDDEV_EVT_START_VOICE)
 					|| (evt_id == AUDDEV_EVT_END_VOICE)) {
-				memset(evt_payload, 0,
+				(void)memset(evt_payload, 0,
 					sizeof(union auddev_evt_data));
 
 				evt_payload->voice_session_id = session_id;
@@ -1697,7 +1697,7 @@ static int __init audio_dev_ctrl_init(void)
 	mutex_init(&routing_info.copp_list_mutex);
 	mutex_init(&routing_info.adm_mutex);
 
-	memset(routing_info.copp_list, COPP_IGNORE,
+	(void)memset(routing_info.copp_list, COPP_IGNORE,
 		(sizeof(unsigned int) * MAX_SESSIONS * AFE_MAX_PORTS));
 	return misc_register(&audio_dev_ctrl_misc);
 }
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
index 3225d61..7300007 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
@@ -705,7 +705,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		struct msm_audio_stats stats;
 
 		pr_debug("%s: AUDIO_GET_STATS cmd\n", __func__);
-		memset(&stats, 0, sizeof(stats));
+		(void)memset(&stats, 0, sizeof(stats));
 		timestamp = q6asm_get_session_time(audio->ac);
 		if (timestamp < 0) {
 			pr_err("%s: Get Session Time return value =%lld\n",
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_mvs.c b/arch/arm/mach-msm/qdsp6v2/audio_mvs.c
index 6e7961c..c5c1d74 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_mvs.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_mvs.c
@@ -1126,7 +1126,7 @@ static int __init audio_mvs_init(void)
 {
 	int rc = 0;
 
-	memset(&audio_mvs_info, 0, sizeof(audio_mvs_info));
+	(void)memset(&audio_mvs_info, 0, sizeof(audio_mvs_info));
 
 	init_waitqueue_head(&audio_mvs_info.in_wait);
 	init_waitqueue_head(&audio_mvs_info.out_wait);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils.c b/arch/arm/mach-msm/qdsp6v2/audio_utils.c
index f9445d8..fe4e8fe 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils.c
@@ -65,7 +65,7 @@ static int audio_in_flush(struct q6audio_in  *audio)
 	}
 	audio->rflush = 1;
 	audio->wflush = 1;
-	memset(audio->out_frame_info, 0, sizeof(audio->out_frame_info));
+	(void)memset(audio->out_frame_info, 0, sizeof(audio->out_frame_info));
 	wake_up(&audio->read_wait);
 	/* get read_lock to ensure no more waiting read thread */
 	mutex_lock(&audio->read_lock);
@@ -144,7 +144,7 @@ int audio_in_disable(struct q6audio_in  *audio)
 				session rc=%d\n", __func__, audio->ac->session,
 				rc);
 		audio->stopped = 1;
-		memset(audio->out_frame_info, 0,
+		(void)memset(audio->out_frame_info, 0,
 				sizeof(audio->out_frame_info));
 		wake_up(&audio->read_wait);
 		wake_up(&audio->write_wait);
@@ -264,7 +264,7 @@ long audio_in_ioctl(struct file *file,
 	}
 	case AUDIO_GET_STREAM_CONFIG: {
 		struct msm_audio_stream_config cfg;
-		memset(&cfg, 0, sizeof(cfg));
+		(void)memset(&cfg, 0, sizeof(cfg));
 		cfg.buffer_size = audio->str_cfg.buffer_size;
 		cfg.buffer_count = audio->str_cfg.buffer_count;
 		if (copy_to_user((void *)arg, &cfg, sizeof(cfg)))
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
index c1b5e8b..617360e 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
@@ -104,7 +104,7 @@ static void extract_meta_out_info(struct q6audio_aio *audio,
 			memcpy(&buf_node->meta_info.meta_in,
 			(char *)buf_node->kvaddr, sizeof(struct dec_meta_in));
 		else
-			memset(&buf_node->meta_info.meta_in,
+			(void)memset(&buf_node->meta_info.meta_in,
 			0, sizeof(struct dec_meta_in));
 		pr_debug("%s[%p]:i/p: msw_ts 0x%lx lsw_ts 0x%lx nflags 0x%8x\n",
 			__func__, audio,
@@ -378,7 +378,7 @@ void audio_aio_async_out_flush(struct q6audio_aio *audio)
 			" eos i/p buffer immediately\n", __func__, audio);
 		audio_aio_post_event(audio, AUDIO_EVENT_WRITE_DONE,
 				audio->eos_write_payload);
-		memset(&audio->eos_write_payload , 0,
+		(void)memset(&audio->eos_write_payload , 0,
 			sizeof(union msm_audio_event_payload));
 	}
 	spin_unlock_irqrestore(&audio->dsp_lock, flags);
@@ -452,7 +452,7 @@ void audio_aio_cb(uint32_t opcode, uint32_t token,
 				audio_aio_post_event(audio,
 						AUDIO_EVENT_WRITE_DONE,
 						audio->eos_write_payload);
-				memset(&audio->eos_write_payload , 0,
+				(void)memset(&audio->eos_write_payload , 0,
 					sizeof(union msm_audio_event_payload));
 				audio->eos_flag = 0;
 			}
@@ -1306,7 +1306,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case AUDIO_GET_STREAM_CONFIG: {
 		struct msm_audio_stream_config cfg;
 		mutex_lock(&audio->lock);
-		memset(&cfg, 0, sizeof(cfg));
+		(void)memset(&cfg, 0, sizeof(cfg));
 		cfg.buffer_size = audio->str_cfg.buffer_size;
 		cfg.buffer_count = audio->str_cfg.buffer_count;
 		pr_debug("%s[%p]:GET STREAM CFG %d %d\n",
diff --git a/arch/arm/mach-msm/qdsp6v2/pcm_in.c b/arch/arm/mach-msm/qdsp6v2/pcm_in.c
index 1f20aa7..6d8938e 100644
--- a/arch/arm/mach-msm/qdsp6v2/pcm_in.c
+++ b/arch/arm/mach-msm/qdsp6v2/pcm_in.c
@@ -118,7 +118,7 @@ static int pcm_in_disable(struct pcm *pcm)
 		rc = q6asm_cmd(pcm->ac, CMD_CLOSE);
 
 		atomic_set(&pcm->in_stopped, 1);
-		memset(pcm->in_frame_info, 0,
+		(void)memset(pcm->in_frame_info, 0,
 				sizeof(char) * pcm->buffer_count * 2);
 		wake_up(&pcm->wait);
 	}
@@ -160,7 +160,7 @@ static long pcm_in_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	case AUDIO_GET_STATS: {
 		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
+		(void)memset(&stats, 0, sizeof(stats));
 		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
 			rc = -EFAULT;
 		break;
@@ -417,7 +417,7 @@ static ssize_t pcm_in_read(struct file *file, char __user *buf,
 			buf += len;
 		}
 		atomic_dec(&pcm->in_count);
-		memset(&pcm->in_frame_info[idx], 0,
+		(void)memset(&pcm->in_frame_info[idx], 0,
 						sizeof(uint32_t) * 2);
 
 		rc = q6asm_read(pcm->ac);
diff --git a/arch/arm/mach-msm/qdsp6v2/pcm_out.c b/arch/arm/mach-msm/qdsp6v2/pcm_out.c
index a4a6b72..0045843 100644
--- a/arch/arm/mach-msm/qdsp6v2/pcm_out.c
+++ b/arch/arm/mach-msm/qdsp6v2/pcm_out.c
@@ -166,7 +166,7 @@ static long pcm_out_ioctl(struct file *file, unsigned int cmd,
 
 	if (cmd == AUDIO_GET_STATS) {
 		struct msm_audio_stats stats;
-		memset(&stats, 0, sizeof(stats));
+		(void)memset(&stats, 0, sizeof(stats));
 		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
 			return -EFAULT;
 		return 0;
diff --git a/arch/arm/mach-msm/qdsp6v2/q6core.c b/arch/arm/mach-msm/qdsp6v2/q6core.c
index edb1e7d..c250244 100644
--- a/arch/arm/mach-msm/qdsp6v2/q6core.c
+++ b/arch/arm/mach-msm/qdsp6v2/q6core.c
@@ -284,7 +284,7 @@ static ssize_t apr_debug_write(struct file *file, const char __user *buf,
 		hdr->dest_port = 0;
 		hdr->token = 0;
 		hdr->opcode = 0x12345678;
-		memset(l_buf + 20, 9, 4060);
+		(void)memset(l_buf + 20, 9, 4060);
 
 		apr_send_pkt(apr_handle_q, (uint32_t *)l_buf);
 		pr_debug("Write_q\n");
@@ -299,7 +299,7 @@ static ssize_t apr_debug_write(struct file *file, const char __user *buf,
 		hdr->dest_port = 0;
 		hdr->token = 0;
 		hdr->opcode = 0x12345678;
-		memset(l_buf + 30, 9, 4060);
+		(void)memset(l_buf + 30, 9, 4060);
 
 		apr_send_pkt(apr_handle_m, (uint32_t *)l_buf);
 		pr_info("Write_m\n");
@@ -314,7 +314,7 @@ static ssize_t apr_debug_write(struct file *file, const char __user *buf,
 		hdr->dest_port = 0;
 		hdr->token = 0;
 		hdr->opcode = 0x12345678;
-		memset(l_buf + 30, 9, 4060);
+		(void)memset(l_buf + 30, 9, 4060);
 
 		apr_send_pkt(apr_handle_q, (uint32_t *)l_buf);
 		pr_info("Write_q\n");
@@ -329,7 +329,7 @@ static ssize_t apr_debug_write(struct file *file, const char __user *buf,
 		hdr->dest_port = 0;
 		hdr->token = 0;
 		hdr->opcode = 0x12345678;
-		memset(l_buf + 30, 9, 4060);
+		(void)memset(l_buf + 30, 9, 4060);
 
 		apr_send_pkt(apr_handle_m, (uint32_t *)l_buf);
 		pr_info("Write_m\n");
diff --git a/arch/arm/mach-msm/qdsp6v2/q6voice.c b/arch/arm/mach-msm/qdsp6v2/q6voice.c
index 34169c0..b8feb85 100644
--- a/arch/arm/mach-msm/qdsp6v2/q6voice.c
+++ b/arch/arm/mach-msm/qdsp6v2/q6voice.c
@@ -2906,7 +2906,7 @@ static int __init voice_init(void)
 {
 	int rc = 0, i = 0;
 
-	memset(&common, 0, sizeof(struct common_data));
+	(void)memset(&common, 0, sizeof(struct common_data));
 
 	/* set default value */
 	common.default_mute_val = 1;  /* default is mute */
diff --git a/arch/arm/mach-msm/qdsp6v2/rtac.c b/arch/arm/mach-msm/qdsp6v2/rtac.c
index 9823209..9314611 100644
--- a/arch/arm/mach-msm/qdsp6v2/rtac.c
+++ b/arch/arm/mach-msm/qdsp6v2/rtac.c
@@ -206,7 +206,7 @@ static void shift_adm_devices(u32 dev_idx)
 		memcpy(&rtac_adm_data.device[dev_idx],
 			&rtac_adm_data.device[dev_idx + 1],
 			sizeof(rtac_adm_data.device[dev_idx]));
-		memset(&rtac_adm_data.device[dev_idx + 1], 0,
+		(void)memset(&rtac_adm_data.device[dev_idx + 1], 0,
 			   sizeof(rtac_adm_data.device[dev_idx]));
 	}
 }
@@ -218,7 +218,7 @@ static void shift_popp(u32 copp_idx, u32 popp_idx)
 		memcpy(&rtac_adm_data.device[copp_idx].popp[popp_idx],
 			&rtac_adm_data.device[copp_idx].popp[popp_idx + 1],
 			sizeof(uint32_t));
-		memset(&rtac_adm_data.device[copp_idx].popp[popp_idx + 1], 0,
+		(void)memset(&rtac_adm_data.device[copp_idx].popp[popp_idx + 1], 0,
 			   sizeof(uint32_t));
 	}
 }
@@ -232,7 +232,7 @@ void rtac_remove_adm_device(u32 port_id)
 	/* look for device */
 	for (i = 0; i < rtac_adm_data.num_of_dev; i++) {
 		if (rtac_adm_data.device[i].afe_port == port_id) {
-			memset(&rtac_adm_data.device[i], 0,
+			(void)memset(&rtac_adm_data.device[i], 0,
 				   sizeof(rtac_adm_data.device[i]));
 			rtac_adm_data.num_of_dev--;
 
@@ -340,7 +340,7 @@ void rtac_remove_voice(u32 cvs_handle)
 		if (rtac_voice_data.voice[i].cvs_handle == cvs_handle) {
 			shift_voice_devices(i);
 			rtac_voice_data.num_of_voice_combos--;
-			memset(&rtac_voice_data.voice[
+			(void)memset(&rtac_voice_data.voice[
 				rtac_voice_data.num_of_voice_combos], 0,
 				sizeof(rtac_voice_data.voice
 				[rtac_voice_data.num_of_voice_combos]));
@@ -966,7 +966,7 @@ static int __init rtac_init(void)
 	pr_debug("%s\n", __func__);
 
 	/* ADM */
-	memset(&rtac_adm_data, 0, sizeof(rtac_adm_data));
+	(void)memset(&rtac_adm_data, 0, sizeof(rtac_adm_data));
 	rtac_adm_apr_data.apr_handle = NULL;
 	atomic_set(&rtac_adm_apr_data.cmd_state, 0);
 	init_waitqueue_head(&rtac_adm_apr_data.cmd_wait);
@@ -996,7 +996,7 @@ static int __init rtac_init(void)
 	}
 
 	/* Voice */
-	memset(&rtac_voice_data, 0, sizeof(rtac_voice_data));
+	(void)memset(&rtac_voice_data, 0, sizeof(rtac_voice_data));
 	for (i = 0; i < RTAC_VOICE_MODES; i++) {
 		rtac_voice_apr_data[i].apr_handle = NULL;
 		atomic_set(&rtac_voice_apr_data[i].cmd_state, 0);
diff --git a/arch/arm/mach-msm/rmt_storage_client.c b/arch/arm/mach-msm/rmt_storage_client.c
index 4bec55d..c77fdbb 100644
--- a/arch/arm/mach-msm/rmt_storage_client.c
+++ b/arch/arm/mach-msm/rmt_storage_client.c
@@ -988,7 +988,7 @@ static long rmt_storage_ioctl(struct file *fp, unsigned int cmd,
 		atomic_dec(&rmc->total_events);
 
 		kevent = get_event(rmc);
-		WARN_ON(kevent == NULL);
+		(void)WARN_ON(kevent == NULL);
 		if (copy_to_user((void __user *)arg, &kevent->event,
 			sizeof(struct rmt_storage_event))) {
 			pr_err("%s: copy to user failed\n\n", __func__);
diff --git a/arch/arm/mach-msm/rpm.c b/arch/arm/mach-msm/rpm.c
index a8d787a..0c60ade 100644
--- a/arch/arm/mach-msm/rpm.c
+++ b/arch/arm/mach-msm/rpm.c
@@ -459,7 +459,7 @@ static int msm_rpm_clear_common(
 		r[i].value = sel_masks[i];
 	}
 
-	memset(sel_masks, 0, sizeof(sel_masks));
+	(void)memset(sel_masks, 0, sizeof(sel_masks));
 	sel_masks[msm_rpm_get_sel_mask_reg(MSM_RPM_SEL_INVALIDATE)] |=
 		msm_rpm_get_sel_mask(MSM_RPM_SEL_INVALIDATE);
 
@@ -488,7 +488,7 @@ static int msm_rpm_clear_common(
 		r[i].value = sel_masks[i];
 	}
 
-	memset(sel_masks, 0, sizeof(sel_masks));
+	(void)memset(sel_masks, 0, sizeof(sel_masks));
 	sel_masks[msm_rpm_get_sel_mask_reg(msm_rpm_data.sel_invalidate)] |=
 		msm_rpm_get_sel_mask(msm_rpm_data.sel_invalidate);
 
@@ -650,7 +650,7 @@ EXPORT_SYMBOL(msm_rpm_set);
  */
 int msm_rpm_set_noirq(int ctx, struct msm_rpm_iv_pair *req, int count)
 {
-	WARN(!irqs_disabled(), "msm_rpm_set_noirq can only be called "
+	(void)WARN(!irqs_disabled(), "msm_rpm_set_noirq can only be called "
 		"safely when local irqs are disabled.  Consider using "
 		"msm_rpm_set or msm_rpm_set_nosleep instead.");
 	return msm_rpm_set_common(ctx, req, count, true);
@@ -689,7 +689,7 @@ EXPORT_SYMBOL(msm_rpm_clear);
  */
 int msm_rpm_clear_noirq(int ctx, struct msm_rpm_iv_pair *req, int count)
 {
-	WARN(!irqs_disabled(), "msm_rpm_clear_noirq can only be called "
+	(void)WARN(!irqs_disabled(), "msm_rpm_clear_noirq can only be called "
 		"safely when local irqs are disabled.  Consider using "
 		"msm_rpm_clear or msm_rpm_clear_nosleep instead.");
 	return msm_rpm_clear_common(ctx, req, count, true);
diff --git a/arch/arm/mach-msm/rpm_resources.c b/arch/arm/mach-msm/rpm_resources.c
index 3568070..7f2b789 100644
--- a/arch/arm/mach-msm/rpm_resources.c
+++ b/arch/arm/mach-msm/rpm_resources.c
@@ -784,7 +784,7 @@ int msm_rpmrs_set(int ctx, struct msm_rpm_iv_pair *req, int count)
 
 int msm_rpmrs_set_noirq(int ctx, struct msm_rpm_iv_pair *req, int count)
 {
-	WARN(!irqs_disabled(), "msm_rpmrs_set_noirq can only be called "
+	(void)WARN(!irqs_disabled(), "msm_rpmrs_set_noirq can only be called "
 		"safely when local irqs are disabled.  Consider using "
 		"msm_rpmrs_set or msm_rpmrs_set_nosleep instead.");
 	return msm_rpmrs_set_common(ctx, req, count, true);
@@ -840,7 +840,7 @@ int msm_rpmrs_clear(int ctx, struct msm_rpm_iv_pair *req, int count)
 
 int msm_rpmrs_clear_noirq(int ctx, struct msm_rpm_iv_pair *req, int count)
 {
-	WARN(!irqs_disabled(), "msm_rpmrs_clear_noirq can only be called "
+	(void)WARN(!irqs_disabled(), "msm_rpmrs_clear_noirq can only be called "
 		"safely when local irqs are disabled.  Consider using "
 		"msm_rpmrs_clear or msm_rpmrs_clear_nosleep instead.");
 	return msm_rpmrs_clear_common(ctx, req, count, true);
diff --git a/arch/arm/mach-msm/rpm_stats.c b/arch/arm/mach-msm/rpm_stats.c
index a831bd5..b387b29 100644
--- a/arch/arm/mach-msm/rpm_stats.c
+++ b/arch/arm/mach-msm/rpm_stats.c
@@ -108,7 +108,7 @@ static int msm_rpmstats_copy_stats(struct msm_rpmstats_private_data *pdata)
 
 	if (record.id == ID_ACCUM_TIME_SCLK) {
 		usec = record.val * USEC_PER_SEC;
-		do_div(usec, SCLK_HZ);
+		(void)do_div(usec, SCLK_HZ);
 	}  else
 		usec = (unsigned long)record.val;
 
diff --git a/arch/arm/mach-msm/smd.c b/arch/arm/mach-msm/smd.c
index 514f817..e79cdb5 100644
--- a/arch/arm/mach-msm/smd.c
+++ b/arch/arm/mach-msm/smd.c
@@ -1433,7 +1433,7 @@ static int smd_alloc_loopback_channel(void)
 	ch->update_state = update_stream_state;
 	ch->read_from_cb = smd_stream_read;
 
-	memset(ch->name, 0, 20);
+	(void)memset(ch->name, 0, 20);
 	memcpy(ch->name, "local_loopback", 14);
 
 	ch->pdev.name = ch->name;
diff --git a/arch/arm/mach-msm/smd_rpcrouter.c b/arch/arm/mach-msm/smd_rpcrouter.c
index 983d0c1..61db607 100644
--- a/arch/arm/mach-msm/smd_rpcrouter.c
+++ b/arch/arm/mach-msm/smd_rpcrouter.c
@@ -452,7 +452,7 @@ static struct rr_server *rpcrouter_create_server(uint32_t pid,
 	if (!server)
 		return ERR_PTR(-ENOMEM);
 
-	memset(server, 0, sizeof(struct rr_server));
+	(void)memset(server, 0, sizeof(struct rr_server));
 	server->pid = pid;
 	server->cid = cid;
 	server->prog = prog;
@@ -573,7 +573,7 @@ struct msm_rpc_endpoint *msm_rpcrouter_create_local_endpoint(dev_t dev)
 	ept = kmalloc(sizeof(struct msm_rpc_endpoint), GFP_KERNEL);
 	if (!ept)
 		return NULL;
-	memset(ept, 0, sizeof(struct msm_rpc_endpoint));
+	(void)memset(ept, 0, sizeof(struct msm_rpc_endpoint));
 	ept->cid = (uint32_t) ept;
 	ept->pid = RPCROUTER_PID_LOCAL;
 	ept->dev = dev;
@@ -675,7 +675,7 @@ static int rpcrouter_create_remote_endpoint(uint32_t pid, uint32_t cid)
 	new_c = kmalloc(sizeof(struct rr_remote_endpoint), GFP_KERNEL);
 	if (!new_c)
 		return -ENOMEM;
-	memset(new_c, 0, sizeof(struct rr_remote_endpoint));
+	(void)memset(new_c, 0, sizeof(struct rr_remote_endpoint));
 
 	new_c->cid = cid;
 	new_c->pid = pid;
@@ -772,7 +772,7 @@ static int process_control_msg(struct rpcrouter_xprt_info *xprt_info,
 	switch (msg->cmd) {
 	case RPCROUTER_CTRL_CMD_HELLO:
 		RR("o HELLO PID %d\n", xprt_info->remote_pid);
-		memset(&ctl, 0, sizeof(ctl));
+		(void)memset(&ctl, 0, sizeof(ctl));
 		ctl.cmd = RPCROUTER_CTRL_CMD_HELLO;
 		rpcrouter_send_control_msg(xprt_info, &ctl);
 
@@ -1225,7 +1225,7 @@ fail_data:
 void msm_rpc_setup_req(struct rpc_request_hdr *hdr, uint32_t prog,
 		       uint32_t vers, uint32_t proc)
 {
-	memset(hdr, 0, sizeof(struct rpc_request_hdr));
+	(void)memset(hdr, 0, sizeof(struct rpc_request_hdr));
 	hdr->xid = cpu_to_be32(atomic_add_return(1, &next_xid));
 	hdr->rpc_vers = cpu_to_be32(2);
 	hdr->prog = cpu_to_be32(prog);
@@ -1506,7 +1506,7 @@ static struct msm_rpc_reply *get_avail_reply(struct msm_rpc_endpoint *ept)
 		if (!reply)
 			return 0;
 		D("Adding reply 0x%08x \n", (unsigned int)reply);
-		memset(reply, 0, sizeof(struct msm_rpc_reply));
+		(void)memset(reply, 0, sizeof(struct msm_rpc_reply));
 		spin_lock_irqsave(&ept->reply_q_lock, flags);
 		ept->reply_cnt++;
 		spin_unlock_irqrestore(&ept->reply_q_lock, flags);
@@ -1729,7 +1729,7 @@ int msm_rpc_call_reply(struct msm_rpc_endpoint *ept, uint32_t proc,
 	if (ept->dst_pid == 0xffffffff)
 		return -ENOTCONN;
 
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 	req->xid = cpu_to_be32(atomic_add_return(1, &next_xid));
 	req->rpc_vers = cpu_to_be32(2);
 	req->prog = ept->dst_prog;
diff --git a/arch/arm/mach-msm/smd_rpcrouter_xdr.c b/arch/arm/mach-msm/smd_rpcrouter_xdr.c
index 1793516..3bf5349 100644
--- a/arch/arm/mach-msm/smd_rpcrouter_xdr.c
+++ b/arch/arm/mach-msm/smd_rpcrouter_xdr.c
@@ -85,7 +85,7 @@ int xdr_send_bytes(struct msm_rpc_xdr *xdr, const void **data,
 	memcpy(buf, *data, *size);
 	buf += *size;
 	if (*size & 0x3) {
-		memset(buf, 0, 4 - (*size & 0x3));
+		(void)memset(buf, 0, 4 - (*size & 0x3));
 		buf += 4 - (*size & 0x3);
 	}
 
diff --git a/arch/arm/mach-msm/socinfo.c b/arch/arm/mach-msm/socinfo.c
index 9a8ab43..6550d30 100644
--- a/arch/arm/mach-msm/socinfo.c
+++ b/arch/arm/mach-msm/socinfo.c
@@ -642,8 +642,8 @@ int __init socinfo_init(void)
 		socinfo = setup_dummy_socinfo();
 	}
 
-	WARN(!socinfo_get_id(), "Unknown SOC ID!\n");
-	WARN(socinfo_get_id() >= ARRAY_SIZE(cpu_of_id),
+	(void)WARN(!socinfo_get_id(), "Unknown SOC ID!\n");
+	(void)WARN(socinfo_get_id() >= ARRAY_SIZE(cpu_of_id),
 		"New IDs added! ID => CPU mapping might need an update.\n");
 
 	if (socinfo->v1.id < ARRAY_SIZE(cpu_of_id))
diff --git a/arch/arm/mach-msm/subsystem_map.c b/arch/arm/mach-msm/subsystem_map.c
index b5ff244..5078f8d 100644
--- a/arch/arm/mach-msm/subsystem_map.c
+++ b/arch/arm/mach-msm/subsystem_map.c
@@ -120,7 +120,7 @@ static int add_buffer(struct msm_buffer_node *node)
 			else if (key > tmp->buf->vaddr)
 				p = &(*p)->rb_right;
 			else {
-				WARN(1, "tried to add buffer twice! buf = %p"
+				(void)WARN(1, "tried to add buffer twice! buf = %p"
 					" vaddr = %p iova = %p", tmp->buf,
 					tmp->buf->vaddr,
 					tmp->buf->iova);
@@ -134,7 +134,7 @@ static int add_buffer(struct msm_buffer_node *node)
 			else if (key > (void *)tmp->buf)
 				p = &(*p)->rb_right;
 			else {
-				WARN(1, "tried to add buffer twice! buf = %p"
+				(void)WARN(1, "tried to add buffer twice! buf = %p"
 					" vaddr = %p iova = %p", tmp->buf,
 					tmp->buf->vaddr,
 					tmp->buf->iova);
@@ -167,7 +167,7 @@ static int add_buffer_phys(struct msm_buffer_node *node)
 			else if (node->phys > tmp->phys)
 				p = &(*p)->rb_right;
 			else {
-				WARN(1, "tried to add buffer twice! buf = %p"
+				(void)WARN(1, "tried to add buffer twice! buf = %p"
 					" vaddr = %p iova = %p", tmp->buf,
 					tmp->buf->vaddr,
 					tmp->buf->iova);
@@ -267,7 +267,7 @@ struct msm_mapped_buffer *msm_subsystem_map_buffer(unsigned long phys,
 		old_buffer = find_buffer_phys(phys);
 
 		if (old_buffer) {
-			WARN(1, "%s: Attempting to map %lx twice in the kernel"
+			(void)WARN(1, "%s: Attempting to map %lx twice in the kernel"
 				" virtual space. Don't do that!\n", __func__,
 				phys);
 			err = ERR_PTR(-EINVAL);
@@ -478,7 +478,7 @@ int msm_subsystem_unmap_buffer(struct msm_mapped_buffer *buf)
 					ret = iommu_unmap(subsys_domain,
 							temp_va,
 							get_order(SZ_4K));
-					WARN(ret, "iommu_unmap returned a "
+					(void)WARN(ret, "iommu_unmap returned a "
 						" non-zero value.\n");
 				}
 				msm_free_iova_address(buf->iova[i], domain_no,
diff --git a/arch/arm/mach-msm/subsystem_restart.c b/arch/arm/mach-msm/subsystem_restart.c
index 78a6203..acfbba0 100644
--- a/arch/arm/mach-msm/subsystem_restart.c
+++ b/arch/arm/mach-msm/subsystem_restart.c
@@ -583,7 +583,7 @@ static int __init ssr_init_soc_restart_orders(void)
 	}
 
 	if (restart_orders == NULL || n_restart_orders < 1) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EINVAL;
 	}
 
diff --git a/arch/arm/mach-msm/timer.c b/arch/arm/mach-msm/timer.c
index 67b1f7b..53f4f31 100644
--- a/arch/arm/mach-msm/timer.c
+++ b/arch/arm/mach-msm/timer.c
@@ -411,7 +411,7 @@ uint32_t msm_timer_get_sclk_ticks(void)
 	int loop_count = 10;
 	int loop_zero_count = 3;
 	int tmp = USEC_PER_SEC;
-	do_div(tmp, sclk_hz);
+	(void)do_div(tmp, sclk_hz);
 	tmp /= (loop_zero_count-1);
 
 	while (loop_zero_count--) {
@@ -652,7 +652,7 @@ static void msm_timer_sync_update(struct msm_timer_sync_data_t *data,
 		   rounding error */
 		temp = src_clk_val;
 		temp *= dst_clk->freq << dst_clk->shift;
-		do_div(temp, src_clk_freq);
+		(void)do_div(temp, src_clk_freq);
 
 		new_offset = (uint32_t)(temp) - dst_clk_val;
 	}
@@ -718,7 +718,7 @@ static void msm_timer_sync_to_gpt(struct msm_clock *clock, int exit_sleep)
 	u64 gpt_period = (1ULL << 32) * HZ;
 	u64 now = get_jiffies_64();
 
-	do_div(gpt_period, gpt_hz);
+	(void)do_div(gpt_period, gpt_hz);
 
 	BUG_ON(clock == gpt_clk);
 
@@ -881,7 +881,7 @@ int64_t msm_timer_get_sclk_time(int64_t *period)
 	uint32_t clock_value;
 	int64_t tmp;
 
-	memset(&data, 0, sizeof(data));
+	(void)memset(&data, 0, sizeof(data));
 	clock_value = msm_timer_do_sync_to_sclk(
 		msm_timer_get_sclk_time_start,
 		msm_timer_get_sclk_time_expired,
@@ -894,13 +894,13 @@ int64_t msm_timer_get_sclk_time(int64_t *period)
 	if (period) {
 		tmp = 1LL << 32;
 		tmp *= NSEC_PER_SEC;
-		do_div(tmp, sclk_hz);
+		(void)do_div(tmp, sclk_hz);
 		*period = tmp;
 	}
 
 	tmp = (int64_t)clock_value;
 	tmp *= NSEC_PER_SEC;
-	do_div(tmp, sclk_hz);
+	(void)do_div(tmp, sclk_hz);
 	return tmp;
 }
 
@@ -1021,7 +1021,7 @@ static void __init msm_timer_init(void)
 			dgt->flags |= MSM_CLOCK_FLAGS_UNSTABLE_COUNT;
 		}
 	} else {
-		WARN(1, "Timer running on unknown hardware. Configure this! "
+		(void)WARN(1, "Timer running on unknown hardware. Configure this! "
 			"Assuming default configuration.\n");
 		dgt->freq = 6750000;
 	}
@@ -1047,7 +1047,7 @@ static void __init msm_timer_init(void)
 
 			temp = clock->freq << clock->shift;
 			temp <<= 32;
-			do_div(temp, gpt_hz);
+			(void)do_div(temp, gpt_hz);
 
 			clock->rollover_offset = (uint32_t) temp;
 		}
diff --git a/arch/arm/mm/ioremap.c b/arch/arm/mm/ioremap.c
index 17e7b0b..6ef0a90 100644
--- a/arch/arm/mm/ioremap.c
+++ b/arch/arm/mm/ioremap.c
@@ -208,7 +208,7 @@ void __iomem * __arm_ioremap_pfn_caller(unsigned long pfn,
 		printk(KERN_WARNING "BUG: Your driver calls ioremap() on system memory.  This leads\n"
 		       KERN_WARNING "to architecturally unpredictable behaviour on ARMv6+, and ioremap()\n"
 		       KERN_WARNING "will fail in the next kernel release.  Please fix your driver.\n");
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	}
 
 	type = get_mem_type(mtype);
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 7f15e65..1fd6cc9 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -556,7 +556,7 @@ EXPORT_SYMBOL(phys_mem_access_prot);
 static void __init *early_alloc(unsigned long sz)
 {
 	void *ptr = __va(memblock_alloc(sz, sz));
-	memset(ptr, 0, sz);
+	(void)memset(ptr, 0, sz);
 	return ptr;
 }
 
diff --git a/arch/arm/perfmon/per-process-perf.c b/arch/arm/perfmon/per-process-perf.c
index c8bebd8..ba62202 100644
--- a/arch/arm/perfmon/per-process-perf.c
+++ b/arch/arm/perfmon/per-process-perf.c
@@ -305,7 +305,7 @@ int per_process_results_read(char *page, char **start, off_t off, int count,
 	/*
 	* Total across all CPUS
 	*/
-	memset(&cnts, 0, sizeof(cnts));
+	(void)memset(&cnts, 0, sizeof(cnts));
 	for (i = 0; i < num_possible_cpus(); i++) {
 		cnts.swaps += p->cnts[i].swaps;
 		cnts.cycles += p->cnts[i].cycles;
@@ -338,7 +338,7 @@ int per_process_l2_results_read(char *page, char **start, off_t off, int count,
 	/*
 	* Total across all CPUS
 	*/
-	memset(&cnts, 0, sizeof(cnts));
+	(void)memset(&cnts, 0, sizeof(cnts));
 	for (i = 0; i < num_possible_cpus(); i++) {
 		cnts.l2_cycles += p->cnts[i].l2_cycles;
 		for (j = 0; j < PERF_NUM_MONITORS; j++)
@@ -575,7 +575,7 @@ void per_process_remove_manual(unsigned long pid)
 	/*
 	* Clear them out...and ensure the pid is invalid
 	*/
-	memset(p, 0, sizeof *p);
+	(void)memset(p, 0, sizeof *p);
 	p->pid = 0xFFFFFFFF;
 	pm_remove_pid = -1;
 }
@@ -770,7 +770,7 @@ void _per_process_switch(unsigned long old_pid, unsigned long new_pid)
 		struct per_process_perf_mon_type *p_clear =
 			per_process_find(pp_clear_pid);
 		if (p_clear) {
-			memset(p_clear->cnts, 0,
+			(void)memset(p_clear->cnts, 0,
 			sizeof(struct pm_counters_s)*num_possible_cpus());
 			printk(KERN_INFO "Clear Per Processor Stats for \
 				PID:%ld\n", pp_clear_pid);
@@ -1155,7 +1155,7 @@ int per_process_perf_init(void)
 	l2_dir = proc_mkdir("l2", proc_dir);
 	l2_results_dir = proc_mkdir("results", l2_dir);
 
-	memset(perf_mons, 0, sizeof(perf_mons));
+	(void)memset(perf_mons, 0, sizeof(perf_mons));
 	per_process_create_results_proc(&perf_mons[0]);
 	per_process_create_l2_results_proc(&perf_mons[0]);
 	thread_register_notifier(&perfmon_notifier_block);
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index d25fabf..9f9953b 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -56,7 +56,7 @@ static void vfp_thread_flush(struct thread_info *thread)
 	union vfp_state *vfp = &thread->vfpstate;
 	unsigned int cpu;
 
-	memset(vfp, 0, sizeof(union vfp_state));
+	(void)memset(vfp, 0, sizeof(union vfp_state));
 
 	vfp->hard.fpexc = FPEXC_EN;
 	vfp->hard.fpscr = FPSCR_ROUND_NEAREST;
@@ -183,7 +183,7 @@ static void vfp_raise_sigfpe(unsigned int sicode, struct pt_regs *regs)
 {
 	siginfo_t info;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 
 	info.si_signo = SIGFPE;
 	info.si_code = sicode;
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 9698160..d318661 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -46,7 +46,7 @@ KBUILD_CPPFLAGS	+= -mbig-endian
 AS		+= -EB
 LD		+= -EB
 else
-KBUILD_CPPFLAGS	+= -mlittle-endian
+#KBUILD_CPPFLAGS	+= -mlittle-endian
 AS		+= -EL
 LD		+= -EL
 endif
@@ -113,7 +113,7 @@ endif
 endif
 
 # Need -Uarm for gcc < 3.x
-KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
+KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) -msoft-float -Uarm
 KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h -msoft-float
 
 CHECKFLAGS	+= -D__arm__

