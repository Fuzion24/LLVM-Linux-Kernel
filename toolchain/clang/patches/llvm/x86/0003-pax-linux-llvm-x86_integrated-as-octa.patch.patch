From 82f3cc0f20a24bc705fdf5ddf3e7b882c0ddca13 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan-Simon=20M=C3=B6ller?= <dl9pf@gmx.de>
Date: Tue, 10 Jul 2012 13:39:58 +0200
Subject: [PATCH 3/6] pax-linux-llvm x86_integrated-as-octa.patch

Patch from series at http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20120507/142707.html by PaX Team.
---
 include/llvm/MC/MCParser/MCAsmLexer.h |   17 +++++++++++++----
 lib/MC/MCParser/AsmLexer.cpp          |    4 ++--
 lib/MC/MCParser/AsmParser.cpp         |    3 +++
 3 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/include/llvm/MC/MCParser/MCAsmLexer.h b/include/llvm/MC/MCParser/MCAsmLexer.h
index 5e29ad4..a98f850 100644
--- a/include/llvm/MC/MCParser/MCAsmLexer.h
+++ b/include/llvm/MC/MCParser/MCAsmLexer.h
@@ -10,6 +10,7 @@
 #ifndef LLVM_MC_MCASMLEXER_H
 #define LLVM_MC_MCASMLEXER_H
 
+#include "llvm/ADT/APInt.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/DataTypes.h"
 #include "llvm/Support/SMLoc.h"
@@ -58,12 +59,14 @@ private:
   /// a memory buffer owned by the source manager.
   StringRef Str;
 
-  int64_t IntVal;
+  APInt IntVal;
 
 public:
   AsmToken() {}
-  AsmToken(TokenKind _Kind, StringRef _Str, int64_t _IntVal = 0)
+  AsmToken(TokenKind _Kind, StringRef _Str, APInt _IntVal)
     : Kind(_Kind), Str(_Str), IntVal(_IntVal) {}
+  AsmToken(TokenKind _Kind, StringRef _Str, int64_t _IntVal = 0)
+    : Kind(_Kind), Str(_Str), IntVal(64, _IntVal, true) {}
 
   TokenKind getKind() const { return Kind; }
   bool is(TokenKind K) const { return Kind == K; }
@@ -100,15 +103,21 @@ public:
   // as a single token, then diagnose as an invalid number).
   int64_t getIntVal() const {
     assert(Kind == Integer && "This token isn't an integer!");
-    return IntVal;
+    return IntVal.getZExtValue();
   }
 
   /// getRegVal - Get the register number for the current token, which should
   /// be a register.
   unsigned getRegVal() const {
     assert(Kind == Register && "This token isn't a register!");
-    return static_cast<unsigned>(IntVal);
+    return static_cast<unsigned>(IntVal.getZExtValue());
+  }
+
+  APInt getAPIntVal() const {
+    assert(Kind == Integer && "This token isn't an integer!");
+    return IntVal;
   }
+
 };
 
 /// MCAsmLexer - Generic assembler lexer interface, for use by target specific
diff --git a/lib/MC/MCParser/AsmLexer.cpp b/lib/MC/MCParser/AsmLexer.cpp
index c76052d..bd7e969 100644
--- a/lib/MC/MCParser/AsmLexer.cpp
+++ b/lib/MC/MCParser/AsmLexer.cpp
@@ -239,7 +239,7 @@ AsmToken AsmLexer::LexDigit() {
     if (CurPtr == NumStart)
       return ReturnError(CurPtr-2, "invalid hexadecimal number");
 
-    unsigned long long Result;
+    APInt Result(128, 0);
     if (StringRef(TokStart, CurPtr - TokStart).getAsInteger(0, Result))
       return ReturnError(TokStart, "invalid hexadecimal number");
 
@@ -248,7 +248,7 @@ AsmToken AsmLexer::LexDigit() {
     SkipIgnoredIntegerSuffix(CurPtr);
 
     return AsmToken(AsmToken::Integer, StringRef(TokStart, CurPtr - TokStart),
-                    (int64_t)Result);
+                    Result);
   }
 
   // Must be an octal number, it starts with 0.
diff --git a/lib/MC/MCParser/AsmParser.cpp b/lib/MC/MCParser/AsmParser.cpp
index a559158..1f88fcd 100644
--- a/lib/MC/MCParser/AsmParser.cpp
+++ b/lib/MC/MCParser/AsmParser.cpp
@@ -234,6 +234,7 @@ private:
  // ".ascii", ".asciiz", ".string"
   bool ParseDirectiveAscii(StringRef IDVal, bool ZeroTerminated);
   bool ParseDirectiveValue(unsigned Size); // ".byte", ".long", ...
+  bool ParseDirectiveOctaValue(); // ".octa"
   bool ParseDirectiveRealValue(const fltSemantics &); // ".single", ...
   bool ParseDirectiveFill(); // ".fill"
   bool ParseDirectiveSpace(); // ".space"
@@ -1203,6 +1204,8 @@ bool AsmParser::ParseStatement() {
       return ParseDirectiveValue(8);
     if (IDVal == ".8byte")
       return ParseDirectiveValue(8);
+    if (IDVal == ".octa")
+      return ParseDirectiveOctaValue();
     if (IDVal == ".single" || IDVal == ".float")
       return ParseDirectiveRealValue(APFloat::IEEEsingle);
     if (IDVal == ".double")
@@ -1832,6 +1943,42 @@
   return false;
 }
 
+/// ParseDirectiveOctaValue
+///  ::= .octa [ hexconstant (, hexconstant)* ]
+bool AsmParser::ParseDirectiveOctaValue() {
+  if (getLexer().isNot(AsmToken::EndOfStatement)) {
+    CheckForValidSection();
+
+    for (;;) {
+      if (Lexer.getKind() != AsmToken::Integer)
+        return TokError("unknown token in expression");
+
+      APInt IntValue = getTok().getAPIntVal();
+      Lex();
+
+      assert(IntValue.isIntN(128) && "Invalid .octa constant");
+      if (MAI.isLittleEndian()) {
+        getStreamer().EmitIntValue(IntValue.getLoBits(64).getZExtValue(), 8, DEFAULT_ADDRSPACE);
+        getStreamer().EmitIntValue(IntValue.getHiBits(64).getZExtValue(), 8, DEFAULT_ADDRSPACE);
+      } else {
+        getStreamer().EmitIntValue(IntValue.getHiBits(64).getZExtValue(), 8, DEFAULT_ADDRSPACE);
+        getStreamer().EmitIntValue(IntValue.getLoBits(64).getZExtValue(), 8, DEFAULT_ADDRSPACE);
+      }
+
+      if (getLexer().is(AsmToken::EndOfStatement))
+        break;
+
+      // FIXME: Improve diagnostic.
+      if (getLexer().isNot(AsmToken::Comma))
+        return TokError("unexpected token in directive");
+      Lex();
+    }
+  }
+
+  Lex();
+  return false;
+}
+
 /// ParseDirectiveRealValue
 ///  ::= (.single | .double) [ expression (, expression)* ]
 bool AsmParser::ParseDirectiveRealValue(const fltSemantics &Semantics) {

-- 
1.7.3.4

