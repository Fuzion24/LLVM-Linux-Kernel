From: Weiming Zhao <weimingz@quicinc.com>
Date: Mon, 2 Apr 2012 09:54:08 -0700
Subject: [PATCH] Bug 6753: spport for 64-bit integer register input and %H
 modifier for inline ASM

This patch adds support for using paired GPR registers for
64-bit
integer input for inline ASM. It also supports %H
modifier for
inline ASM.
---
 include/llvm/Target/TargetLowering.h             |    8 +++++
 lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp |   32 +++++++++++++--------
 lib/Target/ARM/ARMAsmPrinter.cpp                 |   11 +++++++-
 lib/Target/ARM/ARMISelLowering.cpp               |   15 +++++++++-
 lib/Target/ARM/ARMISelLowering.h                 |    3 +-
 5 files changed, 53 insertions(+), 16 deletions(-)
 mode change 100755 => 100644 include/llvm/Target/TargetLowering.h

Index: llvm/include/llvm/Target/TargetLowering.h
===================================================================
--- llvm.orig/include/llvm/Target/TargetLowering.h	2012-07-20 15:11:41.000000000 -0400
+++ llvm/include/llvm/Target/TargetLowering.h	2012-07-20 15:16:40.449513047 -0400
@@ -1544,6 +1544,14 @@
     getRegForInlineAsmConstraint(const std::string &Constraint,
                                  EVT VT) const;
 
+  virtual std::pair<unsigned, const TargetRegisterClass*>
+    getRegForInlineAsmConstraint(const std::string &Constraint,
+                                 EVT VT,
+                                 SmallVectorImpl<unsigned> &AssignedPhyRegs
+                                ) const {
+      return getRegForInlineAsmConstraint(Constraint, VT);
+    }
+
   /// LowerXConstraint - try to replace an X constraint, which matches anything,
   /// with another that has more specific requirements based on the type of the
   /// corresponding operand.  This returns null if there is no replacement to
Index: llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
===================================================================
--- llvm.orig/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2012-07-20 15:11:41.000000000 -0400
+++ llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2012-07-20 15:18:23.806677107 -0400
@@ -5778,7 +5778,8 @@
 static void GetRegistersForValue(SelectionDAG &DAG,
                                  const TargetLowering &TLI,
                                  DebugLoc DL,
-                                 SDISelAsmOperandInfo &OpInfo) {
+                                 SDISelAsmOperandInfo &OpInfo,
+                                 SmallVector<unsigned, 8> &AssignedPhyRegs) {
   LLVMContext &Context = *DAG.getContext();
 
   MachineFunction &MF = DAG.getMachineFunction();
@@ -5788,7 +5789,8 @@
   // register class, find it.
   std::pair<unsigned, const TargetRegisterClass*> PhysReg =
     TLI.getRegForInlineAsmConstraint(OpInfo.ConstraintCode,
-                                     OpInfo.ConstraintVT);
+                                     OpInfo.ConstraintVT,
+                                     AssignedPhyRegs);
 
   unsigned NumRegs = 1;
   if (OpInfo.ConstraintVT != MVT::Other) {
@@ -5838,6 +5840,7 @@
 
     // This is a explicit reference to a physical register.
     Regs.push_back(AssignedReg);
+    AssignedPhyRegs.push_back(AssignedReg);
 
     // If this is an expanded reference, add the rest of the regs to Regs.
     if (NumRegs != 1) {
@@ -5850,9 +5853,9 @@
       for (; NumRegs; --NumRegs, ++I) {
         assert(I != RC->end() && "Ran out of registers to allocate!");
         Regs.push_back(*I);
+        AssignedPhyRegs.push_back(*I);
       }
     }
-
     OpInfo.AssignedRegs = RegsForValue(Regs, RegVT, ValueVT);
     return;
   }
@@ -5880,6 +5883,7 @@
 ///
 void SelectionDAGBuilder::visitInlineAsm(ImmutableCallSite CS) {
   const InlineAsm *IA = cast<InlineAsm>(CS.getCalledValue());
+  SmallVector<unsigned, 8> AssignedPhyRegs;
 
   /// ConstraintOperands - Information about all of the constraints.
   SDISelAsmOperandInfoVector ConstraintOperands;
@@ -5978,10 +5982,12 @@
       if (OpInfo.ConstraintVT != Input.ConstraintVT) {
         std::pair<unsigned, const TargetRegisterClass*> MatchRC =
           TLI.getRegForInlineAsmConstraint(OpInfo.ConstraintCode,
-                                           OpInfo.ConstraintVT);
+                                           OpInfo.ConstraintVT,
+                                           AssignedPhyRegs);
         std::pair<unsigned, const TargetRegisterClass*> InputRC =
           TLI.getRegForInlineAsmConstraint(Input.ConstraintCode,
-                                           Input.ConstraintVT);
+                                           Input.ConstraintVT,
+                                           AssignedPhyRegs);
         if ((OpInfo.ConstraintVT.isInteger() !=
              Input.ConstraintVT.isInteger()) ||
             (MatchRC.second != InputRC.second)) {
@@ -6045,18 +6051,18 @@
     // If this constraint is for a specific register, allocate it before
     // anything else.
     if (OpInfo.ConstraintType == TargetLowering::C_Register)
-      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo);
+      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo, AssignedPhyRegs);
   }
 
   // Second pass - Loop over all of the operands, assigning virtual or physregs
   // to register class operands.
+
   for (unsigned i = 0, e = ConstraintOperands.size(); i != e; ++i) {
     SDISelAsmOperandInfo &OpInfo = ConstraintOperands[i];
-
     // C_Register operands have already been allocated, Other/Memory don't need
     // to be.
     if (OpInfo.ConstraintType == TargetLowering::C_RegisterClass)
-      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo);
+      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo, AssignedPhyRegs);
   }
 
   // AsmNodeOperands - The operands for the ISD::INLINEASM node.
Index: llvm/lib/Target/ARM/ARMAsmPrinter.cpp
===================================================================
--- llvm.orig/lib/Target/ARM/ARMAsmPrinter.cpp	2012-07-20 15:11:41.000000000 -0400
+++ llvm/lib/Target/ARM/ARMAsmPrinter.cpp	2012-07-20 15:16:40.453512945 -0400
@@ -531,8 +531,17 @@
 
     // These modifiers are not yet supported.
     case 'h': // A range of VFP/NEON registers suitable for VLD1/VST1.
-    case 'H': // The highest-numbered register of a pair.
       return true;
+    case 'H': // The highest-numbered register of a pair.
+      if (!MI->getOperand(OpNum).isReg())
+        return true;
+      const MachineOperand &MO = MI->getOperand(OpNum);
+      if (!MO.isReg())
+        return true;
+      unsigned Reg = MO.getReg();
+      Reg = (Reg - ARM::R0) & 1 ? Reg : Reg + 1;
+      O << ARMInstPrinter::getRegisterName(Reg);
+      return false;
     }
   }
 
Index: llvm/lib/Target/ARM/ARMISelLowering.cpp
===================================================================
--- llvm.orig/lib/Target/ARM/ARMISelLowering.cpp	2012-07-20 15:11:41.000000000 -0400
+++ llvm/lib/Target/ARM/ARMISelLowering.cpp	2012-07-20 15:16:40.457512830 -0400
@@ -9356,7 +9356,8 @@
 typedef std::pair<unsigned, const TargetRegisterClass*> RCPair;
 RCPair
 ARMTargetLowering::getRegForInlineAsmConstraint(const std::string &Constraint,
-                                                EVT VT) const {
+                                                                       EVT VT,
+                            SmallVectorImpl<unsigned> &AssignedPhyRegs) const {
   if (Constraint.size() == 1) {
     // GCC ARM Constraint Letters
     switch (Constraint[0]) {
@@ -9369,6 +9370,15 @@
         return RCPair(0U, &ARM::hGPRRegClass);
       break;
     case 'r':
+      if (VT.getSizeInBits() == 64) {
+        SmallVectorImpl<unsigned>::iterator First = AssignedPhyRegs.begin(),
+          Last = AssignedPhyRegs.end();
+        for (unsigned Reg = ARM::R0; Reg < ARM::R12; Reg += 2)
+          if (std::find(First, Last, Reg) == Last &&
+              std::find(First, Last, Reg + 1) == Last)
+            return RCPair(Reg, &ARM::GPRRegClass);
+        return RCPair(0U, NULL);
+      }
       return RCPair(0U, &ARM::GPRRegClass);
     case 'w':
       if (VT == MVT::f32)
@@ -9395,7 +9405,8 @@
   if (StringRef("{cc}").equals_lower(Constraint))
     return std::make_pair(unsigned(ARM::CPSR), &ARM::CCRRegClass);
 
-  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT);
+  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT,
+                                                      AssignedPhyRegs);
 }
 
 /// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
Index: llvm/lib/Target/ARM/ARMISelLowering.h
===================================================================
--- llvm.orig/lib/Target/ARM/ARMISelLowering.h	2012-07-20 15:11:41.000000000 -0400
+++ llvm/lib/Target/ARM/ARMISelLowering.h	2012-07-20 15:16:40.457512830 -0400
@@ -336,7 +336,8 @@
 
     std::pair<unsigned, const TargetRegisterClass*>
       getRegForInlineAsmConstraint(const std::string &Constraint,
-                                   EVT VT) const;
+                             EVT VT,
+                             SmallVectorImpl<unsigned>& AssignedPhyRegs) const;
 
     /// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
     /// vector.  If it is invalid, don't add anything to Ops. If hasMemory is
