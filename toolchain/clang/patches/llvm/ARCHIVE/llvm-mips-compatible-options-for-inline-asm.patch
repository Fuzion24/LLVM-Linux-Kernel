From e2b9f0f5ce8199083307ecc20a629cfdc76b6891 Mon Sep 17 00:00:00 2001
From: Toma Tabacu <toma.tabacu@imgtec.com>
Date: Tue, 18 Nov 2014 15:26:08 +0000
Subject: [PATCH] [mips] Set GCC-compatible asssembler options before entering
 inline asm blocks.

This patch fixes the conflicts between inline asm blocks from Linux and
the surrounding assembly code generated by Clang.

Clang does not generate assembly in the same way as GCC.
The following are true for GCC at the beginning of an inline asm block, and are
not true for Clang:
* $at is enabled and assigned to $1 (.set at)
* macro instructions are enabled (.set macro)
* instruction reordering is enabled (.set reorder)

This version is a WIP.

Signed-off-by: Toma Tabacu <toma.tabacu@imgtec.com>
---
 include/llvm/CodeGen/AsmPrinter.h              |  2 ++
 lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp |  5 +++++
 lib/Target/Mips/MipsAsmPrinter.cpp             | 19 ++++++++++++++++-
 lib/Target/Mips/MipsAsmPrinter.h               |  7 ++++++-
 lib/Target/Mips/MipsISelDAGToDAG.cpp           | 10 ++++++++-
 lib/Target/Mips/MipsISelLowering.cpp           | 11 +++++-----
 lib/Target/Mips/MipsRegisterInfo.cpp           |  5 +++++
 lib/Target/Mips/MipsRegisterInfo.td            | 28 ++++++++++++++++++++++++++
 8 files changed, 79 insertions(+), 8 deletions(-)

diff --git a/include/llvm/CodeGen/AsmPrinter.h b/include/llvm/CodeGen/AsmPrinter.h
index 25b99a2..7a499f1 100644
--- a/include/llvm/CodeGen/AsmPrinter.h
+++ b/include/llvm/CodeGen/AsmPrinter.h
@@ -465,6 +465,8 @@ public:
                                      unsigned AsmVariant, const char *ExtraCode,
                                      raw_ostream &OS);
 
+  virtual void emitInlineAsmStart(const MCSubtargetInfo &StartInfo) const;
+
   /// Let the target do anything it needs to do after emitting inlineasm.
   /// This callback can be used restore the original mode in case the
   /// inlineasm contains directives to switch modes.
diff --git a/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp b/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
index cca5f22..a7841ac 100644
--- a/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
+++ b/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
@@ -90,6 +90,7 @@ void AsmPrinter::EmitInlineAsm(StringRef Str, const MDNode *LocMDNode,
   assert(MCAI && "No MCAsmInfo");
   if (!MCAI->useIntegratedAssembler() &&
       !OutStreamer.isIntegratedAssemblerRequired()) {
+    emitInlineAsmStart(TM.getSubtarget<MCSubtargetInfo>());
     OutStreamer.EmitRawText(Str);
     emitInlineAsmEnd(TM.getSubtarget<MCSubtargetInfo>(), nullptr);
     return;
@@ -137,6 +138,8 @@ void AsmPrinter::EmitInlineAsm(StringRef Str, const MDNode *LocMDNode,
   // emitInlineAsmEnd().
   MCSubtargetInfo STIOrig = *STI;
 
+  emitInlineAsmStart(STIOrig);
+
   MCTargetOptions MCOptions;
   if (MF)
     MCOptions = MF->getTarget().Options.MCOptions;
@@ -566,5 +569,7 @@ bool AsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI, unsigned OpNo,
   return true;
 }
 
+void AsmPrinter::emitInlineAsmStart(const MCSubtargetInfo &StartInfo) const {}
+
 void AsmPrinter::emitInlineAsmEnd(const MCSubtargetInfo &StartInfo,
                                   const MCSubtargetInfo *EndInfo) const {}
diff --git a/lib/Target/Mips/MipsAsmPrinter.cpp b/lib/Target/Mips/MipsAsmPrinter.cpp
index 832fa05..afdb46f 100644
--- a/lib/Target/Mips/MipsAsmPrinter.cpp
+++ b/lib/Target/Mips/MipsAsmPrinter.cpp
@@ -53,7 +53,7 @@ using namespace llvm;
 
 #define DEBUG_TYPE "mips-asm-printer"
 
-MipsTargetStreamer &MipsAsmPrinter::getTargetStreamer() {
+MipsTargetStreamer &MipsAsmPrinter::getTargetStreamer() const {
   return static_cast<MipsTargetStreamer &>(*OutStreamer.getTargetStreamer());
 }
 
@@ -743,6 +743,23 @@ void MipsAsmPrinter::EmitStartOfAsmFile(Module &M) {
                                                     Subtarget->isABI_O32());
 }
 
+void MipsAsmPrinter::emitInlineAsmStart(
+    const MCSubtargetInfo &StartInfo) const {
+  MipsTargetStreamer &TS = getTargetStreamer();
+
+  TS.emitDirectiveSetPush();
+  TS.emitDirectiveSetAt();
+  TS.emitDirectiveSetMacro();
+  TS.emitDirectiveSetReorder();
+  OutStreamer.emitRawComment(" Start of user-made asm.");
+}
+
+void MipsAsmPrinter::emitInlineAsmEnd(const MCSubtargetInfo &StartInfo,
+                                      const MCSubtargetInfo *EndInfo) const {
+  OutStreamer.emitRawComment(" End of user-made asm.");
+  getTargetStreamer().emitDirectiveSetPop();
+}
+
 void MipsAsmPrinter::EmitJal(MCSymbol *Symbol) {
   MCInst I;
   I.setOpcode(Mips::JAL);
diff --git a/lib/Target/Mips/MipsAsmPrinter.h b/lib/Target/Mips/MipsAsmPrinter.h
index 0582e21..723155f 100644
--- a/lib/Target/Mips/MipsAsmPrinter.h
+++ b/lib/Target/Mips/MipsAsmPrinter.h
@@ -31,7 +31,7 @@ class Module;
 class raw_ostream;
 
 class LLVM_LIBRARY_VISIBILITY MipsAsmPrinter : public AsmPrinter {
-  MipsTargetStreamer &getTargetStreamer();
+  MipsTargetStreamer &getTargetStreamer() const;
 
   void EmitInstrWithMacroNoAT(const MachineInstr *MI);
 
@@ -60,6 +60,11 @@ private:
   std::map<const char *, const llvm::Mips16HardFloatInfo::FuncSignature *>
   StubsNeeded;
 
+  void emitInlineAsmStart(const MCSubtargetInfo &StartInfo) const override;
+
+  void emitInlineAsmEnd(const MCSubtargetInfo &StartInfo,
+                        const MCSubtargetInfo *EndInfo) const override;
+
   void EmitJal(MCSymbol *Symbol);
 
   void EmitInstrReg(unsigned Opcode, unsigned Reg);
diff --git a/lib/Target/Mips/MipsISelDAGToDAG.cpp b/lib/Target/Mips/MipsISelDAGToDAG.cpp
index 0bdabf3..6364be3 100644
--- a/lib/Target/Mips/MipsISelDAGToDAG.cpp
+++ b/lib/Target/Mips/MipsISelDAGToDAG.cpp
@@ -227,7 +227,15 @@ bool MipsDAGToDAGISel::
 SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
                              std::vector<SDValue> &OutOps) {
   assert(ConstraintCode == 'm' && "unexpected asm memory constraint");
-  OutOps.push_back(Op);
+  const TargetRegisterInfo *TRI = TM.getSubtargetImpl()->getRegisterInfo();
+  const TargetRegisterClass *TRC = TRI->getPointerRegClass(*MF, 1 /* Kind */);
+
+  SDValue RC = CurDAG->getTargetConstant(TRC->getID(), MVT::i32);
+  SDValue NewOp =
+      SDValue(CurDAG->getMachineNode(TargetOpcode::COPY_TO_REGCLASS, SDLoc(Op),
+                                     Op.getValueType(), Op, RC),
+              0);
+  OutOps.push_back(NewOp);
   return false;
 }
 
diff --git a/lib/Target/Mips/MipsISelLowering.cpp b/lib/Target/Mips/MipsISelLowering.cpp
index 8e904eb..99b72f8 100644
--- a/lib/Target/Mips/MipsISelLowering.cpp
+++ b/lib/Target/Mips/MipsISelLowering.cpp
@@ -3302,12 +3302,12 @@ getRegForInlineAsmConstraint(const std::string &Constraint, MVT VT) const
       if (VT == MVT::i32 || VT == MVT::i16 || VT == MVT::i8) {
         if (Subtarget.inMips16Mode())
           return std::make_pair(0U, &Mips::CPU16RegsRegClass);
-        return std::make_pair(0U, &Mips::GPR32RegClass);
+        return std::make_pair(0U, &Mips::GPR32InlineAsmRegClass);
       }
       if (VT == MVT::i64 && !Subtarget.isGP64bit())
-        return std::make_pair(0U, &Mips::GPR32RegClass);
+        return std::make_pair(0U, &Mips::GPR32InlineAsmRegClass);
       if (VT == MVT::i64 && Subtarget.isGP64bit())
-        return std::make_pair(0U, &Mips::GPR64RegClass);
+        return std::make_pair(0U, &Mips::GPR64InlineAsmRegClass);
       // This will generate an error message
       return std::make_pair(0U, nullptr);
     case 'f': // FPU or MSA register
@@ -3329,9 +3329,10 @@ getRegForInlineAsmConstraint(const std::string &Constraint, MVT VT) const
       break;
     case 'c': // register suitable for indirect jump
       if (VT == MVT::i32)
-        return std::make_pair((unsigned)Mips::T9, &Mips::GPR32RegClass);
+        return std::make_pair((unsigned)Mips::T9, &Mips::GPR32InlineAsmRegClass);
       assert(VT == MVT::i64 && "Unexpected type.");
-      return std::make_pair((unsigned)Mips::T9_64, &Mips::GPR64RegClass);
+      return std::make_pair((unsigned)Mips::T9_64,
+                            &Mips::GPR64InlineAsmRegClass);
     case 'l': // register suitable for indirect jump
       if (VT == MVT::i32)
         return std::make_pair((unsigned)Mips::LO0, &Mips::LO32RegClass);
diff --git a/lib/Target/Mips/MipsRegisterInfo.cpp b/lib/Target/Mips/MipsRegisterInfo.cpp
index 20ef3f3..a024e3e 100644
--- a/lib/Target/Mips/MipsRegisterInfo.cpp
+++ b/lib/Target/Mips/MipsRegisterInfo.cpp
@@ -50,6 +50,11 @@ unsigned MipsRegisterInfo::getPICCallReg() { return Mips::T9; }
 const TargetRegisterClass *
 MipsRegisterInfo::getPointerRegClass(const MachineFunction &MF,
                                      unsigned Kind) const {
+  // Do not use AT if called from SelectInlineAsmMemoryOperand.
+  if (Kind == 1)
+    return Subtarget.isABI_N64() ? &Mips::GPR64InlineAsmRegClass
+                                 : &Mips::GPR32InlineAsmRegClass;
+
   return Subtarget.isABI_N64() ? &Mips::GPR64RegClass : &Mips::GPR32RegClass;
 }
 
diff --git a/lib/Target/Mips/MipsRegisterInfo.td b/lib/Target/Mips/MipsRegisterInfo.td
index 2b3b6c1..8ec82fb 100644
--- a/lib/Target/Mips/MipsRegisterInfo.td
+++ b/lib/Target/Mips/MipsRegisterInfo.td
@@ -288,6 +288,20 @@ class GPR32Class<list<ValueType> regTypes> :
 def GPR32 : GPR32Class<[i32]>;
 def DSPR  : GPR32Class<[v4i8, v2i16]>;
 
+def GPR32InlineAsm : RegisterClass<"Mips", [i32], 32, (add
+  // Reserved
+  ZERO, // no AT
+  // Return Values and Arguments
+  V0, V1, A0, A1, A2, A3,
+  // Not preserved across procedure calls
+  T0, T1, T2, T3, T4, T5, T6, T7,
+  // Callee save
+  S0, S1, S2, S3, S4, S5, S6, S7,
+  // Not preserved across procedure calls
+  T8, T9,
+  // Reserved
+  K0, K1, GP, SP, FP, RA)>;
+
 def GPRMM16 : RegisterClass<"Mips", [i32], 32, (add
   // Callee save
   S0, S1,
@@ -316,6 +330,20 @@ def GPR64 : RegisterClass<"Mips", [i64], 64, (add
   // Reserved
   K0_64, K1_64, GP_64, SP_64, FP_64, RA_64)>;
 
+def GPR64InlineAsm : RegisterClass<"Mips", [i64], 64, (add
+  // Reserved
+  ZERO_64, // no AT_64
+  // Return Values and Arguments
+  V0_64, V1_64, A0_64, A1_64, A2_64, A3_64,
+  // Not preserved across procedure calls
+  T0_64, T1_64, T2_64, T3_64, T4_64, T5_64, T6_64, T7_64,
+  // Callee save
+  S0_64, S1_64, S2_64, S3_64, S4_64, S5_64, S6_64, S7_64,
+  // Not preserved across procedure calls
+  T8_64, T9_64,
+  // Reserved
+  K0_64, K1_64, GP_64, SP_64, FP_64, RA_64)>;
+
 def CPU16Regs : RegisterClass<"Mips", [i32], 32, (add
   // Return Values and Arguments
   V0, V1, A0, A1, A2, A3,
-- 
1.9.1

