diff --git a/include/linux/bitmap.h b/include/linux/bitmap.h
index 7ad6345..ad78dba 100644
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -162,7 +162,7 @@ static inline void bitmap_zero(unsigned long *dst, int nbits)
 		*dst = 0UL;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memset(dst, 0, len);
+		(void)memset(dst, 0, len);
 	}
 }
 
@@ -171,7 +171,7 @@ static inline void bitmap_fill(unsigned long *dst, int nbits)
 	size_t nlongs = BITS_TO_LONGS(nbits);
 	if (!small_const_nbits(nbits)) {
 		int len = (nlongs - 1) * sizeof(unsigned long);
-		memset(dst, 0xff,  len);
+		(void)memset(dst, 0xff,  len);
 	}
 	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
 }
@@ -183,7 +183,7 @@ static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
 		*dst = *src;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memcpy(dst, src, len);
+		(void)memcpy(dst, src, len);
 	}
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 6c6a1f0..d69f132 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -448,7 +448,7 @@ static inline void queue_flag_set_unlocked(unsigned int flag,
 static inline int queue_flag_test_and_clear(unsigned int flag,
 					    struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (test_bit(flag, &q->queue_flags)) {
 		__clear_bit(flag, &q->queue_flags);
@@ -461,7 +461,7 @@ static inline int queue_flag_test_and_clear(unsigned int flag,
 static inline int queue_flag_test_and_set(unsigned int flag,
 					  struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (!test_bit(flag, &q->queue_flags)) {
 		__set_bit(flag, &q->queue_flags);
@@ -473,7 +473,7 @@ static inline int queue_flag_test_and_set(unsigned int flag,
 
 static inline void queue_flag_set(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__set_bit(flag, &q->queue_flags);
 }
 
@@ -490,7 +490,7 @@ static inline int queue_in_flight(struct request_queue *q)
 
 static inline void queue_flag_clear(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__clear_bit(flag, &q->queue_flags);
 }
 
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 81e803e..b945988 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -123,7 +123,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 {
 	uint64_t tmp = ((uint64_t)ticks) << shift;
 
-	do_div(tmp, nsec);
+	(void)do_div(tmp, nsec);
 	return (unsigned long) tmp;
 }
 
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147d..456d605 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -230,7 +230,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 	u64 tmp = ((u64)1000000) << shift_constant;
 
 	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
+	(void)do_div(tmp, khz);
 
 	return (u32)tmp;
 }
@@ -256,7 +256,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	u64 tmp = ((u64)1000000000) << shift_constant;
 
 	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
+	(void)do_div(tmp, hz);
 
 	return (u32)tmp;
 }
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 581e74b..79bfd6e 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -151,7 +151,7 @@ struct vm_area_struct;
 /* Convert GFP flags to their corresponding migrate type */
 static inline int allocflags_to_migratetype(gfp_t gfp_flags)
 {
-	WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
+	(void)WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 
 	if (unlikely(page_group_by_mobility_disabled))
 		return MIGRATE_UNMOVABLE;
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index 3a93f73..63ed5d1 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -181,7 +181,7 @@ alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
 static inline void clear_highpage(struct page *page)
 {
 	void *kaddr = kmap_atomic(page, KM_USER0);
-	clear_page(kaddr);
+	(void)clear_page(kaddr);
 	kunmap_atomic(kaddr, KM_USER0);
 }
 
@@ -194,10 +194,10 @@ static inline void zero_user_segments(struct page *page,
 	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);
 
 	if (end1 > start1)
-		memset(kaddr + start1, 0, end1 - start1);
+		(void)memset(kaddr + start1, 0, end1 - start1);
 
 	if (end2 > start2)
-		memset(kaddr + start2, 0, end2 - start2);
+		(void)memset(kaddr + start2, 0, end2 - start2);
 
 	kunmap_atomic(kaddr, KM_USER0);
 	flush_dcache_page(page);
diff --git a/include/linux/irqflags.h b/include/linux/irqflags.h
index d176d65..c02806e 100644
--- a/include/linux/irqflags.h
+++ b/include/linux/irqflags.h
@@ -60,22 +60,22 @@
 #define raw_local_irq_enable()		arch_local_irq_enable()
 #define raw_local_irq_save(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_irq_save();		\
 	} while (0)
 #define raw_local_irq_restore(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_local_irq_restore(flags);		\
 	} while (0)
 #define raw_local_save_flags(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_save_flags();	\
 	} while (0)
 #define raw_irqs_disabled_flags(flags)			\
 	({						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_irqs_disabled_flags(flags);	\
 	})
 #define raw_irqs_disabled()		(arch_irqs_disabled())
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0eac07c..c4fced5 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1323,8 +1323,8 @@ static inline
 void netdev_reset_tc(struct net_device *dev)
 {
 	dev->num_tc = 0;
-	memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
-	memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
+	(void)memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
+	(void)memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
 }
 
 static inline
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 52e4895..31f3eb6 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -250,7 +250,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
 	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
-		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
+		(void)memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 
diff --git a/include/linux/poll.h b/include/linux/poll.h
index cf40010..5273a23 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -110,7 +110,7 @@ int get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 	if (ufdset)
 		return copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;
 
-	memset(fdset, 0, nr);
+	(void)memset(fdset, 0, nr);
 	return 0;
 }
 
@@ -125,7 +125,7 @@ set_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 static inline
 void zero_fd_set(unsigned long nr, unsigned long *fdset)
 {
-	memset(fdset, 0, FDS_BYTES(nr));
+	(void)memset(fdset, 0, FDS_BYTES(nr));
 }
 
 #define MAX_INT64_SECONDS (((s64)(~((u64)0)>>1)/HZ)-1)
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index c2f1f6a..d52e4ca 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -363,7 +363,7 @@ extern void user_single_step_siginfo(struct task_struct *tsk,
 static inline void user_single_step_siginfo(struct task_struct *tsk,
 				struct pt_regs *regs, siginfo_t *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->si_signo = SIGTRAP;
 }
 #endif
diff --git a/include/linux/regset.h b/include/linux/regset.h
index 8abee65..3c3e979 100644
--- a/include/linux/regset.h
+++ b/include/linux/regset.h
@@ -283,7 +283,7 @@ static inline int user_regset_copyout_zero(unsigned int *pos,
 		unsigned int copy = (end_pos < 0 ? *count
 				     : min(*count, end_pos - *pos));
 		if (*kbuf) {
-			memset(*kbuf, 0, copy);
+			(void)memset(*kbuf, 0, copy);
 			*kbuf += copy;
 		} else if (__clear_user(*ubuf, copy))
 			return -EFAULT;
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index 8e872ea..4a5eb58 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -732,7 +732,7 @@ __rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 	return rta;
 }
 
diff --git a/include/linux/security.h b/include/linux/security.h
index 83c18e8..2dae9d0 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1898,13 +1898,13 @@ static inline int security_settime(const struct timespec *ts,
 
 static inline int security_vm_enough_memory(long pages)
 {
-	WARN_ON(current->mm == NULL);
+	(void)WARN_ON(current->mm == NULL);
 	return cap_vm_enough_memory(current->mm, pages);
 }
 
 static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	WARN_ON(mm == NULL);
+	(void)WARN_ON(mm == NULL);
 	return cap_vm_enough_memory(mm, pages);
 }
 
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7987ce74..2256c0a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -159,7 +159,7 @@ static inline void sigemptyset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, 0, sizeof(sigset_t));
+		(void)memset(set, 0, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1:	set->sig[0] = 0;
@@ -171,7 +171,7 @@ static inline void sigfillset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, -1, sizeof(sigset_t));
+		(void)memset(set, -1, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1:	set->sig[0] = -1;
@@ -201,7 +201,7 @@ static inline void siginitset(sigset_t *set, unsigned long mask)
 	set->sig[0] = mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1: ;
@@ -213,7 +213,7 @@ static inline void siginitsetinv(sigset_t *set, unsigned long mask)
 	set->sig[0] = ~mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1: ;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 50db9b0..622c720 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -510,7 +510,7 @@ static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
 	/* If refdst was not refcounted, check we still are in a 
 	 * rcu_read_lock section
 	 */
-	WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
+	(void)WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
 		!rcu_read_lock_held() &&
 		!rcu_read_lock_bh_held());
 	return (struct dst_entry *)(skb->_skb_refdst & SKB_DST_PTRMASK);
@@ -1543,7 +1543,7 @@ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 {
 	if (unlikely(skb_is_nonlinear(skb))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	skb->len = len;
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 7df6c17..b58581b 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -175,7 +175,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 # define raw_spin_lock_nest_lock(lock, nest_lock)			\
 	 do {								\
-		 typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
+		 (void)typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
 		 _raw_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);	\
 	 } while (0)
 #else
@@ -187,20 +187,20 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_spin_lock_irqsave(lock);	\
 	} while (0)
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave_nested(lock, subclass);	\
 	} while (0)
 #else
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave(lock);			\
 	} while (0)
 #endif
@@ -209,7 +209,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)		\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_spin_lock_irqsave(lock, flags);	\
 	} while (0)
 
@@ -225,7 +225,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_unlock_irqrestore(lock, flags)		\
 	do {							\
-		typecheck(unsigned long, flags);		\
+		(void)typecheck(unsigned long, flags);		\
 		_raw_spin_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define raw_spin_unlock_bh(lock)	_raw_spin_unlock_bh(lock)
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 65efb92..35ca2a3 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -181,7 +181,7 @@ extern void zone_statistics(struct zone *, struct zone *, gfp_t gfp);
 
 static inline void zap_zone_vm_stats(struct zone *zone)
 {
-	memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
+	(void)memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
 }
 
 extern void inc_zone_state(struct zone *, enum zone_stat_item);
diff --git a/include/net/dst.h b/include/net/dst.h
index 344c8dd..cbae81d 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -173,7 +173,7 @@ dst_metric_raw(const struct dst_entry *dst, const int metric)
 static inline u32
 dst_metric(const struct dst_entry *dst, const int metric)
 {
-	WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
+	(void)WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
 		     metric == RTAX_ADVMSS ||
 		     metric == RTAX_MTU);
 	return dst_metric_raw(dst, metric);
@@ -303,7 +303,7 @@ static inline void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb
 static inline void skb_dst_force(struct sk_buff *skb)
 {
 	if (skb_dst_is_noref(skb)) {
-		WARN_ON(!rcu_read_lock_held());
+		(void)WARN_ON(!rcu_read_lock_held());
 		skb->_skb_refdst &= ~SKB_DST_NOREF;
 		dst_clone(skb_dst(skb));
 	}
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index dbf9aab..0bb043e 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -172,7 +172,7 @@ static inline int inet_csk_ack_scheduled(const struct sock *sk)
 
 static inline void inet_csk_delack_init(struct sock *sk)
 {
-	memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
+	(void)memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
 }
 
 extern void inet_csk_delete_keepalive_timer(struct sock *sk);
diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index 06b795d..52ac08a 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -102,7 +102,7 @@ extern bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);
  */
 static inline void inet_peer_refcheck(const struct inet_peer *p)
 {
-	WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
+	(void)WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
 }
 
 
diff --git a/include/net/ip.h b/include/net/ip.h
index 775009f..52a58a8 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -384,7 +384,7 @@ static inline int sk_mc_loop(struct sock *sk)
 		return inet6_sk(sk)->mc_loop;
 #endif
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 1;
 }
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index e4170a2..7081938 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -317,7 +317,7 @@ static inline void ipv6_addr_prefix(struct in6_addr *pfx,
 	int o = plen >> 3,
 	    b = plen & 0x7;
 
-	memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
+	(void)memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
 	memcpy(pfx->s6_addr, addr, o);
 	if (b != 0)
 		pfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);
diff --git a/include/net/request_sock.h b/include/net/request_sock.h
index 4c0766e..2c68508 100644
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@ -181,7 +181,7 @@ static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue
 {
 	struct request_sock *req = queue->rskq_accept_head;
 
-	WARN_ON(req == NULL);
+	(void)WARN_ON(req == NULL);
 
 	queue->rskq_accept_head = req->dl_next;
 	if (queue->rskq_accept_head == NULL)
@@ -196,7 +196,7 @@ static inline struct sock *reqsk_queue_get_child(struct request_sock_queue *queu
 	struct request_sock *req = reqsk_queue_remove(queue);
 	struct sock *child = req->sk;
 
-	WARN_ON(child == NULL);
+	(void)WARN_ON(child == NULL);
 
 	sk_acceptq_removed(parent);
 	__reqsk_free(req);
diff --git a/include/net/route.h b/include/net/route.h
index 91855d1..8e809d7 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -156,7 +156,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->flowi4_oif = oif;
 	fl4->daddr = daddr;
 	fl4->saddr = saddr;
diff --git a/include/net/sock.h b/include/net/sock.h
index bb972d2..9d44141 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -474,7 +474,7 @@ static __inline__ int sk_del_node_init(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index 887629e..a1c76ef 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -71,7 +71,7 @@ identify_ramdisk_image(int fd, int start_block, decompress_fn *decompressor)
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
 	squashfsb = (struct squashfs_super_block *) buf;
-	memset(buf, 0xe5, size);
+	(void)memset(buf, 0xe5, size);
 
 	/*
 	 * Read block 0 to test for compressed kernel
diff --git a/init/initramfs.c b/init/initramfs.c
index 8216c30..5e6b06b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -507,7 +507,7 @@ static void __init free_initrd(void)
 		 * Initialize initrd memory region since the kexec boot does
 		 * not do.
 		 */
-		memset((void *)initrd_start, 0, initrd_end - initrd_start);
+		(void)memset((void *)initrd_start, 0, initrd_end - initrd_start);
 		if (initrd_start < crashk_start)
 			free_initrd_mem(initrd_start, crashk_start);
 		if (initrd_end > crashk_end)
@@ -530,11 +530,11 @@ static void __init clean_rootfs(void)
 	int num;
 
 	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
-	WARN_ON(fd < 0);
+	(void)WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
 	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
-	WARN_ON(!buf);
+	(void)WARN_ON(!buf);
 	if (!buf) {
 		sys_close(fd);
 		return;
@@ -548,7 +548,7 @@ static void __init clean_rootfs(void)
 			int ret;
 
 			ret = sys_newlstat(dirp->d_name, &st);
-			WARN_ON_ONCE(ret);
+			(void)WARN_ON_ONCE(ret);
 			if (!ret) {
 				if (S_ISDIR(st.st_mode))
 					sys_rmdir(dirp->d_name);
@@ -560,7 +560,7 @@ static void __init clean_rootfs(void)
 			dirp = (void *)dirp + dirp->d_reclen;
 		}
 		dirp = buf;
-		memset(buf, 0, BUF_SIZE);
+		(void)memset(buf, 0, BUF_SIZE);
 		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index e66e9b6..d365326 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -348,7 +348,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	int len;
 
 	if (env->envp_idx >= ARRAY_SIZE(env->envp)) {
-		WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
 		return -ENOMEM;
 	}
 
@@ -359,7 +359,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	va_end(args);
 
 	if (len >= (sizeof(env->buf) - env->buflen)) {
-		WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
 		return -ENOMEM;
 	}
 
diff --git a/lib/plist.c b/lib/plist.c
index a0a4da4..5117cd1 100644
--- a/lib/plist.c
+++ b/lib/plist.c
@@ -33,7 +33,7 @@ static struct plist_head test_head;
 static void plist_check_prev_next(struct list_head *t, struct list_head *p,
 				  struct list_head *n)
 {
-	WARN(n->prev != p || p->next != n,
+	(void)WARN(n->prev != p || p->next != n,
 			"top: %p, n: %p, p: %p\n"
 			"prev: %p, n: %p, p: %p\n"
 			"next: %p, n: %p, p: %p\n",
@@ -77,8 +77,8 @@ void plist_add(struct plist_node *node, struct plist_head *head)
 	struct list_head *node_next = &head->node_list;
 
 	plist_check_head(head);
-	WARN_ON(!plist_node_empty(node));
-	WARN_ON(!list_empty(&node->prio_list));
+	(void)WARN_ON(!plist_node_empty(node));
+	(void)WARN_ON(!list_empty(&node->prio_list));
 
 	if (plist_head_empty(head))
 		goto ins_node;
diff --git a/lib/timerqueue.c b/lib/timerqueue.c
index 191176a..e520c72 100644
--- a/lib/timerqueue.c
+++ b/lib/timerqueue.c
@@ -42,7 +42,7 @@ void timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)
 	struct timerqueue_node  *ptr;
 
 	/* Make sure we don't add nodes that are already added */
-	WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
 
 	while (*p) {
 		parent = *p;
@@ -70,7 +70,7 @@ EXPORT_SYMBOL_GPL(timerqueue_add);
  */
 void timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
 {
-	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
 
 	/* update next pointer */
 	if (head->next == node) {
diff --git a/net/sunrpc/addr.c b/net/sunrpc/addr.c
index ee77742..d7e685a 100644
--- a/net/sunrpc/addr.c
+++ b/net/sunrpc/addr.c
@@ -146,7 +146,7 @@ static size_t rpc_pton4(const char *buf, const size_t buflen,
 	if (buflen > INET_ADDRSTRLEN || salen < sizeof(struct sockaddr_in))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in));
 
 	if (in4_pton(buf, buflen, addr, '\0', NULL) == 0)
 		return 0;
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 727e506..e3d21ad 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -424,7 +424,7 @@ rpcauth_lookupcred(struct rpc_auth *auth, int flags)
 	dprintk("RPC:       looking up %s cred\n",
 		auth->au_ops->au_name);
 
-	memset(&acred, 0, sizeof(acred));
+	(void)memset(&acred, 0, sizeof(acred));
 	acred.uid = cred->fsuid;
 	acred.gid = cred->fsgid;
 	acred.group_info = get_group_info(((struct cred *)cred)->group_info);
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 3341d89..f69e9dd 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -820,7 +820,7 @@ EXPORT_SYMBOL_GPL(rpc_free);
  */
 static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)
 {
-	memset(task, 0, sizeof(*task));
+	(void)memset(task, 0, sizeof(*task));
 	atomic_set(&task->tk_count, 1);
 	task->tk_flags  = task_setup_data->flags;
 	task->tk_ops = task_setup_data->callback_ops;
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 74cb0d8..b8b7b86 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -151,7 +151,7 @@ EXPORT_SYMBOL_GPL(svc_xprt_put);
 void svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,
 		   struct svc_xprt *xprt, struct svc_serv *serv)
 {
-	memset(xprt, 0, sizeof(*xprt));
+	(void)memset(xprt, 0, sizeof(*xprt));
 	xprt->xpt_class = xcl;
 	xprt->xpt_ops = xcl->xcl_ops;
 	kref_init(&xprt->xpt_ref);
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 4645709..1e74d56 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1360,7 +1360,7 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 
 		svsk->sk_reclen = 0;
 		svsk->sk_tcplen = 0;
-		memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
+		(void)memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
 
 		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;
 
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 593f4c6..0735555 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -67,7 +67,7 @@ __be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)
 		if (ptr != NULL)
 			memcpy(p, ptr, nbytes);
 		if (padding != 0)
-			memset((char *)p + nbytes, 0, padding);
+			(void)memset((char *)p + nbytes, 0, padding);
 		p += quadlen;
 	}
 	return p;
@@ -649,7 +649,7 @@ EXPORT_SYMBOL_GPL(xdr_init_decode);
 void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,
 			   struct page **pages, unsigned int len)
 {
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	buf->pages =  pages;
 	buf->page_len =  len;
 	buf->buflen =  len;
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 55472c4..c078dcc 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1080,7 +1080,7 @@ static inline void xs_tcp_read_xid(struct sock_xprt *transport, struct xdr_skb_r
 	char *p;
 
 	len = sizeof(transport->tcp_xid) - transport->tcp_offset;
-	dprintk("RPC:       reading XID (%Zu bytes)\n", len);
+	dprintk("RPC:       reading XID (%zu bytes)\n", len);
 	p = ((char *) &transport->tcp_xid) + transport->tcp_offset;
 	used = xdr_skb_read_bits(desc, p, len);
 	transport->tcp_offset += used;
@@ -1111,7 +1111,7 @@ static inline void xs_tcp_read_calldir(struct sock_xprt *transport,
 	 */
 	offset = transport->tcp_offset - sizeof(transport->tcp_xid);
 	len = sizeof(transport->tcp_calldir) - offset;
-	dprintk("RPC:       reading CALL/REPLY flag (%Zu bytes)\n", len);
+	dprintk("RPC:       reading CALL/REPLY flag (%zu bytes)\n", len);
 	p = ((char *) &transport->tcp_calldir) + offset;
 	used = xdr_skb_read_bits(desc, p, len);
 	transport->tcp_offset += used;
@@ -1202,7 +1202,7 @@ static inline void xs_tcp_read_common(struct rpc_xprt *xprt,
 		return;
 	}
 
-	dprintk("RPC:       XID %08x read %Zd bytes\n",
+	dprintk("RPC:       XID %08x read %zd bytes\n",
 			ntohl(transport->tcp_xid), r);
 	dprintk("RPC:       xprt = %p, tcp_copied = %lu, tcp_offset = %u, "
 			"tcp_reclen = %u\n", xprt, transport->tcp_copied,
@@ -1344,7 +1344,7 @@ static inline void xs_tcp_read_discard(struct sock_xprt *transport, struct xdr_s
 	desc->count -= len;
 	desc->offset += len;
 	transport->tcp_offset += len;
-	dprintk("RPC:       discarded %Zu bytes\n", len);
+	dprintk("RPC:       discarded %zu bytes\n", len);
 	xs_tcp_check_fraghdr(transport);
 }
 
diff --git a/net/sysctl_net.c b/net/sysctl_net.c
index e758139..e3a86d9 100644
--- a/net/sysctl_net.c
+++ b/net/sysctl_net.c
@@ -82,7 +82,7 @@ static int __net_init sysctl_net_init(struct net *net)
 
 static void __net_exit sysctl_net_exit(struct net *net)
 {
-	WARN_ON(!list_empty(&net->sysctls.list));
+	(void)WARN_ON(!list_empty(&net->sysctls.list));
 }
 
 static struct pernet_operations sysctl_pernet_ops = {
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aad8fb6..7ca7faa 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1333,7 +1333,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 static void unix_destruct_scm(struct sk_buff *skb)
 {
 	struct scm_cookie scm;
-	memset(&scm, 0, sizeof(scm));
+	(void)memset(&scm, 0, sizeof(scm));
 	scm.pid  = UNIXCB(skb).pid;
 	scm.cred = UNIXCB(skb).cred;
 	if (UNIXCB(skb).fp)
@@ -1800,7 +1800,7 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 	scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).cred);
 	unix_set_secdata(siocb->scm, skb);
@@ -1904,7 +1904,7 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
 	err = mutex_lock_interruptible(&u->readlock);
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 5b228f9..b23979b 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -516,7 +516,7 @@ void __xfrm_state_destroy(struct xfrm_state *x)
 {
 	struct net *net = xs_net(x);
 
-	WARN_ON(x->km.state != XFRM_STATE_DEAD);
+	(void)WARN_ON(x->km.state != XFRM_STATE_DEAD);
 
 	spin_lock_bh(&xfrm_state_gc_lock);
 	hlist_add_head(&x->gclist, &net->xfrm.state_gc_list);
@@ -2051,14 +2051,14 @@ void xfrm_state_fini(struct net *net)
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, &audit_info);
 	flush_work(&net->xfrm.state_gc_work);
 
-	WARN_ON(!list_empty(&net->xfrm.state_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.state_all));
 
 	sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.state_byspi));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_byspi));
 	xfrm_hash_free(net->xfrm.state_byspi, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
 	xfrm_hash_free(net->xfrm.state_bysrc, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bydst));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bydst));
 	xfrm_hash_free(net->xfrm.state_bydst, sz);
 }
 
