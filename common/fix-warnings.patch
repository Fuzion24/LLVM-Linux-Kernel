diff --git a/arch/arm/nwfpe/fpa11_cpdt.c b/arch/arm/nwfpe/fpa11_cpdt.c
index d31c49f..e9fcbaa 100644
--- a/arch/arm/nwfpe/fpa11_cpdt.c
+++ b/arch/arm/nwfpe/fpa11_cpdt.c
@@ -32,7 +32,7 @@ static inline void loadSingle(const unsigned int Fn, const unsigned int __user *
 {
 	FPA11 *fpa11 = GET_FPA11();
 	fpa11->fType[Fn] = typeSingle;
-	get_user(fpa11->fpreg[Fn].fSingle, pMem);
+	(void)get_user(fpa11->fpreg[Fn].fSingle, pMem);
 }
 
 static inline void loadDouble(const unsigned int Fn, const unsigned int __user *pMem)
@@ -42,11 +42,11 @@ static inline void loadDouble(const unsigned int Fn, const unsigned int __user *
 	p = (unsigned int *) &fpa11->fpreg[Fn].fDouble;
 	fpa11->fType[Fn] = typeDouble;
 #ifdef __ARMEB__
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
-	get_user(p[1], &pMem[1]);
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[1], &pMem[1]);
 #else
-	get_user(p[0], &pMem[1]);
-	get_user(p[1], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[1]);
+	(void)get_user(p[1], &pMem[0]);	/* sign & exponent */
 #endif
 }
 
@@ -57,13 +57,13 @@ static inline void loadExtended(const unsigned int Fn, const unsigned int __user
 	unsigned int *p;
 	p = (unsigned int *) &fpa11->fpreg[Fn].fExtended;
 	fpa11->fType[Fn] = typeExtended;
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
 #ifdef __ARMEB__
-	get_user(p[1], &pMem[1]);	/* ms bits */
-	get_user(p[2], &pMem[2]);	/* ls bits */
+	(void)get_user(p[1], &pMem[1]);	/* ms bits */
+	(void)get_user(p[2], &pMem[2]);	/* ls bits */
 #else
-	get_user(p[1], &pMem[2]);	/* ls bits */
-	get_user(p[2], &pMem[1]);	/* ms bits */
+	(void)get_user(p[1], &pMem[2]);	/* ls bits */
+	(void)get_user(p[2], &pMem[1]);	/* ms bits */
 #endif
 }
 #endif
@@ -75,15 +75,15 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 	unsigned long x;
 
 	p = (unsigned int *) &(fpa11->fpreg[Fn]);
-	get_user(x, &pMem[0]);
+	(void)get_user(x, &pMem[0]);
 	fpa11->fType[Fn] = (x >> 14) & 0x00000003;
 
 	switch (fpa11->fType[Fn]) {
 	case typeSingle:
 	case typeDouble:
 		{
-			get_user(p[0], &pMem[2]);	/* Single */
-			get_user(p[1], &pMem[1]);	/* double msw */
+			(void)get_user(p[0], &pMem[2]);	/* Single */
+			(void)get_user(p[1], &pMem[1]);	/* double msw */
 			p[2] = 0;			/* empty */
 		}
 		break;
@@ -91,8 +91,8 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			get_user(p[1], &pMem[2]);
-			get_user(p[2], &pMem[1]);	/* msw */
+			(void)get_user(p[1], &pMem[2]);
+			(void)get_user(p[2], &pMem[1]);	/* msw */
 			p[0] = (x & 0x80003fff);
 		}
 		break;
@@ -123,7 +123,7 @@ static inline void storeSingle(struct roundingData *roundData, const unsigned in
 		val.f = fpa11->fpreg[Fn].fSingle;
 	}
 
-	put_user(val.i[0], pMem);
+	(void)put_user(val.i[0], pMem);
 }
 
 static inline void storeDouble(struct roundingData *roundData, const unsigned int Fn, unsigned int __user *pMem)
@@ -150,11 +150,11 @@ static inline void storeDouble(struct roundingData *roundData, const unsigned in
 	}
 
 #ifdef __ARMEB__
-	put_user(val.i[0], &pMem[0]);	/* msw */
-	put_user(val.i[1], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[0], &pMem[0]);	/* msw */
+	(void)put_user(val.i[1], &pMem[1]);	/* lsw */
 #else
-	put_user(val.i[1], &pMem[0]);	/* msw */
-	put_user(val.i[0], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[1], &pMem[0]);	/* msw */
+	(void)put_user(val.i[0], &pMem[1]);	/* lsw */
 #endif
 }
 
@@ -180,13 +180,13 @@ static inline void storeExtended(const unsigned int Fn, unsigned int __user *pMe
 		val.f = fpa11->fpreg[Fn].fExtended;
 	}
 
-	put_user(val.i[0], &pMem[0]);	/* sign & exp */
+	(void)put_user(val.i[0], &pMem[0]);	/* sign & exp */
 #ifdef __ARMEB__
-	put_user(val.i[1], &pMem[1]);	/* msw */
-	put_user(val.i[2], &pMem[2]);
+	(void)put_user(val.i[1], &pMem[1]);	/* msw */
+	(void)put_user(val.i[2], &pMem[2]);
 #else
-	put_user(val.i[1], &pMem[2]);
-	put_user(val.i[2], &pMem[1]);	/* msw */
+	(void)put_user(val.i[1], &pMem[2]);
+	(void)put_user(val.i[2], &pMem[1]);	/* msw */
 #endif
 }
 #endif
@@ -203,18 +203,18 @@ static inline void storeMultiple(const unsigned int Fn, unsigned int __user *pMe
 	case typeSingle:
 	case typeDouble:
 		{
-			put_user(p[0], &pMem[2]);	/* single */
-			put_user(p[1], &pMem[1]);	/* double msw */
-			put_user(nType << 14, &pMem[0]);
+			(void)put_user(p[0], &pMem[2]);	/* single */
+			(void)put_user(p[1], &pMem[1]);	/* double msw */
+			(void)put_user(nType << 14, &pMem[0]);
 		}
 		break;
 
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			put_user(p[2], &pMem[1]);	/* msw */
-			put_user(p[1], &pMem[2]);
-			put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
+			(void)put_user(p[2], &pMem[1]);	/* msw */
+			(void)put_user(p[1], &pMem[2]);
+			(void)put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
 		}
 		break;
 #endif
diff --git a/arch/arm/nwfpe/softfloat-macros b/arch/arm/nwfpe/softfloat-macros
index cf2a617..d7136f3 100644
--- a/arch/arm/nwfpe/softfloat-macros
+++ b/arch/arm/nwfpe/softfloat-macros
@@ -568,7 +568,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
         z = LIT64( 0xFFFFFFFF00000000 );
     }  else {
         z = a0;
-        do_div( z, b0 );
+        (void)do_div( z, b0 );
         z <<= 32;
     }
     mul64To128( b, z, &term0, &term1 );
@@ -582,7 +582,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
     if ( b0<<32 <= rem0 ) {
         z |= 0xFFFFFFFF;
     } else {
-        do_div( rem0, b0 );
+        (void)do_div( rem0, b0 );
         z |= rem0;
     }
     return z;
@@ -627,7 +627,7 @@ static bits32 estimateSqrt32( int16 aExp, bits32 a )
         if ( z <= a ) return (bits32) ( ( (sbits32) a )>>1 );
     }
     A = ( (bits64) a )<<31;
-    do_div( A, z );
+    (void)do_div( A, z );
     return ( (bits32) A ) + ( z>>1 );
 
 }
diff --git a/drivers/input/serio/ambakmi.c b/drivers/input/serio/ambakmi.c
index 8407d5b..e60eaa9 100644
--- a/drivers/input/serio/ambakmi.c
+++ b/drivers/input/serio/ambakmi.c
@@ -197,7 +197,7 @@ static struct amba_id amba_kmi_idtable[] = {
 
 MODULE_DEVICE_TABLE(amba, amba_kmi_idtable);
 
-static struct amba_driver ambakmi_driver = {
+static struct amba_driver ambakmi_driver __refdata = {
 	.drv		= {
 		.name	= "kmi-pl050",
 		.owner	= THIS_MODULE,
diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index 9ae0240..b7a84e4 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -1843,7 +1843,7 @@ static int __init pl011_console_setup(struct console *co, char *options)
 }
 
 static struct uart_driver amba_reg;
-static struct console amba_console = {
+static struct console amba_console __initdata = {
 	.name		= "ttyAMA",
 	.write		= pl011_console_write,
 	.device		= uart_console_device,
diff --git a/include/linux/bitmap.h b/include/linux/bitmap.h
index 7ad6345..ad78dba 100644
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -162,7 +162,7 @@ static inline void bitmap_zero(unsigned long *dst, int nbits)
 		*dst = 0UL;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memset(dst, 0, len);
+		(void)memset(dst, 0, len);
 	}
 }
 
@@ -171,7 +171,7 @@ static inline void bitmap_fill(unsigned long *dst, int nbits)
 	size_t nlongs = BITS_TO_LONGS(nbits);
 	if (!small_const_nbits(nbits)) {
 		int len = (nlongs - 1) * sizeof(unsigned long);
-		memset(dst, 0xff,  len);
+		(void)memset(dst, 0xff,  len);
 	}
 	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
 }
@@ -183,7 +183,7 @@ static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
 		*dst = *src;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memcpy(dst, src, len);
+		(void)memcpy(dst, src, len);
 	}
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 6c6a1f0..d69f132 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -448,7 +448,7 @@ static inline void queue_flag_set_unlocked(unsigned int flag,
 static inline int queue_flag_test_and_clear(unsigned int flag,
 					    struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (test_bit(flag, &q->queue_flags)) {
 		__clear_bit(flag, &q->queue_flags);
@@ -461,7 +461,7 @@ static inline int queue_flag_test_and_clear(unsigned int flag,
 static inline int queue_flag_test_and_set(unsigned int flag,
 					  struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (!test_bit(flag, &q->queue_flags)) {
 		__set_bit(flag, &q->queue_flags);
@@ -473,7 +473,7 @@ static inline int queue_flag_test_and_set(unsigned int flag,
 
 static inline void queue_flag_set(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__set_bit(flag, &q->queue_flags);
 }
 
@@ -490,7 +490,7 @@ static inline int queue_in_flight(struct request_queue *q)
 
 static inline void queue_flag_clear(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__clear_bit(flag, &q->queue_flags);
 }
 
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 81e803e..b945988 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -123,7 +123,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 {
 	uint64_t tmp = ((uint64_t)ticks) << shift;
 
-	do_div(tmp, nsec);
+	(void)do_div(tmp, nsec);
 	return (unsigned long) tmp;
 }
 
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147d..456d605 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -230,7 +230,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 	u64 tmp = ((u64)1000000) << shift_constant;
 
 	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
+	(void)do_div(tmp, khz);
 
 	return (u32)tmp;
 }
@@ -256,7 +256,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	u64 tmp = ((u64)1000000000) << shift_constant;
 
 	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
+	(void)do_div(tmp, hz);
 
 	return (u32)tmp;
 }
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index fe23ee7..b83a7e9 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -315,7 +315,7 @@ static inline void part_stat_set_all(struct hd_struct *part, int value)
 	int i;
 
 	for_each_possible_cpu(i)
-		memset(per_cpu_ptr(part->dkstats, i), value,
+		(void)memset(per_cpu_ptr(part->dkstats, i), value,
 				sizeof(struct disk_stats));
 }
 
@@ -343,7 +343,7 @@ static inline void free_part_stats(struct hd_struct *part)
 
 static inline void part_stat_set_all(struct hd_struct *part, int value)
 {
-	memset(&part->dkstats, value, sizeof(struct disk_stats));
+	(void)memset(&part->dkstats, value, sizeof(struct disk_stats));
 }
 
 static inline int init_part_stats(struct hd_struct *part)
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 581e74b..79bfd6e 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -151,7 +151,7 @@ struct vm_area_struct;
 /* Convert GFP flags to their corresponding migrate type */
 static inline int allocflags_to_migratetype(gfp_t gfp_flags)
 {
-	WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
+	(void)WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 
 	if (unlikely(page_group_by_mobility_disabled))
 		return MIGRATE_UNMOVABLE;
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index 3a93f73..63ed5d1 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -181,7 +181,7 @@ alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
 static inline void clear_highpage(struct page *page)
 {
 	void *kaddr = kmap_atomic(page, KM_USER0);
-	clear_page(kaddr);
+	(void)clear_page(kaddr);
 	kunmap_atomic(kaddr, KM_USER0);
 }
 
@@ -194,10 +194,10 @@ static inline void zero_user_segments(struct page *page,
 	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);
 
 	if (end1 > start1)
-		memset(kaddr + start1, 0, end1 - start1);
+		(void)memset(kaddr + start1, 0, end1 - start1);
 
 	if (end2 > start2)
-		memset(kaddr + start2, 0, end2 - start2);
+		(void)memset(kaddr + start2, 0, end2 - start2);
 
 	kunmap_atomic(kaddr, KM_USER0);
 	flush_dcache_page(page);
diff --git a/include/linux/irqflags.h b/include/linux/irqflags.h
index d176d65..c02806e 100644
--- a/include/linux/irqflags.h
+++ b/include/linux/irqflags.h
@@ -60,22 +60,22 @@
 #define raw_local_irq_enable()		arch_local_irq_enable()
 #define raw_local_irq_save(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_irq_save();		\
 	} while (0)
 #define raw_local_irq_restore(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_local_irq_restore(flags);		\
 	} while (0)
 #define raw_local_save_flags(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_save_flags();	\
 	} while (0)
 #define raw_irqs_disabled_flags(flags)			\
 	({						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_irqs_disabled_flags(flags);	\
 	})
 #define raw_irqs_disabled()		(arch_irqs_disabled())
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0eac07c..c4fced5 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1323,8 +1323,8 @@ static inline
 void netdev_reset_tc(struct net_device *dev)
 {
 	dev->num_tc = 0;
-	memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
-	memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
+	(void)memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
+	(void)memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
 }
 
 static inline
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 52e4895..31f3eb6 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -250,7 +250,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
 	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
-		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
+		(void)memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 
diff --git a/include/linux/poll.h b/include/linux/poll.h
index cf40010..5273a23 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -110,7 +110,7 @@ int get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 	if (ufdset)
 		return copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;
 
-	memset(fdset, 0, nr);
+	(void)memset(fdset, 0, nr);
 	return 0;
 }
 
@@ -125,7 +125,7 @@ set_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 static inline
 void zero_fd_set(unsigned long nr, unsigned long *fdset)
 {
-	memset(fdset, 0, FDS_BYTES(nr));
+	(void)memset(fdset, 0, FDS_BYTES(nr));
 }
 
 #define MAX_INT64_SECONDS (((s64)(~((u64)0)>>1)/HZ)-1)
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index c2f1f6a..d52e4ca 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -363,7 +363,7 @@ extern void user_single_step_siginfo(struct task_struct *tsk,
 static inline void user_single_step_siginfo(struct task_struct *tsk,
 				struct pt_regs *regs, siginfo_t *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->si_signo = SIGTRAP;
 }
 #endif
diff --git a/include/linux/regset.h b/include/linux/regset.h
index 8abee65..3c3e979 100644
--- a/include/linux/regset.h
+++ b/include/linux/regset.h
@@ -283,7 +283,7 @@ static inline int user_regset_copyout_zero(unsigned int *pos,
 		unsigned int copy = (end_pos < 0 ? *count
 				     : min(*count, end_pos - *pos));
 		if (*kbuf) {
-			memset(*kbuf, 0, copy);
+			(void)memset(*kbuf, 0, copy);
 			*kbuf += copy;
 		} else if (__clear_user(*ubuf, copy))
 			return -EFAULT;
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index 8e872ea..4a5eb58 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -732,7 +732,7 @@ __rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 	return rta;
 }
 
diff --git a/include/linux/security.h b/include/linux/security.h
index 83c18e8..2dae9d0 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1898,13 +1898,13 @@ static inline int security_settime(const struct timespec *ts,
 
 static inline int security_vm_enough_memory(long pages)
 {
-	WARN_ON(current->mm == NULL);
+	(void)WARN_ON(current->mm == NULL);
 	return cap_vm_enough_memory(current->mm, pages);
 }
 
 static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	WARN_ON(mm == NULL);
+	(void)WARN_ON(mm == NULL);
 	return cap_vm_enough_memory(mm, pages);
 }
 
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7987ce74..2256c0a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -159,7 +159,7 @@ static inline void sigemptyset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, 0, sizeof(sigset_t));
+		(void)memset(set, 0, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1:	set->sig[0] = 0;
@@ -171,7 +171,7 @@ static inline void sigfillset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, -1, sizeof(sigset_t));
+		(void)memset(set, -1, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1:	set->sig[0] = -1;
@@ -201,7 +201,7 @@ static inline void siginitset(sigset_t *set, unsigned long mask)
 	set->sig[0] = mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1: ;
@@ -213,7 +213,7 @@ static inline void siginitsetinv(sigset_t *set, unsigned long mask)
 	set->sig[0] = ~mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1: ;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 50db9b0..622c720 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -510,7 +510,7 @@ static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
 	/* If refdst was not refcounted, check we still are in a 
 	 * rcu_read_lock section
 	 */
-	WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
+	(void)WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
 		!rcu_read_lock_held() &&
 		!rcu_read_lock_bh_held());
 	return (struct dst_entry *)(skb->_skb_refdst & SKB_DST_PTRMASK);
@@ -1543,7 +1543,7 @@ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 {
 	if (unlikely(skb_is_nonlinear(skb))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	skb->len = len;
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 7df6c17..b58581b 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -175,7 +175,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 # define raw_spin_lock_nest_lock(lock, nest_lock)			\
 	 do {								\
-		 typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
+		 (void)typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
 		 _raw_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);	\
 	 } while (0)
 #else
@@ -187,20 +187,20 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_spin_lock_irqsave(lock);	\
 	} while (0)
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave_nested(lock, subclass);	\
 	} while (0)
 #else
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave(lock);			\
 	} while (0)
 #endif
@@ -209,7 +209,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)		\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_spin_lock_irqsave(lock, flags);	\
 	} while (0)
 
@@ -225,7 +225,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_unlock_irqrestore(lock, flags)		\
 	do {							\
-		typecheck(unsigned long, flags);		\
+		(void)typecheck(unsigned long, flags);		\
 		_raw_spin_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define raw_spin_unlock_bh(lock)	_raw_spin_unlock_bh(lock)
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 65efb92..35ca2a3 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -181,7 +181,7 @@ extern void zone_statistics(struct zone *, struct zone *, gfp_t gfp);
 
 static inline void zap_zone_vm_stats(struct zone *zone)
 {
-	memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
+	(void)memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
 }
 
 extern void inc_zone_state(struct zone *, enum zone_stat_item);
diff --git a/include/net/dst.h b/include/net/dst.h
index 344c8dd..cbae81d 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -173,7 +173,7 @@ dst_metric_raw(const struct dst_entry *dst, const int metric)
 static inline u32
 dst_metric(const struct dst_entry *dst, const int metric)
 {
-	WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
+	(void)WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
 		     metric == RTAX_ADVMSS ||
 		     metric == RTAX_MTU);
 	return dst_metric_raw(dst, metric);
@@ -303,7 +303,7 @@ static inline void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb
 static inline void skb_dst_force(struct sk_buff *skb)
 {
 	if (skb_dst_is_noref(skb)) {
-		WARN_ON(!rcu_read_lock_held());
+		(void)WARN_ON(!rcu_read_lock_held());
 		skb->_skb_refdst &= ~SKB_DST_NOREF;
 		dst_clone(skb_dst(skb));
 	}
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index dbf9aab..0bb043e 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -172,7 +172,7 @@ static inline int inet_csk_ack_scheduled(const struct sock *sk)
 
 static inline void inet_csk_delack_init(struct sock *sk)
 {
-	memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
+	(void)memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
 }
 
 extern void inet_csk_delete_keepalive_timer(struct sock *sk);
diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index 06b795d..52ac08a 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -102,7 +102,7 @@ extern bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);
  */
 static inline void inet_peer_refcheck(const struct inet_peer *p)
 {
-	WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
+	(void)WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
 }
 
 
diff --git a/include/net/ip.h b/include/net/ip.h
index 775009f..52a58a8 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -384,7 +384,7 @@ static inline int sk_mc_loop(struct sock *sk)
 		return inet6_sk(sk)->mc_loop;
 #endif
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 1;
 }
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index e4170a2..7081938 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -317,7 +317,7 @@ static inline void ipv6_addr_prefix(struct in6_addr *pfx,
 	int o = plen >> 3,
 	    b = plen & 0x7;
 
-	memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
+	(void)memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
 	memcpy(pfx->s6_addr, addr, o);
 	if (b != 0)
 		pfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);
diff --git a/include/net/netlabel.h b/include/net/netlabel.h
index f674409..6b50c2a 100644
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@ -303,7 +303,7 @@ static inline void netlbl_secattr_catmap_free(
  */
 static inline void netlbl_secattr_init(struct netlbl_lsm_secattr *secattr)
 {
-	memset(secattr, 0, sizeof(*secattr));
+	(void)memset(secattr, 0, sizeof(*secattr));
 }
 
 /**
diff --git a/include/net/request_sock.h b/include/net/request_sock.h
index 4c0766e..2c68508 100644
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@ -181,7 +181,7 @@ static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue
 {
 	struct request_sock *req = queue->rskq_accept_head;
 
-	WARN_ON(req == NULL);
+	(void)WARN_ON(req == NULL);
 
 	queue->rskq_accept_head = req->dl_next;
 	if (queue->rskq_accept_head == NULL)
@@ -196,7 +196,7 @@ static inline struct sock *reqsk_queue_get_child(struct request_sock_queue *queu
 	struct request_sock *req = reqsk_queue_remove(queue);
 	struct sock *child = req->sk;
 
-	WARN_ON(child == NULL);
+	(void)WARN_ON(child == NULL);
 
 	sk_acceptq_removed(parent);
 	__reqsk_free(req);
diff --git a/include/net/route.h b/include/net/route.h
index 91855d1..8e809d7 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -156,7 +156,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->flowi4_oif = oif;
 	fl4->daddr = daddr;
 	fl4->saddr = saddr;
diff --git a/include/net/sock.h b/include/net/sock.h
index bb972d2..54d7904 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -474,7 +474,7 @@ static __inline__ int sk_del_node_init(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index 887629e..a1c76ef 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -71,7 +71,7 @@ identify_ramdisk_image(int fd, int start_block, decompress_fn *decompressor)
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
 	squashfsb = (struct squashfs_super_block *) buf;
-	memset(buf, 0xe5, size);
+	(void)memset(buf, 0xe5, size);
 
 	/*
 	 * Read block 0 to test for compressed kernel
diff --git a/init/initramfs.c b/init/initramfs.c
index 8216c30..5e6b06b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -507,7 +507,7 @@ static void __init free_initrd(void)
 		 * Initialize initrd memory region since the kexec boot does
 		 * not do.
 		 */
-		memset((void *)initrd_start, 0, initrd_end - initrd_start);
+		(void)memset((void *)initrd_start, 0, initrd_end - initrd_start);
 		if (initrd_start < crashk_start)
 			free_initrd_mem(initrd_start, crashk_start);
 		if (initrd_end > crashk_end)
@@ -530,11 +530,11 @@ static void __init clean_rootfs(void)
 	int num;
 
 	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
-	WARN_ON(fd < 0);
+	(void)WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
 	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
-	WARN_ON(!buf);
+	(void)WARN_ON(!buf);
 	if (!buf) {
 		sys_close(fd);
 		return;
@@ -548,7 +548,7 @@ static void __init clean_rootfs(void)
 			int ret;
 
 			ret = sys_newlstat(dirp->d_name, &st);
-			WARN_ON_ONCE(ret);
+			(void)WARN_ON_ONCE(ret);
 			if (!ret) {
 				if (S_ISDIR(st.st_mode))
 					sys_rmdir(dirp->d_name);
@@ -560,7 +560,7 @@ static void __init clean_rootfs(void)
 			dirp = (void *)dirp + dirp->d_reclen;
 		}
 		dirp = buf;
-		memset(buf, 0, BUF_SIZE);
+		(void)memset(buf, 0, BUF_SIZE);
 		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index e66e9b6..d365326 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -348,7 +348,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	int len;
 
 	if (env->envp_idx >= ARRAY_SIZE(env->envp)) {
-		WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
 		return -ENOMEM;
 	}
 
@@ -359,7 +359,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	va_end(args);
 
 	if (len >= (sizeof(env->buf) - env->buflen)) {
-		WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
 		return -ENOMEM;
 	}
 
diff --git a/lib/plist.c b/lib/plist.c
index a0a4da4..5117cd1 100644
--- a/lib/plist.c
+++ b/lib/plist.c
@@ -33,7 +33,7 @@ static struct plist_head test_head;
 static void plist_check_prev_next(struct list_head *t, struct list_head *p,
 				  struct list_head *n)
 {
-	WARN(n->prev != p || p->next != n,
+	(void)WARN(n->prev != p || p->next != n,
 			"top: %p, n: %p, p: %p\n"
 			"prev: %p, n: %p, p: %p\n"
 			"next: %p, n: %p, p: %p\n",
@@ -77,8 +77,8 @@ void plist_add(struct plist_node *node, struct plist_head *head)
 	struct list_head *node_next = &head->node_list;
 
 	plist_check_head(head);
-	WARN_ON(!plist_node_empty(node));
-	WARN_ON(!list_empty(&node->prio_list));
+	(void)WARN_ON(!plist_node_empty(node));
+	(void)WARN_ON(!list_empty(&node->prio_list));
 
 	if (plist_head_empty(head))
 		goto ins_node;
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index 4ceb05d..af9e1f7 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -84,7 +84,7 @@ EXPORT_SYMBOL(sg_last);
  **/
 void sg_init_table(struct scatterlist *sgl, unsigned int nents)
 {
-	memset(sgl, 0, sizeof(*sgl) * nents);
+	(void)memset(sgl, 0, sizeof(*sgl) * nents);
 #ifdef CONFIG_DEBUG_SG
 	{
 		unsigned int i;
@@ -232,7 +232,7 @@ int __sg_alloc_table(struct sg_table *table, unsigned int nents,
 	BUG_ON(nents > max_ents);
 #endif
 
-	memset(table, 0, sizeof(*table));
+	(void)memset(table, 0, sizeof(*table));
 
 	left = nents;
 	prv = NULL;
@@ -333,12 +333,12 @@ EXPORT_SYMBOL(sg_alloc_table);
 void sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
 		    unsigned int nents, unsigned int flags)
 {
-	memset(miter, 0, sizeof(struct sg_mapping_iter));
+	(void)memset(miter, 0, sizeof(struct sg_mapping_iter));
 
 	miter->__sg = sgl;
 	miter->__nents = nents;
 	miter->__offset = 0;
-	WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
+	(void)WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
 	miter->__flags = flags;
 }
 EXPORT_SYMBOL(sg_miter_start);
@@ -413,7 +413,7 @@ EXPORT_SYMBOL(sg_miter_next);
  */
 void sg_miter_stop(struct sg_mapping_iter *miter)
 {
-	WARN_ON(miter->consumed > miter->length);
+	(void)WARN_ON(miter->consumed > miter->length);
 
 	/* drop resources from the last iteration */
 	if (miter->addr) {
@@ -423,7 +423,7 @@ void sg_miter_stop(struct sg_mapping_iter *miter)
 			flush_kernel_dcache_page(miter->page);
 
 		if (miter->__flags & SG_MITER_ATOMIC) {
-			WARN_ON(!irqs_disabled());
+			(void)WARN_ON(!irqs_disabled());
 			kunmap_atomic(miter->addr, KM_BIO_SRC_IRQ);
 		} else
 			kunmap(miter->page);
diff --git a/lib/timerqueue.c b/lib/timerqueue.c
index 191176a..e520c72 100644
--- a/lib/timerqueue.c
+++ b/lib/timerqueue.c
@@ -42,7 +42,7 @@ void timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)
 	struct timerqueue_node  *ptr;
 
 	/* Make sure we don't add nodes that are already added */
-	WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
 
 	while (*p) {
 		parent = *p;
@@ -70,7 +70,7 @@ EXPORT_SYMBOL_GPL(timerqueue_add);
  */
 void timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
 {
-	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
 
 	/* update next pointer */
 	if (head->next == node) {
diff --git a/net/core/filter.c b/net/core/filter.c
index 5dea452..041dabf 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -351,7 +351,7 @@ load_b:
 			continue;
 		}
 		default:
-			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
+			(void)WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 				       fentry->code, fentry->jt,
 				       fentry->jf, fentry->k);
 			return 0;
@@ -380,7 +380,7 @@ static int check_load_and_stores(struct sock_filter *filter, int flen)
 	masks = kmalloc(flen * sizeof(*masks), GFP_KERNEL);
 	if (!masks)
 		return -ENOMEM;
-	memset(masks, 0xff, flen * sizeof(*masks));
+	(void)memset(masks, 0xff, flen * sizeof(*masks));
 
 	for (pc = 0; pc < flen; pc++) {
 		memvalid &= masks[pc];
diff --git a/net/core/flow.c b/net/core/flow.c
index e318c7e..c848334 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -430,7 +430,7 @@ static int __init flow_cache_init(struct flow_cache *fc)
 	fc->hotcpu_notifier = (struct notifier_block){
 		.notifier_call = flow_cache_cpu,
 	};
-	register_hotcpu_notifier(&fc->hotcpu_notifier);
+	(void)register_hotcpu_notifier(&fc->hotcpu_notifier);
 
 	setup_timer(&fc->rnd_timer, flow_cache_new_hashrnd,
 		    (unsigned long) fc);
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index a1727cd..2ab3e1b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -338,7 +338,7 @@ static ssize_t netstat_show(const struct device *d,
 	struct net_device *dev = to_net_dev(d);
 	ssize_t ret = -EINVAL;
 
-	WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
+	(void)WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
 			offset % sizeof(u64) != 0);
 
 	read_lock(&dev_base_lock);
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index a246836..c98e70b 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -105,7 +105,7 @@ int eth_header(struct sk_buff *skb, struct net_device *dev,
 	 */
 
 	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		memset(eth->h_dest, 0, ETH_ALEN);
+		(void)memset(eth->h_dest, 0, ETH_ALEN);
 		return ETH_HLEN;
 	}
 
@@ -342,7 +342,7 @@ void ether_setup(struct net_device *dev)
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 	dev->priv_flags		|= IFF_TX_SKB_SHARING;
 
-	memset(dev->broadcast, 0xFF, ETH_ALEN);
+	(void)memset(dev->broadcast, 0xFF, ETH_ALEN);
 
 }
 EXPORT_SYMBOL(ether_setup);
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 59402be..41a94dd 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -670,7 +670,7 @@ struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
 	if (target_hw != NULL)
 		memcpy(arp_ptr, target_hw, dev->addr_len);
 	else
-		memset(arp_ptr, 0, dev->addr_len);
+		(void)memset(arp_ptr, 0, dev->addr_len);
 	arp_ptr += dev->addr_len;
 	memcpy(arp_ptr, &dest_ip, 4);
 
@@ -958,7 +958,7 @@ static int arp_rcv(struct sk_buff *skb, struct net_device *dev,
 	if (skb == NULL)
 		goto out_of_mem;
 
-	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
+	(void)memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
 	return NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process);
 
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 2e4e244..f7f1f0c 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -201,7 +201,7 @@ tb_not_found:
 success:
 	if (!inet_csk(sk)->icsk_bind_hash)
 		inet_bind_hash(sk, tb, snum);
-	WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
+	(void)WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
 	ret = 0;
 
 fail_unlock:
@@ -293,7 +293,7 @@ struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)
 	}
 
 	newsk = reqsk_queue_get_child(&icsk->icsk_accept_queue, sk);
-	WARN_ON(newsk->sk_state == TCP_SYN_RECV);
+	(void)WARN_ON(newsk->sk_state == TCP_SYN_RECV);
 out:
 	release_sock(sk);
 	return newsk;
@@ -443,7 +443,7 @@ struct request_sock *inet_csk_search_req(const struct sock *sk,
 		    ireq->rmt_addr == raddr &&
 		    ireq->loc_addr == laddr &&
 		    AF_INET_FAMILY(req->rsk_ops->family)) {
-			WARN_ON(req->sk);
+			(void)WARN_ON(req->sk);
 			*prevp = prev;
 			break;
 		}
@@ -618,7 +618,7 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,
 		newicsk->icsk_probes_out  = 0;
 
 		/* Deinitialize accept_queue to trap illegal accesses. */
-		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
+		(void)memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
 
 		security_inet_csk_clone(newsk, req);
 	}
@@ -634,14 +634,14 @@ EXPORT_SYMBOL_GPL(inet_csk_clone_lock);
  */
 void inet_csk_destroy_sock(struct sock *sk)
 {
-	WARN_ON(sk->sk_state != TCP_CLOSE);
-	WARN_ON(!sock_flag(sk, SOCK_DEAD));
+	(void)WARN_ON(sk->sk_state != TCP_CLOSE);
+	(void)WARN_ON(!sock_flag(sk, SOCK_DEAD));
 
 	/* It cannot be in hash table! */
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	/* If it has not 0 inet_sk(sk)->inet_num, it must be bound */
-	WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
+	(void)WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
 
 	sk->sk_prot->destroy(sk);
 
@@ -722,7 +722,7 @@ void inet_csk_listen_stop(struct sock *sk)
 
 		local_bh_disable();
 		bh_lock_sock(child);
-		WARN_ON(sock_owned_by_user(child));
+		(void)WARN_ON(sock_owned_by_user(child));
 		sock_hold(child);
 
 		sk->sk_prot->disconnect(child, O_NONBLOCK);
@@ -740,7 +740,7 @@ void inet_csk_listen_stop(struct sock *sk)
 		sk_acceptq_removed(sk);
 		__reqsk_free(req);
 	}
-	WARN_ON(sk->sk_ack_backlog);
+	(void)WARN_ON(sk->sk_ack_backlog);
 }
 EXPORT_SYMBOL_GPL(inet_csk_listen_stop);
 
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 984ec65..5ea6a1e 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -339,7 +339,7 @@ unique:
 	inet->inet_num = lport;
 	inet->inet_sport = htons(lport);
 	sk->sk_hash = hash;
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	__sk_nulls_add_node_rcu(sk, &head->chain);
 	if (tw) {
 		twrefcnt = inet_twsk_unhash(tw);
@@ -381,7 +381,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	struct inet_ehash_bucket *head;
 	int twrefcnt = 0;
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	sk->sk_hash = inet_sk_ehashfn(sk);
 	head = inet_ehash_bucket(hashinfo, sk->sk_hash);
@@ -391,7 +391,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	spin_lock(lock);
 	__sk_nulls_add_node_rcu(sk, list);
 	if (tw) {
-		WARN_ON(sk->sk_hash != tw->tw_hash);
+		(void)WARN_ON(sk->sk_hash != tw->tw_hash);
 		twrefcnt = inet_twsk_unhash(tw);
 	}
 	spin_unlock(lock);
@@ -410,7 +410,7 @@ static void __inet_hash(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	ilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
 
 	spin_lock(&ilb->lock);
@@ -493,7 +493,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 				    tb->port == port) {
 					if (tb->fastreuse >= 0)
 						goto next_port;
-					WARN_ON(hlist_empty(&tb->owners));
+					(void)WARN_ON(hlist_empty(&tb->owners));
 					if (!check_established(death_row, sk,
 								port, &tw))
 						goto ok;
diff --git a/net/ipv4/inet_timewait_sock.c b/net/ipv4/inet_timewait_sock.c
index 89168c6..4f79d22 100644
--- a/net/ipv4/inet_timewait_sock.c
+++ b/net/ipv4/inet_timewait_sock.c
@@ -139,7 +139,7 @@ void __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,
 			hashinfo->bhash_size)];
 	spin_lock(&bhead->lock);
 	tw->tw_tb = icsk->icsk_bind_hash;
-	WARN_ON(!icsk->icsk_bind_hash);
+	(void)WARN_ON(!icsk->icsk_bind_hash);
 	inet_twsk_add_bind_node(tw, &tw->tw_tb->owners);
 	spin_unlock(&bhead->lock);
 
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 1f23a57..d97316d 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -571,8 +571,8 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 		qp->q.fragments = head;
 	}
 
-	WARN_ON(head == NULL);
-	WARN_ON(FRAG_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(FRAG_CB(head)->offset != 0);
 
 	/* Allocate a new buffer for the datagram. */
 	ihlen = ip_hdrlen(head);
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 073a9b0..6ea13f7 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -435,7 +435,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	}
 
 	/* Remove any debris in the socket control block */
-	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+	(void)memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index 1e60f76..7665eab 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -64,12 +64,12 @@ void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
 		return;
 	}
 	if (opt->rr) {
-		memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
+		(void)memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
 		opt->rr = 0;
 		opt->rr_needaddr = 0;
 	}
 	if (opt->ts) {
-		memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
+		(void)memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
 		opt->ts = 0;
 		opt->ts_needaddr = opt->ts_needtime = 0;
 	}
@@ -92,7 +92,7 @@ int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)
 	int	optlen;
 	__be32	daddr;
 
-	memset(dopt, 0, sizeof(struct ip_options));
+	(void)memset(dopt, 0, sizeof(struct ip_options));
 
 	sopt = &(IPCB(skb)->opt);
 
@@ -228,7 +228,7 @@ void ip_options_fragment(struct sk_buff * skb)
 		if (optlen<2 || optlen>l)
 		  return;
 		if (!IPOPT_COPIED(*optptr))
-			memset(optptr, IPOPT_NOOP, optlen);
+			(void)memset(optptr, IPOPT_NOOP, optlen);
 		l -= optlen;
 		optptr += optlen;
 	}
@@ -481,19 +481,19 @@ void ip_options_undo(struct ip_options * opt)
 	if (opt->rr_needaddr) {
 		unsigned  char * optptr = opt->__data+opt->rr-sizeof(struct  iphdr);
 		optptr[2] -= 4;
-		memset(&optptr[optptr[2]-1], 0, 4);
+		(void)memset(&optptr[optptr[2]-1], 0, 4);
 	}
 	if (opt->ts) {
 		unsigned  char * optptr = opt->__data+opt->ts-sizeof(struct  iphdr);
 		if (opt->ts_needtime) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 			if ((optptr[3]&0xF) == IPOPT_TS_PRESPEC)
 				optptr[2] -= 4;
 		}
 		if (opt->ts_needaddr) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 		}
 	}
 }
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 8aa87c1..6350fc9 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -139,7 +139,7 @@ static void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = iph->daddr;
 	sin.sin_port = ports[1];
-	memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+	(void)memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
 
 	put_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);
 }
@@ -403,7 +403,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +
 						   serr->addr_offset);
 		sin->sin_port = serr->port;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
@@ -415,7 +415,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 		if (inet->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	}
@@ -647,7 +647,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (optlen >= sizeof(struct in_addr) &&
 			    copy_from_user(&mreq.imr_address, optval,
 					   sizeof(struct in_addr)))
@@ -700,7 +700,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))
 				break;
 		}
@@ -800,7 +800,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		psin = (struct sockaddr_in *)&greq.gr_group;
 		if (psin->sin_family != AF_INET)
 			goto e_inval;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		mreq.imr_multiaddr = psin->sin_addr;
 		mreq.imr_ifindex = greq.gr_interface;
 
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index 3ccda5a..ad004e9 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -717,7 +717,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
@@ -736,7 +736,7 @@ static int raw_init(struct sock *sk)
 	struct raw_sock *rp = raw_sk(sk);
 
 	if (inet_sk(sk)->inet_num == IPPROTO_ICMP)
-		memset(&rp->filter, 0, sizeof(rp->filter));
+		(void)memset(&rp->filter, 0, sizeof(rp->filter));
 	return 0;
 }
 
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bcacf54..6209d52 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1847,7 +1847,7 @@ static int ip_rt_bug(struct sk_buff *skb)
 		&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,
 		skb->dev ? skb->dev->name : "?");
 	kfree_skb(skb);
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 9bcdec3..14d6111 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1198,7 +1198,7 @@ void tcp_cleanup_rbuf(struct sock *sk, int copied)
 
 	struct sk_buff *skb = skb_peek(&sk->sk_receive_queue);
 
-	WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
+	(void)WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
 	     "cleanup rbuf bug: copied %X seq %X rcvnxt %X\n",
 	     tp->copied_seq, TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt);
 
@@ -1492,7 +1492,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 				goto found_ok_skb;
 			if (tcp_hdr(skb)->fin)
 				goto found_fin_ok;
-			WARN(!(flags & MSG_PEEK),
+			(void)WARN(!(flags & MSG_PEEK),
 			     "recvmsg bug 2: copied %X seq %X rcvnxt %X fl %X\n",
 			     *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);
 		}
@@ -1555,7 +1555,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 			tp->ucopy.len = len;
 
-			WARN_ON(tp->copied_seq != tp->rcv_nxt &&
+			(void)WARN_ON(tp->copied_seq != tp->rcv_nxt &&
 				!(flags & (MSG_PEEK | MSG_TRUNC)));
 
 			/* Ugly... If prequeue is not empty, we have to
@@ -1972,7 +1972,7 @@ adjudge_to_death:
 	 */
 	local_bh_disable();
 	bh_lock_sock(sk);
-	WARN_ON(sock_owned_by_user(sk));
+	(void)WARN_ON(sock_owned_by_user(sk));
 
 	percpu_counter_inc(sk->sk_prot->orphan_count);
 
@@ -2101,10 +2101,10 @@ int tcp_disconnect(struct sock *sk, int flags)
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
 	tcp_init_send_head(sk);
-	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
+	(void)memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
 	__sk_dst_reset(sk);
 
-	WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
+	(void)WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
 
 	sk->sk_error_report(sk);
 	return err;
@@ -2437,7 +2437,7 @@ void tcp_get_info(const struct sock *sk, struct tcp_info *info)
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	u32 now = tcp_time_stamp;
 
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 
 	info->tcpi_state = sk->sk_state;
 	info->tcpi_ca_state = icsk->icsk_ca_state;
@@ -2585,7 +2585,7 @@ static int do_tcp_getsockopt(struct sock *sk, int level,
 		if (len < sizeof(ctd))
 			return -EINVAL;
 
-		memset(&ctd, 0, sizeof(ctd));
+		(void)memset(&ctd, 0, sizeof(ctd));
 		ctd.tcpct_flags = (tp->rx_opt.cookie_in_always ?
 				   TCP_COOKIE_IN_ALWAYS : 0)
 				| (tp->rx_opt.cookie_out_never ?
@@ -3295,8 +3295,8 @@ void __init tcp_init(void)
 
 	tcp_register_congestion_control(&tcp_reno);
 
-	memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
-	memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
+	(void)memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
+	(void)memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
 	tcp_secret_one.expires = jiffy; /* past due */
 	tcp_secret_two.expires = jiffy; /* past due */
 	tcp_secret_generating = &tcp_secret_one;
diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c
index fc6d475..3e03f5a 100644
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@ -220,7 +220,7 @@ int tcp_set_allowed_congestion_control(char *val)
 	/* pass 3 mark as allowed */
 	while ((name = strsep(&val, " ")) && *name) {
 		ca = tcp_ca_find(name);
-		WARN_ON(!ca);
+		(void)WARN_ON(!ca);
 		if (ca)
 			ca->flags |= TCP_CONG_NON_RESTRICTED;
 	}
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 2877c3e..6be2d34 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1935,10 +1935,10 @@ advance_sp:
 out:
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
-	WARN_ON((int)tcp_packets_in_flight(tp) < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tcp_packets_in_flight(tp) < 0);
 #endif
 	return state.flag;
 }
@@ -2526,7 +2526,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 	int err;
 	unsigned int mss;
 
-	WARN_ON(packets > tp->packets_out);
+	(void)WARN_ON(packets > tp->packets_out);
 	if (tp->lost_skb_hint) {
 		skb = tp->lost_skb_hint;
 		cnt = tp->lost_cnt_hint;
@@ -3048,7 +3048,7 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked,
 	/* E. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
 	if (icsk->icsk_ca_state == TCP_CA_Open) {
-		WARN_ON(tp->retrans_out != 0);
+		(void)WARN_ON(tp->retrans_out != 0);
 		tp->retrans_stamp = 0;
 	} else if (!before(tp->snd_una, tp->high_seq)) {
 		switch (icsk->icsk_ca_state) {
@@ -3413,9 +3413,9 @@ static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,
 	}
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
 	if (!tp->packets_out && tcp_is_sack(tp)) {
 		icsk = inet_csk(sk);
 		if (tp->lost_out) {
@@ -4361,7 +4361,7 @@ static void tcp_sack_remove(struct tcp_sock *tp)
 			int i;
 
 			/* RCV.NXT must cover all the block! */
-			WARN_ON(before(tp->rcv_nxt, sp->end_seq));
+			(void)WARN_ON(before(tp->rcv_nxt, sp->end_seq));
 
 			/* Zap this SACK, by moving forward any other SACKS. */
 			for (i=this_sack+1; i < num_sacks; i++)
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 1eb4ad5..0d28b10 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -472,7 +472,7 @@ void tcp_v4_err(struct sk_buff *icmp_skb, u32 info)
 		/* ICMPs are not backlogged, hence we cannot get
 		   an established socket here.
 		 */
-		WARN_ON(req->sk);
+		(void)WARN_ON(req->sk);
 
 		if (seq != tcp_rsk(req)->snt_isn) {
 			NET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -612,7 +612,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 		return;
 
 	/* Swap the send and the receive. */
-	memset(&rep, 0, sizeof(rep));
+	(void)memset(&rep, 0, sizeof(rep));
 	rep.th.dest   = th->source;
 	rep.th.source = th->dest;
 	rep.th.doff   = sizeof(struct tcphdr) / 4;
@@ -626,7 +626,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 				       skb->len - (th->doff << 2));
 	}
 
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&arg, 0, sizeof(arg));
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
 
@@ -682,8 +682,8 @@ static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack,
 	struct ip_reply_arg arg;
 	struct net *net = dev_net(skb_dst(skb)->dev);
 
-	memset(&rep.th, 0, sizeof(struct tcphdr));
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&rep.th, 0, sizeof(struct tcphdr));
+	(void)memset(&arg, 0, sizeof(arg));
 
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
@@ -1121,7 +1121,7 @@ static int tcp_v4_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 
@@ -1171,7 +1171,7 @@ int tcp_v4_md5_hash_skb(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 EXPORT_SYMBOL(tcp_v4_md5_hash_skb);
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 8c8de27..a5d4c47 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -826,7 +826,7 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 	inet = inet_sk(sk);
 	tp = tcp_sk(sk);
 	tcb = TCP_SKB_CB(skb);
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 
 	if (unlikely(tcb->tcp_flags & TCPHDR_SYN))
 		tcp_options_size = tcp_syn_options(sk, skb, &opts, &md5);
@@ -2478,7 +2478,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 		ireq->rcv_wscale = rcv_wscale;
 	}
 
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 #ifdef CONFIG_SYN_COOKIES
 	if (unlikely(req->cookie_ts))
 		TCP_SKB_CB(skb)->when = cookie_init_timestamp(req);
@@ -2493,7 +2493,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 	skb_reset_transport_header(skb);
 
 	th = tcp_hdr(skb);
-	memset(th, 0, sizeof(struct tcphdr));
+	(void)memset(th, 0, sizeof(struct tcphdr));
 	th->syn = 1;
 	th->ack = 1;
 	TCP_ECN_make_synack(req, th);
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index a516d1e..c8222a4 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -325,7 +325,7 @@ void tcp_retransmit_timer(struct sock *sk)
 	if (!tp->packets_out)
 		goto out;
 
-	WARN_ON(tcp_write_queue_empty(sk));
+	(void)WARN_ON(tcp_write_queue_empty(sk));
 
 	if (!tp->snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
 	    !((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 5d075b5..2d969bb 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1230,7 +1230,7 @@ try_again:
 		sin->sin_family = AF_INET;
 		sin->sin_port = udp_hdr(skb)->source;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/sunrpc/addr.c b/net/sunrpc/addr.c
index ee77742..d7e685a 100644
--- a/net/sunrpc/addr.c
+++ b/net/sunrpc/addr.c
@@ -146,7 +146,7 @@ static size_t rpc_pton4(const char *buf, const size_t buflen,
 	if (buflen > INET_ADDRSTRLEN || salen < sizeof(struct sockaddr_in))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in));
 
 	if (in4_pton(buf, buflen, addr, '\0', NULL) == 0)
 		return 0;
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 727e506..e3d21ad 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -424,7 +424,7 @@ rpcauth_lookupcred(struct rpc_auth *auth, int flags)
 	dprintk("RPC:       looking up %s cred\n",
 		auth->au_ops->au_name);
 
-	memset(&acred, 0, sizeof(acred));
+	(void)memset(&acred, 0, sizeof(acred));
 	acred.uid = cred->fsuid;
 	acred.gid = cred->fsgid;
 	acred.group_info = get_group_info(((struct cred *)cred)->group_info);
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 3341d89..f69e9dd 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -820,7 +820,7 @@ EXPORT_SYMBOL_GPL(rpc_free);
  */
 static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)
 {
-	memset(task, 0, sizeof(*task));
+	(void)memset(task, 0, sizeof(*task));
 	atomic_set(&task->tk_count, 1);
 	task->tk_flags  = task_setup_data->flags;
 	task->tk_ops = task_setup_data->callback_ops;
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 74cb0d8..b8b7b86 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -151,7 +151,7 @@ EXPORT_SYMBOL_GPL(svc_xprt_put);
 void svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,
 		   struct svc_xprt *xprt, struct svc_serv *serv)
 {
-	memset(xprt, 0, sizeof(*xprt));
+	(void)memset(xprt, 0, sizeof(*xprt));
 	xprt->xpt_class = xcl;
 	xprt->xpt_ops = xcl->xcl_ops;
 	kref_init(&xprt->xpt_ref);
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 4645709..1e74d56 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1360,7 +1360,7 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 
 		svsk->sk_reclen = 0;
 		svsk->sk_tcplen = 0;
-		memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
+		(void)memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
 
 		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;
 
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 593f4c6..0735555 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -67,7 +67,7 @@ __be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)
 		if (ptr != NULL)
 			memcpy(p, ptr, nbytes);
 		if (padding != 0)
-			memset((char *)p + nbytes, 0, padding);
+			(void)memset((char *)p + nbytes, 0, padding);
 		p += quadlen;
 	}
 	return p;
@@ -649,7 +649,7 @@ EXPORT_SYMBOL_GPL(xdr_init_decode);
 void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,
 			   struct page **pages, unsigned int len)
 {
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	buf->pages =  pages;
 	buf->page_len =  len;
 	buf->buflen =  len;
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 55472c4..c078dcc 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1080,7 +1080,7 @@ static inline void xs_tcp_read_xid(struct sock_xprt *transport, struct xdr_skb_r
 	char *p;
 
 	len = sizeof(transport->tcp_xid) - transport->tcp_offset;
-	dprintk("RPC:       reading XID (%Zu bytes)\n", len);
+	dprintk("RPC:       reading XID (%zu bytes)\n", len);
 	p = ((char *) &transport->tcp_xid) + transport->tcp_offset;
 	used = xdr_skb_read_bits(desc, p, len);
 	transport->tcp_offset += used;
@@ -1111,7 +1111,7 @@ static inline void xs_tcp_read_calldir(struct sock_xprt *transport,
 	 */
 	offset = transport->tcp_offset - sizeof(transport->tcp_xid);
 	len = sizeof(transport->tcp_calldir) - offset;
-	dprintk("RPC:       reading CALL/REPLY flag (%Zu bytes)\n", len);
+	dprintk("RPC:       reading CALL/REPLY flag (%zu bytes)\n", len);
 	p = ((char *) &transport->tcp_calldir) + offset;
 	used = xdr_skb_read_bits(desc, p, len);
 	transport->tcp_offset += used;
@@ -1202,7 +1202,7 @@ static inline void xs_tcp_read_common(struct rpc_xprt *xprt,
 		return;
 	}
 
-	dprintk("RPC:       XID %08x read %Zd bytes\n",
+	dprintk("RPC:       XID %08x read %zd bytes\n",
 			ntohl(transport->tcp_xid), r);
 	dprintk("RPC:       xprt = %p, tcp_copied = %lu, tcp_offset = %u, "
 			"tcp_reclen = %u\n", xprt, transport->tcp_copied,
@@ -1344,7 +1344,7 @@ static inline void xs_tcp_read_discard(struct sock_xprt *transport, struct xdr_s
 	desc->count -= len;
 	desc->offset += len;
 	transport->tcp_offset += len;
-	dprintk("RPC:       discarded %Zu bytes\n", len);
+	dprintk("RPC:       discarded %zu bytes\n", len);
 	xs_tcp_check_fraghdr(transport);
 }
 
diff --git a/net/sysctl_net.c b/net/sysctl_net.c
index e758139..e3a86d9 100644
--- a/net/sysctl_net.c
+++ b/net/sysctl_net.c
@@ -82,7 +82,7 @@ static int __net_init sysctl_net_init(struct net *net)
 
 static void __net_exit sysctl_net_exit(struct net *net)
 {
-	WARN_ON(!list_empty(&net->sysctls.list));
+	(void)WARN_ON(!list_empty(&net->sysctls.list));
 }
 
 static struct pernet_operations sysctl_pernet_ops = {
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aad8fb6..7ca7faa 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1333,7 +1333,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 static void unix_destruct_scm(struct sk_buff *skb)
 {
 	struct scm_cookie scm;
-	memset(&scm, 0, sizeof(scm));
+	(void)memset(&scm, 0, sizeof(scm));
 	scm.pid  = UNIXCB(skb).pid;
 	scm.cred = UNIXCB(skb).cred;
 	if (UNIXCB(skb).fp)
@@ -1800,7 +1800,7 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 	scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).cred);
 	unix_set_secdata(siocb->scm, skb);
@@ -1904,7 +1904,7 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
 	err = mutex_lock_interruptible(&u->readlock);
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 5b228f9..b23979b 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -516,7 +516,7 @@ void __xfrm_state_destroy(struct xfrm_state *x)
 {
 	struct net *net = xs_net(x);
 
-	WARN_ON(x->km.state != XFRM_STATE_DEAD);
+	(void)WARN_ON(x->km.state != XFRM_STATE_DEAD);
 
 	spin_lock_bh(&xfrm_state_gc_lock);
 	hlist_add_head(&x->gclist, &net->xfrm.state_gc_list);
@@ -2051,14 +2051,14 @@ void xfrm_state_fini(struct net *net)
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, &audit_info);
 	flush_work(&net->xfrm.state_gc_work);
 
-	WARN_ON(!list_empty(&net->xfrm.state_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.state_all));
 
 	sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.state_byspi));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_byspi));
 	xfrm_hash_free(net->xfrm.state_byspi, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
 	xfrm_hash_free(net->xfrm.state_bysrc, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bydst));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bydst));
 	xfrm_hash_free(net->xfrm.state_bydst, sz);
 }
 
