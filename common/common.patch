diff --git a/crypto/shash.c b/crypto/shash.c
index 9100912..5ec0ebd 100644
--- a/crypto/shash.c
+++ b/crypto/shash.c
@@ -67,7 +67,8 @@ EXPORT_SYMBOL_GPL(crypto_shash_setkey);
 static inline unsigned int shash_align_buffer_size(unsigned len,
 						   unsigned long mask)
 {
-	return len + (mask & ~(__alignof__(u8 __attribute__ ((aligned))) - 1));
+	// FIXME (aligned not supported) - return len + (mask & ~(__alignof__(u8 __attribute__ ((aligned))) - 1));
+	return len + (mask & ~(__alignof__(u8) - 1));
 }
 
 static int shash_update_unaligned(struct shash_desc *desc, const u8 *data,
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 0d955ff..667ce16 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -1506,9 +1506,15 @@ static struct amba_id mmci_ids[] = {
 	{ 0, 0 },
 };
 
-MODULE_DEVICE_TABLE(amba, mmci_ids);
+// FIXME
+// MODULE_DEVICE_TABLE(amba, mmci_ids);
+// Which expands to:
+// extern const struct amba_device_id __mod_amba_device_table __attribute__ ((unused, __alias__("mmci_ids")));
+// causes the following error in LLVM:
+// ERROR: "__unnamed_1" [drivers/mmc/host/mmci.ko] undefined!
 
-static struct amba_driver mmci_driver = {
+
+static struct amba_driver mmci_driver __refdata = {
 	.drv		= {
 		.name	= DRIVER_NAME,
 	},
diff --git a/drivers/tty/serial/8250.c b/drivers/tty/serial/8250.c
index 9f50c4e..cd41fb3 100644
--- a/drivers/tty/serial/8250.c
+++ b/drivers/tty/serial/8250.c
@@ -3106,7 +3106,7 @@ static int serial8250_resume(struct platform_device *dev)
 	return 0;
 }
 
-static struct platform_driver serial8250_isa_driver = {
+static struct platform_driver serial8250_isa_driver __refdata = {
 	.probe		= serial8250_probe,
 	.remove		= __devexit_p(serial8250_remove),
 	.suspend	= serial8250_suspend,
diff --git a/fs/bio.c b/fs/bio.c
index b1fe82c..152fa2a 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -424,7 +424,7 @@ void bio_put(struct bio *bio)
 }
 EXPORT_SYMBOL(bio_put);
 
-inline int bio_phys_segments(struct request_queue *q, struct bio *bio)
+int bio_phys_segments(struct request_queue *q, struct bio *bio)
 {
 	if (unlikely(!bio_flagged(bio, BIO_SEG_VALID)))
 		blk_recount_segments(q, bio);
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 0e575d1..ee252b0 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -41,7 +41,7 @@ static inline struct bdev_inode *BDEV_I(struct inode *inode)
 	return container_of(inode, struct bdev_inode, vfs_inode);
 }
 
-inline struct block_device *I_BDEV(struct inode *inode)
+struct block_device *I_BDEV(struct inode *inode)
 {
 	return &BDEV_I(inode)->bdev;
 }
diff --git a/fs/buffer.c b/fs/buffer.c
index 1a30db7..adf9efb 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -46,7 +46,7 @@ static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 
 #define BH_ENTRY(list) list_entry((list), struct buffer_head, b_assoc_buffers)
 
-inline void
+void
 init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)
 {
 	bh->b_end_io = handler;
diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index 81c04f4..4bbda3c 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -836,7 +836,7 @@ void __kfree_rcu(struct rcu_head *head, unsigned long offset)
 {
 	typedef void (*rcu_callback)(struct rcu_head *);
 
-	BUILD_BUG_ON(!__builtin_constant_p(offset));
+	// FIXME - BUILD_BUG_ON(!__builtin_constant_p(offset));
 
 	/* See the kfree_rcu() header comment. */
 	BUILD_BUG_ON(!__is_kfree_rcu_offset(offset));
diff --git a/kernel/time.c b/kernel/time.c
index 73e416d..5916c36 100644
--- a/kernel/time.c
+++ b/kernel/time.c
@@ -238,7 +238,7 @@ EXPORT_SYMBOL(current_fs_time);
  * Avoid unnecessary multiplications/divisions in the
  * two most common HZ cases:
  */
-inline unsigned int jiffies_to_msecs(const unsigned long j)
+unsigned int jiffies_to_msecs(const unsigned long j)
 {
 #if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
 	return (MSEC_PER_SEC / HZ) * j;
@@ -254,7 +254,7 @@ inline unsigned int jiffies_to_msecs(const unsigned long j)
 }
 EXPORT_SYMBOL(jiffies_to_msecs);
 
-inline unsigned int jiffies_to_usecs(const unsigned long j)
+unsigned int jiffies_to_usecs(const unsigned long j)
 {
 #if HZ <= USEC_PER_SEC && !(USEC_PER_SEC % HZ)
 	return (USEC_PER_SEC / HZ) * j;
diff --git a/mm/filemap.c b/mm/filemap.c
index 97f49ed..9878f2f 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2162,7 +2162,7 @@ EXPORT_SYMBOL(iov_iter_single_seg_count);
  * Returns appropriate error code that caller should return or
  * zero in case that write should be allowed.
  */
-inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
 {
 	struct inode *inode = file->f_mapping->host;
 	unsigned long limit = rlimit(RLIMIT_FSIZE);
diff --git a/mm/slab.c b/mm/slab.c
index f0bd785..1b55992 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -310,7 +310,8 @@ static __always_inline int index_of(const size_t size)
 {
 	extern void __bad_size(void);
 
-	if (__builtin_constant_p(size)) {
+	//if (__builtin_constant_p(size)) {
+	if (1) {
 		int i = 0;
 
 #define CACHE(x) \diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
diff --git a/net/core/dev.c b/net/core/dev.c
index 115dee1..7cd0a28 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3389,7 +3389,7 @@ out:
 	return netif_receive_skb(skb);
 }
 
-inline void napi_gro_flush(struct napi_struct *napi)
+void napi_gro_flush(struct napi_struct *napi)
 {
 	struct sk_buff *skb, *next;
 
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index ff302bd..c5cce53 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -85,7 +85,7 @@ int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 EXPORT_SYMBOL(sysctl_ip_default_ttl);
 
 /* Generate a checksum for an outgoing IP datagram. */
-__inline__ void ip_send_check(struct iphdr *iph)
+void ip_send_check(struct iphdr *iph)
 {
 	iph->check = 0;
 	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
diff --git a/sound/arm/aaci.c b/sound/arm/aaci.c
index b37b702a..c16beea 100644
--- a/sound/arm/aaci.c
+++ b/sound/arm/aaci.c
@@ -1097,9 +1097,14 @@ static struct amba_id aaci_ids[] = {
 	{ 0, 0 },
 };
 
-MODULE_DEVICE_TABLE(amba, aaci_ids);
+// FIXME
+// MODULE_DEVICE_TABLE(amba, aaci_ids);
+// Which expands to:
+// extern const struct amba_device_id __mod_amba_device_table __attribute__ ((unused, __alias__("aaci_ids")));
+// causes the following error in LLVM:
+// ERROR: "__unnamed_1" [sound/arm/snd-aaci.ko] undefined!
 
-static struct amba_driver aaci_driver = {
+static struct amba_driver aaci_driver __refdata = {
 	.drv		= {
 		.name	= DRIVER_NAME,
 	},
