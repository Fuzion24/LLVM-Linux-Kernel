diff --git a/block/blk-core.c b/block/blk-core.c
index e6c05a9..f6381ad 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -129,7 +129,7 @@ EXPORT_SYMBOL(blk_get_backing_dev_info);
 
 void blk_rq_init(struct request_queue *q, struct request *rq)
 {
-	memset(rq, 0, sizeof(*rq));
+	(void)memset(rq, 0, sizeof(*rq));
 
 	INIT_LIST_HEAD(&rq->queuelist);
 	INIT_LIST_HEAD(&rq->timeout_list);
@@ -237,7 +237,7 @@ EXPORT_SYMBOL(blk_delay_queue);
  **/
 void blk_start_queue(struct request_queue *q)
 {
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	queue_flag_clear(QUEUE_FLAG_STOPPED, q);
 	__blk_run_queue(q);
@@ -1130,7 +1130,7 @@ void __blk_put_request(struct request_queue *q, struct request *req)
 	elv_completed_request(q, req);
 
 	/* this is a bio leak */
-	WARN_ON(req->bio != NULL);
+	(void)WARN_ON(req->bio != NULL);
 
 	/*
 	 * Request may not have originated from ll_rw_blk. if not,
@@ -2443,7 +2443,7 @@ EXPORT_SYMBOL(blk_end_request_cur);
  */
 bool blk_end_request_err(struct request *rq, int error)
 {
-	WARN_ON(error >= 0);
+	(void)WARN_ON(error >= 0);
 	return blk_end_request(rq, error, blk_rq_err_bytes(rq));
 }
 EXPORT_SYMBOL_GPL(blk_end_request_err);
@@ -2522,7 +2522,7 @@ EXPORT_SYMBOL(__blk_end_request_cur);
  */
 bool __blk_end_request_err(struct request *rq, int error)
 {
-	WARN_ON(error >= 0);
+	(void)WARN_ON(error >= 0);
 	return __blk_end_request(rq, error, blk_rq_err_bytes(rq));
 }
 EXPORT_SYMBOL_GPL(__blk_end_request_err);
diff --git a/block/blk-exec.c b/block/blk-exec.c
index fb2cbd5..21fcc0e 100644
--- a/block/blk-exec.c
+++ b/block/blk-exec.c
@@ -50,7 +50,7 @@ void blk_execute_rq_nowait(struct request_queue *q, struct gendisk *bd_disk,
 {
 	int where = at_head ? ELEVATOR_INSERT_FRONT : ELEVATOR_INSERT_BACK;
 
-	WARN_ON(irqs_disabled());
+	(void)WARN_ON(irqs_disabled());
 	spin_lock_irq(q->queue_lock);
 
 	if (unlikely(blk_queue_dead(q))) {
@@ -98,7 +98,7 @@ int blk_execute_rq(struct request_queue *q, struct gendisk *bd_disk,
 	rq->ref_count++;
 
 	if (!rq->sense) {
-		memset(sense, 0, sizeof(sense));
+		(void)memset(sense, 0, sizeof(sense));
 		rq->sense = sense;
 		rq->sense_len = 0;
 	}
diff --git a/block/blk-flush.c b/block/blk-flush.c
index 720ad60..823d9ed 100644
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@ -337,7 +337,7 @@ void blk_insert_flush(struct request *rq)
 	 * @rq should go through flush machinery.  Mark it part of flush
 	 * sequence and submit for further processing.
 	 */
-	memset(&rq->flush, 0, sizeof(rq->flush));
+	(void)memset(&rq->flush, 0, sizeof(rq->flush));
 	INIT_LIST_HEAD(&rq->flush.list);
 	rq->cmd_flags |= REQ_FLUSH_SEQ;
 	rq->flush.saved_end_io = rq->end_io; /* Usually NULL */
diff --git a/block/blk-iopoll.c b/block/blk-iopoll.c
index 58916af..25bf009 100644
--- a/block/blk-iopoll.c
+++ b/block/blk-iopoll.c
@@ -181,7 +181,7 @@ EXPORT_SYMBOL(blk_iopoll_enable);
  **/
 void blk_iopoll_init(struct blk_iopoll *iop, int weight, blk_iopoll_fn *poll_fn)
 {
-	memset(iop, 0, sizeof(*iop));
+	(void)memset(iop, 0, sizeof(*iop));
 	INIT_LIST_HEAD(&iop->list);
 	iop->weight = weight;
 	iop->poll = poll_fn;
@@ -221,7 +221,7 @@ static __init int blk_iopoll_setup(void)
 		INIT_LIST_HEAD(&per_cpu(blk_cpu_iopoll, i));
 
 	open_softirq(BLOCK_IOPOLL_SOFTIRQ, blk_iopoll_softirq);
-	register_hotcpu_notifier(&blk_iopoll_cpu_notifier);
+	(void)register_hotcpu_notifier(&blk_iopoll_cpu_notifier);
 	return 0;
 }
 subsys_initcall(blk_iopoll_setup);
diff --git a/block/blk-merge.c b/block/blk-merge.c
index cfcc37c..08b5415 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -180,7 +180,7 @@ new_segment:
 
 	if (q->dma_drain_size && q->dma_drain_needed(rq)) {
 		if (rq->cmd_flags & REQ_WRITE)
-			memset(q->dma_drain_buffer, 0, q->dma_drain_size);
+			(void)memset(q->dma_drain_buffer, 0, q->dma_drain_size);
 
 		sg->page_link &= ~0x02;
 		sg = sg_next(sg);
@@ -337,7 +337,7 @@ void blk_rq_set_mixed_merge(struct request *rq)
 	 * Distributes the attributs to each bio.
 	 */
 	for (bio = rq->bio; bio; bio = bio->bi_next) {
-		WARN_ON_ONCE((bio->bi_rw & REQ_FAILFAST_MASK) &&
+		(void)WARN_ON_ONCE((bio->bi_rw & REQ_FAILFAST_MASK) &&
 			     (bio->bi_rw & REQ_FAILFAST_MASK) != ff);
 		bio->bi_rw |= ff;
 	}
diff --git a/block/blk-settings.c b/block/blk-settings.c
index d3234fc..a8c11b5 100644
--- a/block/blk-settings.c
+++ b/block/blk-settings.c
@@ -798,7 +798,7 @@ EXPORT_SYMBOL(blk_queue_update_dma_alignment);
  */
 void blk_queue_flush(struct request_queue *q, unsigned int flush)
 {
-	WARN_ON_ONCE(flush & ~(REQ_FLUSH | REQ_FUA));
+	(void)WARN_ON_ONCE(flush & ~(REQ_FLUSH | REQ_FUA));
 
 	if (WARN_ON_ONCE(!(flush & REQ_FLUSH) && (flush & REQ_FUA)))
 		flush &= ~REQ_FUA;
diff --git a/block/blk-softirq.c b/block/blk-softirq.c
index 1366a89..5895d21 100644
--- a/block/blk-softirq.c
+++ b/block/blk-softirq.c
@@ -180,7 +180,7 @@ static __init int blk_softirq_init(void)
 		INIT_LIST_HEAD(&per_cpu(blk_cpu_done, i));
 
 	open_softirq(BLOCK_SOFTIRQ, blk_done_softirq);
-	register_hotcpu_notifier(&blk_cpu_notifier);
+	(void)register_hotcpu_notifier(&blk_cpu_notifier);
 	return 0;
 }
 subsys_initcall(blk_softirq_init);
diff --git a/block/blk.h b/block/blk.h
index 7efd772..4894459 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -222,7 +222,7 @@ void create_io_context_slowpath(struct task_struct *task, gfp_t gfp_mask,
 static inline struct io_context *create_io_context(struct task_struct *task,
 						   gfp_t gfp_mask, int node)
 {
-	WARN_ON_ONCE(irqs_disabled());
+	(void)WARN_ON_ONCE(irqs_disabled());
 	if (unlikely(!task->io_context))
 		create_io_context_slowpath(task, gfp_mask, node);
 	return task->io_context;
diff --git a/block/bsg.c b/block/bsg.c
index 4cf703f..a223d73 100644
--- a/block/bsg.c
+++ b/block/bsg.c
@@ -1012,7 +1012,7 @@ int bsg_register_queue(struct request_queue *q, struct device *parent,
 		return 0;
 
 	bcd = &q->bsg_dev;
-	memset(bcd, 0, sizeof(*bcd));
+	(void)memset(bcd, 0, sizeof(*bcd));
 
 	mutex_lock(&bsg_mutex);
 
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index ee55019..217bc33 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -529,7 +529,7 @@ static inline int cfq_prio_slice(struct cfq_data *cfqd, bool sync,
 {
 	const int base_slice = cfqd->cfq_slice[sync];
 
-	WARN_ON(prio >= IOPRIO_BE_NR);
+	(void)WARN_ON(prio >= IOPRIO_BE_NR);
 
 	return base_slice + (base_slice/CFQ_SLICE_SCALE * (4 - prio));
 }
@@ -545,7 +545,7 @@ static inline u64 cfq_scale_slice(unsigned long delta, struct cfq_group *cfqg)
 	u64 d = delta << CFQ_SERVICE_SHIFT;
 
 	d = d * BLKIO_WEIGHT_DEFAULT;
-	do_div(d, cfqg->weight);
+	(void)do_div(d, cfqg->weight);
 	return d;
 }
 
@@ -1594,7 +1594,7 @@ static void cfq_deactivate_request(struct request_queue *q, struct request *rq)
 {
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 
-	WARN_ON(!cfqd->rq_in_driver);
+	(void)WARN_ON(!cfqd->rq_in_driver);
 	cfqd->rq_in_driver--;
 	cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "deactivate rq, drv=%d",
 						cfqd->rq_in_driver);
@@ -1614,7 +1614,7 @@ static void cfq_remove_request(struct request *rq)
 	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
 					rq_data_dir(rq), rq_is_sync(rq));
 	if (rq->cmd_flags & REQ_PRIO) {
-		WARN_ON(!cfqq->prio_pending);
+		(void)WARN_ON(!cfqq->prio_pending);
 		cfqq->prio_pending--;
 	}
 }
@@ -2025,8 +2025,8 @@ static void cfq_arm_slice_timer(struct cfq_data *cfqd)
 	if (blk_queue_nonrot(cfqd->queue) && cfqd->hw_tag)
 		return;
 
-	WARN_ON(!RB_EMPTY_ROOT(&cfqq->sort_list));
-	WARN_ON(cfq_cfqq_slice_new(cfqq));
+	(void)WARN_ON(!RB_EMPTY_ROOT(&cfqq->sort_list));
+	(void)WARN_ON(cfq_cfqq_slice_new(cfqq));
 
 	/*
 	 * idle is disabled, either manually or by past process history
@@ -2131,7 +2131,7 @@ cfq_prio_to_maxrq(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
 	const int base_rq = cfqd->cfq_slice_async_rq;
 
-	WARN_ON(cfqq->ioprio >= IOPRIO_BE_NR);
+	(void)WARN_ON(cfqq->ioprio >= IOPRIO_BE_NR);
 
 	return 2 * base_rq * (IOPRIO_BE_NR - cfqq->ioprio);
 }
@@ -2697,7 +2697,7 @@ static void cfq_put_cooperator(struct cfq_queue *cfqq)
 	__cfqq = cfqq->new_cfqq;
 	while (__cfqq) {
 		if (__cfqq == cfqq) {
-			WARN(1, "cfqq->new_cfqq loop detected\n");
+			(void)WARN(1, "cfqq->new_cfqq loop detected\n");
 			break;
 		}
 		next = __cfqq->new_cfqq;
@@ -3299,8 +3299,8 @@ static void cfq_completed_request(struct request_queue *q, struct request *rq)
 
 	cfq_update_hw_tag(cfqd);
 
-	WARN_ON(!cfqd->rq_in_driver);
-	WARN_ON(!cfqq->dispatched);
+	(void)WARN_ON(!cfqd->rq_in_driver);
+	(void)WARN_ON(!cfqq->dispatched);
 	cfqd->rq_in_driver--;
 	cfqq->dispatched--;
 	(RQ_CFQG(rq))->dispatched--;
diff --git a/block/genhd.c b/block/genhd.c
index 23b4f70..30ca52e 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -345,7 +345,7 @@ void unregister_blkdev(unsigned int major, const char *name)
 		if ((*n)->major == major)
 			break;
 	if (!*n || strcmp((*n)->name, name)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	} else {
 		p = *n;
 		*n = p->next;
@@ -583,14 +583,14 @@ void add_disk(struct gendisk *disk)
 	 * be accompanied with EXT_DEVT flag.  Make sure all
 	 * parameters make sense.
 	 */
-	WARN_ON(disk->minors && !(disk->major || disk->first_minor));
-	WARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));
+	(void)WARN_ON(disk->minors && !(disk->major || disk->first_minor));
+	(void)WARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));
 
 	disk->flags |= GENHD_FL_UP;
 
 	retval = blk_alloc_devt(&disk->part0, &devt);
 	if (retval) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	disk_to_dev(disk)->devt = devt;
@@ -614,7 +614,7 @@ void add_disk(struct gendisk *disk)
 	 * Take an extra ref on queue which will be put on disk_release()
 	 * so that it sticks around as long as @disk is there.
 	 */
-	WARN_ON_ONCE(!blk_get_queue(disk->queue));
+	(void)WARN_ON_ONCE(!blk_get_queue(disk->queue));
 
 	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
 				   "bdi");
@@ -618,7 +618,7 @@ void add_disk(struct gendisk *disk)
 
 	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
 				   "bdi");
-	WARN_ON(retval);
+	(void)WARN_ON(retval);
 
 	disk_add_events(disk);
 }
@@ -1794,6 +1794,6 @@ static void disk_del_events(struct gendisk *disk)
 static void disk_release_events(struct gendisk *disk)
 {
 	/* the block count should be 1 from disk_del_events() */
-	WARN_ON_ONCE(disk->ev && disk->ev->block != 1);
+	(void)WARN_ON_ONCE(disk->ev && disk->ev->block != 1);
 	kfree(disk->ev);
 }

diff --git a/block/ioctl.c b/block/ioctl.c
index ba15b2d..0fb0f1ef 100644
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@ -260,7 +260,7 @@ int blkdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 		 * We need to set the startsect first, the driver may
 		 * want to override it.
 		 */
-		memset(&geo, 0, sizeof(geo));
+		(void)memset(&geo, 0, sizeof(geo));
 		geo.start = get_start_sect(bdev);
 		ret = disk->fops->getgeo(bdev, &geo);
 		if (ret)
diff --git a/block/partitions/check.c b/block/partitions/check.c
index bc90867..7136055 100644
--- a/block/partitions/check.c
+++ b/block/partitions/check.c
@@ -131,7 +131,7 @@ check_partition(struct gendisk *hd, struct block_device *bdev)
 	state->limit = disk_max_parts(hd);
 	i = res = err = 0;
 	while (!res && check_part[i]) {
-		memset(&state->parts, 0, sizeof(state->parts));
+		(void)memset(&state->parts, 0, sizeof(state->parts));
 		res = check_part[i++](state);
 		if (res < 0) {
 			/* We have hit an I/O error which we don't report now.
diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
index 260fa80..a0d2afe 100644
--- a/block/scsi_ioctl.c
+++ b/block/scsi_ioctl.c
@@ -371,7 +371,7 @@ static int sg_io(struct request_queue *q, struct gendisk *bd_disk,
 		goto out;
 
 	bio = rq->bio;
-	memset(sense, 0, sizeof(sense));
+	(void)memset(sense, 0, sizeof(sense));
 	rq->sense = sense;
 	rq->sense_len = 0;
 	rq->retries = 0;
@@ -508,7 +508,7 @@ int sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,
 		goto out;
 	}
 
-	memset(sense, 0, sizeof(sense));
+	(void)memset(sense, 0, sizeof(sense));
 	rq->sense = sense;
 	rq->sense_len = 0;
 	rq->cmd_type = REQ_TYPE_BLOCK_PC;
@@ -619,7 +619,7 @@ int scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mod
 			if (copy_from_user(&cgc, arg, sizeof(cgc)))
 				break;
 			cgc.timeout = clock_t_to_jiffies(cgc.timeout);
-			memset(&hdr, 0, sizeof(hdr));
+			(void)memset(&hdr, 0, sizeof(hdr));
 			hdr.interface_id = 'S';
 			hdr.cmd_len = sizeof(cgc.cmd);
 			hdr.dxfer_len = cgc.buflen;
diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c
index a0f768c..08a59a6 100644
--- a/crypto/ablkcipher.c
+++ b/crypto/ablkcipher.c
@@ -323,7 +323,7 @@ static int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cipher->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/aead.c b/crypto/aead.c
index 04add3dc..65d66e6 100644
--- a/crypto/aead.c
+++ b/crypto/aead.c
@@ -43,7 +43,7 @@ static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = aead->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/algapi.c b/crypto/algapi.c
index 9d4a9fe..3dc6bbb 100644
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@ -343,7 +343,7 @@ static void crypto_wait_for_test(struct crypto_larval *larval)
 	}
 
 	err = wait_for_completion_interruptible(&larval->completion);
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 out:
 	crypto_larval_kill(&larval->alg);
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index 6ddd99e..8a85d69 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -219,7 +219,7 @@ static int get_prng_bytes(char *buf, size_t nbytes, struct prng_context *ctx,
 remainder:
 	if (ctx->rand_data_valid == DEFAULT_BLK_SZ) {
 		if (_get_more_prng_bytes(ctx, do_cont_test) < 0) {
-			memset(buf, 0, nbytes);
+			(void)memset(buf, 0, nbytes);
 			err = -EINVAL;
 			goto done;
 		}
@@ -246,7 +246,7 @@ empty_rbuf:
 	for (; byte_count >= DEFAULT_BLK_SZ; byte_count -= DEFAULT_BLK_SZ) {
 		if (ctx->rand_data_valid == DEFAULT_BLK_SZ) {
 			if (_get_more_prng_bytes(ctx, do_cont_test) < 0) {
-				memset(buf, 0, nbytes);
+				(void)memset(buf, 0, nbytes);
 				err = -EINVAL;
 				goto done;
 			}
@@ -299,10 +299,10 @@ static int reset_prng_context(struct prng_context *ctx,
 	if (DT)
 		memcpy(ctx->DT, DT, DEFAULT_BLK_SZ);
 	else
-		memset(ctx->DT, 0, DEFAULT_BLK_SZ);
+		(void)memset(ctx->DT, 0, DEFAULT_BLK_SZ);
 
-	memset(ctx->rand_data, 0, DEFAULT_BLK_SZ);
-	memset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);
+	(void)memset(ctx->rand_data, 0, DEFAULT_BLK_SZ);
+	(void)memset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);
 
 	ctx->rand_data_valid = DEFAULT_BLK_SZ;
 
diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c
index 1e61d1a..0151883 100644
--- a/crypto/blkcipher.c
+++ b/crypto/blkcipher.c
@@ -375,7 +375,7 @@ static int setkey_unaligned(struct crypto_tfm *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cipher->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/cipher.c b/crypto/cipher.c
index 39541e0..530bc13 100644
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -37,7 +37,7 @@ static int setkey_unaligned(struct crypto_tfm *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cia->cia_setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 
diff --git a/crypto/eseqiv.c b/crypto/eseqiv.c
index 42ce9f5..285f7a1 100644
--- a/crypto/eseqiv.c
+++ b/crypto/eseqiv.c
@@ -129,7 +129,7 @@ static int eseqiv_givencrypt(struct skcipher_givcrypt_request *req)
 
 	len = ivsize;
 	if (ivsize > sizeof(u64)) {
-		memset(req->giv, 0, ivsize - sizeof(u64));
+		(void)memset(req->giv, 0, ivsize - sizeof(u64));
 		len = sizeof(u64);
 	}
 	seq = cpu_to_be64(req->seq);
diff --git a/crypto/md4.c b/crypto/md4.c
index 0477a6a..21221fd 100644
--- a/crypto/md4.c
+++ b/crypto/md4.c
@@ -207,13 +207,13 @@ static int md4_final(struct shash_desc *desc, u8 *out)
 
 	*p++ = 0x80;
 	if (padding < 0) {
-		memset(p, 0x00, padding + sizeof (u64));
+		(void)memset(p, 0x00, padding + sizeof (u64));
 		md4_transform_helper(mctx);
 		p = (char *)mctx->block;
 		padding = 56;
 	}
 
-	memset(p, 0, padding);
+	(void)memset(p, 0, padding);
 	mctx->block[14] = mctx->byte_count << 3;
 	mctx->block[15] = mctx->byte_count >> 29;
 	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
@@ -221,7 +221,7 @@ static int md4_final(struct shash_desc *desc, u8 *out)
 	md4_transform(mctx->hash, mctx->block);
 	cpu_to_le32_array(mctx->hash, ARRAY_SIZE(mctx->hash));
 	memcpy(out, mctx->hash, sizeof(mctx->hash));
-	memset(mctx, 0, sizeof(*mctx));
+	(void)memset(mctx, 0, sizeof(*mctx));
 
 	return 0;
 }
diff --git a/crypto/md5.c b/crypto/md5.c
index 7febeaa..4b9dd7a 100644
--- a/crypto/md5.c
+++ b/crypto/md5.c
@@ -101,13 +101,13 @@ static int md5_final(struct shash_desc *desc, u8 *out)
 
 	*p++ = 0x80;
 	if (padding < 0) {
-		memset(p, 0x00, padding + sizeof (u64));
+		(void)memset(p, 0x00, padding + sizeof (u64));
 		md5_transform_helper(mctx);
 		p = (char *)mctx->block;
 		padding = 56;
 	}
 
-	memset(p, 0, padding);
+	(void)memset(p, 0, padding);
 	mctx->block[14] = mctx->byte_count << 3;
 	mctx->block[15] = mctx->byte_count >> 29;
 	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
@@ -115,7 +115,7 @@ static int md5_final(struct shash_desc *desc, u8 *out)
 	md5_transform(mctx->hash, mctx->block);
 	cpu_to_le32_array(mctx->hash, sizeof(mctx->hash) / sizeof(u32));
 	memcpy(out, mctx->hash, sizeof(mctx->hash));
-	memset(mctx, 0, sizeof(*mctx));
+	(void)memset(mctx, 0, sizeof(*mctx));
 
 	return 0;
 }
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index 4279480..629740b 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -64,7 +64,7 @@ int crypto_sha1_update(struct shash_desc *desc, const u8 *data,
 			src = data + done;
 		} while (done + SHA1_BLOCK_SIZE <= len);
 
-		memset(temp, 0, sizeof(temp));
+		(void)memset(temp, 0, sizeof(temp));
 		partial = 0;
 	}
 	memcpy(sctx->buffer + partial, src, len - done);
@@ -98,7 +98,7 @@ static int sha1_final(struct shash_desc *desc, u8 *out)
 		dst[i] = cpu_to_be32(sctx->state[i]);
 
 	/* Wipe context */
-	memset(sctx, 0, sizeof *sctx);
+	(void)memset(sctx, 0, sizeof *sctx);
 
 	return 0;
 }
diff --git a/crypto/sha256_generic.c b/crypto/sha256_generic.c
index c48459e..41fffde 100644
--- a/crypto/sha256_generic.c
+++ b/crypto/sha256_generic.c
@@ -210,7 +210,7 @@ static void sha256_transform(u32 *state, const u8 *input)
 
 	/* clear any sensitive info... */
 	a = b = c = d = e = f = g = h = t1 = t2 = 0;
-	memset(W, 0, 64 * sizeof(u32));
+	(void)memset(W, 0, 64 * sizeof(u32));
 }
 
 
@@ -303,7 +303,7 @@ static int sha256_final(struct shash_desc *desc, u8 *out)
 		dst[i] = cpu_to_be32(sctx->state[i]);
 
 	/* Zeroize sensitive information. */
-	memset(sctx, 0, sizeof(*sctx));
+	(void)memset(sctx, 0, sizeof(*sctx));
 
 	return 0;
 }
@@ -315,7 +315,7 @@ static int sha224_final(struct shash_desc *desc, u8 *hash)
 	sha256_final(desc, D);
 
 	memcpy(hash, D, SHA224_DIGEST_SIZE);
-	memset(D, 0, SHA256_DIGEST_SIZE);
+	(void)memset(D, 0, SHA256_DIGEST_SIZE);
 
 	return 0;
 }
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 40fb122..52599f1 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -541,7 +541,7 @@ void bus_probe_device(struct device *dev)
 
 	if (bus->p->drivers_autoprobe) {
 		ret = device_attach(dev);
-		WARN_ON(ret < 0);
+		(void)WARN_ON(ret < 0);
 	}
 
 	mutex_lock(&bus->p->mutex);
diff --git a/drivers/base/class.c b/drivers/base/class.c
index 03243d4..7988d7f 100644
--- a/drivers/base/class.c
+++ b/drivers/base/class.c
@@ -382,7 +382,7 @@ int class_for_each_device(struct class *class, struct device *start,
 	if (!class)
 		return -EINVAL;
 	if (!class->p) {
-		WARN(1, "%s called for class '%s' before it was initialized",
+		(void)WARN(1, "%s called for class '%s' before it was initialized",
 		     __func__, class->name);
 		return -EINVAL;
 	}
@@ -429,7 +429,7 @@ struct device *class_find_device(struct class *class, struct device *start,
 	if (!class)
 		return NULL;
 	if (!class->p) {
-		WARN(1, "%s called for class '%s' before it was initialized",
+		(void)WARN(1, "%s called for class '%s' before it was initialized",
 		     __func__, class->name);
 		return NULL;
 	}
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a67cc0..a4a1f2c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -189,7 +189,7 @@ static void device_release(struct kobject *kobj)
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else
-		WARN(1, KERN_ERR "Device '%s' does not have a release() "
+		(void)WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev_name(dev));
 	kfree(p);
@@ -890,7 +890,7 @@ static int device_create_sys_dev_entry(struct device *dev)
 	char devt_str[15];
 
 	if (kobj) {
-		format_dev_t(devt_str, dev->devt);
+		(void)format_dev_t(devt_str, dev->devt);
 		error = sysfs_create_link(kobj, &dev->kobj, devt_str);
 	}
 
@@ -903,7 +903,7 @@ static void device_remove_sys_dev_entry(struct device *dev)
 	char devt_str[15];
 
 	if (kobj) {
-		format_dev_t(devt_str, dev->devt);
+		(void)format_dev_t(devt_str, dev->devt);
 		sysfs_remove_link(kobj, devt_str);
 	}
 }
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 142e3d600..4721024 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -112,7 +112,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
-	WARN_ON(!list_empty(&dev->devres_head));
+	(void)WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
 	if (driver_sysfs_add(dev)) {
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index 524bf96..d681942 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -91,7 +91,7 @@ static __always_inline struct devres * alloc_dr(dr_release_t release,
 	if (unlikely(!dr))
 		return NULL;
 
-	memset(dr, 0, tot_size);
+	(void)memset(dr, 0, tot_size);
 	INIT_LIST_HEAD(&dr->node.entry);
 	dr->node.release = release;
 	return dr;
@@ -519,7 +519,7 @@ void devres_close_group(struct device *dev, void *id)
 	if (grp)
 		add_dr(dev, &grp->node[1]);
 	else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 }
@@ -547,7 +547,7 @@ void devres_remove_group(struct device *dev, void *id)
 		list_del_init(&grp->node[1].entry);
 		devres_log(dev, &grp->node[0], "REM");
 	} else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 
@@ -585,7 +585,7 @@ int devres_release_group(struct device *dev, void *id)
 
 		cnt = release_nodes(dev, first, end, flags);
 	} else {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		spin_unlock_irqrestore(&dev->devres_lock, flags);
 	}
 
@@ -646,6 +646,6 @@ void devm_kfree(struct device *dev, void *p)
 	int rc;
 
 	rc = devres_destroy(dev, devm_kzalloc_release, devm_kzalloc_match, p);
-	WARN_ON(rc);
+	(void)WARN_ON(rc);
 }
 EXPORT_SYMBOL_GPL(devm_kfree);

diff --git a/drivers/base/dma-coherent.c b/drivers/base/dma-coherent.c
index bb0025c..62d59f1 100644
--- a/drivers/base/dma-coherent.c
+++ b/drivers/base/dma-coherent.c
@@ -135,7 +135,7 @@ int dma_alloc_from_coherent(struct device *dev, ssize_t size,
 	 */
 	*dma_handle = mem->device_base + (pageno << PAGE_SHIFT);
 	*ret = mem->virt_base + (pageno << PAGE_SHIFT);
-	memset(*ret, 0, size);
+	(void)memset(*ret, 0, size);
 
 	return 1;
 
diff --git a/drivers/base/dma-mapping.c b/drivers/base/dma-mapping.c
index 6f3676f..f593dde 100644
--- a/drivers/base/dma-mapping.c
+++ b/drivers/base/dma-mapping.c
@@ -39,7 +39,7 @@ static int dmam_match(struct device *dev, void *res, void *match_data)
 	struct dma_devres *this = res, *match = match_data;
 
 	if (this->vaddr == match->vaddr) {
-		WARN_ON(this->size != match->size ||
+		(void)WARN_ON(this->size != match->size ||
 			this->dma_handle != match->dma_handle);
 		return 1;
 	}
@@ -100,7 +100,7 @@ void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
 	struct dma_devres match_data = { size, vaddr, dma_handle };
 
 	dma_free_coherent(dev, size, vaddr, dma_handle);
-	WARN_ON(devres_destroy(dev, dmam_coherent_release, dmam_match,
+	(void)WARN_ON(devres_destroy(dev, dmam_coherent_release, dmam_match,
 			       &match_data));
 }
 EXPORT_SYMBOL(dmam_free_coherent);
@@ -159,7 +159,7 @@ void dmam_free_noncoherent(struct device *dev, size_t size, void *vaddr,
 	struct dma_devres match_data = { size, vaddr, dma_handle };
 
 	dma_free_noncoherent(dev, size, vaddr, dma_handle);
-	WARN_ON(!devres_destroy(dev, dmam_noncoherent_release, dmam_match,
+	(void)WARN_ON(!devres_destroy(dev, dmam_noncoherent_release, dmam_match,
 				&match_data));
 }
 EXPORT_SYMBOL(dmam_free_noncoherent);
@@ -213,7 +213,7 @@ EXPORT_SYMBOL(dmam_declare_coherent_memory);
  */
 void dmam_release_declared_memory(struct device *dev)
 {
-	WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
+	(void)WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
 }
 EXPORT_SYMBOL(dmam_release_declared_memory);
 
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b631f7c..30a6016 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -259,7 +259,7 @@ EXPORT_SYMBOL_GPL(driver_register);
 void driver_unregister(struct device_driver *drv)
 {
 	if (!drv || !drv->p) {
-		WARN(1, "Unexpected driver unregister!\n");
+		(void)WARN(1, "Unexpected driver unregister!\n");
 		return;
 	}
 	driver_remove_groups(drv, drv->groups);
diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c
index 26ab358..fafa513 100644
--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@ -234,7 +234,7 @@ static ssize_t firmware_loading_store(struct device *dev,
 	switch (loading) {
 	case 1:
 		firmware_free_data(fw_priv->fw);
-		memset(fw_priv->fw, 0, sizeof(struct firmware));
+		(void)memset(fw_priv->fw, 0, sizeof(struct firmware));
 		/* If the pages are not owned by 'struct firmware' */
 		for (i = 0; i < fw_priv->nr_pages; i++)
 			__free_page(fw_priv->pages[i]);
@@ -342,7 +342,7 @@ static int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)
 		}
 		memcpy(new_pages, fw_priv->pages,
 		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
+		(void)memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
 		       (new_array_size - fw_priv->page_array_size));
 		kfree(fw_priv->pages);
 		fw_priv->pages = new_pages;
@@ -637,7 +637,7 @@ static int request_firmware_work_func(void *arg)
 	int ret;
 
 	if (!arg) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f0c605e..5f5b481 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1151,7 +1151,7 @@ void __init early_platform_cleanup(void)
 	list_for_each_entry_safe(pd, pd2, &early_platform_device_list,
 				 dev.devres_head) {
 		list_del(&pd->dev.devres_head);
-		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
+		(void)memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
 	}
 }
 
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index e2cc3d2..632238e 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -325,7 +325,7 @@ static void dpm_show_time(ktime_t starttime, pm_message_t state, char *info)
 
 	calltime = ktime_get();
 	usecs64 = ktime_to_ns(ktime_sub(calltime, starttime));
-	do_div(usecs64, NSEC_PER_USEC);
+	(void)do_div(usecs64, NSEC_PER_USEC);
 	usecs = usecs64;
 	if (usecs == 0)
 		usecs = 1;
diff --git a/drivers/base/power/qos.c b/drivers/base/power/qos.c
index c5d3588..a0ce7d9 100644
--- a/drivers/base/power/qos.c
+++ b/drivers/base/power/qos.c
@@ -180,7 +180,7 @@ void dev_pm_qos_constraints_destroy(struct device *dev)
 		 * callbacks if needed
 		 */
 		apply_constraint(req, PM_QOS_REMOVE_REQ, PM_QOS_DEFAULT_VALUE);
-		memset(req, 0, sizeof(*req));
+		(void)memset(req, 0, sizeof(*req));
 	}
 
 	spin_lock_irq(&dev->power.lock);
@@ -325,7 +325,7 @@ int dev_pm_qos_remove_request(struct dev_pm_qos_request *req)
 	if (req->dev->power.constraints) {
 		ret = apply_constraint(req, PM_QOS_REMOVE_REQ,
 				       PM_QOS_DEFAULT_VALUE);
-		memset(req, 0, sizeof(*req));
+		(void)memset(req, 0, sizeof(*req));
 	} else {
 		/* Return if the device has been removed */
 		ret = -ENODEV;
diff --git a/drivers/base/syscore.c b/drivers/base/syscore.c
index e8d11b6..2a0cf2f 100644
--- a/drivers/base/syscore.c
+++ b/drivers/base/syscore.c
@@ -56,7 +56,7 @@ int syscore_suspend(void)
 	if (ret)
 		return ret;
 
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		"Interrupts enabled before system core suspend.\n");
 
 	list_for_each_entry_reverse(ops, &syscore_ops_list, node)
@@ -66,7 +66,7 @@ int syscore_suspend(void)
 			ret = ops->suspend();
 			if (ret)
 				goto err_out;
-			WARN_ONCE(!irqs_disabled(),
+			(void)WARN_ONCE(!irqs_disabled(),
 				"Interrupts enabled after %pF\n", ops->suspend);
 		}
 
@@ -92,7 +92,7 @@ void syscore_resume(void)
 {
 	struct syscore_ops *ops;
 
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		"Interrupts enabled before system core resume.\n");
 
 	list_for_each_entry(ops, &syscore_ops_list, node)
@@ -100,7 +100,7 @@ void syscore_resume(void)
 			if (initcall_debug)
 				pr_info("PM: Calling %pF\n", ops->resume);
 			ops->resume();
-			WARN_ONCE(!irqs_disabled(),
+			(void)WARN_ONCE(!irqs_disabled(),
 				"Interrupts enabled after %pF\n", ops->resume);
 		}
 }
diff --git a/drivers/block/brd.c b/drivers/block/brd.c
index ec24643..895d98d 100644
--- a/drivers/block/brd.c
+++ b/drivers/block/brd.c
@@ -277,7 +277,7 @@ static void copy_from_brd(void *dst, struct brd_device *brd,
 		memcpy(dst, src + offset, copy);
 		kunmap_atomic(src, KM_USER1);
 	} else
-		memset(dst, 0, copy);
+		(void)memset(dst, 0, copy);
 
 	if (copy < n) {
 		dst += copy;
@@ -289,7 +289,7 @@ static void copy_from_brd(void *dst, struct brd_device *brd,
 			memcpy(dst, src, copy);
 			kunmap_atomic(src, KM_USER1);
 		} else
-			memset(dst, 0, copy);
+			(void)memset(dst, 0, copy);
 	}
 }
 
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index f002577..8c001b9 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -536,7 +536,7 @@ static int loop_thread(void *data)
 
 	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
-		wait_event_interruptible(lo->lo_event,
+		(void)wait_event_interruptible(lo->lo_event,
 				!bio_list_empty(&lo->lo_bio_list) ||
 				kthread_should_stop());
 
@@ -999,9 +999,9 @@ static int loop_clr_fd(struct loop_device *lo)
 	lo->lo_sizelimit = 0;
 	lo->lo_encrypt_key_size = 0;
 	lo->lo_thread = NULL;
-	memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
-	memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
-	memset(lo->lo_file_name, 0, LO_NAME_SIZE);
+	(void)memset(lo->lo_encrypt_key, 0, LO_KEY_SIZE);
+	(void)memset(lo->lo_crypt_name, 0, LO_NAME_SIZE);
+	(void)memset(lo->lo_file_name, 0, LO_NAME_SIZE);
 	if (bdev)
 		invalidate_bdev(bdev);
 	set_capacity(lo->lo_disk, 0);
@@ -1118,7 +1118,7 @@ loop_get_status(struct loop_device *lo, struct loop_info64 *info)
 	error = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
 	if (error)
 		return error;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->lo_number = lo->lo_number;
 	info->lo_device = huge_encode_dev(stat.dev);
 	info->lo_inode = stat.ino;
@@ -1141,7 +1141,7 @@ loop_get_status(struct loop_device *lo, struct loop_info64 *info)
 static void
 loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
 {
-	memset(info64, 0, sizeof(*info64));
+	(void)memset(info64, 0, sizeof(*info64));
 	info64->lo_number = info->lo_number;
 	info64->lo_device = info->lo_device;
 	info64->lo_inode = info->lo_inode;
@@ -1163,7 +1163,7 @@ loop_info64_from_old(const struct loop_info *info, struct loop_info64 *info64)
 static int
 loop_info64_to_old(const struct loop_info64 *info64, struct loop_info *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->lo_number = info64->lo_number;
 	info->lo_device = info64->lo_device;
 	info->lo_inode = info64->lo_inode;
diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index 0711448..2297f6c 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -535,7 +535,7 @@ static int __init hci_uart_init(void)
 
 	/* Register the tty discipline */
 
-	memset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));
+	(void)memset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));
 	hci_uart_ldisc.magic		= TTY_LDISC_MAGIC;
 	hci_uart_ldisc.name		= "n_hci";
 	hci_uart_ldisc.open		= hci_uart_tty_open;
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 54ca8b2..0d5f989 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -844,8 +844,8 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	 * pool while mixing, and hash one final time.
 	 */
 	sha_transform(hash, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	(void)memset(extract, 0, sizeof(extract));
+	(void)memset(workspace, 0, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
@@ -856,7 +856,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	hash[1] ^= hash[4];
 	hash[2] ^= rol32(hash[2], 16);
 	memcpy(out, hash, EXTRACT_SIZE);
-	memset(hash, 0, sizeof(hash));
+	(void)memset(hash, 0, sizeof(hash));
 }
 
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
@@ -887,7 +887,7 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	(void)memset(tmp, 0, sizeof(tmp));
 
 	return ret;
 }
@@ -924,7 +924,7 @@ static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	(void)memset(tmp, 0, sizeof(tmp));
 
 	return ret;
 }
@@ -1053,7 +1053,7 @@ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 
 			DEBUG_ENT("sleeping?\n");
 
-			wait_event_interruptible(random_read_wait,
+			(void)wait_event_interruptible(random_read_wait,
 				input_pool.entropy_count >=
 						 random_read_wakeup_thresh);
 
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 622013f..65a4006 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -913,7 +913,7 @@ static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 	/* Initially set CPU itself as the policy_cpu */
 	per_cpu(cpufreq_policy_cpu, cpu) = cpu;
 	ret = (lock_policy_rwsem_write(cpu) < 0);
-	WARN_ON(ret);
+	(void)WARN_ON(ret);
 
 	init_completion(&policy->kobj_unregister);
 	INIT_WORK(&policy->update, handle_update);
@@ -1378,7 +1378,7 @@ int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)
 {
 	int ret;
 
-	WARN_ON(!init_cpufreq_transition_notifier_list_called);
+	(void)WARN_ON(!init_cpufreq_transition_notifier_list_called);
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
diff --git a/drivers/cpuidle/driver.c b/drivers/cpuidle/driver.c
index 284d7af..aecc8c4 100644
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@ -83,7 +83,7 @@ EXPORT_SYMBOL_GPL(cpuidle_get_driver);
 void cpuidle_unregister_driver(struct cpuidle_driver *drv)
 {
 	if (drv != cpuidle_curr_driver) {
-		WARN(1, "invalid cpuidle_unregister_driver(%s)\n",
+		(void)WARN(1, "invalid cpuidle_unregister_driver(%s)\n",
 			drv->name);
 		return;
 	}
diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c
index ad09526..0bbb2c7 100644
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -395,7 +395,7 @@ static int menu_enable_device(struct cpuidle_driver *drv,
 {
 	struct menu_device *data = &per_cpu(menu_devices, dev->cpu);
 
-	memset(data, 0, sizeof(struct menu_device));
+	(void)memset(data, 0, sizeof(struct menu_device));
 
 	return 0;
 }
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 17fdf4b..34f0331 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -1240,7 +1240,7 @@ void gpio_free(unsigned gpio)
 	might_sleep();
 
 	if (!gpio_is_valid(gpio)) {
-		WARN_ON(extra_checks);
+		(void)WARN_ON(extra_checks);
 		return;
 	}
 
@@ -1262,7 +1262,7 @@ void gpio_free(unsigned gpio)
 		clear_bit(FLAG_ACTIVE_LOW, &desc->flags);
 		clear_bit(FLAG_REQUESTED, &desc->flags);
 	} else
-		WARN_ON(extra_checks);
+		(void)WARN_ON(extra_checks);
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 }
@@ -1560,7 +1560,7 @@ int __gpio_get_value(unsigned gpio)
 	int value;
 
 	chip = gpio_to_chip(gpio);
-	WARN_ON(chip->can_sleep);
+	(void)WARN_ON(chip->can_sleep);
 	value = chip->get ? chip->get(chip, gpio - chip->base) : 0;
 	trace_gpio_value(gpio, 1, value);
 	return value;
@@ -1581,7 +1581,7 @@ void __gpio_set_value(unsigned gpio, int value)
 	struct gpio_chip	*chip;
 
 	chip = gpio_to_chip(gpio);
-	WARN_ON(chip->can_sleep);
+	(void)WARN_ON(chip->can_sleep);
 	trace_gpio_value(gpio, 0, value);
 	chip->set(chip, gpio - chip->base, value);
 }
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index af08ce7..db67cc6 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -135,7 +135,7 @@ static int open_collection(struct hid_parser *parser, unsigned type)
 		memcpy(collection, parser->device->collection,
 			sizeof(struct hid_collection) *
 			parser->device->collection_size);
-		memset(collection + parser->device->collection_size, 0,
+		(void)memset(collection + parser->device->collection_size, 0,
 			sizeof(struct hid_collection) *
 			parser->device->collection_size);
 		kfree(parser->device->collection);
@@ -788,7 +788,7 @@ static void implement(const struct hid_device *hid, __u8 *report,
 	if (value > m)
 		hid_warn(hid, "%s() called with too large value %d! (%s)\n",
 			 __func__, value, current->comm);
-	WARN_ON(value > m);
+	(void)WARN_ON(value > m);
 	value &= m;
 
 	report += offset >> 3;
@@ -977,7 +977,7 @@ void hid_output_report(struct hid_report *report, __u8 *data)
 	if (report->id > 0)
 		*data++ = report->id;
 
-	memset(data, 0, ((report->size - 1) >> 3) + 1);
+	(void)memset(data, 0, ((report->size - 1) >> 3) + 1);
 	for (n = 0; n < report->maxfield; n++)
 		hid_output_field(report->device, report->field[n], data);
 }
@@ -1054,7 +1054,7 @@ void hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
 	if (csize < rsize) {
 		dbg_hid("report %d is too short, (%d < %d)\n", report->id,
 				csize, rsize);
-		memset(cdata + csize, 0, rsize - csize);
+		(void)memset(cdata + csize, 0, rsize - csize);
 	}
 
 	if ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 5bf91db..7765ed9 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -225,7 +225,7 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	int kicked;
 	int r;
 
-	WARN_ON(hid == NULL);
+	(void)WARN_ON(hid == NULL);
 	if (!hid)
 		return 0;
 
@@ -686,7 +686,7 @@ static int hid_get_class_descriptor(struct usb_device *dev, int ifnum,
 {
 	int result, retries = 4;
 
-	memset(buf, 0, size);
+	(void)memset(buf, 0, size);
 
 	do {
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 1e56061..c7d76b2 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -655,7 +655,7 @@ i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,
 	char *blank, end;
 	int res;
 
-	memset(&info, 0, sizeof(struct i2c_board_info));
+	(void)memset(&info, 0, sizeof(struct i2c_board_info));
 
 	blank = strchr(buf, ' ');
 	if (!blank) {
@@ -1095,7 +1095,7 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 
 	/* Clear the device structure in case this adapter is ever going to be
 	   added again */
-	memset(&adap->dev, 0, sizeof(adap->dev));
+	(void)memset(&adap->dev, 0, sizeof(adap->dev));
 
 	return 0;
 }
@@ -1490,7 +1490,7 @@ static int i2c_detect_address(struct i2c_client *temp_client,
 		return 0;
 
 	/* Finally call the custom detection function */
-	memset(&info, 0, sizeof(struct i2c_board_info));
+	(void)memset(&info, 0, sizeof(struct i2c_board_info));
 	info.addr = addr;
 	err = driver->detect(temp_client, &info);
 	if (err) {
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 1f78c95..9953204 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -404,7 +404,7 @@ void input_alloc_absinfo(struct input_dev *dev)
 		dev->absinfo = kcalloc(ABS_CNT, sizeof(struct input_absinfo),
 					GFP_KERNEL);
 
-	WARN(!dev->absinfo, "%s(): kcalloc() failed?\n", __func__);
+	(void)WARN(!dev->absinfo, "%s(): kcalloc() failed?\n", __func__);
 }
 EXPORT_SYMBOL(input_alloc_absinfo);
 
@@ -1899,7 +1899,7 @@ void input_unregister_device(struct input_dev *dev)
 
 	list_for_each_entry_safe(handle, next, &dev->h_list, d_node)
 		handle->handler->disconnect(handle);
-	WARN_ON(!list_empty(&dev->h_list));
+	(void)WARN_ON(!list_empty(&dev->h_list));
 
 	del_timer_sync(&dev->timer);
 	list_del_init(&dev->node);
@@ -1967,7 +1967,7 @@ void input_unregister_handler(struct input_handler *handler)
 
 	list_for_each_entry_safe(handle, next, &handler->h_list, h_node)
 		handler->disconnect(handle);
-	WARN_ON(!list_empty(&handler->h_list));
+	(void)WARN_ON(!list_empty(&handler->h_list));
 
 	list_del_init(&handler->node);
 
diff --git a/drivers/input/keyboard/atkbd.c b/drivers/input/keyboard/atkbd.c
index e05a2e7..4a793a5 100644
--- a/drivers/input/keyboard/atkbd.c
+++ b/drivers/input/keyboard/atkbd.c
@@ -976,7 +976,7 @@ static void atkbd_set_keycode_table(struct atkbd *atkbd)
 	unsigned int scancode;
 	int i, j;
 
-	memset(atkbd->keycode, 0, sizeof(atkbd->keycode));
+	(void)memset(atkbd->keycode, 0, sizeof(atkbd->keycode));
 	bitmap_zero(atkbd->force_release_mask, ATKBD_KEYMAP_SIZE);
 
 	if (atkbd->translated) {
diff --git a/drivers/input/keyboard/matrix_keypad.c b/drivers/input/keyboard/matrix_keypad.c
index 9b223d7..f68947a 100644
--- a/drivers/input/keyboard/matrix_keypad.c
+++ b/drivers/input/keyboard/matrix_keypad.c
@@ -124,7 +124,7 @@ static void matrix_keypad_scan(struct work_struct *work)
 	/* de-activate all columns for scanning */
 	activate_all_cols(pdata, false);
 
-	memset(new_state, 0, sizeof(new_state));
+	(void)memset(new_state, 0, sizeof(new_state));
 
 	/* assert each column and read the row status out */
 	for (col = 0; col < pdata->num_col_gpios; col++) {
diff --git a/drivers/input/keyboard/pmic8xxx-keypad.c b/drivers/input/keyboard/pmic8xxx-keypad.c
index 01a1c9f..f6a6454 100644
--- a/drivers/input/keyboard/pmic8xxx-keypad.c
+++ b/drivers/input/keyboard/pmic8xxx-keypad.c
@@ -644,8 +644,8 @@ static int __devinit pmic8xxx_kp_probe(struct platform_device *pdev)
 	input_set_drvdata(kp->input, kp);
 
 	/* initialize keypad state */
-	memset(kp->keystate, 0xff, sizeof(kp->keystate));
-	memset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));
+	(void)memset(kp->keystate, 0xff, sizeof(kp->keystate));
+	(void)memset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));
 
 	rc = pmic8xxx_kpd_init(kp);
 	if (rc < 0) {
diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c
index 7360568..93d3ea5 100644
--- a/drivers/input/misc/uinput.c
+++ b/drivers/input/misc/uinput.c
@@ -713,7 +713,7 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 			if (req->u.upload.old)
 				ff_up.old = *req->u.upload.old;
 			else
-				memset(&ff_up.old, 0, sizeof(struct ff_effect));
+				(void)memset(&ff_up.old, 0, sizeof(struct ff_effect));
 
 			retval = uinput_ff_upload_to_user(p, &ff_up);
 			break;
diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c
index bd87380..cd32a08 100644
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@ -397,7 +397,7 @@ static void alps_process_trackstick_packet_v3(struct psmouse *psmouse)
 
 	/* Sanity check packet */
 	if (!(packet[0] & 0x40)) {
-		psmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");
+		(void)psmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");
 		return;
 	}
 
@@ -705,7 +705,7 @@ static psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)
 		      psmouse->packet[4] |
 		      psmouse->packet[5]) & 0x80) ||
 		    (!alps_is_valid_first_byte(priv->i, psmouse->packet[6]))) {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "refusing packet %x %x %x %x (suspected interleaved ps/2)\n",
 				    psmouse->packet[3], psmouse->packet[4],
 				    psmouse->packet[5], psmouse->packet[6]);
@@ -769,7 +769,7 @@ static void alps_flush_packet(unsigned long data)
 		if ((psmouse->packet[3] |
 		     psmouse->packet[4] |
 		     psmouse->packet[5]) & 0x80) {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "refusing packet %x %x %x (suspected interleaved ps/2)\n",
 				    psmouse->packet[3], psmouse->packet[4],
 				    psmouse->packet[5]);
@@ -804,7 +804,7 @@ static psmouse_ret_t alps_process_byte(struct psmouse *psmouse)
 	}
 
 	if (!alps_is_valid_first_byte(model, psmouse->packet[0])) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",
 			    psmouse->packet[0], model->mask0, model->byte0);
 		return PSMOUSE_BAD_DATA;
@@ -813,7 +813,7 @@ static psmouse_ret_t alps_process_byte(struct psmouse *psmouse)
 	/* Bytes 2 - pktsize should have 0 in the highest bit */
 	if (psmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&
 	    (psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {
-		psmouse_dbg(psmouse, "refusing packet[%i] = %x\n",
+		(void)psmouse_dbg(psmouse, "refusing packet[%i] = %x\n",
 			    psmouse->pktcnt - 1,
 			    psmouse->packet[psmouse->pktcnt - 1]);
 		return PSMOUSE_BAD_DATA;
@@ -923,7 +923,7 @@ static int alps_enter_command_mode(struct psmouse *psmouse,
 	}
 
 	if (param[0] != 0x88 && param[1] != 0x07) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "unknown response while entering command mode: %2.2x %2.2x %2.2x\n",
 			    param[0], param[1], param[2]);
 		return -1;
@@ -965,7 +965,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return NULL;
 
-	psmouse_dbg(psmouse, "E6 report: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "E6 report: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	if (param[0] != 0 || param[1] != 0 || (param[2] != 10 && param[2] != 100))
@@ -986,7 +986,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return NULL;
 
-	psmouse_dbg(psmouse, "E7 report: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "E7 report: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	if (version) {
@@ -1023,7 +1023,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 			alps_exit_command_mode(psmouse);
 
 			if (!model)
-				psmouse_dbg(psmouse,
+				(void)psmouse_dbg(psmouse,
 					    "Unknown command mode response %2.2x\n",
 					    param[0]);
 		}
@@ -1084,7 +1084,7 @@ static int alps_get_status(struct psmouse *psmouse, char *param)
 	    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return -1;
 
-	psmouse_dbg(psmouse, "Status: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "Status: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	return 0;
@@ -1264,7 +1264,7 @@ static int alps_hw_init_v3(struct psmouse *psmouse)
 		    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {
 			psmouse_warn(psmouse, "trackstick E7 report failed\n");
 		} else {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "trackstick E7 report: %2.2x %2.2x %2.2x\n",
 				    param[0], param[1], param[2]);
 
diff --git a/drivers/input/mouse/logips2pp.c b/drivers/input/mouse/logips2pp.c
index 84de2fc..28211fc 100644
--- a/drivers/input/mouse/logips2pp.c
+++ b/drivers/input/mouse/logips2pp.c
@@ -83,7 +83,7 @@ static psmouse_ret_t ps2pp_process_byte(struct psmouse *psmouse)
 			break;
 
 		default:
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "Received PS2++ packet #%x, but don't know how to handle.\n",
 				    (packet[1] >> 4) | (packet[0] & 0x30));
 			break;
diff --git a/drivers/input/mouse/psmouse-base.c b/drivers/input/mouse/psmouse-base.c
index e6c9931..6798a18 100644
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@ -654,11 +654,11 @@ static void psmouse_apply_defaults(struct psmouse *psmouse)
 {
 	struct input_dev *input_dev = psmouse->dev;
 
-	memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
-	memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
-	memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
-	memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
-	memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
+	(void)memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
+	(void)memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
+	(void)memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
+	(void)memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
+	(void)memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
 
 	__set_bit(EV_KEY, input_dev->evbit);
 	__set_bit(EV_REL, input_dev->evbit);
@@ -1015,7 +1015,7 @@ static const struct psmouse_protocol *psmouse_protocol_by_type(enum psmouse_type
 		if (psmouse_protocols[i].type == type)
 			return &psmouse_protocols[i];
 
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return &psmouse_protocols[0];
 }
 
@@ -1472,7 +1472,7 @@ static int psmouse_reconnect(struct serio *serio)
 	int rc = -1;
 
 	if (!drv || !psmouse) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "reconnect request, but serio is disconnected, ignoring...\n");
 		return -1;
 	}
diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c
index 8081a0a..36ae8eb 100644
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@ -476,7 +476,7 @@ static int synaptics_parse_hw_state(const unsigned char buf[],
 				    struct synaptics_data *priv,
 				    struct synaptics_hw_state *hw)
 {
-	memset(hw, 0, sizeof(struct synaptics_hw_state));
+	(void)memset(hw, 0, sizeof(struct synaptics_hw_state));
 
 	if (SYN_MODEL_NEWABS(priv->model_id)) {
 		hw->w = (((buf[0] & 0x30) >> 2) |
@@ -1306,7 +1306,7 @@ static int synaptics_reconnect(struct psmouse *psmouse)
 		return -1;
 
 	if (retry > 1)
-		psmouse_dbg(psmouse, "reconnected after %d tries\n", retry);
+		(void)psmouse_dbg(psmouse, "reconnected after %d tries\n", retry);
 
 	if (synaptics_query_hardware(psmouse)) {
 		psmouse_err(psmouse, "Unable to query device.\n");
diff --git a/drivers/input/mousedev.c b/drivers/input/mousedev.c
index 0110b5a..e71937d 100644
--- a/drivers/input/mousedev.c
+++ b/drivers/input/mousedev.c
@@ -285,7 +285,7 @@ static void mousedev_notify_readers(struct mousedev *mousedev,
 			new_head = (client->head + 1) % PACKET_QUEUE_LEN;
 			if (new_head != client->tail) {
 				p = &client->packets[client->head = new_head];
-				memset(p, 0, sizeof(struct mousedev_motion));
+				(void)memset(p, 0, sizeof(struct mousedev_motion));
 			}
 		}
 
diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c
index 07a8363..eb6e035 100644
--- a/drivers/input/serio/libps2.c
+++ b/drivers/input/serio/libps2.c
@@ -43,7 +43,7 @@ int ps2_sendbyte(struct ps2dev *ps2dev, unsigned char byte, int timeout)
 	serio_continue_rx(ps2dev->serio);
 
 	if (serio_write(ps2dev->serio, byte) == 0)
-		wait_event_timeout(ps2dev->wait,
+		(void)wait_event_timeout(ps2dev->wait,
 				   !(ps2dev->flags & PS2_FLAG_ACK),
 				   msecs_to_jiffies(timeout));
 
@@ -81,7 +81,7 @@ EXPORT_SYMBOL(ps2_end_command);
 void ps2_drain(struct ps2dev *ps2dev, int maxbytes, int timeout)
 {
 	if (maxbytes > sizeof(ps2dev->cmdbuf)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		maxbytes = sizeof(ps2dev->cmdbuf);
 	}
 
@@ -92,7 +92,7 @@ void ps2_drain(struct ps2dev *ps2dev, int maxbytes, int timeout)
 	ps2dev->cmdcnt = maxbytes;
 	serio_continue_rx(ps2dev->serio);
 
-	wait_event_timeout(ps2dev->wait,
+	(void)wait_event_timeout(ps2dev->wait,
 			   !(ps2dev->flags & PS2_FLAG_CMD),
 			   msecs_to_jiffies(timeout));
 
@@ -190,12 +190,12 @@ int __ps2_command(struct ps2dev *ps2dev, unsigned char *param, int command)
 	int i;
 
 	if (receive > sizeof(ps2dev->cmdbuf)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -1;
 	}
 
 	if (send && !param) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -1;
 	}
 
@@ -231,7 +231,7 @@ int __ps2_command(struct ps2dev *ps2dev, unsigned char *param, int command)
 	if (ps2dev->cmdcnt && !(ps2dev->flags & PS2_FLAG_CMD1)) {
 
 		timeout = ps2_adjust_timeout(ps2dev, command, timeout);
-		wait_event_timeout(ps2dev->wait,
+		(void)wait_event_timeout(ps2dev->wait,
 				   !(ps2dev->flags & PS2_FLAG_CMD), timeout);
 	}
 
diff --git a/drivers/input/serio/serport.c b/drivers/input/serio/serport.c
index 8755f5f..95a94f7 100644
--- a/drivers/input/serio/serport.c
+++ b/drivers/input/serio/serport.c
@@ -186,7 +186,7 @@ static ssize_t serport_ldisc_read(struct tty_struct * tty, struct file * file, u
 	serio_register_port(serport->serio);
 	printk(KERN_INFO "serio: Serial port %s\n", tty_name(tty, name));
 
-	wait_event_interruptible(serport->wait, test_bit(SERPORT_DEAD, &serport->flags));
+	(void)wait_event_interruptible(serport->wait, test_bit(SERPORT_DEAD, &serport->flags));
 	serio_unregister_port(serport->serio);
 	serport->serio = NULL;
 
diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 8c2a000..7701b76 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -289,7 +289,7 @@ static int crypt_iv_essiv_wipe(struct crypt_config *cc)
 	struct crypto_cipher *essiv_tfm;
 	int cpu, r, err = 0;
 
-	memset(essiv->salt, 0, salt_size);
+	(void)memset(essiv->salt, 0, salt_size);
 
 	for_each_possible_cpu(cpu) {
 		essiv_tfm = per_cpu_ptr(cc->cpu, cpu)->iv_private;
@@ -453,7 +453,7 @@ static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,
 {
 	__be64 val;
 
-	memset(iv, 0, cc->iv_size - sizeof(u64)); /* rest is cleared below */
+	(void)memset(iv, 0, cc->iv_size - sizeof(u64)); /* rest is cleared below */
 
 	val = cpu_to_be64(((u64)dmreq->iv_sector << cc->iv_gen_private.benbi.shift) + 1);
 	put_unaligned(val, (__be64 *)(iv + cc->iv_size - sizeof(u64)));
@@ -464,7 +464,7 @@ static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,
 static int crypt_iv_null_gen(struct crypt_config *cc, u8 *iv,
 			     struct dm_crypt_request *dmreq)
 {
-	memset(iv, 0, cc->iv_size);
+	(void)memset(iv, 0, cc->iv_size);
 
 	return 0;
 }
@@ -526,7 +526,7 @@ static int crypt_iv_lmk_wipe(struct crypt_config *cc)
 	struct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;
 
 	if (lmk->seed)
-		memset(lmk->seed, 0, LMK_SEED_SIZE);
+		(void)memset(lmk->seed, 0, LMK_SEED_SIZE);
 
 	return 0;
 }
diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c
index ad2eba4..3ff6cfa 100644
--- a/drivers/md/dm-io.c
+++ b/drivers/md/dm-io.c
@@ -377,7 +377,7 @@ static int sync_io(struct dm_io_client *client, unsigned int num_regions,
 	struct io *io = (struct io *)PTR_ALIGN(&io_, __alignof__(struct io));
 
 	if (num_regions > 1 && (rw & RW_MASK) != WRITE) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EIO;
 	}
 
@@ -414,7 +414,7 @@ static int async_io(struct dm_io_client *client, unsigned int num_regions,
 	struct io *io;
 
 	if (num_regions > 1 && (rw & RW_MASK) != WRITE) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		fn(1, context);
 		return -EIO;
 	}
diff --git a/drivers/md/dm-ioctl.c b/drivers/md/dm-ioctl.c
index 31c2dc2..c2d1c75 100644
--- a/drivers/md/dm-ioctl.c
+++ b/drivers/md/dm-ioctl.c
@@ -1571,7 +1571,7 @@ static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl **param)
 
 bad:
 	if (secure_data)
-		memset(dmi, 0, tmp.data_size);
+		(void)memset(dmi, 0, tmp.data_size);
 	vfree(dmi);
 	return -EFAULT;
 }
@@ -1678,7 +1678,7 @@ static int ctl_ioctl(uint command, struct dm_ioctl __user *user)
 
 out:
 	if (wipe_buffer)
-		memset(param, 0, input_param_size);
+		(void)memset(param, 0, input_param_size);
 
 	vfree(param);
 	return r;
diff --git a/drivers/md/dm-stripe.c b/drivers/md/dm-stripe.c
index 3d80cf0..e97b057 100644
--- a/drivers/md/dm-stripe.c
+++ b/drivers/md/dm-stripe.c
@@ -348,7 +348,7 @@ static int stripe_end_io(struct dm_target *ti, struct bio *bio,
 	if (error == -EOPNOTSUPP)
 		return error;
 
-	memset(major_minor, 0, sizeof(major_minor));
+	(void)memset(major_minor, 0, sizeof(major_minor));
 	sprintf(major_minor, "%d:%d",
 		MAJOR(disk_devt(bio->bi_bdev->bd_disk)),
 		MINOR(disk_devt(bio->bi_bdev->bd_disk)));
diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c
index 63cc542..bac42f6 100644
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -188,7 +188,7 @@ static int alloc_targets(struct dm_table *t, unsigned int num)
 		memcpy(n_targets, t->targets, sizeof(*n_targets) * n);
 	}
 
-	memset(n_highs + n, -1, sizeof(*n_highs) * (num - n));
+	(void)memset(n_highs + n, -1, sizeof(*n_highs) * (num - n));
 	vfree(t->highs);
 
 	t->num_allocated = num;
@@ -496,7 +496,7 @@ int dm_get_device(struct dm_target *ti, const char *path, fmode_t mode,
 			return r;
 		}
 
-		format_dev_t(dd->dm_dev.name, dev);
+		(void)format_dev_t(dd->dm_dev.name, dev);
 
 		atomic_set(&dd->count, 0);
 		list_add(&dd->list, &t->devices);
@@ -752,7 +752,7 @@ int dm_table_add_target(struct dm_table *t, const char *type,
 		return r;
 
 	tgt = t->targets + t->num_targets;
-	memset(tgt, 0, sizeof(*tgt));
+	(void)memset(tgt, 0, sizeof(*tgt));
 
 	if (!len) {
 		DMERR("%s: zero-length target", dm_device_name(t->md));
@@ -1282,7 +1282,7 @@ static void dm_table_set_integrity(struct dm_table *t)
 
 	template_disk = dm_table_get_integrity_disk(t, true);
 	if (template_disk)
-		blk_integrity_register(dm_disk(t->md),
+		(void)blk_integrity_register(dm_disk(t->md),
 				       blk_get_integrity(template_disk));
 	else if (blk_integrity_is_initialized(dm_disk(t->md)))
 		DMWARN("%s: device no longer has a valid integrity profile",
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index b89c548..91b450c 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1066,7 +1066,7 @@ static struct bio *split_bvec(struct bio *bio, sector_t sector,
 	clone->bi_flags |= 1 << BIO_CLONED;
 
 	if (bio_integrity(bio)) {
-		bio_integrity_clone(clone, bio, GFP_NOIO, bs);
+		(void)bio_integrity_clone(clone, bio, GFP_NOIO, bs);
 		bio_integrity_trim(clone,
 				   bio_sector_offset(bio, idx, offset), len);
 	}
@@ -1093,7 +1093,7 @@ static struct bio *clone_bio(struct bio *bio, sector_t sector,
 	clone->bi_flags &= ~(1 << BIO_SEG_VALID);
 
 	if (bio_integrity(bio)) {
-		bio_integrity_clone(clone, bio, GFP_NOIO, bs);
+		(void)bio_integrity_clone(clone, bio, GFP_NOIO, bs);
 
 		if (idx != bio->bi_idx || clone->bi_size < bio->bi_size)
 			bio_integrity_trim(clone,
@@ -1110,7 +1110,7 @@ static struct dm_target_io *alloc_tio(struct clone_info *ci,
 
 	tio->io = ci->io;
 	tio->ti = ti;
-	memset(&tio->info, 0, sizeof(tio->info));
+	(void)memset(&tio->info, 0, sizeof(tio->info));
 
 	return tio;
 }
@@ -1519,7 +1519,7 @@ static struct request *clone_rq(struct request *rq, struct mapped_device *md,
 	tio->ti = NULL;
 	tio->orig = rq;
 	tio->error = 0;
-	memset(&tio->info, 0, sizeof(tio->info));
+	(void)memset(&tio->info, 0, sizeof(tio->info));
 
 	clone = &tio->clone;
 	if (setup_clone(clone, rq, tio)) {
@@ -1872,7 +1872,7 @@ static struct mapped_device *alloc_dev(int minor)
 	md->disk->private_data = md;
 	sprintf(md->disk->disk_name, "dm-%d", minor);
 	add_disk(md->disk);
-	format_dev_t(md->name, MKDEV(_major, minor));
+	(void)format_dev_t(md->name, MKDEV(_major, minor));
 
 	md->wq = alloc_workqueue("kdmflush",
 				 WQ_NON_REENTRANT | WQ_MEM_RECLAIM, 0);
@@ -2064,7 +2064,7 @@ static struct dm_table *__bind(struct mapped_device *md, struct dm_table *t,
 	 * Wipe any geometry if the size of the table changed.
 	 */
 	if (size != get_capacity(md->disk))
-		memset(&md->geometry, 0, sizeof(md->geometry));
+		(void)memset(&md->geometry, 0, sizeof(md->geometry));
 
 	__set_size(md, size);
 
@@ -2417,7 +2417,7 @@ static int lock_fs(struct mapped_device *md)
 {
 	int r;
 
-	WARN_ON(md->frozen_sb);
+	(void)WARN_ON(md->frozen_sb);
 
 	md->frozen_sb = freeze_bdev(md->bdev);
 	if (IS_ERR(md->frozen_sb)) {
diff --git a/drivers/media/common/tuners/mt20xx.c b/drivers/media/common/tuners/mt20xx.c
index 0e74e97..af6611c 100644
--- a/drivers/media/common/tuners/mt20xx.c
+++ b/drivers/media/common/tuners/mt20xx.c
@@ -613,7 +613,7 @@ struct dvb_frontend *microtune_attach(struct dvb_frontend *fe,
 
 	//priv->radio_if2 = 10700 * 1000;	/* 10.7MHz - FM radio */
 
-	memset(buf,0,sizeof(buf));
+	(void)memset(buf,0,sizeof(buf));
 
 	name = "unknown";
 
diff --git a/drivers/media/common/tuners/tda18271-fe.c b/drivers/media/common/tuners/tda18271-fe.c
index 2e67f44..4b351d8 100644
--- a/drivers/media/common/tuners/tda18271-fe.c
+++ b/drivers/media/common/tuners/tda18271-fe.c
@@ -1054,7 +1054,7 @@ static int tda18271_release(struct dvb_frontend *fe)
 	mutex_lock(&tda18271_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&tda18271_list_mutex);
 
diff --git a/drivers/media/common/tuners/tda8290.c b/drivers/media/common/tuners/tda8290.c
index 8c48521..184b876 100644
--- a/drivers/media/common/tuners/tda8290.c
+++ b/drivers/media/common/tuners/tda8290.c
@@ -803,7 +803,7 @@ struct dvb_frontend *tda829x_attach(struct dvb_frontend *fe,
 	return fe;
 
 fail:
-	memset(&fe->ops.analog_ops, 0, sizeof(struct analog_demod_ops));
+	(void)memset(&fe->ops.analog_ops, 0, sizeof(struct analog_demod_ops));
 
 	tda829x_release(fe);
 	return NULL;
diff --git a/drivers/media/common/tuners/tda9887.c b/drivers/media/common/tuners/tda9887.c
index cdb645d..115f693 100644
--- a/drivers/media/common/tuners/tda9887.c
+++ b/drivers/media/common/tuners/tda9887.c
@@ -536,7 +536,7 @@ static int tda9887_status(struct dvb_frontend *fe)
 	unsigned char buf[1];
 	int rc;
 
-	memset(buf,0,sizeof(buf));
+	(void)memset(buf,0,sizeof(buf));
 	if (1 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props,buf,1)))
 		tuner_info("i2c i/o error: rc == %d (should be 1)\n", rc);
 	dump_read_message(fe, buf);
@@ -548,7 +548,7 @@ static void tda9887_configure(struct dvb_frontend *fe)
 	struct tda9887_priv *priv = fe->analog_demod_priv;
 	int rc;
 
-	memset(priv->data,0,sizeof(priv->data));
+	(void)memset(priv->data,0,sizeof(priv->data));
 	tda9887_set_tvnorm(fe);
 
 	/* A note on the port settings:
@@ -652,7 +652,7 @@ static void tda9887_release(struct dvb_frontend *fe)
 	mutex_lock(&tda9887_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&tda9887_list_mutex);
 
diff --git a/drivers/media/common/tuners/tea5761.c b/drivers/media/common/tuners/tea5761.c
index bf78cb9..8105ede 100644
--- a/drivers/media/common/tuners/tea5761.c
+++ b/drivers/media/common/tuners/tea5761.c
@@ -203,7 +203,7 @@ static int tea5761_read_status(struct dvb_frontend *fe, char *buffer)
 	struct tea5761_priv *priv = fe->tuner_priv;
 	int rc;
 
-	memset(buffer, 0, 16);
+	(void)memset(buffer, 0, 16);
 	if (16 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 16))) {
 		tuner_warn("i2c i/o error: rc == %d (should be 16)\n", rc);
 		return -EREMOTEIO;
diff --git a/drivers/media/common/tuners/tea5767.c b/drivers/media/common/tuners/tea5767.c
index 36e85d8..f0df484 100644
--- a/drivers/media/common/tuners/tea5767.c
+++ b/drivers/media/common/tuners/tea5767.c
@@ -287,7 +287,7 @@ static int tea5767_read_status(struct dvb_frontend *fe, char *buffer)
 	struct tea5767_priv *priv = fe->tuner_priv;
 	int rc;
 
-	memset(buffer, 0, 5);
+	(void)memset(buffer, 0, 5);
 	if (5 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 5))) {
 		tuner_warn("i2c i/o error: rc == %d (should be 5)\n", rc);
 		return -EREMOTEIO;
diff --git a/drivers/media/common/tuners/tuner-simple.c b/drivers/media/common/tuners/tuner-simple.c
index 39e7e58..dea9945 100644
--- a/drivers/media/common/tuners/tuner-simple.c
+++ b/drivers/media/common/tuners/tuner-simple.c
@@ -1009,7 +1009,7 @@ static int simple_release(struct dvb_frontend *fe)
 	mutex_lock(&tuner_simple_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&tuner_simple_list_mutex);
 
diff --git a/drivers/media/common/tuners/tuner-xc2028.c b/drivers/media/common/tuners/tuner-xc2028.c
index b5ee3eb..068f6b4 100644
--- a/drivers/media/common/tuners/tuner-xc2028.c
+++ b/drivers/media/common/tuners/tuner-xc2028.c
@@ -271,7 +271,7 @@ static void free_firmware(struct xc2028_data *priv)
 	priv->firm = NULL;
 	priv->firm_size = 0;
 
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 }
 
 static int load_all_firmwares(struct dvb_frontend *fe)
@@ -757,7 +757,7 @@ retry:
 	}
 
 	/* Updating BASE - forget about all currently loaded firmware */
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 
 	/* Reset is needed before loading firmware */
 	rc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);
@@ -876,7 +876,7 @@ read_not_reliable:
 	return 0;
 
 fail:
-	memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
+	(void)memset(&priv->cur_fw, 0, sizeof(priv->cur_fw));
 	if (retry_count < 8) {
 		msleep(50);
 		retry_count++;
@@ -1242,7 +1242,7 @@ static int xc2028_dvb_release(struct dvb_frontend *fe)
 	}
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&xc2028_list_mutex);
 
diff --git a/drivers/media/common/tuners/xc5000.c b/drivers/media/common/tuners/xc5000.c
index 296df05..f6b9e5e 100644
--- a/drivers/media/common/tuners/xc5000.c
+++ b/drivers/media/common/tuners/xc5000.c
@@ -1050,7 +1050,7 @@ static int xc5000_release(struct dvb_frontend *fe)
 	mutex_lock(&xc5000_list_mutex);
 
 	if (priv)
-		hybrid_tuner_release_state(priv);
+		(void)hybrid_tuner_release_state(priv);
 
 	mutex_unlock(&xc5000_list_mutex);
 
diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c
index 5faba2a..3c7ba22 100644
--- a/drivers/media/rc/ir-lirc-codec.c
+++ b/drivers/media/rc/ir-lirc-codec.c
@@ -76,7 +76,7 @@ static int ir_lirc_decode(struct rc_dev *dev, struct ir_raw_event ev)
 				lirc->gap_start));
 
 			/* Convert to ms and cap by LIRC_VALUE_MASK */
-			do_div(lirc->gap_duration, 1000);
+			(void)do_div(lirc->gap_duration, 1000);
 			lirc->gap_duration = min(lirc->gap_duration,
 							(u64)LIRC_VALUE_MASK);
 
diff --git a/drivers/media/rc/lirc_dev.c b/drivers/media/rc/lirc_dev.c
index ca12d32..63f76b3 100644
--- a/drivers/media/rc/lirc_dev.c
+++ b/drivers/media/rc/lirc_dev.c
@@ -509,7 +509,7 @@ int lirc_dev_fop_close(struct inode *inode, struct file *file)
 
 	dev_dbg(ir->d.dev, LOGHEAD "close called\n", ir->d.name, ir->d.minor);
 
-	WARN_ON(mutex_lock_killable(&lirc_dev_lock));
+	(void)WARN_ON(mutex_lock_killable(&lirc_dev_lock));
 
 	ir->open--;
 	if (ir->attached) {
diff --git a/drivers/media/video/gspca/gspca.c b/drivers/media/video/gspca/gspca.c
index ca5a2b1..88c16f8 100644
--- a/drivers/media/video/gspca/gspca.c
+++ b/drivers/media/video/gspca/gspca.c
@@ -2101,7 +2101,7 @@ static int read_alloc(struct gspca_dev *gspca_dev,
 	if (gspca_dev->nframes == 0) {
 		struct v4l2_requestbuffers rb;
 
-		memset(&rb, 0, sizeof rb);
+		(void)memset(&rb, 0, sizeof rb);
 		rb.count = gspca_dev->nbufread;
 		rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		rb.memory = GSPCA_MEMORY_READ;
@@ -2110,7 +2110,7 @@ static int read_alloc(struct gspca_dev *gspca_dev,
 			PDEBUG(D_STREAM, "read reqbuf err %d", ret);
 			return ret;
 		}
-		memset(&v4l2_buf, 0, sizeof v4l2_buf);
+		(void)memset(&v4l2_buf, 0, sizeof v4l2_buf);
 		v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		v4l2_buf.memory = GSPCA_MEMORY_READ;
 		for (i = 0; i < gspca_dev->nbufread; i++) {
@@ -2184,7 +2184,7 @@ static ssize_t dev_read(struct file *file, char __user *data,
 	timestamp.tv_sec--;
 	n = 2;
 	for (;;) {
-		memset(&v4l2_buf, 0, sizeof v4l2_buf);
+		(void)memset(&v4l2_buf, 0, sizeof v4l2_buf);
 		v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		v4l2_buf.memory = GSPCA_MEMORY_READ;
 		ret = vidioc_dqbuf(file, gspca_dev, &v4l2_buf);
diff --git a/drivers/media/video/uvc/uvc_ctrl.c b/drivers/media/video/uvc/uvc_ctrl.c
index 0efd3b1..07dd9a1 100644
--- a/drivers/media/video/uvc/uvc_ctrl.c
+++ b/drivers/media/video/uvc/uvc_ctrl.c
@@ -918,7 +918,7 @@ int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		goto done;
 	}
 
-	memset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);
+	(void)memset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);
 	v4l2_ctrl->id = mapping->id;
 	v4l2_ctrl->type = mapping->v4l2_type;
 	strlcpy(v4l2_ctrl->name, mapping->name, sizeof v4l2_ctrl->name);
@@ -1008,7 +1008,7 @@ int uvc_query_v4l2_menu(struct uvc_video_chain *chain,
 	u32 id = query_menu->id;
 	int ret;
 
-	memset(query_menu, 0, sizeof(*query_menu));
+	(void)memset(query_menu, 0, sizeof(*query_menu));
 	query_menu->id = id;
 	query_menu->index = index;
 
@@ -1266,7 +1266,7 @@ int uvc_ctrl_set(struct uvc_video_chain *chain,
 	 */
 	if (!ctrl->loaded && (ctrl->info.size * 8) != mapping->size) {
 		if ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0) {
-			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
+			(void)memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl->info.size);
 		} else {
 			ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
diff --git a/drivers/media/video/uvc/uvc_driver.c b/drivers/media/video/uvc/uvc_driver.c
index a240d43..9456d72 100644
--- a/drivers/media/video/uvc/uvc_driver.c
+++ b/drivers/media/video/uvc/uvc_driver.c
@@ -405,7 +405,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 
 		/* Create a dummy frame descriptor. */
 		frame = &format->frame[0];
-		memset(&format->frame[0], 0, sizeof format->frame[0]);
+		(void)memset(&format->frame[0], 0, sizeof format->frame[0]);
 		frame->bFrameIntervalType = 1;
 		frame->dwDefaultFrameInterval = 1;
 		frame->dwFrameInterval = *intervals;
diff --git a/drivers/media/video/uvc/uvc_v4l2.c b/drivers/media/video/uvc/uvc_v4l2.c
index 2ae4f88..3bd1c4b 100644
--- a/drivers/media/video/uvc/uvc_v4l2.c
+++ b/drivers/media/video/uvc/uvc_v4l2.c
@@ -211,7 +211,7 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 		(100000000/interval)%10);
 
 	/* Set the format index, frame index and frame interval. */
-	memset(probe, 0, sizeof *probe);
+	(void)memset(probe, 0, sizeof *probe);
 	probe->bmHint = 1;	/* dwFrameInterval */
 	probe->bFormatIndex = format->index;
 	probe->bFrameIndex = frame->bFrameIndex;
@@ -335,7 +335,7 @@ static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 	denominator = 10000000;
 	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
 
-	memset(parm, 0, sizeof *parm);
+	(void)memset(parm, 0, sizeof *parm);
 	parm->type = stream->type;
 
 	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
@@ -551,7 +551,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 	{
 		struct v4l2_capability *cap = arg;
 
-		memset(cap, 0, sizeof *cap);
+		(void)memset(cap, 0, sizeof *cap);
 		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 		strlcpy(cap->card, vdev->name, sizeof cap->card);
 		usb_make_path(stream->dev->udev,
@@ -575,7 +575,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		struct v4l2_control *ctrl = arg;
 		struct v4l2_ext_control xctrl;
 
-		memset(&xctrl, 0, sizeof xctrl);
+		(void)memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 
 		ret = uvc_ctrl_begin(chain);
@@ -594,7 +594,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		struct v4l2_control *ctrl = arg;
 		struct v4l2_ext_control xctrl;
 
-		memset(&xctrl, 0, sizeof xctrl);
+		(void)memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 		xctrl.value = ctrl->value;
 
@@ -699,7 +699,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		if (iterm == NULL || iterm->id != pin)
 			return -EINVAL;
 
-		memset(input, 0, sizeof *input);
+		(void)memset(input, 0, sizeof *input);
 		input->index = index;
 		strlcpy(input->name, iterm->name, sizeof input->name);
 		if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
@@ -761,7 +761,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 		    fmt->index >= stream->nformats)
 			return -EINVAL;
 
-		memset(fmt, 0, sizeof(*fmt));
+		(void)memset(fmt, 0, sizeof(*fmt));
 		fmt->index = index;
 		fmt->type = type;
 
diff --git a/drivers/media/video/uvc/uvc_video.c b/drivers/media/video/uvc/uvc_video.c
index c7e69b8..6a16e31 100644
--- a/drivers/media/video/uvc/uvc_video.c
+++ b/drivers/media/video/uvc/uvc_video.c
@@ -183,7 +183,7 @@ static int uvc_get_video_ctrl(struct uvc_streaming *stream,
 		uvc_warn_once(stream->dev, UVC_WARN_MINMAX, "UVC non "
 			"compliance - GET_MIN/MAX(PROBE) incorrectly "
 			"supported. Enabling workaround.\n");
-		memset(ctrl, 0, sizeof *ctrl);
+		(void)memset(ctrl, 0, sizeof *ctrl);
 		ctrl->wCompQuality = le16_to_cpup((__le16 *)data);
 		ret = 0;
 		goto out;
diff --git a/drivers/media/video/v4l2-common.c b/drivers/media/video/v4l2-common.c
index 5c6100f..a762fa8 100644
--- a/drivers/media/video/v4l2-common.c
+++ b/drivers/media/video/v4l2-common.c
@@ -363,7 +363,7 @@ struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,
 
 	/* Setup the i2c board info with the device type and
 	   the device address. */
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.type, client_type, sizeof(info.type));
 	info.addr = addr;
 
diff --git a/drivers/media/video/v4l2-ctrls.c b/drivers/media/video/v4l2-ctrls.c
index cccd42b..b1da0c2 100644
--- a/drivers/media/video/v4l2-ctrls.c
+++ b/drivers/media/video/v4l2-ctrls.c
@@ -1361,7 +1361,7 @@ static struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,
 		ctrl->cur.string = (char *)&ctrl[1] + sz_extra - (max + 1);
 		ctrl->string = (char *)&ctrl[1] + sz_extra - 2 * (max + 1);
 		if (ctrl->minimum)
-			memset(ctrl->cur.string, ' ', ctrl->minimum);
+			(void)memset(ctrl->cur.string, ' ', ctrl->minimum);
 	}
 	if (handler_new_ref(hdl, ctrl)) {
 		kfree(ctrl);
@@ -1393,9 +1393,9 @@ struct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,
 
 	is_menu = (cfg->type == V4L2_CTRL_TYPE_MENU);
 	if (is_menu)
-		WARN_ON(step);
+		(void)WARN_ON(step);
 	else
-		WARN_ON(cfg->menu_skip_mask);
+		(void)WARN_ON(cfg->menu_skip_mask);
 	if (is_menu && qmenu == NULL)
 		qmenu = v4l2_ctrl_get_menu(cfg->id);
 
@@ -1737,7 +1737,7 @@ int v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc)
 		return -EINVAL;
 
 	ctrl = ref->ctrl;
-	memset(qc, 0, sizeof(*qc));
+	(void)memset(qc, 0, sizeof(*qc));
 	if (id >= V4L2_CID_PRIVATE_BASE)
 		qc->id = id;
 	else
@@ -2052,7 +2052,7 @@ s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)
 	s32 val = 0;
 
 	/* It's a driver bug if this happens. */
-	WARN_ON(!type_is_int(ctrl));
+	(void)WARN_ON(!type_is_int(ctrl));
 	get_ctrl(ctrl, &val);
 	return val;
 }
diff --git a/drivers/media/video/v4l2-dev.c b/drivers/media/video/v4l2-dev.c
index 96e9615..2bde425 100644
--- a/drivers/media/video/v4l2-dev.c
+++ b/drivers/media/video/v4l2-dev.c
@@ -215,7 +215,7 @@ static inline bool prio_is_valid(enum v4l2_priority prio)
 
 void v4l2_prio_init(struct v4l2_prio_state *global)
 {
-	memset(global, 0, sizeof(*global));
+	(void)memset(global, 0, sizeof(*global));
 }
 EXPORT_SYMBOL(v4l2_prio_init);
 
@@ -652,7 +652,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 	devnode_set(vdev);
 
 	/* Should not happen since we thought this minor was free */
-	WARN_ON(video_device[vdev->minor] != NULL);
+	(void)WARN_ON(video_device[vdev->minor] != NULL);
 	vdev->index = get_index(vdev);
 	mutex_unlock(&videodev_lock);
 
diff --git a/drivers/media/video/v4l2-device.c b/drivers/media/video/v4l2-device.c
index 1f203b8..449b9e1 100644
--- a/drivers/media/video/v4l2-device.c
+++ b/drivers/media/video/v4l2-device.c
@@ -44,7 +44,7 @@ int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)
 	v4l2_dev->dev = dev;
 	if (dev == NULL) {
 		/* If dev == NULL, then name must be filled in by the caller */
-		WARN_ON(!v4l2_dev->name[0]);
+		(void)WARN_ON(!v4l2_dev->name[0]);
 		return 0;
 	}
 
@@ -151,7 +151,7 @@ int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
 		return -EINVAL;
 
 	/* Warn if we apparently re-register a subdev */
-	WARN_ON(sd->v4l2_dev != NULL);
+	(void)WARN_ON(sd->v4l2_dev != NULL);
 
 	if (!try_module_get(sd->owner))
 		return -ENODEV;
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index 3f62385..4b0b454 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -724,32 +724,32 @@ static long __video_do_ioctl(struct file *file,
 
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			if (ops->vidioc_s_fmt_vid_cap)
 				ret = ops->vidioc_s_fmt_vid_cap(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			if (ops->vidioc_s_fmt_vid_cap_mplane)
 				ret = ops->vidioc_s_fmt_vid_cap_mplane(file,
 									fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
-			CLEAR_AFTER_FIELD(f, fmt.win);
+			(void)CLEAR_AFTER_FIELD(f, fmt.win);
 			if (ops->vidioc_s_fmt_vid_overlay)
 				ret = ops->vidioc_s_fmt_vid_overlay(file,
 								    fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-			CLEAR_AFTER_FIELD(f, fmt.pix);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix);
 			v4l_print_pix_fmt(vfd, &f->fmt.pix);
 			if (ops->vidioc_s_fmt_vid_out)
 				ret = ops->vidioc_s_fmt_vid_out(file, fh, f);
 			break;
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
-			CLEAR_AFTER_FIELD(f, fmt.pix_mp);
+			(void)CLEAR_AFTER_FIELD(f, fmt.pix_mp);
 			v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);
 			if (ops->vidioc_s_fmt_vid_out_mplane)
 				ret = ops->vidioc_s_fmt_vid_out_mplane(file,
@@ -895,7 +895,7 @@ static long __video_do_ioctl(struct file *file,
 			break;
 
 		if (p->type < V4L2_BUF_TYPE_PRIVATE)
-			CLEAR_AFTER_FIELD(p, memory);
+			(void)CLEAR_AFTER_FIELD(p, memory);
 
 		ret = ops->vidioc_reqbufs(file, fh, p);
 		dbgarg(cmd, "count=%d, type=%s, memory=%s\n",
@@ -1897,7 +1897,7 @@ static long __video_do_ioctl(struct file *file,
 			break;
 
 		/* Clear up to type, everything after type is zerod already */
-		memset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));
+		(void)memset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));
 
 		dbgarg(cmd, "type=%s\n", prt_names(p->type, v4l2_type_names));
 		ret = ops->vidioc_g_sliced_vbi_cap(file, fh, p);
@@ -2387,10 +2387,10 @@ video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
 
 			/* zero out anything we don't copy from userspace */
 			if (n < _IOC_SIZE(cmd))
-				memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
+				(void)memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
 		} else {
 			/* read-only ioctl */
-			memset(parg, 0, _IOC_SIZE(cmd));
+			(void)memset(parg, 0, _IOC_SIZE(cmd));
 		}
 	}
 
diff --git a/drivers/media/video/videobuf2-core.c b/drivers/media/video/videobuf2-core.c
index 2e8f1df..71da5e5 100644
--- a/drivers/media/video/videobuf2-core.c
+++ b/drivers/media/video/videobuf2-core.c
@@ -1863,7 +1863,7 @@ static int __vb2_init_fileio(struct vb2_queue *q, int read)
 		 */
 		for (i = 0; i < q->num_buffers; i++) {
 			struct v4l2_buffer *b = &fileio->b;
-			memset(b, 0, sizeof(*b));
+			(void)memset(b, 0, sizeof(*b));
 			b->type = q->type;
 			b->memory = q->memory;
 			b->index = i;
@@ -1969,7 +1969,7 @@ static size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_
 		/*
 		 * Call vb2_dqbuf to get buffer back.
 		 */
-		memset(&fileio->b, 0, sizeof(fileio->b));
+		(void)memset(&fileio->b, 0, sizeof(fileio->b));
 		fileio->b.type = q->type;
 		fileio->b.memory = q->memory;
 		fileio->b.index = index;
@@ -2037,7 +2037,7 @@ static size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_
 		/*
 		 * Call vb2_qbuf and give buffer to the driver.
 		 */
-		memset(&fileio->b, 0, sizeof(fileio->b));
+		(void)memset(&fileio->b, 0, sizeof(fileio->b));
 		fileio->b.type = q->type;
 		fileio->b.memory = q->memory;
 		fileio->b.index = index;
diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c
index 0f59228..2b0f23f 100644
--- a/drivers/mfd/mfd-core.c
+++ b/drivers/mfd/mfd-core.c
@@ -50,7 +50,7 @@ int mfd_cell_disable(struct platform_device *pdev)
 		atomic_inc(cell->usage_count);
 
 	/* sanity check; did someone call disable too many times? */
-	WARN_ON(atomic_read(cell->usage_count) < 0);
+	(void)WARN_ON(atomic_read(cell->usage_count) < 0);
 
 	return err;
 }
@@ -220,7 +220,7 @@ int mfd_clone_cell(const char *cell, const char **clones, size_t n_clones)
 	pdev = to_platform_device(dev);
 	memcpy(&cell_entry, mfd_get_cell(pdev), sizeof(cell_entry));
 
-	WARN_ON(!cell_entry.enable);
+	(void)WARN_ON(!cell_entry.enable);
 
 	for (i = 0; i < n_clones; i++) {
 		cell_entry.name = clones[i];
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 0cad48a..8653a5d 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -568,7 +568,7 @@ static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 	if (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))
 		return (u32)-1;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 
 	cmd.opcode = SD_APP_SEND_NUM_WR_BLKS;
 	cmd.arg = 0;
@@ -1093,7 +1093,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		(rq_data_dir(req) == WRITE) &&
 		(md->flags & MMC_BLK_REL_WR);
 
-	memset(brq, 0, sizeof(struct mmc_blk_request));
+	(void)memset(brq, 0, sizeof(struct mmc_blk_request));
 	brq->mrq.cmd = &brq->cmd;
 	brq->mrq.data = &brq->data;
 
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 2517547..2acadee 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -175,8 +175,8 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	if (!mq->queue)
 		return -ENOMEM;
 
-	memset(&mq->mqrq_cur, 0, sizeof(mq->mqrq_cur));
-	memset(&mq->mqrq_prev, 0, sizeof(mq->mqrq_prev));
+	(void)memset(&mq->mqrq_cur, 0, sizeof(mq->mqrq_cur));
+	(void)memset(&mq->mqrq_prev, 0, sizeof(mq->mqrq_prev));
 	mq->mqrq_cur = mqrq_cur;
 	mq->mqrq_prev = mqrq_prev;
 	mq->queue->queuedata = mq;
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f545a3e..900ef5b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -207,7 +207,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			 mrq->stop->arg, mrq->stop->flags);
 	}
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	mrq->cmd->error = 0;
 	mrq->cmd->mrq = mrq;
@@ -456,9 +456,9 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 {
 	struct mmc_request mrq = {NULL};
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
-	memset(cmd->resp, 0, sizeof(cmd->resp));
+	(void)memset(cmd->resp, 0, sizeof(cmd->resp));
 	cmd->retries = retries;
 
 	mrq.cmd = cmd;
@@ -831,7 +831,7 @@ EXPORT_SYMBOL(mmc_host_lazy_disable);
  */
 void mmc_release_host(struct mmc_host *host)
 {
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	mmc_host_lazy_disable(host);
 
@@ -876,7 +876,7 @@ void mmc_set_chip_select(struct mmc_host *host, int mode)
  */
 static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
 {
-	WARN_ON(hz < host->f_min);
+	(void)WARN_ON(hz < host->f_min);
 
 	if (hz > host->f_max)
 		hz = host->f_max;
@@ -1409,7 +1409,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 	BUG_ON(!host);
 	BUG_ON(!ops);
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1432,8 +1432,8 @@ void mmc_detach_bus(struct mmc_host *host)
 
 	BUG_ON(!host);
 
-	WARN_ON(!host->claimed);
-	WARN_ON(!host->bus_ops);
+	(void)WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->bus_ops);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1664,7 +1664,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 	if (mmc_card_sd(card))
 		cmd.opcode = SD_ERASE_WR_BLK_END;
 	else
@@ -1679,7 +1679,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
@@ -1696,7 +1696,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 
 	do {
-		memset(&cmd, 0, sizeof(struct mmc_command));
+		(void)memset(&cmd, 0, sizeof(struct mmc_command));
 		cmd.opcode = MMC_SEND_STATUS;
 		cmd.arg = card->rca << 16;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
@@ -2078,7 +2078,7 @@ int mmc_detect_card_removed(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 	/*
 	 * The card will be considered unchanged unless we have been asked to
 	 * detect a change or host requires polling to provide card detection.
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 30055f2..442cb33 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -263,7 +263,7 @@ static inline void mmc_host_clk_exit(struct mmc_host *host)
 	if (host->clk_gated)
 		mmc_host_clk_hold(host);
 	/* There should be only one user now */
-	WARN_ON(host->clk_requests > 1);
+	(void)WARN_ON(host->clk_requests > 1);
 }
 
 static inline void mmc_host_clk_sysfs_init(struct mmc_host *host)
@@ -367,7 +367,7 @@ int mmc_add_host(struct mmc_host *host)
 {
 	int err;
 
-	WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
+	(void)WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
 		!host->ops->enable_sdio_irq);
 
 	err = device_add(&host->class_dev);
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 59b9ba5..c699ddb 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -810,7 +810,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	u8 *ext_csd = NULL;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Set correct bus mode for MMC before attempting init */
 	if (!mmc_host_is_spi(host))
@@ -1429,7 +1429,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	u32 ocr;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Set correct bus mode for MMC before attempting attach */
 	if (!mmc_host_is_spi(host))
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c63ad03..daf54e0 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -65,7 +65,7 @@ void mmc_decode_cid(struct mmc_card *card)
 {
 	u32 *resp = card->raw_cid;
 
-	memset(&card->cid, 0, sizeof(struct mmc_cid));
+	(void)memset(&card->cid, 0, sizeof(struct mmc_cid));
 
 	/*
 	 * SD doesn't currently have a version field so we will
@@ -901,7 +901,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	u32 rocr = 0;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
@@ -1143,7 +1143,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	u32 ocr;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Make sure we are at 3.3V signalling voltage */
 	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
diff --git a/drivers/mmc/core/sd_ops.c b/drivers/mmc/core/sd_ops.c
index 274ef00..27e4807 100644
--- a/drivers/mmc/core/sd_ops.c
+++ b/drivers/mmc/core/sd_ops.c
@@ -92,9 +92,9 @@ int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
 			continue;
 		}
 
-		memset(&mrq, 0, sizeof(struct mmc_request));
+		(void)memset(&mrq, 0, sizeof(struct mmc_request));
 
-		memset(cmd->resp, 0, sizeof(cmd->resp));
+		(void)memset(cmd->resp, 0, sizeof(cmd->resp));
 		cmd->retries = 0;
 
 		mrq.cmd = cmd;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index bd7bacc..4953bc3 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -105,7 +105,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 	unsigned char data;
 	unsigned char speed;
 
-	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
+	(void)memset(&card->cccr, 0, sizeof(struct sdio_cccr));
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);
 	if (ret)
@@ -578,7 +578,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/*
 	 * Inform the card of the voltage
@@ -1043,7 +1043,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	struct mmc_card *card;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	err = mmc_send_io_op_cond(host, 0, &ocr);
 	if (err)
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 68f81b9..3f26671 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -166,7 +166,7 @@ static int sdio_card_irq_get(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	if (!host->sdio_irqs++) {
 		atomic_set(&host->sdio_irq_thread_abort, 0);
@@ -187,7 +187,7 @@ static int sdio_card_irq_put(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 	BUG_ON(host->sdio_irqs < 1);
 
 	if (!--host->sdio_irqs) {
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index d29e206..ad64a09 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -128,7 +128,7 @@ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 
 	BUG_ON(!card);
 	BUG_ON(fn > 7);
-	WARN_ON(blksz == 0);
+	(void)WARN_ON(blksz == 0);
 
 	/* sanity check */
 	if (addr & ~0x1FFFF)
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 0d955ff..06b696f 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -588,7 +588,7 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	data->bytes_xfered = 0;
 
 	clks = (unsigned long long)data->timeout_ns * host->cclk;
-	do_div(clks, 1000000000UL);
+	(void)do_div(clks, 1000000000UL);
 
 	timeout = data->timeout_clks + (unsigned int)clks;
 
@@ -985,7 +985,7 @@ static void mmci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	struct mmci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	WARN_ON(host->mrq != NULL);
+	(void)WARN_ON(host->mrq != NULL);
 
 	if (mrq->data && !is_power_of_2(mrq->data->blksz)) {
 		dev_err(mmc_dev(mmc), "unsupported block size (%d bytes)\n",
diff --git a/drivers/mmc/host/msm_sdcc.c b/drivers/mmc/host/msm_sdcc.c
index 1d14cda..36c4d6c 100644
--- a/drivers/mmc/host/msm_sdcc.c
+++ b/drivers/mmc/host/msm_sdcc.c
@@ -495,7 +495,7 @@ msmsdcc_start_data(struct msmsdcc_host *host, struct mmc_data *data,
 	host->curr.data_xfered = 0;
 	host->curr.got_dataend = 0;
 
-	memset(&host->pio, 0, sizeof(host->pio));
+	(void)memset(&host->pio, 0, sizeof(host->pio));
 
 	datactrl = MCI_DPSM_ENABLE | (data->blksz << 4);
 
@@ -1140,7 +1140,7 @@ msmsdcc_busclk_expired(unsigned long _data)
 static int
 msmsdcc_init_dma(struct msmsdcc_host *host)
 {
-	memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
+	(void)memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
 	host->dma.host = host;
 	host->dma.channel = -1;
 
@@ -1155,7 +1155,7 @@ msmsdcc_init_dma(struct msmsdcc_host *host)
 		pr_err("Unable to allocate DMA buffer\n");
 		return -ENOMEM;
 	}
-	memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
+	(void)memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
 	host->dma.cmd_busaddr = host->dma.nc_busaddr;
 	host->dma.cmdptr_busaddr = host->dma.nc_busaddr +
 				offsetof(struct msmsdcc_nc_dmadata, cmdptr);
diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index e1e122f..be1dfb7 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -176,7 +176,7 @@ static void fixup_convert_atmel_pri(struct mtd_info *mtd)
 	extp->ProtRegAddr = cpu_to_le16(extp->ProtRegAddr);
 
 	memcpy(&atmel_pri, extp, sizeof(atmel_pri));
-	memset((char *)extp + 5, 0, sizeof(*extp) - 5);
+	(void)memset((char *)extp + 5, 0, sizeof(*extp) - 5);
 
 	printk(KERN_ERR "atmel Features: %02x\n", atmel_pri.Features);
 
diff --git a/drivers/mtd/chips/cfi_probe.c b/drivers/mtd/chips/cfi_probe.c
index d255352..496ff43 100644
--- a/drivers/mtd/chips/cfi_probe.c
+++ b/drivers/mtd/chips/cfi_probe.c
@@ -173,7 +173,7 @@ static int __xipram cfi_chip_setup(struct map_info *map,
 		return 0;
 	}
 
-	memset(cfi->cfiq,0,sizeof(struct cfi_ident));
+	(void)memset(cfi->cfiq,0,sizeof(struct cfi_ident));
 
 	cfi->cfi_mode = CFI_MODE_CFI;
 
diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 3b9a284..3d6028b 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -64,7 +64,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	int i, j, mapsize;
 	int max_chips;
 
-	memset(&cfi, 0, sizeof(cfi));
+	(void)memset(&cfi, 0, sizeof(cfi));
 
 	/* Call the probetype-specific code with all permutations of
 	   interleave and device type, etc. */
@@ -146,7 +146,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	}
 
 	memcpy(retcfi, &cfi, sizeof(cfi));
-	memset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);
+	(void)memset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);
 
 	for (i = 0, j = 0; (j < cfi.numchips) && (i < max_chips); i++) {
 		if(test_bit(i, chip_map)) {
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index 424ca5f..9f7d72a 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -454,7 +454,7 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
 	if (new->disk_attributes) {
 		ret = sysfs_create_group(&disk_to_dev(gd)->kobj,
 					new->disk_attributes);
-		WARN_ON(ret);
+		(void)WARN_ON(ret);
 	}
 	return 0;
 error4:
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 50c6a1e..224c317 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -511,7 +511,7 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 	if (!from || !to)
 		return -EINVAL;
 
-	memset(to, 0, sizeof(*to));
+	(void)memset(to, 0, sizeof(*to));
 
 	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES);
 	for (i = 0; i < to->eccbytes; i++)
@@ -663,7 +663,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 
 	case MEMGETINFO:
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		info.type	= mtd->type;
 		info.flags	= mtd->flags;
 		info.size	= mtd->size;
diff --git a/drivers/mtd/mtdconcat.c b/drivers/mtd/mtdconcat.c
index 1ed5103..d18b05f 100644
--- a/drivers/mtd/mtdconcat.c
+++ b/drivers/mtd/mtdconcat.c
@@ -944,7 +944,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 					erase_region_p->erasesize =
 					    curr_erasesize;
 					tmp64 = position - begin;
-					do_div(tmp64, curr_erasesize);
+					(void)do_div(tmp64, curr_erasesize);
 					erase_region_p->numblocks = tmp64;
 					begin = position;
 
@@ -963,7 +963,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 						erase_region_p->erasesize =
 						    curr_erasesize;
 						tmp64 = position - begin;
-						do_div(tmp64, curr_erasesize);
+						(void)do_div(tmp64, curr_erasesize);
 						erase_region_p->numblocks = tmp64;
 						begin = position;
 
@@ -982,7 +982,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 		erase_region_p->offset = begin;
 		erase_region_p->erasesize = curr_erasesize;
 		tmp64 = position - begin;
-		do_div(tmp64, curr_erasesize);
+		(void)do_div(tmp64, curr_erasesize);
 		erase_region_p->numblocks = tmp64;
 	}
 
diff --git a/drivers/net/ethernet/smsc/smc91x.c b/drivers/net/ethernet/smsc/smc91x.c
index 64ad3ed..16aa4ef 100644
--- a/drivers/net/ethernet/smsc/smc91x.c
+++ b/drivers/net/ethernet/smsc/smc91x.c
@@ -1420,7 +1420,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		static const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};
 
 		/* start with a table of all zeros: reject all */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 
 		netdev_for_each_mc_addr(ha, dev) {
 			int position;
@@ -1446,7 +1446,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		 * since I'm disabling all multicast entirely, I need to
 		 * clear the multicast list
 		 */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 		update_multicast = 1;
 	}
 
@@ -2105,7 +2105,7 @@ static int smc_enable_device(struct platform_device *pdev)
 	local_irq_save(flags);
 	ecor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;
 	writeb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));
-	readb(addr + (ECOR << SMC_IO_SHIFT));
+	(void)readb(addr + (ECOR << SMC_IO_SHIFT));
 
 	/*
 	 * Wait 100us for the chip to reset.
diff --git a/drivers/oprofile/event_buffer.c b/drivers/oprofile/event_buffer.c
index c0cc4e7..c862609 100644
--- a/drivers/oprofile/event_buffer.c
+++ b/drivers/oprofile/event_buffer.c
@@ -48,7 +48,7 @@ void add_event_entry(unsigned long value)
 	 * canceled or flushed before the event buffer is freed.
 	 */
 	if (!event_buffer) {
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return;
 	}
 
@@ -167,7 +167,7 @@ static ssize_t event_buffer_read(struct file *file, char __user *buf,
 	if (count != max || *offset)
 		return -EINVAL;
 
-	wait_event_interruptible(buffer_wait, atomic_read(&buffer_ready));
+	(void)wait_event_interruptible(buffer_wait, atomic_read(&buffer_ready));
 
 	if (signal_pending(current))
 		return -EINTR;
diff --git a/drivers/oprofile/oprofilefs.c b/drivers/oprofile/oprofilefs.c
index 2f0aa0f..d2e8edc 100644
--- a/drivers/oprofile/oprofilefs.c
+++ b/drivers/oprofile/oprofilefs.c
@@ -78,7 +78,7 @@ int oprofilefs_ulong_from_user(unsigned long *val, char const __user *buf, size_
 	if (count > TMPBUFSIZE - 1)
 		return -EINVAL;
 
-	memset(tmpbuf, 0x0, TMPBUFSIZE);
+	(void)memset(tmpbuf, 0x0, TMPBUFSIZE);
 
 	if (copy_from_user(tmpbuf, buf, count))
 		return -EFAULT;
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b1fa25d..f52e99d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2757,9 +2757,9 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 		return ERR_PTR(-EINVAL);
 
 	/* Only one of each should be implemented */
-	WARN_ON(regulator_desc->ops->get_voltage &&
+	(void)WARN_ON(regulator_desc->ops->get_voltage &&
 		regulator_desc->ops->get_voltage_sel);
-	WARN_ON(regulator_desc->ops->set_voltage &&
+	(void)WARN_ON(regulator_desc->ops->set_voltage &&
 		regulator_desc->ops->set_voltage_sel);
 
 	/* If we're using selectors we must implement list_voltage. */
diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index 8a1c031..5a4db20 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -28,7 +28,7 @@ static int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)
 	else if (!rtc->ops->read_time)
 		err = -EINVAL;
 	else {
-		memset(tm, 0, sizeof(struct rtc_time));
+		(void)memset(tm, 0, sizeof(struct rtc_time));
 		err = rtc->ops->read_time(rtc->dev.parent, tm);
 	}
 	return err;
@@ -130,7 +130,7 @@ static int rtc_read_alarm_internal(struct rtc_device *rtc, struct rtc_wkalrm *al
 	else if (!rtc->ops->read_alarm)
 		err = -EINVAL;
 	else {
-		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		(void)memset(alarm, 0, sizeof(struct rtc_wkalrm));
 		err = rtc->ops->read_alarm(rtc->dev.parent, alarm);
 	}
 
@@ -309,7 +309,7 @@ int rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
 	else if (!rtc->ops->read_alarm)
 		err = -EINVAL;
 	else {
-		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		(void)memset(alarm, 0, sizeof(struct rtc_wkalrm));
 		alarm->enabled = rtc->aie_timer.enabled;
 		alarm->time = rtc_ktime_to_tm(rtc->aie_timer.node.expires);
 	}
diff --git a/drivers/scsi/ch.c b/drivers/scsi/ch.c
index a15474e..37465a1 100644
--- a/drivers/scsi/ch.c
+++ b/drivers/scsi/ch.c
@@ -245,7 +245,7 @@ ch_read_element_status(scsi_changer *ch, u_int elem, char *data)
 		return -ENOMEM;
 
  retry:
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0] = READ_ELEMENT_STATUS;
 	cmd[1] = (ch->device->lun << 5) |
 		(ch->voltags ? 0x10 : 0) |
@@ -281,7 +281,7 @@ ch_init_elem(scsi_changer *ch)
 	u_char cmd[6];
 
 	VPRINTK(KERN_INFO, "INITIALIZE ELEMENT STATUS, may take some time ...\n");
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0] = INITIALIZE_ELEMENT_STATUS;
 	cmd[1] = ch->device->lun << 5;
 	err = ch_do_scsi(ch, cmd, NULL, 0, DMA_NONE);
@@ -301,7 +301,7 @@ ch_readconfig(scsi_changer *ch)
 	if (!buffer)
 		return -ENOMEM;
 
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0] = MODE_SENSE;
 	cmd[1] = ch->device->lun << 5;
 	cmd[2] = 0x1d;
@@ -426,7 +426,7 @@ ch_position(scsi_changer *ch, u_int trans, u_int elem, int rotate)
 	DPRINTK("position: 0x%x\n",elem);
 	if (0 == trans)
 		trans = ch->firsts[CHET_MT];
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0]  = POSITION_TO_ELEMENT;
 	cmd[1]  = ch->device->lun << 5;
 	cmd[2]  = (trans >> 8) & 0xff;
@@ -445,7 +445,7 @@ ch_move(scsi_changer *ch, u_int trans, u_int src, u_int dest, int rotate)
 	DPRINTK("move: 0x%x => 0x%x\n",src,dest);
 	if (0 == trans)
 		trans = ch->firsts[CHET_MT];
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0]  = MOVE_MEDIUM;
 	cmd[1]  = ch->device->lun << 5;
 	cmd[2]  = (trans >> 8) & 0xff;
@@ -468,7 +468,7 @@ ch_exchange(scsi_changer *ch, u_int trans, u_int src,
 		src,dest1,dest2);
 	if (0 == trans)
 		trans = ch->firsts[CHET_MT];
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0]  = EXCHANGE_MEDIUM;
 	cmd[1]  = ch->device->lun << 5;
 	cmd[2]  = (trans >> 8) & 0xff;
@@ -516,7 +516,7 @@ ch_set_voltag(scsi_changer *ch, u_int elem,
 		clear     ? "clear"     : "set",
 		alternate ? "alternate" : "primary",
 		elem, tag);
-	memset(cmd,0,sizeof(cmd));
+	(void)memset(cmd,0,sizeof(cmd));
 	cmd[0]  = SEND_VOLUME_TAG;
 	cmd[1] = (ch->device->lun << 5) |
 		ch_elem_to_typecode(ch,elem);
@@ -631,7 +631,7 @@ static long ch_ioctl(struct file *file,
 	{
 		struct changer_vendor_params vparams;
 
-		memset(&vparams,0,sizeof(vparams));
+		(void)memset(&vparams,0,sizeof(vparams));
 		if (ch->counts[CHET_V1]) {
 			vparams.cvp_n1  = ch->counts[CHET_V1];
 			strncpy(vparams.cvp_label1,vendor_labels[0],16);
@@ -752,7 +752,7 @@ static long ch_ioctl(struct file *file,
 		mutex_lock(&ch->lock);
 
 	voltag_retry:
-		memset(ch_cmd, 0, sizeof(ch_cmd));
+		(void)memset(ch_cmd, 0, sizeof(ch_cmd));
 		ch_cmd[0] = READ_ELEMENT_STATUS;
 		ch_cmd[1] = (ch->device->lun << 5) |
 			(ch->voltags ? 0x10 : 0) |
diff --git a/drivers/scsi/constants.c b/drivers/scsi/constants.c
index 450e011..f9eed3f 100644
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@ -1341,7 +1341,7 @@ scsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,
 		info = ((sense_buffer[3] << 24) | (sense_buffer[4] << 16) |
 			(sense_buffer[5] << 8) | sense_buffer[6]);
 		res = 0;
-		memset(buff, 0, sizeof(buff));
+		(void)memset(buff, 0, sizeof(buff));
 		blen = sizeof(buff) - 1;
 		if (fixed_valid)
 			res += snprintf(buff + res, blen - res,
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 2aeb2e9..13e5e44 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -263,7 +263,7 @@ struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
 			buf = cmd->sense_buffer;
 			prot = cmd->prot_sdb;
 
-			memset(cmd, 0, sizeof(*cmd));
+			(void)memset(cmd, 0, sizeof(*cmd));
 
 			cmd->sense_buffer = buf;
 			cmd->prot_sdb = prot;
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 5f84a14..96e68d0 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -691,8 +691,8 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 
 	scmd->prot_op = SCSI_PROT_NORMAL;
 	scmd->cmnd = ses->eh_cmnd;
-	memset(scmd->cmnd, 0, BLK_MAX_CDB);
-	memset(&scmd->sdb, 0, sizeof(scmd->sdb));
+	(void)memset(scmd->cmnd, 0, BLK_MAX_CDB);
+	(void)memset(&scmd->sdb, 0, sizeof(scmd->sdb));
 	scmd->request->next_rq = NULL;
 
 	if (sense_bytes) {
@@ -725,7 +725,7 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 	 * Zero the sense buffer.  The scsi spec mandates that any
 	 * untransferred sense data should be interpreted as being zero.
 	 */
-	memset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+	(void)memset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 }
 EXPORT_SYMBOL(scsi_eh_prep_cmnd);
 
@@ -1948,7 +1948,7 @@ scsi_reset_provider(struct scsi_device *dev, int flag)
 	scmd->cmnd = req.cmd;
 
 	scmd->scsi_done		= scsi_reset_provider_done_command;
-	memset(&scmd->sdb, 0, sizeof(scmd->sdb));
+	(void)memset(&scmd->sdb, 0, sizeof(scmd->sdb));
 
 	scmd->cmd_len			= 0;
 
@@ -2028,7 +2028,7 @@ int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
 	if (!sense_buffer || !sb_len)
 		return 0;
 
-	memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
+	(void)memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
 
 	sshdr->response_code = (sense_buffer[0] & 0x7f);
 
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index b2c95db..7d1ec98 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -243,7 +243,7 @@ int scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 	 * and prevent security leaks by zeroing out the excess data.
 	 */
 	if (unlikely(req->resid_len > 0 && req->resid_len <= bufflen))
-		memset(buffer + (bufflen - req->resid_len), 0, req->resid_len);
+		(void)memset(buffer + (bufflen - req->resid_len), 0, req->resid_len);
 
 	if (resid)
 		*resid = req->resid_len;
@@ -294,7 +294,7 @@ static void scsi_init_cmd_errh(struct scsi_cmnd *cmd)
 {
 	cmd->serial_number = 0;
 	scsi_set_resid(cmd, 0);
-	memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+	(void)memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 	if (cmd->cmd_len == 0)
 		cmd->cmd_len = scsi_command_size(cmd->cmnd);
 }
@@ -636,7 +636,7 @@ static void __scsi_release_buffers(struct scsi_cmnd *cmd, int do_bidi_check)
 	if (cmd->sdb.table.nents)
 		scsi_free_sgtable(&cmd->sdb);
 
-	memset(&cmd->sdb, 0, sizeof(cmd->sdb));
+	(void)memset(&cmd->sdb, 0, sizeof(cmd->sdb));
 
 	if (do_bidi_check && scsi_bidi_cmnd(cmd)) {
 		struct scsi_data_buffer *bidi_sdb =
@@ -1109,7 +1109,7 @@ int scsi_setup_blk_pc_cmnd(struct scsi_device *sdev, struct request *req)
 	} else {
 		BUG_ON(blk_rq_bytes(req));
 
-		memset(&cmd->sdb, 0, sizeof(cmd->sdb));
+		(void)memset(&cmd->sdb, 0, sizeof(cmd->sdb));
 		req->buffer = NULL;
 	}
 
@@ -1156,7 +1156,7 @@ int scsi_setup_fs_cmnd(struct scsi_device *sdev, struct request *req)
 	if (unlikely(!cmd))
 		return BLKPREP_DEFER;
 
-	memset(cmd->cmnd, 0, BLK_MAX_CDB);
+	(void)memset(cmd->cmnd, 0, BLK_MAX_CDB);
 	return scsi_init_io(cmd, GFP_ATOMIC);
 }
 EXPORT_SYMBOL(scsi_setup_fs_cmnd);
@@ -1844,7 +1844,7 @@ scsi_mode_select(struct scsi_device *sdev, int pf, int sp, int modepage,
 	unsigned char *real_buffer;
 	int ret;
 
-	memset(cmd, 0, sizeof(cmd));
+	(void)memset(cmd, 0, sizeof(cmd));
 	cmd[1] = (pf ? 0x10 : 0) | (sp ? 0x01 : 0);
 
 	if (sdev->use_10_for_ms) {
@@ -1922,8 +1922,8 @@ scsi_mode_sense(struct scsi_device *sdev, int dbd, int modepage,
 	int result;
 	struct scsi_sense_hdr my_sshdr;
 
-	memset(data, 0, sizeof(*data));
-	memset(&cmd[0], 0, 12);
+	(void)memset(data, 0, sizeof(*data));
+	(void)memset(&cmd[0], 0, 12);
 	cmd[1] = dbd & 0x18;	/* allows DBD and LLBA bits */
 	cmd[2] = modepage;
 
@@ -1950,7 +1950,7 @@ scsi_mode_sense(struct scsi_device *sdev, int dbd, int modepage,
 		header_length = 4;
 	}
 
-	memset(buffer, 0, len);
+	(void)memset(buffer, 0, len);
 
 	result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer, len,
 				  sshdr, timeout, retries, NULL);
@@ -2538,7 +2538,7 @@ void *scsi_kmap_atomic_sg(struct scatterlist *sgl, int sg_count,
 	struct scatterlist *sg;
 	struct page *page;
 
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	for_each_sg(sgl, sg, sg_count, i) {
 		len_complete = sg_len; /* Complete sg-entries */
@@ -2551,7 +2551,7 @@ void *scsi_kmap_atomic_sg(struct scatterlist *sgl, int sg_count,
 		printk(KERN_ERR "%s: Bytes in sg: %zu, requested offset %zu, "
 			"elements %d\n",
 		       __func__, sg_len, *offset, sg_count);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return NULL;
 	}
 
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 89da43f..2b2a7d1 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -577,11 +577,11 @@ static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 	for (count = 0; count < 3; ++count) {
 		int resid;
 
-		memset(scsi_cmd, 0, 6);
+		(void)memset(scsi_cmd, 0, 6);
 		scsi_cmd[0] = INQUIRY;
 		scsi_cmd[4] = (unsigned char) try_inquiry_len;
 
-		memset(inq_result, 0, try_inquiry_len);
+		(void)memset(inq_result, 0, try_inquiry_len);
 
 		result = scsi_execute_req(sdev,  scsi_cmd, DMA_FROM_DEVICE,
 					  inq_result, try_inquiry_len, &sshdr,
@@ -1271,7 +1271,7 @@ void int_to_scsilun(unsigned int lun, struct scsi_lun *scsilun)
 {
 	int i;
 
-	memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
+	(void)memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
 
 	for (i = 0; i < sizeof(lun); i += 2) {
 		scsilun->scsi_lun[i] = (lun >> 8) & 0xFF;
@@ -1369,7 +1369,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 	/*
 	 * bytes 1 - 5: reserved, set to zero.
 	 */
-	memset(&scsi_cmd[1], 0, 5);
+	(void)memset(&scsi_cmd[1], 0, 5);
 
 	/*
 	 * bytes 6 - 9: length of the command.
diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
index 6209110..9b622cf 100644
--- a/drivers/scsi/scsi_tgt_if.c
+++ b/drivers/scsi/scsi_tgt_if.c
@@ -111,7 +111,7 @@ int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, u64 itn_id,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.cmd_req.host_no = shost->host_no;
 	ev.p.cmd_req.itn_id = itn_id;
 	ev.p.cmd_req.data_len = scsi_bufflen(cmd);
@@ -137,7 +137,7 @@ int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 itn_id, u64 tag)
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.cmd_done.host_no = shost->host_no;
 	ev.p.cmd_done.itn_id = itn_id;
 	ev.p.cmd_done.tag = tag;
@@ -160,7 +160,7 @@ int scsi_tgt_uspace_send_tsk_mgmt(int host_no, u64 itn_id, int function,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.tsk_mgmt_req.host_no = host_no;
 	ev.p.tsk_mgmt_req.itn_id = itn_id;
 	ev.p.tsk_mgmt_req.function = function;
@@ -184,7 +184,7 @@ int scsi_tgt_uspace_send_it_nexus_request(int host_no, u64 itn_id,
 	struct tgt_event ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	ev.p.it_nexus_req.host_no = host_no;
 	ev.p.it_nexus_req.function = function;
 	ev.p.it_nexus_req.itn_id = itn_id;
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index c691fb5..b6b08c3 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -554,7 +554,7 @@ static int scsi_setup_discard_cmnd(struct scsi_device *sdp, struct request *rq)
 
 	rq->timeout = SD_TIMEOUT;
 
-	memset(rq->cmd, 0, rq->cmd_len);
+	(void)memset(rq->cmd, 0, rq->cmd_len);
 
 	page = alloc_page(GFP_ATOMIC | __GFP_ZERO);
 	if (!page)
@@ -807,7 +807,7 @@ static int sd_prep_fn(struct request_queue *q, struct request *rq)
 		}
 
 		SCpnt->cmd_len = SD_EXT_CDB_SIZE;
-		memset(SCpnt->cmnd, 0, SCpnt->cmd_len);
+		(void)memset(SCpnt->cmnd, 0, SCpnt->cmd_len);
 		SCpnt->cmnd[0] = VARIABLE_LENGTH_CMD;
 		SCpnt->cmnd[7] = 0x18;
 		SCpnt->cmnd[9] = (rq_data_dir(rq) == READ) ? READ_32 : WRITE_32;
@@ -1345,8 +1345,8 @@ static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)
 	} else {
 		/* be careful ... don't want any overflows */
 		u64 factor = scmd->device->sector_size / 512;
-		do_div(start_lba, factor);
-		do_div(end_lba, factor);
+		(void)do_div(start_lba, factor);
+		(void)do_div(end_lba, factor);
 	}
 
 	/* The bad lba was reported incorrectly, we have no idea where
@@ -1417,7 +1417,7 @@ static int sd_done(struct scsi_cmnd *SCpnt)
 		 */
 		scsi_print_sense("sd", SCpnt);
 		SCpnt->result = 0;
-		memset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		(void)memset(SCpnt->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
 		break;
 	case ABORTED_COMMAND:
 		if (sshdr.asc == 0x10)  /* DIF: Target detected corruption */
@@ -1478,7 +1478,7 @@ sd_spinup_disk(struct scsi_disk *sdkp)
 
 		do {
 			cmd[0] = TEST_UNIT_READY;
-			memset((void *) &cmd[1], 0, 9);
+			(void)memset((void *) &cmd[1], 0, 9);
 
 			the_result = scsi_execute_req(sdkp->device, cmd,
 						      DMA_NONE, NULL, 0,
@@ -1531,7 +1531,7 @@ sd_spinup_disk(struct scsi_disk *sdkp)
 				sd_printk(KERN_NOTICE, sdkp, "Spinning up disk...");
 				cmd[0] = START_STOP;
 				cmd[1] = 1;	/* Return immediately */
-				memset((void *) &cmd[2], 0, 8);
+				(void)memset((void *) &cmd[2], 0, 8);
 				cmd[4] = 1;	/* Start spin cycle */
 				if (sdkp->device->start_stop_pwr_cond)
 					cmd[4] |= 1 << 4;
@@ -1663,11 +1663,11 @@ static int read_capacity_16(struct scsi_disk *sdkp, struct scsi_device *sdp,
 		return -EINVAL;
 
 	do {
-		memset(cmd, 0, 16);
+		(void)memset(cmd, 0, 16);
 		cmd[0] = SERVICE_ACTION_IN;
 		cmd[1] = SAI_READ_CAPACITY_16;
 		cmd[13] = RC16_LEN;
-		memset(buffer, 0, RC16_LEN);
+		(void)memset(buffer, 0, RC16_LEN);
 
 		the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
 					buffer, RC16_LEN, &sshdr,
@@ -1753,8 +1753,8 @@ static int read_capacity_10(struct scsi_disk *sdkp, struct scsi_device *sdp,
 
 	do {
 		cmd[0] = READ_CAPACITY;
-		memset(&cmd[1], 0, 9);
-		memset(buffer, 0, 8);
+		(void)memset(&cmd[1], 0, 9);
+		(void)memset(buffer, 0, 8);
 
 		the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
 					buffer, 8, &sshdr,
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index eacd46b..bd4a450 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -428,7 +428,7 @@ sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)
 			goto free_old_hdr;
 		}
 	}
-	memset(old_hdr, 0, SZ_SG_HEADER);
+	(void)memset(old_hdr, 0, SZ_SG_HEADER);
 	old_hdr->reply_len = (int) hp->timeout;
 	old_hdr->pack_len = old_hdr->reply_len; /* old, strange behaviour */
 	old_hdr->pack_id = hp->pack_id;
@@ -974,7 +974,7 @@ sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 			read_lock_irqsave(&sfp->rq_list_lock, iflags);
 			for (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE;
 			     ++val, srp = srp ? srp->nextrp : srp) {
-				memset(&rinfo[val], 0, SZ_SG_REQ_INFO);
+				(void)memset(&rinfo[val], 0, SZ_SG_REQ_INFO);
 				if (srp) {
 					rinfo[val].req_state = srp->done + 1;
 					rinfo[val].problem =
@@ -1857,7 +1857,7 @@ sg_remove_scat(Sg_scatter_hold * schp)
 			kfree(schp->pages);
 		}
 	}
-	memset(schp, 0, sizeof (*schp));
+	(void)memset(schp, 0, sizeof (*schp));
 }
 
 static int
@@ -1985,7 +1985,7 @@ sg_add_request(Sg_fd * sfp)
 	write_lock_irqsave(&sfp->rq_list_lock, iflags);
 	resp = sfp->headrp;
 	if (!resp) {
-		memset(rp, 0, sizeof (Sg_request));
+		(void)memset(rp, 0, sizeof (Sg_request));
 		rp->parentfp = sfp;
 		resp = rp;
 		sfp->headrp = resp;
@@ -1998,7 +1998,7 @@ sg_add_request(Sg_fd * sfp)
 					break;
 			}
 			if (k < SG_MAX_QUEUE) {
-				memset(rp, 0, sizeof (Sg_request));
+				(void)memset(rp, 0, sizeof (Sg_request));
 				rp->parentfp = sfp;
 				while (resp->nextrp)
 					resp = resp->nextrp;
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b2ccdea..3734837 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -427,7 +427,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	if (!proxy)
 		return NULL;
 
-	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
+	(void)WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
 
 	proxy->chip_select = chip->chip_select;
 	proxy->max_speed_hz = chip->max_speed_hz;
@@ -1066,7 +1066,7 @@ int spi_write_then_read(struct spi_device *spi,
 		return -EINVAL;
 
 	spi_message_init(&message);
-	memset(x, 0, sizeof x);
+	(void)memset(x, 0, sizeof x);
 	if (n_tx) {
 		x[0].len = n_tx;
 		spi_message_add_tail(&x[0], &message);
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 7491801..6e05588 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -189,7 +189,7 @@ static struct binder_transaction_log_entry *binder_transaction_log_add(
 {
 	struct binder_transaction_log_entry *e;
 	e = &log->entry[log->next];
-	memset(e, 0, sizeof(*e));
+	(void)memset(e, 0, sizeof(*e));
 	log->next++;
 	if (log->next == ARRAY_SIZE(log->entry)) {
 		log->next = 0;
@@ -2240,7 +2240,7 @@ retry:
 				"for process work before calling BC_REGISTER_"
 				"LOOPER or BC_ENTER_LOOPER (state %x)\n",
 				proc->pid, thread->pid, thread->looper);
-			wait_event_interruptible(binder_user_error_wait,
+			(void)wait_event_interruptible(binder_user_error_wait,
 						 binder_stop_on_user_error < 2);
 		}
 		binder_set_nice(proc->default_priority);
@@ -2745,7 +2745,7 @@ err:
 	if (thread)
 		thread->looper &= ~BINDER_LOOPER_STATE_NEED_RETURN;
 	mutex_unlock(&binder_lock);
-	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error < 2);
+	(void)wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error < 2);
 	if (ret && ret != -ERESTARTSYS)
 		printk(KERN_INFO "binder: %d:%d ioctl %x %lx returned %d\n", proc->pid, current->pid, cmd, arg, ret);
 	return ret;
diff --git a/drivers/thermal/thermal_sys.c b/drivers/thermal/thermal_sys.c
index dd9a574..3d6d257 100644
--- a/drivers/thermal/thermal_sys.c
+++ b/drivers/thermal/thermal_sys.c
@@ -1345,7 +1345,7 @@ int generate_netlink_event(u32 orig, enum events event)
 		return -EINVAL;
 	}
 
-	memset(thermal_event, 0, sizeof(struct thermal_genl_event));
+	(void)memset(thermal_event, 0, sizeof(struct thermal_genl_event));
 
 	thermal_event->orig = orig;
 	thermal_event->event = event;
diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index d2256d0..f078723 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -183,7 +183,7 @@ static void reset_buffer_flags(struct tty_struct *tty)
 	mutex_unlock(&tty->echo_lock);
 
 	tty->canon_head = tty->canon_data = tty->erasing = 0;
-	memset(&tty->read_flags, 0, sizeof tty->read_flags);
+	(void)memset(&tty->read_flags, 0, sizeof tty->read_flags);
 	n_tty_set_room(tty);
 }
 
@@ -1463,7 +1463,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 	if (old)
 		canon_change = (old->c_lflag ^ tty->termios->c_lflag) & ICANON;
 	if (canon_change) {
-		memset(&tty->read_flags, 0, sizeof tty->read_flags);
+		(void)memset(&tty->read_flags, 0, sizeof tty->read_flags);
 		tty->canon_head = tty->read_tail;
 		tty->canon_data = 0;
 		tty->erasing = 0;
@@ -1483,7 +1483,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
 	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
 	    I_PARMRK(tty)) {
-		memset(tty->process_char_map, 0, 256/8);
+		(void)memset(tty->process_char_map, 0, 256/8);
 
 		if (I_IGNCR(tty) || I_ICRNL(tty))
 			set_bit('\r', tty->process_char_map);
diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d8653ab..a6b7cd5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -39,7 +39,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 {
 	BUG_ON(!tty);
 	if (tty->driver->subtype == PTY_TYPE_MASTER)
-		WARN_ON(tty->count > 1);
+		(void)WARN_ON(tty->count > 1);
 	else {
 		if (tty->count > 2)
 			return;
diff --git a/drivers/tty/serial/8250/8250.c b/drivers/tty/serial/8250/8250.c
index 9f50c4e..4dab9be 100644
--- a/drivers/tty/serial/8250/8250.c
+++ b/drivers/tty/serial/8250/8250.c
@@ -3026,7 +3026,7 @@ static int __devinit serial8250_probe(struct platform_device *dev)
 	struct uart_port port;
 	int ret, i, irqflag = 0;
 
-	memset(&port, 0, sizeof(struct uart_port));
+	(void)memset(&port, 0, sizeof(struct uart_port));
 
 	if (share_irqs)
 		irqflag = IRQF_SHARED;
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index c7bf31a..bd971e1 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -397,7 +397,7 @@ uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,
 		}
 	}
 	/* Should never happen */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
@@ -506,7 +506,7 @@ static int uart_write(struct tty_struct *tty,
 	 * closed.  No cookie for you.
 	 */
 	if (!state) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EL3HLT;
 	}
 
@@ -570,7 +570,7 @@ static void uart_flush_buffer(struct tty_struct *tty)
 	 * closed.  No cookie for you.
 	 */
 	if (!state) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -641,7 +641,7 @@ static int uart_get_info(struct uart_state *state,
 	struct tty_port *port = &state->port;
 	struct serial_struct tmp;
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 
 	/* Ensure the state we copy is consistent and no hardware changes
 	   occur as we go */
@@ -1777,7 +1777,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 	spin_lock_init(&port->lock);
 	lockdep_set_class(&port->lock, &port_lock_key);
 
-	memset(&termios, 0, sizeof(struct ktermios));
+	(void)memset(&termios, 0, sizeof(struct ktermios));
 
 	termios.c_cflag = CREAD | HUPCL | CLOCAL;
 
@@ -1954,7 +1954,7 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		/*
 		 * First try to use the console cflag setting.
 		 */
-		memset(&termios, 0, sizeof(struct ktermios));
+		(void)memset(&termios, 0, sizeof(struct ktermios));
 		termios.c_cflag = uport->cons->cflag;
 
 		/*
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 6c9b7cd..4bb9837 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -89,7 +89,7 @@ static void tty_buffer_free(struct tty_struct *tty, struct tty_buffer *b)
 {
 	/* Dumb strategy for now - should keep some stats */
 	tty->buf.memory_used -= b->size;
-	WARN_ON(tty->buf.memory_used < 0);
+	(void)WARN_ON(tty->buf.memory_used < 0);
 
 	if (b->size >= 512)
 		kfree(b);
@@ -255,7 +255,7 @@ int tty_insert_flip_string_fixed_flag(struct tty_struct *tty,
 		if (unlikely(space == 0))
 			break;
 		memcpy(tb->char_buf_ptr + tb->used, chars, space);
-		memset(tb->flag_buf_ptr + tb->used, flag, space);
+		(void)memset(tb->flag_buf_ptr + tb->used, flag, space);
 		tb->used += space;
 		copied += space;
 		chars += space;
@@ -348,7 +348,7 @@ int tty_prepare_flip_string(struct tty_struct *tty, unsigned char **chars,
 	if (likely(space)) {
 		struct tty_buffer *tb = tty->buf.tail;
 		*chars = tb->char_buf_ptr + tb->used;
-		memset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);
+		(void)memset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);
 		tb->used += space;
 	}
 	return space;
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index e41b9bb..9691b31 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1354,7 +1354,7 @@ static int tty_reopen(struct tty_struct *tty)
 	tty->driver = driver; /* N.B. why do this every time?? */
 
 	mutex_lock(&tty->ldisc_mutex);
-	WARN_ON(!test_bit(TTY_LDISC, &tty->flags));
+	(void)WARN_ON(!test_bit(TTY_LDISC, &tty->flags));
 	mutex_unlock(&tty->ldisc_mutex);
 
 	return 0;
@@ -1549,7 +1549,7 @@ EXPORT_SYMBOL(tty_kref_put);
 static void release_tty(struct tty_struct *tty, int idx)
 {
 	/* This should always be true but check for the moment */
-	WARN_ON(tty->index != idx);
+	(void)WARN_ON(tty->index != idx);
 
 	if (tty->link)
 		tty_kref_put(tty->link);
@@ -2598,7 +2598,7 @@ static int tty_tiocgicount(struct tty_struct *tty, void __user *arg)
 {
 	int retval = -EINVAL;
 	struct serial_icounter_struct icount;
-	memset(&icount, 0, sizeof(icount));
+	(void)memset(&icount, 0, sizeof(icount));
 	if (tty->ops->get_icount)
 		retval = tty->ops->get_icount(tty, &icount);
 	if (retval != 0)
@@ -2934,7 +2934,7 @@ static struct device *tty_get_device(struct tty_struct *tty)
 void initialize_tty_struct(struct tty_struct *tty,
 		struct tty_driver *driver, int idx)
 {
-	memset(tty, 0, sizeof(struct tty_struct));
+	(void)memset(tty, 0, sizeof(struct tty_struct));
 	kref_init(&tty->kref);
 	tty->magic = TTY_MAGIC;
 	tty_ldisc_init(tty);
@@ -3400,7 +3400,7 @@ int __init tty_init(void)
 	if (IS_ERR(consdev))
 		consdev = NULL;
 	else
-		WARN_ON(device_create_file(consdev, &dev_attr_active) < 0);
+		(void)WARN_ON(device_create_file(consdev, &dev_attr_active) < 0);
 
 #ifdef CONFIG_VT
 	vty_init(&console_fops);
diff --git a/drivers/tty/tty_ldisc.c b/drivers/tty/tty_ldisc.c
index 24b95db..98ccbf7 100644
--- a/drivers/tty/tty_ldisc.c
+++ b/drivers/tty/tty_ldisc.c
@@ -429,7 +429,7 @@ static void tty_set_termios_ldisc(struct tty_struct *tty, int num)
 
 static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)
 {
-	WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));
+	(void)WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));
 	if (ld->ops->open) {
 		int ret;
                 /* BTM here locks versus a hangup event */
@@ -452,7 +452,7 @@ static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)
 
 static void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)
 {
-	WARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));
+	(void)WARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));
 	clear_bit(TTY_LDISC_OPEN, &tty->flags);
 	if (ld->ops->close)
 		ld->ops->close(tty);
@@ -475,7 +475,7 @@ static void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)
 
 	/* There is an outstanding reference here so this is safe */
 	old = tty_ldisc_get(old->ops->num);
-	WARN_ON(IS_ERR(old));
+	(void)WARN_ON(IS_ERR(old));
 	tty_ldisc_assign(tty, old);
 	tty_set_termios_ldisc(tty, old->ops->num);
 	if (tty_ldisc_open(tty, old) < 0) {
@@ -854,7 +854,7 @@ retry:
 		   N_TTY open cannot fail */
 		if (reset || err) {
 			BUG_ON(tty_ldisc_reinit(tty, N_TTY));
-			WARN_ON(tty_ldisc_open(tty, tty->ldisc));
+			(void)WARN_ON(tty_ldisc_open(tty, tty->ldisc));
 		}
 		tty_ldisc_enable(tty);
 	}
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index ef9dd62..1df91d9 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -20,7 +20,7 @@
 
 void tty_port_init(struct tty_port *port)
 {
-	memset(port, 0, sizeof(*port));
+	(void)memset(port, 0, sizeof(*port));
 	init_waitqueue_head(&port->open_wait);
 	init_waitqueue_head(&port->close_wait);
 	init_waitqueue_head(&port->delta_msr_wait);
@@ -231,7 +231,7 @@ int tty_port_block_til_ready(struct tty_port *port,
 
 	/* block if port is in the process of being closed */
 	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		wait_event_interruptible_tty(port->close_wait,
+		(void)wait_event_interruptible_tty(port->close_wait,
 				!(port->flags & ASYNC_CLOSING));
 		if (port->flags & ASYNC_HUP_NOTIFY)
 			return -EAGAIN;
diff --git a/drivers/tty/vt/consolemap.c b/drivers/tty/vt/consolemap.c
index a0f3d6c..a6f0e27 100644
--- a/drivers/tty/vt/consolemap.c
+++ b/drivers/tty/vt/consolemap.c
@@ -197,7 +197,7 @@ static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int
 			kmalloc(MAX_GLYPH, GFP_KERNEL);
 		if (!q) return;
 	}
-	memset(q, 0, MAX_GLYPH);
+	(void)memset(q, 0, MAX_GLYPH);
 
 	for (j = 0; j < E_TABSZ; j++) {
 		glyph = conv_uni_to_pc(conp, t[j]);
@@ -223,7 +223,7 @@ static void set_inverse_trans_unicode(struct vc_data *conp,
 		if (!q)
 			return;
 	}
-	memset(q, 0, MAX_GLYPH * sizeof(u16));
+	(void)memset(q, 0, MAX_GLYPH * sizeof(u16));
 
 	for (i = 0; i < 32; i++) {
 		p1 = p->uni_pgdir[i];
@@ -314,7 +314,7 @@ int con_set_trans_old(unsigned char __user * arg)
 
 	for (i=0; i<E_TABSZ ; i++) {
 		unsigned char uc;
-		__get_user(uc, arg+i);
+		(void)__get_user(uc, arg+i);
 		p[i] = UNI_DIRECT_BASE | uc;
 	}
 
@@ -333,7 +333,7 @@ int con_get_trans_old(unsigned char __user * arg)
 	for (i=0; i<E_TABSZ ; i++)
 	  {
 	    ch = conv_uni_to_pc(vc_cons[fg_console].d, p[i]);
-	    __put_user((ch & ~0xff) ? 0 : ch, arg+i);
+	    (void)__put_user((ch & ~0xff) ? 0 : ch, arg+i);
 	  }
 	return 0;
 }
@@ -348,7 +348,7 @@ int con_set_trans_new(ushort __user * arg)
 
 	for (i=0; i<E_TABSZ ; i++) {
 		unsigned short us;
-		__get_user(us, arg+i);
+		(void)__get_user(us, arg+i);
 		p[i] = us;
 	}
 
@@ -365,7 +365,7 @@ int con_get_trans_new(ushort __user * arg)
 		return -EFAULT;
 
 	for (i=0; i<E_TABSZ ; i++)
-	  __put_user(p[i], arg+i);
+	  (void)__put_user(p[i], arg+i);
 	
 	return 0;
 }
@@ -477,7 +477,7 @@ con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)
 	if (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {
 		p2 = p1[n] = kmalloc(64*sizeof(u16), GFP_KERNEL);
 		if (!p2) return -ENOMEM;
-		memset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */
+		(void)memset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */
 	}
 
 	p2[unicode & 0x3f] = fontpos;
@@ -550,8 +550,8 @@ int con_set_unimap(struct vc_data *vc, ushort ct, struct unipair __user *list)
 	
 	while (ct--) {
 		unsigned short unicode, fontpos;
-		__get_user(unicode, &list->unicode);
-		__get_user(fontpos, &list->fontpos);
+		(void)__get_user(unicode, &list->unicode);
+		(void)__get_user(fontpos, &list->fontpos);
 		if ((err1 = con_insert_unipair(p, unicode,fontpos)) != 0)
 			err = err1;
 		list++;
@@ -649,16 +649,16 @@ int con_get_unimap(struct vc_data *vc, ushort ct, ushort __user *uct, struct uni
 			if ((p2 = *(p1++)))
 				for (k = 0; k < 64; k++) {
 					if (*p2 < MAX_GLYPH && ect++ < ct) {
-						__put_user((u_short)((i<<11)+(j<<6)+k),
+						(void)__put_user((u_short)((i<<11)+(j<<6)+k),
 							   &list->unicode);
-						__put_user((u_short) *p2, 
+						(void)__put_user((u_short) *p2, 
 							   &list->fontpos);
 						list++;
 					}
 					p2++;
 				}
 	}
-	__put_user(ect, uct);
+	(void)__put_user(ect, uct);
 	return ((ect <= ct) ? 0 : -ENOMEM);
 }
 
diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c
index a605549..5a8f6e9 100644
--- a/drivers/tty/vt/keyboard.c
+++ b/drivers/tty/vt/keyboard.c
@@ -389,7 +389,7 @@ void compute_shiftstate(void)
 	unsigned int i, j, k, sym, val;
 
 	shift_state = 0;
-	memset(shift_down, 0, sizeof(shift_down));
+	(void)memset(shift_down, 0, sizeof(shift_down));
 
 	for (i = 0; i < ARRAY_SIZE(key_down); i++) {
 
diff --git a/drivers/tty/vt/selection.c b/drivers/tty/vt/selection.c
index 7a0a12a..297e815 100644
--- a/drivers/tty/vt/selection.c
+++ b/drivers/tty/vt/selection.c
@@ -146,11 +146,11 @@ int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *t
 
 	  if (!access_ok(VERIFY_READ, sel, sizeof(*sel)))
 		return -EFAULT;
-	  __get_user(xs, &sel->xs);
-	  __get_user(ys, &sel->ys);
-	  __get_user(xe, &sel->xe);
-	  __get_user(ye, &sel->ye);
-	  __get_user(sel_mode, &sel->sel_mode);
+	  (void)__get_user(xs, &sel->xs);
+	  (void)__get_user(ys, &sel->ys);
+	  (void)__get_user(xe, &sel->xe);
+	  (void)__get_user(ye, &sel->ye);
+	  (void)__get_user(sel_mode, &sel->sel_mode);
 	  xs--; ys--; xe--; ye--;
 	  xs = limit(xs, vc->vc_cols - 1);
 	  ys = limit(ys, vc->vc_rows - 1);
diff --git a/drivers/tty/vt/vc_screen.c b/drivers/tty/vt/vc_screen.c
index 7a367ff..938d584 100644
--- a/drivers/tty/vt/vc_screen.c
+++ b/drivers/tty/vt/vc_screen.c
@@ -139,7 +139,7 @@ vcs_vc(struct inode *inode, int *viewed)
 {
 	unsigned int currcons = iminor(inode) & 127;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (currcons == 0) {
 		currcons = fg_console;
@@ -164,7 +164,7 @@ vcs_size(struct inode *inode)
 	int minor = iminor(inode);
 	struct vc_data *vc;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	vc = vcs_vc(inode, NULL);
 	if (!vc)
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index e716839..db83bd7 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -390,7 +390,7 @@ static void do_update_region(struct vc_data *vc, unsigned long start, int count)
 
 void update_region(struct vc_data *vc, unsigned long start, int count)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (DO_UPDATE(vc)) {
 		hide_cursor(vc);
@@ -461,7 +461,7 @@ void invert_screen(struct vc_data *vc, int offset, int count, int viewed)
 {
 	unsigned short *p;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	count /= 2;
 	p = screenpos(vc, offset, viewed);
@@ -508,7 +508,7 @@ void complement_pos(struct vc_data *vc, int offset)
 	static unsigned short old;
 	static unsigned short oldx, oldy;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (old_offset != -1 && old_offset >= 0 &&
 	    old_offset < vc->vc_screenbuf_size) {
@@ -634,7 +634,7 @@ static void set_cursor(struct vc_data *vc)
 
 static void set_origin(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!CON_IS_VISIBLE(vc) ||
 	    !vc->vc_sw->con_set_origin ||
@@ -647,7 +647,7 @@ static void set_origin(struct vc_data *vc)
 
 static inline void save_screen(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc->vc_sw->con_save_screen)
 		vc->vc_sw->con_save_screen(vc);
@@ -672,7 +672,7 @@ void redraw_screen(struct vc_data *vc, int is_switch)
 {
 	int redraw = 0;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!vc) {
 		/* strange ... */
@@ -769,7 +769,7 @@ static void visual_init(struct vc_data *vc, int num, int init)
 
 int vc_allocate(unsigned int currcons)	/* return 0 on success */
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (currcons >= MAX_NR_CONSOLES)
 		return -ENXIO;
@@ -861,7 +861,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 	unsigned int user;
 	unsigned short *newscreen;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!vc)
 		return -ENXIO;
@@ -951,7 +951,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 		/* Rewrite the requested winsize data with the actual
 		   resulting sizes */
 		struct winsize ws;
-		memset(&ws, 0, sizeof(ws));
+		(void)memset(&ws, 0, sizeof(ws));
 		ws.ws_row = vc->vc_rows;
 		ws.ws_col = vc->vc_cols;
 		ws.ws_ypixel = vc->vc_scan_lines;
@@ -1006,7 +1006,7 @@ static int vt_resize(struct tty_struct *tty, struct winsize *ws)
 
 void vc_deallocate(unsigned int currcons)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc_cons_allocated(currcons)) {
 		struct vc_data *vc = vc_cons[currcons].d;
@@ -2984,7 +2984,7 @@ int __init vty_init(const struct file_operations *console_fops)
 	if (IS_ERR(tty0dev))
 		tty0dev = NULL;
 	else
-		WARN_ON(device_create_file(tty0dev, &dev_attr_active) < 0);
+		(void)WARN_ON(device_create_file(tty0dev, &dev_attr_active) < 0);
 
 	vcs_init();
 
@@ -3725,7 +3725,7 @@ void do_blank_screen(int entering_gfx)
 	struct vc_data *vc = vc_cons[fg_console].d;
 	int i;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (console_blanked) {
 		if (blank_state == blank_vesa_wait) {
@@ -3792,7 +3792,7 @@ void do_unblank_screen(int leaving_gfx)
 	if (!oops_in_progress)
 		might_sleep();
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	ignore_poke = 0;
 	if (!console_blanked)
@@ -3853,7 +3853,7 @@ static void blank_screen_t(unsigned long dummy)
 
 void poke_blanked_console(void)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	/* Add this so we quickly catch whoever might call us in a non
 	 * safe context. Nowadays, unblank_screen() isn't to be called in
@@ -3885,7 +3885,7 @@ void poke_blanked_console(void)
 
 static void set_palette(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc->vc_mode != KD_GRAPHICS)
 		vc->vc_sw->con_set_palette(vc, color_table);
@@ -3895,17 +3895,17 @@ static int set_get_cmap(unsigned char __user *arg, int set)
 {
     int i, j, k;
 
-    WARN_CONSOLE_UNLOCKED();
+    (void)WARN_CONSOLE_UNLOCKED();
 
     for (i = 0; i < 16; i++)
 	if (set) {
-	    get_user(default_red[i], arg++);
-	    get_user(default_grn[i], arg++);
-	    get_user(default_blu[i], arg++);
+	    (void)get_user(default_red[i], arg++);
+	    (void)get_user(default_grn[i], arg++);
+	    (void)get_user(default_blu[i], arg++);
 	} else {
-	    put_user(default_red[i], arg++);
-	    put_user(default_grn[i], arg++);
-	    put_user(default_blu[i], arg++);
+	    (void)put_user(default_red[i], arg++);
+	    (void)put_user(default_grn[i], arg++);
+	    (void)put_user(default_blu[i], arg++);
 	}
     if (set) {
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
diff --git a/drivers/tty/vt/vt_ioctl.c b/drivers/tty/vt/vt_ioctl.c
index 5e096f4..f9f7d1c 100644
--- a/drivers/tty/vt/vt_ioctl.c
+++ b/drivers/tty/vt/vt_ioctl.c
@@ -1166,12 +1166,12 @@ int vt_ioctl(struct tty_struct *tty,
 			break;
 		}
 		/* FIXME: Should check the copies properly */
-		__get_user(ll, &vtconsize->v_rows);
-		__get_user(cc, &vtconsize->v_cols);
-		__get_user(vlin, &vtconsize->v_vlin);
-		__get_user(clin, &vtconsize->v_clin);
-		__get_user(vcol, &vtconsize->v_vcol);
-		__get_user(ccol, &vtconsize->v_ccol);
+		(void)__get_user(ll, &vtconsize->v_rows);
+		(void)__get_user(cc, &vtconsize->v_cols);
+		(void)__get_user(vlin, &vtconsize->v_vlin);
+		(void)__get_user(clin, &vtconsize->v_clin);
+		(void)__get_user(vcol, &vtconsize->v_vcol);
+		(void)__get_user(ccol, &vtconsize->v_ccol);
 		vlin = vlin ? vlin : vc->vc_scan_lines;
 		if (clin) {
 			if (ll) {
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index 9543b19..346a9dc 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -229,7 +229,7 @@ static int acm_write_start(struct acm *acm, int wbn)
 		return -ENODEV;
 	}
 
-	dev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,
+	(void)dev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,
 							acm->susp_count);
 	usb_autopm_get_interface_async(acm->control);
 	if (acm->susp_count) {
@@ -378,7 +378,7 @@ static int acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)
 	if (!test_and_clear_bit(index, &acm->read_urbs_free))
 		return 0;
 
-	dev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);
+	(void)dev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);
 
 	res = usb_submit_urb(acm->read_urbs[index], mem_flags);
 	if (res) {
@@ -431,7 +431,7 @@ static void acm_read_bulk_callback(struct urb *urb)
 	struct acm *acm = rb->instance;
 	unsigned long flags;
 
-	dev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,
+	(void)dev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,
 					rb->index, urb->actual_length);
 	set_bit(rb->index, &acm->read_urbs_free);
 
@@ -467,7 +467,7 @@ static void acm_write_bulk(struct urb *urb)
 	unsigned long flags;
 
 	if (urb->status	|| (urb->actual_length != urb->transfer_buffer_length))
-		dev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",
+		(void)dev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",
 			__func__,
 			urb->actual_length,
 			urb->transfer_buffer_length,
@@ -484,7 +484,7 @@ static void acm_softint(struct work_struct *work)
 	struct acm *acm = container_of(work, struct acm, work);
 	struct tty_struct *tty;
 
-	dev_vdbg(&acm->data->dev, "%s\n", __func__);
+	(void)dev_vdbg(&acm->data->dev, "%s\n", __func__);
 
 	tty = tty_port_tty_get(&acm->port);
 	if (!tty)
@@ -659,7 +659,7 @@ static int acm_tty_write(struct tty_struct *tty,
 	if (!count)
 		return 0;
 
-	dev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);
+	(void)dev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);
 
 	spin_lock_irqsave(&acm->write_lock, flags);
 	wbn = acm_wb_alloc(acm);
@@ -670,7 +670,7 @@ static int acm_tty_write(struct tty_struct *tty,
 	wb = &acm->wb[wbn];
 
 	count = (count > acm->writesize) ? acm->writesize : count;
-	dev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);
+	(void)dev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);
 	memcpy(wb->buf, buf, count);
 	wb->len = count;
 	spin_unlock_irqrestore(&acm->write_lock, flags);
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 8df4b76..78c3ba8 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1279,7 +1279,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		 * that the gaps don't leak kernel data to userspace.
 		 */
 		if (is_in && uurb->type == USBDEVFS_URB_TYPE_ISO)
-			memset(as->urb->transfer_buffer, 0,
+			(void)memset(as->urb->transfer_buffer, 0,
 					uurb->buffer_length);
 	}
 	as->urb->dev = ps->dev;
@@ -1706,7 +1706,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 				return -EFAULT;
 			}
 		} else {
-			memset(buf, 0, size);
+			(void)memset(buf, 0, size);
 		}
 	}
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index d40ff95..a1cf7fc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1032,7 +1032,7 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver->suspend(udev, msg);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1064,7 +1064,7 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver->resume(udev, msg);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1085,7 +1085,7 @@ static int usb_suspend_interface(struct usb_device *udev,
 		dev_err(&intf->dev, "suspend error %d\n", status);
 
  done:
-	dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1137,7 +1137,7 @@ static int usb_resume_interface(struct usb_device *udev,
 	}
 
 done:
-	dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&intf->dev, "%s: status %d\n", __func__, status);
 
 	/* Later we will unbind the driver and/or reprobe, if necessary */
 	return status;
@@ -1215,7 +1215,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	}
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	return status;
 }
 
@@ -1264,7 +1264,7 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	usb_mark_last_busy(udev);
 
  done:
-	dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
+	(void)dev_vdbg(&udev->dev, "%s: status %d\n", __func__, status);
 	if (!status)
 		udev->reset_resume = 0;
 	return status;
@@ -1398,7 +1398,7 @@ void usb_autosuspend_device(struct usb_device *udev)
 
 	usb_mark_last_busy(udev);
 	status = pm_runtime_put_sync_autosuspend(&udev->dev);
-	dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&udev->dev.power.usage_count),
 			status);
 }
@@ -1428,7 +1428,7 @@ int usb_autoresume_device(struct usb_device *udev)
 	status = pm_runtime_get_sync(&udev->dev);
 	if (status < 0)
 		pm_runtime_put_sync(&udev->dev);
-	dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&udev->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&udev->dev.power.usage_count),
 			status);
 	if (status > 0)
@@ -1459,7 +1459,7 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	usb_mark_last_busy(udev);
 	atomic_dec(&intf->pm_usage_cnt);
 	status = pm_runtime_put_sync(&intf->dev);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 }
@@ -1488,7 +1488,7 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 	usb_mark_last_busy(udev);
 	atomic_dec(&intf->pm_usage_cnt);
 	status = pm_runtime_put(&intf->dev);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 }
@@ -1539,7 +1539,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 		pm_runtime_put_sync(&intf->dev);
 	else
 		atomic_inc(&intf->pm_usage_cnt);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 	if (status > 0)
@@ -1572,7 +1572,7 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 		pm_runtime_put_noidle(&intf->dev);
 	else
 		atomic_inc(&intf->pm_usage_cnt);
-	dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
+	(void)dev_vdbg(&intf->dev, "%s: cnt %d -> %d\n",
 			__func__, atomic_read(&intf->dev.power.usage_count),
 			status);
 	if (status > 0 || status == -EINPROGRESS)
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index eb19cba..14131a2 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -886,7 +886,7 @@ static struct attribute_group usb_bus_attr_group = {
  */
 static void usb_bus_init (struct usb_bus *bus)
 {
-	memset (&bus->devmap, 0, sizeof(struct usb_devmap));
+	(void)memset (&bus->devmap, 0, sizeof(struct usb_devmap));
 
 	bus->devnum_next = 1;
 
@@ -982,7 +982,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 
 	usb_dev->devnum = devnum;
 	usb_dev->bus->devnum_next = devnum + 1;
-	memset (&usb_dev->bus->devmap.devicemap, 0,
+	(void)memset (&usb_dev->bus->devmap.devicemap, 0,
 			sizeof usb_dev->bus->devmap.devicemap);
 	set_bit (devnum, usb_dev->bus->devmap.devicemap);
 	usb_set_device_state(usb_dev, USB_STATE_ADDRESS);
@@ -1231,7 +1231,7 @@ static int hcd_alloc_coherent(struct usb_bus *bus,
 	unsigned char *vaddr;
 
 	if (*vaddr_handle == NULL) {
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return -EFAULT;
 	}
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a0613d8..065bc7f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3693,7 +3693,7 @@ static int hub_thread(void *__unused)
 
 	do {
 		hub_events();
-		wait_event_freezable(khubd_wait,
+		(void)wait_event_freezable(khubd_wait,
 				!list_empty(&hub_event_list) ||
 				kthread_should_stop());
 	} while (!kthread_should_stop() || !list_empty(&hub_event_list));
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 909625b..542575a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -38,7 +38,7 @@ static void urb_destroy(struct kref *kref)
 void usb_init_urb(struct urb *urb)
 {
 	if (urb) {
-		memset(urb, 0, sizeof(*urb));
+		(void)memset(urb, 0, sizeof(*urb));
 		kref_init(&urb->kref);
 		INIT_LIST_HEAD(&urb->anchor_list);
 	}
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a007a9f..d6ab797 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1217,7 +1217,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (qh) {
 		usb_settoggle(qh->dev, epnum, is_out, 0);
 		if (!list_empty(&qh->qtd_list)) {
-			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
+			(void)WARN_ONCE(1, "clear_halt for a busy endpoint\n");
 		} else if (qh->qh_state == QH_STATE_LINKED ||
 				qh->qh_state == QH_STATE_COMPLETING) {
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 77bbb23..447dd42 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -640,8 +640,8 @@ ehci_hub_descriptor (
 	desc->bDescLength = 7 + 2 * temp;
 
 	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
-	memset(&desc->u.hs.DeviceRemovable[0], 0, temp);
-	memset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);
+	(void)memset(&desc->u.hs.DeviceRemovable[0], 0, temp);
+	(void)memset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);
 
 	temp = 0x0008;			/* per-port overcurrent reporting */
 	if (HCS_PPC (ehci->hcs_params))
@@ -787,7 +787,7 @@ static int ehci_hub_control (
 		break;
 	case GetHubStatus:
 		/* no hub-wide feature/status flags */
-		memset (buf, 0, 4);
+		(void)memset (buf, 0, 4);
 		//cpu_to_le32s ((u32 *) buf);
 		break;
 	case GetPortStatus:
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 12f70c3..49e96cf 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -38,7 +38,7 @@
 static inline void ehci_qtd_init(struct ehci_hcd *ehci, struct ehci_qtd *qtd,
 				  dma_addr_t dma)
 {
-	memset (qtd, 0, sizeof *qtd);
+	(void)memset (qtd, 0, sizeof *qtd);
 	qtd->qtd_dma = dma;
 	qtd->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	qtd->hw_next = EHCI_LIST_END(ehci);
@@ -91,7 +91,7 @@ static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
 		dma_pool_alloc(ehci->qh_pool, flags, &dma);
 	if (!qh->hw)
 		goto fail;
-	memset(qh->hw, 0, sizeof *qh->hw);
+	(void)memset(qh->hw, 0, sizeof *qh->hw);
 	qh->refcount = 1;
 	qh->ehci = ehci;
 	qh->qh_dma = dma;
@@ -116,7 +116,7 @@ fail:
 /* to share a qh (cpu threads, or hc) */
 static inline struct ehci_qh *qh_get (struct ehci_qh *qh)
 {
-	WARN_ON(!qh->refcount);
+	(void)WARN_ON(!qh->refcount);
 	qh->refcount++;
 	return qh;
 }
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 36ca507..a025f80 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -975,7 +975,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (unlikely(qh->clearing_tt))
 		return;
 
-	WARN_ON(qh->qh_state != QH_STATE_IDLE);
+	(void)WARN_ON(qh->qh_state != QH_STATE_IDLE);
 
 	/* (re)start the async schedule? */
 	head = ehci->async;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a60679c..339cf63 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1278,7 +1278,7 @@ itd_urb_transaction (
 			}
 		}
 
-		memset (itd, 0, sizeof *itd);
+		(void)memset (itd, 0, sizeof *itd);
 		itd->itd_dma = itd_dma;
 		list_add (&itd->itd_list, &sched->td_list);
 	}
@@ -1977,7 +1977,7 @@ sitd_urb_transaction (
 			}
 		}
 
-		memset (sitd, 0, sizeof *sitd);
+		(void)memset (sitd, 0, sizeof *sitd);
 		sitd->sitd_dma = sitd_dma;
 		list_add (&sitd->sitd_list, &iso_sched->td_list);
 	}
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 0a5fda7..843b058 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -193,7 +193,7 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 static inline void
 iaa_watchdog_start(struct ehci_hcd *ehci)
 {
-	WARN_ON(timer_pending(&ehci->iaa_watchdog));
+	(void)WARN_ON(timer_pending(&ehci->iaa_watchdog));
 	mod_timer(&ehci->iaa_watchdog,
 			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
 }
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
index b276f8f..43f5ce8 100644
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -1313,7 +1313,7 @@ static ssize_t msm_otg_mode_write(struct file *file, const char __user *ubuf,
 	int status = count;
 	enum usb_mode_type req_mode;
 
-	memset(buf, 0x00, sizeof(buf));
+	(void)memset(buf, 0x00, sizeof(buf));
 
 	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count))) {
 		status = -EFAULT;
diff --git a/drivers/usb/storage/alauda.c b/drivers/usb/storage/alauda.c
index 51af2fe..7e7ce87 100644
--- a/drivers/usb/storage/alauda.c
+++ b/drivers/usb/storage/alauda.c
@@ -373,7 +373,7 @@ static int alauda_reset_media(struct us_data *us)
 {
 	unsigned char *command = us->iobuf;
 
-	memset(command, 0, 9);
+	(void)memset(command, 0, 9);
 	command[0] = ALAUDA_BULK_CMD;
 	command[1] = ALAUDA_BULK_RESET_MEDIA;
 	command[8] = MEDIA_PORT(us);
@@ -853,7 +853,7 @@ static int alauda_write_lba(struct us_data *us, u16 lba,
 		if (result != USB_STOR_XFER_GOOD)
 			return result;
 	} else {
-		memset(blockbuffer, 0, blocksize * (pagesize + 64));
+		(void)memset(blockbuffer, 0, blocksize * (pagesize + 64));
 	}
 
 	lbap = (lba_offset << 1) | 0x1000;
@@ -986,7 +986,7 @@ static int alauda_read_data(struct us_data *us, unsigned long address,
 			   Instead of returning USB_STOR_TRANSPORT_ERROR
 			   it is better to return all zero data. */
 
-			memset(buffer, 0, len);
+			(void)memset(buffer, 0, len);
 		} else {
 			US_DEBUGP("Read %d pages, from PBA %d"
 				  " (LBA %d) page %d\n",
@@ -1220,7 +1220,7 @@ static int alauda_transport(struct scsi_cmnd *srb, struct us_data *us)
 	if (srb->cmnd[0] == REQUEST_SENSE) {
 		US_DEBUGP("alauda_transport: REQUEST_SENSE.\n");
 
-		memset(ptr, 0, 18);
+		(void)memset(ptr, 0, 18);
 		ptr[0] = 0xF0;
 		ptr[2] = info->sense_key;
 		ptr[7] = 11;
diff --git a/drivers/usb/storage/cypress_atacb.c b/drivers/usb/storage/cypress_atacb.c
index 387cbd47..b70f935 100644
--- a/drivers/usb/storage/cypress_atacb.c
+++ b/drivers/usb/storage/cypress_atacb.c
@@ -90,7 +90,7 @@ static void cypress_atacb_passthrough(struct scsi_cmnd *srb, struct us_data *us)
 	}
 
 	memcpy(save_cmnd, srb->cmnd, sizeof(save_cmnd));
-	memset(srb->cmnd, 0, MAX_COMMAND_SIZE);
+	(void)memset(srb->cmnd, 0, MAX_COMMAND_SIZE);
 
 	/* check if we support the command */
 	if (save_cmnd[1] >> 5) /* MULTIPLE_COUNT */
@@ -196,7 +196,7 @@ static void cypress_atacb_passthrough(struct scsi_cmnd *srb, struct us_data *us)
 			goto invalid_fld;
 
 		/* build the sense */
-		memset(sb, 0, SCSI_SENSE_BUFFERSIZE);
+		(void)memset(sb, 0, SCSI_SENSE_BUFFERSIZE);
 
 		/* set sk, asc for a good command */
 		sb[1] = RECOVERED_ERROR;
diff --git a/drivers/usb/storage/datafab.c b/drivers/usb/storage/datafab.c
index 15d41f2..f19f7f3 100644
--- a/drivers/usb/storage/datafab.c
+++ b/drivers/usb/storage/datafab.c
@@ -487,7 +487,7 @@ static int datafab_handle_mode_sense(struct us_data *us,
 		break;
 	}
 
-	memset(ptr, 0, 8);
+	(void)memset(ptr, 0, 8);
 	if (sense_6) {
 		ptr[2] = 0x00;		// WP enable: 0x80
 		i = 4;
@@ -667,7 +667,7 @@ static int datafab_transport(struct scsi_cmnd *srb, struct us_data *us)
 		// we can set the correct sense data.  so far though it hasn't been
 		// necessary
 		//
-		memset(ptr, 0, 18);
+		(void)memset(ptr, 0, 18);
 		ptr[0] = 0xF0;
 		ptr[2] = info->sense_key;
 		ptr[7] = 11;
diff --git a/drivers/usb/storage/freecom.c b/drivers/usb/storage/freecom.c
index fa16157..eda3b56 100644
--- a/drivers/usb/storage/freecom.c
+++ b/drivers/usb/storage/freecom.c
@@ -159,7 +159,7 @@ freecom_readdata (struct scsi_cmnd *srb, struct us_data *us,
 	fxfr->Type = FCM_PACKET_INPUT | 0x00;
 	fxfr->Timeout = 0;    /* Short timeout for debugging. */
 	fxfr->Count = cpu_to_le32 (count);
-	memset (fxfr->Pad, 0, sizeof (fxfr->Pad));
+	(void)memset (fxfr->Pad, 0, sizeof (fxfr->Pad));
 
 	US_DEBUGP("Read data Freecom! (c=%d)\n", count);
 
@@ -192,7 +192,7 @@ freecom_writedata (struct scsi_cmnd *srb, struct us_data *us,
 	fxfr->Type = FCM_PACKET_OUTPUT | 0x00;
 	fxfr->Timeout = 0;    /* Short timeout for debugging. */
 	fxfr->Count = cpu_to_le32 (count);
-	memset (fxfr->Pad, 0, sizeof (fxfr->Pad));
+	(void)memset (fxfr->Pad, 0, sizeof (fxfr->Pad));
 
 	US_DEBUGP("Write data Freecom! (c=%d)\n", count);
 
@@ -240,7 +240,7 @@ static int freecom_transport(struct scsi_cmnd *srb, struct us_data *us)
 	fcb->Type = FCM_PACKET_ATAPI | 0x00;
 	fcb->Timeout = 0;
 	memcpy (fcb->Atapi, srb->cmnd, 12);
-	memset (fcb->Filler, 0, sizeof (fcb->Filler));
+	(void)memset (fcb->Filler, 0, sizeof (fcb->Filler));
 
 	US_DEBUG(pdump (srb->cmnd, 12));
 
@@ -281,8 +281,8 @@ static int freecom_transport(struct scsi_cmnd *srb, struct us_data *us)
 		/* Get the status again */
 		fcb->Type = FCM_PACKET_STATUS;
 		fcb->Timeout = 0;
-		memset (fcb->Atapi, 0, sizeof(fcb->Atapi));
-		memset (fcb->Filler, 0, sizeof (fcb->Filler));
+		(void)memset (fcb->Atapi, 0, sizeof(fcb->Atapi));
+		(void)memset (fcb->Filler, 0, sizeof (fcb->Filler));
 
 		/* Send it out. */
 		result = usb_stor_bulk_transfer_buf (us, opipe, fcb,
diff --git a/drivers/usb/storage/initializers.c b/drivers/usb/storage/initializers.c
index 105d900..4dc579b 100644
--- a/drivers/usb/storage/initializers.c
+++ b/drivers/usb/storage/initializers.c
@@ -75,7 +75,7 @@ int usb_stor_ucr61s2b_init(struct us_data *us)
 	bcb->DataTransferLength = cpu_to_le32(0);
 	bcb->Flags = bcb->Lun = 0;
 	bcb->Length = sizeof(init_string) - 1;
-	memset(bcb->CDB, 0, sizeof(bcb->CDB));
+	(void)memset(bcb->CDB, 0, sizeof(bcb->CDB));
 	memcpy(bcb->CDB, init_string, sizeof(init_string) - 1);
 
 	res = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe, bcb,
diff --git a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c
index bd55027..7efdc66 100644
--- a/drivers/usb/storage/isd200.c
+++ b/drivers/usb/storage/isd200.c
@@ -496,7 +496,7 @@ static int isd200_action( struct us_data *us, int action,
 	struct scsi_cmnd *srb = &info->srb;
 	int status;
 
-	memset(&ata, 0, sizeof(ata));
+	(void)memset(&ata, 0, sizeof(ata));
 	srb->cmnd = info->cmnd;
 	srb->device = &srb_dev;
 
@@ -1141,7 +1141,7 @@ static int isd200_get_inquiry_data( struct us_data *us )
 				isd200_fix_driveid(id);
 				isd200_dump_driveid(id);
 
-				memset(&info->InquiryData, 0, sizeof(info->InquiryData));
+				(void)memset(&info->InquiryData, 0, sizeof(info->InquiryData));
 
 				/* Standard IDE interface only supports disks */
 				info->InquiryData.DeviceType = DIRECT_ACCESS_DEVICE;
@@ -1229,7 +1229,7 @@ static int isd200_scsi_to_ata(struct scsi_cmnd *srb, struct us_data *us,
 	unsigned long blockCount;
 	unsigned char senseData[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
-	memset(ataCdb, 0, sizeof(union ata_cdb));
+	(void)memset(ataCdb, 0, sizeof(union ata_cdb));
 
 	/* SCSI Command */
 	switch (srb->cmnd[0]) {
diff --git a/drivers/usb/storage/jumpshot.c b/drivers/usb/storage/jumpshot.c
index a19211b..fedef43 100644
--- a/drivers/usb/storage/jumpshot.c
+++ b/drivers/usb/storage/jumpshot.c
@@ -413,7 +413,7 @@ static int jumpshot_handle_mode_sense(struct us_data *us,
 		break;
 	}
 
-	memset(ptr, 0, 8);
+	(void)memset(ptr, 0, 8);
 	if (sense_6) {
 		ptr[2] = 0x00;		// WP enable: 0x80
 		i = 4;
@@ -593,7 +593,7 @@ static int jumpshot_transport(struct scsi_cmnd *srb, struct us_data *us)
 	if (srb->cmnd[0] == REQUEST_SENSE) {
 		US_DEBUGP("jumpshot_transport:  REQUEST_SENSE.\n");
 
-		memset(ptr, 0, 18);
+		(void)memset(ptr, 0, 18);
 		ptr[0] = 0xF0;
 		ptr[2] = info->sense_key;
 		ptr[7] = 11;
diff --git a/drivers/usb/storage/karma.c b/drivers/usb/storage/karma.c
index e720f8e..c171008 100644
--- a/drivers/usb/storage/karma.c
+++ b/drivers/usb/storage/karma.c
@@ -107,7 +107,7 @@ static int rio_karma_send_command(char cmd, struct us_data *us)
 	struct karma_data *data = (struct karma_data *) us->extra;
 
 	US_DEBUGP("karma: sending command %04x\n", cmd);
-	memset(us->iobuf, 0, RIO_SEND_LEN);
+	(void)memset(us->iobuf, 0, RIO_SEND_LEN);
 	memcpy(us->iobuf, RIO_PREFIX, RIO_PREFIX_LEN);
 	us->iobuf[5] = cmd;
 	us->iobuf[6] = seq;
diff --git a/drivers/usb/storage/sddr09.c b/drivers/usb/storage/sddr09.c
index 425df7d..d994dd3 100644
--- a/drivers/usb/storage/sddr09.c
+++ b/drivers/usb/storage/sddr09.c
@@ -363,7 +363,7 @@ sddr09_request_sense(struct us_data *us, unsigned char *sensebuf, int buflen) {
 	unsigned char *command = us->iobuf;
 	int result;
 
-	memset(command, 0, 12);
+	(void)memset(command, 0, 12);
 	command[0] = 0x03;
 	command[1] = LUNBITS;
 	command[4] = buflen;
@@ -540,7 +540,7 @@ sddr09_erase(struct us_data *us, unsigned long Eaddress) {
 
 	US_DEBUGP("sddr09_erase: erase address %lu\n", Eaddress);
 
-	memset(command, 0, 12);
+	(void)memset(command, 0, 12);
 	command[0] = 0xEA;
 	command[1] = LUNBITS;
 	command[6] = MSB_of(Eaddress>>16);
@@ -729,7 +729,7 @@ sddr09_read_status(struct us_data *us, unsigned char *status) {
 
 	US_DEBUGP("Reading status...\n");
 
-	memset(command, 0, 12);
+	(void)memset(command, 0, 12);
 	command[0] = 0xEC;
 	command[1] = LUNBITS;
 
@@ -808,7 +808,7 @@ sddr09_read_data(struct us_data *us,
 			   Instead of returning an error
 			   it is better to return all zero data. */
 
-			memset(buffer, 0, len);
+			(void)memset(buffer, 0, len);
 
 		} else {
 			US_DEBUGP("Read %d pages, from PBA %d"
@@ -1087,7 +1087,7 @@ sddr09_read_deviceID(struct us_data *us, unsigned char *deviceID) {
 	unsigned char *content = us->iobuf;
 	int result, i;
 
-	memset(command, 0, 12);
+	(void)memset(command, 0, 12);
 	command[0] = 0xED;
 	command[1] = LUNBITS;
 
@@ -1571,7 +1571,7 @@ static int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us)
 
 	if (srb->cmnd[0] == REQUEST_SENSE && havefakesense) {
 		/* for a faked command, we have to follow with a faked sense */
-		memset(ptr, 0, 18);
+		(void)memset(ptr, 0, 18);
 		ptr[0] = 0x70;
 		ptr[2] = sensekey;
 		ptr[7] = 11;
diff --git a/drivers/usb/storage/sddr55.c b/drivers/usb/storage/sddr55.c
index e4ca5fc..dcb6493 100644
--- a/drivers/usb/storage/sddr55.c
+++ b/drivers/usb/storage/sddr55.c
@@ -139,7 +139,7 @@ static int sddr55_status(struct us_data *us)
 	struct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;
 
 	/* send command */
-	memset(command, 0, 8);
+	(void)memset(command, 0, 8);
 	command[5] = 0xB0;
 	command[7] = 0x80;
 	result = sddr55_bulk_transport(us,
@@ -242,7 +242,7 @@ static int sddr55_read_data(struct us_data *us,
 
 		if (pba == NOT_ALLOCATED) {
 			/* no pba for this lba, fill with zeroes */
-			memset (buffer, 0, len);
+			(void)memset (buffer, 0, len);
 		} else {
 
 			address = (pba << info->blockshift) + page;
@@ -526,7 +526,7 @@ static int sddr55_read_deviceID(struct us_data *us,
 	unsigned char *command = us->iobuf;
 	unsigned char *content = us->iobuf;
 
-	memset(command, 0, 8);
+	(void)memset(command, 0, 8);
 	command[5] = 0xB0;
 	command[7] = 0x84;
 	result = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);
@@ -666,7 +666,7 @@ static int sddr55_read_map(struct us_data *us) {
 	if (!buffer)
 		return -1;
 
-	memset(command, 0, 8);
+	(void)memset(command, 0, 8);
 	command[5] = 0xB0;
 	command[6] = numblocks * 2 / 256;
 	command[7] = 0x8A;
@@ -706,8 +706,8 @@ static int sddr55_read_map(struct us_data *us) {
 		return -1;
 	}
 
-	memset(info->lba_to_pba, 0xff, numblocks*sizeof(int));
-	memset(info->pba_to_lba, 0xff, numblocks*sizeof(int));
+	(void)memset(info->lba_to_pba, 0xff, numblocks*sizeof(int));
+	(void)memset(info->pba_to_lba, 0xff, numblocks*sizeof(int));
 
 	/* set maximum lba */
 	max_lba = info->max_log_blks;
@@ -814,12 +814,12 @@ static int sddr55_transport(struct scsi_cmnd *srb, struct us_data *us)
 		ptr[0] = 0x70;
 		ptr[7] = 11;
 		usb_stor_set_xfer_buf (ptr, sizeof info->sense_data, srb);
-		memset (info->sense_data, 0, sizeof info->sense_data);
+		(void)memset (info->sense_data, 0, sizeof info->sense_data);
 
 		return USB_STOR_TRANSPORT_GOOD;
 	}
 
-	memset (info->sense_data, 0, sizeof info->sense_data);
+	(void)memset (info->sense_data, 0, sizeof info->sense_data);
 
 	/* Dummy up a response for INQUIRY since SDDR55 doesn't
 	   respond to INQUIRY commands */
diff --git a/drivers/usb/storage/shuttle_usbat.c b/drivers/usb/storage/shuttle_usbat.c
index 1369d25..855a1ad 100644
--- a/drivers/usb/storage/shuttle_usbat.c
+++ b/drivers/usb/storage/shuttle_usbat.c
@@ -1792,7 +1792,7 @@ static int usbat_flash_transport(struct scsi_cmnd * srb, struct us_data *us)
 	if (srb->cmnd[0] == REQUEST_SENSE) {
 		US_DEBUGP("usbat_flash_transport: REQUEST_SENSE.\n");
 
-		memset(ptr, 0, 18);
+		(void)memset(ptr, 0, 18);
 		ptr[0] = 0xF0;
 		ptr[2] = info->sense_key;
 		ptr[7] = 11;
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 0e5c91c..0898ed6 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -1079,7 +1079,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	bcb->Length = srb->cmd_len;
 
 	/* copy the command payload */
-	memset(bcb->CDB, 0, sizeof(bcb->CDB));
+	(void)memset(bcb->CDB, 0, sizeof(bcb->CDB));
 	memcpy(bcb->CDB, srb->cmnd, bcb->Length);
 
 	/* send it to out endpoint */
@@ -1268,7 +1268,7 @@ static int usb_stor_reset_common(struct us_data *us,
 
 	/* Give the device some time to recover from the reset,
 	 * but don't delay disconnect processing. */
-	wait_event_interruptible_timeout(us->delay_wait,
+	(void)wait_event_interruptible_timeout(us->delay_wait,
 			test_bit(US_FLIDX_DISCONNECTING, &us->dflags),
 			HZ*6);
 	if (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {
@@ -1300,7 +1300,7 @@ int usb_stor_CB_reset(struct us_data *us)
 {
 	US_DEBUGP("%s called\n", __func__);
 
-	memset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);
+	(void)memset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);
 	us->iobuf[0] = SEND_DIAGNOSTIC;
 	us->iobuf[1] = 4;
 	return usb_stor_reset_common(us, US_CBI_ADSC, 
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 3dd7da9..8191fd4 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -232,7 +232,7 @@ void fill_inquiry_response(struct us_data *us, unsigned char *data,
 	if (data_len<36) // You lose.
 		return;
 
-	memset(data+8, ' ', 28);
+	(void)memset(data+8, ' ', 28);
 	if(data[0]&0x20) { /* USB device currently not connected. Return
 			      peripheral qualifier 001b ("...however, the
 			      physical device is not currently connected
@@ -911,7 +911,7 @@ int usb_stor_probe1(struct us_data **pus,
 	host->max_cmd_len = 16;
 	host->sg_tablesize = usb_stor_sg_tablesize(intf);
 	*pus = us = host_to_us(host);
-	memset(us, 0, sizeof(struct us_data));
+	(void)memset(us, 0, sizeof(struct us_data));
 	mutex_init(&(us->dev_mutex));
 	init_completion(&us->cmnd_ready);
 	init_completion(&(us->notify));
diff --git a/drivers/video/amba-clcd.c b/drivers/video/amba-clcd.c
index 0a2cce7..9863e32 100644
--- a/drivers/video/amba-clcd.c
+++ b/drivers/video/amba-clcd.c
@@ -137,7 +137,7 @@ clcdfb_set_bitfields(struct clcd_fb *fb, struct fb_var_screeninfo *var)
 	if (!(fb->panel->cntl & CNTL_LCDTFT))
 		caps &= ~CLCD_CAP_888;
 
-	memset(&var->transp, 0, sizeof(var->transp));
+	(void)memset(&var->transp, 0, sizeof(var->transp));
 
 	var->red.msb_right = 0;
 	var->green.msb_right = 0;
diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index bf5b1ec..6d5bc7c 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -59,7 +59,7 @@ static int fb_notifier_callback(struct notifier_block *self,
 
 static int backlight_register_fb(struct backlight_device *bd)
 {
-	memset(&bd->fb_notif, 0, sizeof(bd->fb_notif));
+	(void)memset(&bd->fb_notif, 0, sizeof(bd->fb_notif));
 	bd->fb_notif.notifier_call = fb_notifier_callback;
 
 	return fb_register_client(&bd->fb_notif);
@@ -311,7 +311,7 @@ struct backlight_device *backlight_device_register(const char *name,
 		memcpy(&new_bd->props, props,
 		       sizeof(struct backlight_properties));
 		if (props->type <= 0 || props->type >= BACKLIGHT_TYPE_MAX) {
-			WARN(1, "%s: invalid backlight type", name);
+			(void)WARN(1, "%s: invalid backlight type", name);
 			new_bd->props.type = BACKLIGHT_RAW;
 		}
 	} else {
diff --git a/drivers/video/backlight/generic_bl.c b/drivers/video/backlight/generic_bl.c
index 9ce6170..c62622b 100644
--- a/drivers/video/backlight/generic_bl.c
+++ b/drivers/video/backlight/generic_bl.c
@@ -90,7 +90,7 @@ static int genericbl_probe(struct platform_device *pdev)
 	if (machinfo->name)
 		name = machinfo->name;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
+	(void)memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = machinfo->max_intensity;
 	bd = backlight_device_register(name, &pdev->dev, NULL, &genericbl_ops,
diff --git a/drivers/video/backlight/lcd.c b/drivers/video/backlight/lcd.c
index 79c1b0d..68787c7 100644
--- a/drivers/video/backlight/lcd.c
+++ b/drivers/video/backlight/lcd.c
@@ -57,7 +57,7 @@ static int fb_notifier_callback(struct notifier_block *self,
 
 static int lcd_register_fb(struct lcd_device *ld)
 {
-	memset(&ld->fb_notif, 0, sizeof(ld->fb_notif));
+	(void)memset(&ld->fb_notif, 0, sizeof(ld->fb_notif));
 	ld->fb_notif.notifier_call = fb_notifier_callback;
 	return fb_register_client(&ld->fb_notif);
 }
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index 8745637..09664d9 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -2182,7 +2182,7 @@ static int fbcon_switch(struct vc_data *vc)
 			o->currcon = vc->vc_num;
 		}
 	}
-	memset(&var, 0, sizeof(struct fb_var_screeninfo));
+	(void)memset(&var, 0, sizeof(struct fb_var_screeninfo));
 	display_to_var(&var, p);
 	var.activate = FB_ACTIVATE_NOW;
 
@@ -2382,7 +2382,7 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 		j = vc->vc_font.height;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 32 - j);
+			(void)memset(data + j, 0, 32 - j);
 			data += 32;
 			fontdata += j;
 		}
@@ -2390,7 +2390,7 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 		j = vc->vc_font.height * 2;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 64 - j);
+			(void)memset(data + j, 0, 64 - j);
 			data += 64;
 			fontdata += j;
 		}
@@ -2402,14 +2402,14 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 				*data++ = fontdata[2];
 				fontdata += sizeof(u32);
 			}
-			memset(data, 0, 3 * (32 - j));
+			(void)memset(data, 0, 3 * (32 - j));
 			data += 3 * (32 - j);
 		}
 	} else {
 		j = vc->vc_font.height * 4;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 128 - j);
+			(void)memset(data + j, 0, 128 - j);
 			data += 128;
 			fontdata += j;
 		}
diff --git a/drivers/video/fbcmap.c b/drivers/video/fbcmap.c
index 5c3960d..df84bcd 100644
--- a/drivers/video/fbcmap.c
+++ b/drivers/video/fbcmap.c
@@ -268,7 +268,7 @@ int fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *info)
 	if (size < 0 || size < cmap->len)
 		return -E2BIG;
 
-	memset(&umap, 0, sizeof(struct fb_cmap));
+	(void)memset(&umap, 0, sizeof(struct fb_cmap));
 	rc = fb_alloc_cmap_gfp(&umap, cmap->len, cmap->transp != NULL,
 				GFP_KERNEL);
 	if (rc)
diff --git a/drivers/video/fbcvt.c b/drivers/video/fbcvt.c
index 7cb715d..614d1a4 100644
--- a/drivers/video/fbcvt.c
+++ b/drivers/video/fbcvt.c
@@ -306,7 +306,7 @@ int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
 {
 	struct fb_cvt_data cvt;
 
-	memset(&cvt, 0, sizeof(cvt));
+	(void)memset(&cvt, 0, sizeof(cvt));
 
 	if (margins)
 	    cvt.flags |= FB_CVT_FLAG_MARGINS;
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index ac9141b..e67a5a6 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -917,8 +917,8 @@ static int fb_check_caps(struct fb_info *info, struct fb_var_screeninfo *var,
 	struct fb_blit_caps caps, fbcaps;
 	int err = 0;
 
-	memset(&caps, 0, sizeof(caps));
-	memset(&fbcaps, 0, sizeof(fbcaps));
+	(void)memset(&caps, 0, sizeof(caps));
+	(void)memset(&fbcaps, 0, sizeof(fbcaps));
 	caps.flags = (activate & FB_ACTIVATE_ALL) ? 1 : 0;
 	event.info = info;
 	event.data = &caps;
diff --git a/drivers/video/fbsysfs.c b/drivers/video/fbsysfs.c
index 67afa9c..f66f84c 100644
--- a/drivers/video/fbsysfs.c
+++ b/drivers/video/fbsysfs.c
@@ -134,7 +134,7 @@ static ssize_t store_mode(struct device *device, struct device_attribute *attr,
 	size_t i;
 	int err;
 
-	memset(&var, 0, sizeof(var));
+	(void)memset(&var, 0, sizeof(var));
 
 	list_for_each(pos, &fb_info->modelist) {
 		modelist = list_entry(pos, struct fb_modelist, list);
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index a9a907c..965b38b 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -663,7 +663,7 @@ done:
 				(margins) ? " with margins" : "",
 				(interlace) ? " interlaced" : "");
 
-			memset(&cvt_mode, 0, sizeof(cvt_mode));
+			(void)memset(&cvt_mode, 0, sizeof(cvt_mode));
 			cvt_mode.xres = xres;
 			cvt_mode.yres = yres;
 			cvt_mode.refresh = (refresh) ? refresh : 60;
@@ -1102,7 +1102,7 @@ const struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,
 	if (specs->max_x && specs->max_y) {
 		struct fb_var_screeninfo var;
 
-		memset(&var, 0, sizeof(struct fb_var_screeninfo));
+		(void)memset(&var, 0, sizeof(struct fb_var_screeninfo));
 		var.xres = (specs->max_x * 7200)/254;
 		var.yres = (specs->max_y * 7200)/254;
 		m = fb_find_best_mode(&var, head);
diff --git a/fs/aio.c b/fs/aio.c
index 969beb0..eec0a67 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1171,7 +1171,7 @@ static int read_events(struct kioctx *ctx,
 	/* needed to zero any padding within an entry (there shouldn't be 
 	 * any, but C is fun!
 	 */
-	memset(&ent, 0, sizeof(ent));
+	(void)memset(&ent, 0, sizeof(ent));
 retry:
 	ret = 0;
 	while (likely(i < nr)) {
@@ -1832,7 +1832,7 @@ SYSCALL_DEFINE3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb,
 	if (NULL != cancel) {
 		struct io_event tmp;
 		pr_debug("calling cancel\n");
-		memset(&tmp, 0, sizeof(tmp));
+		(void)memset(&tmp, 0, sizeof(tmp));
 		tmp.obj = (u64)(unsigned long)kiocb->ki_obj.user;
 		tmp.data = kiocb->ki_user_data;
 		ret = cancel(kiocb, &tmp);
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index bcb884e..2361046 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -247,7 +247,7 @@ create_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,
 	}
 #undef NEW_AUX_ENT
 	/* AT_NULL is zero; clear the rest too */
-	memset(&elf_info[ei_index], 0,
+	(void)memset(&elf_info[ei_index], 0,
 	       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);
 
 	/* And advance past the AT_NULL entry.  */
@@ -983,7 +983,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
 
-	start_thread(regs, elf_entry, bprm->p);
+	(void)start_thread(regs, elf_entry, bprm->p);
 	retval = 0;
 out:
 	kfree(loc);
@@ -1230,7 +1230,7 @@ static int writenote(struct memelfnote *men, struct file *file,
 static void fill_elf_header(struct elfhdr *elf, int segs,
 			    u16 machine, u32 flags, u8 osabi)
 {
-	memset(elf, 0, sizeof(*elf));
+	(void)memset(elf, 0, sizeof(*elf));
 
 	memcpy(elf->e_ident, ELFMAG, SELFMAG);
 	elf->e_ident[EI_CLASS] = ELF_CLASS;
@@ -1314,7 +1314,7 @@ static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,
 	unsigned int i, len;
 	
 	/* first copy the parameters from user space */
-	memset(psinfo, 0, sizeof(struct elf_prpsinfo));
+	(void)memset(psinfo, 0, sizeof(struct elf_prpsinfo));
 
 	len = mm->arg_end - mm->arg_start;
 	if (len >= ELF_PRARGSZ)
@@ -1484,7 +1484,7 @@ static int fill_note_info(struct elfhdr *elf, int phdrs,
 	 */
 	if (unlikely(info->thread_notes == 0) ||
 	    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
@@ -1582,7 +1582,7 @@ static void free_note_info(struct elf_note_info *info)
 		unsigned int i;
 		struct elf_thread_core_info *t = threads;
 		threads = t->next;
-		WARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);
+		(void)WARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);
 		for (i = 1; i < info->thread_notes; ++i)
 			kfree(t->notes[i].data);
 		kfree(t);
@@ -1853,7 +1853,7 @@ static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,
 	elf->e_shnum = 1;
 	elf->e_shstrndx = SHN_UNDEF;
 
-	memset(shdr4extnum, 0, sizeof(*shdr4extnum));
+	(void)memset(shdr4extnum, 0, sizeof(*shdr4extnum));
 
 	shdr4extnum->sh_type = SHT_NULL;
 	shdr4extnum->sh_size = elf->e_shnum;
diff --git a/fs/bio.c b/fs/bio.c
index b1fe82c..31a889a 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -137,7 +137,7 @@ static void bio_put_slab(struct bio_set *bs)
 	if (WARN(!bslab, KERN_ERR "bio: unable to find slab!\n"))
 		goto out;
 
-	WARN_ON(!bslab->slab_ref);
+	(void)WARN_ON(!bslab->slab_ref);
 
 	if (--bslab->slab_ref)
 		goto out;
@@ -253,7 +253,7 @@ EXPORT_SYMBOL(bio_free);
 
 void bio_init(struct bio *bio)
 {
-	memset(bio, 0, sizeof(*bio));
+	(void)memset(bio, 0, sizeof(*bio));
 	bio->bi_flags = 1 << BIO_UPTODATE;
 	atomic_set(&bio->bi_cnt, 1);
 }
@@ -395,7 +395,7 @@ void zero_fill_bio(struct bio *bio)
 
 	bio_for_each_segment(bv, bio, i) {
 		char *data = bvec_kmap_irq(bv, &flags);
-		memset(data, 0, bv->bv_len);
+		(void)memset(data, 0, bv->bv_len);
 		flush_dcache_page(bv->bv_page);
 		bvec_kunmap_irq(data, &flags);
 	}
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 0e575d1..7ba8418 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -461,7 +461,7 @@ static void init_once(void *foo)
 	struct bdev_inode *ei = (struct bdev_inode *) foo;
 	struct block_device *bdev = &ei->bdev;
 
-	memset(bdev, 0, sizeof(*bdev));
+	(void)memset(bdev, 0, sizeof(*bdev));
 	mutex_init(&bdev->bd_mutex);
 	INIT_LIST_HEAD(&bdev->bd_inodes);
 	INIT_LIST_HEAD(&bdev->bd_list);
@@ -890,7 +890,7 @@ int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)
 
 	mutex_lock(&bdev->bd_mutex);
 
-	WARN_ON_ONCE(!bdev->bd_holder);
+	(void)WARN_ON_ONCE(!bdev->bd_holder);
 
 	/* FIXME: remove the following once add_disk() handles errors */
 	if (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))
@@ -1274,7 +1274,7 @@ int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)
 	struct block_device *whole = NULL;
 	int res;
 
-	WARN_ON_ONCE((mode & FMODE_EXCL) && !holder);
+	(void)WARN_ON_ONCE((mode & FMODE_EXCL) && !holder);
 
 	if ((mode & FMODE_EXCL) && holder) {
 		whole = bd_start_claiming(bdev, holder);
@@ -1453,7 +1453,7 @@ static int __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)
 		bdev->bd_part_count--;
 
 	if (!--bdev->bd_openers) {
-		WARN_ON_ONCE(bdev->bd_holders);
+		(void)WARN_ON_ONCE(bdev->bd_holders);
 		sync_blockdev(bdev);
 		kill_bdev(bdev);
 		/* ->release can cause the old bdi to disappear,
@@ -1500,8 +1500,8 @@ int blkdev_put(struct block_device *bdev, fmode_t mode)
 		 */
 		spin_lock(&bdev_lock);
 
-		WARN_ON_ONCE(--bdev->bd_holders < 0);
-		WARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);
+		(void)WARN_ON_ONCE(--bdev->bd_holders < 0);
+		(void)WARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);
 
 		/* bd_contains might point to self, check in a separate step */
 		if ((bdev_free = !bdev->bd_holders))
diff --git a/fs/buffer.c b/fs/buffer.c
index 1a30db7..bfd2487 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -465,7 +465,7 @@ EXPORT_SYMBOL(mark_buffer_async_write);
 static void __remove_assoc_queue(struct buffer_head *bh)
 {
 	list_del_init(&bh->b_assoc_buffers);
-	WARN_ON(!bh->b_assoc_map);
+	(void)WARN_ON(!bh->b_assoc_map);
 	if (buffer_write_io_error(bh))
 		set_bit(AS_EIO, &bh->b_assoc_map->flags);
 	bh->b_assoc_map = NULL;
@@ -615,7 +615,7 @@ static void __set_page_dirty(struct page *page,
 {
 	spin_lock_irq(&mapping->tree_lock);
 	if (page->mapping) {	/* Race with truncate? */
-		WARN_ON_ONCE(warn && !PageUptodate(page));
+		(void)WARN_ON_ONCE(warn && !PageUptodate(page));
 		account_page_dirtied(page, mapping);
 		radix_tree_tag_set(&mapping->page_tree,
 				page_index(page), PAGECACHE_TAG_DIRTY);
@@ -1100,7 +1100,7 @@ __getblk_slow(struct block_device *bdev, sector_t block, int size)
  */
 void mark_buffer_dirty(struct buffer_head *bh)
 {
-	WARN_ON_ONCE(!buffer_uptodate(bh));
+	(void)WARN_ON_ONCE(!buffer_uptodate(bh));
 
 	/*
 	 * Very *carefully* optimize the it-is-already-dirty case.
@@ -1138,7 +1138,7 @@ void __brelse(struct buffer_head * buf)
 		put_bh(buf);
 		return;
 	}
-	WARN(1, KERN_ERR "VFS: brelse: Trying to free free buffer\n");
+	(void)WARN(1, KERN_ERR "VFS: brelse: Trying to free free buffer\n");
 }
 EXPORT_SYMBOL(__brelse);
 
@@ -1387,7 +1387,7 @@ static void invalidate_bh_lru(void *arg)
 	
 void invalidate_bh_lrus(void)
 {
-	on_each_cpu(invalidate_bh_lru, NULL, 1);
+	(void)on_each_cpu(invalidate_bh_lru, NULL, 1);
 }
 EXPORT_SYMBOL_GPL(invalidate_bh_lrus);
 
@@ -1623,7 +1623,7 @@ static int __block_write_full_page(struct inode *inode, struct page *page,
 			set_buffer_uptodate(bh);
 		} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&
 			   buffer_dirty(bh)) {
-			WARN_ON(bh->b_size != blocksize);
+			(void)WARN_ON(bh->b_size != blocksize);
 			err = get_block(inode, block, bh, 1);
 			if (err)
 				goto recover;
@@ -1815,7 +1815,7 @@ int __block_write_begin(struct page *page, loff_t pos, unsigned len,
 		if (buffer_new(bh))
 			clear_buffer_new(bh);
 		if (!buffer_mapped(bh)) {
-			WARN_ON(bh->b_size != blocksize);
+			(void)WARN_ON(bh->b_size != blocksize);
 			err = get_block(inode, block, bh, 1);
 			if (err)
 				break;
@@ -2081,7 +2081,7 @@ int block_read_full_page(struct page *page, get_block_t *get_block)
 
 			fully_mapped = 0;
 			if (iblock < lblock) {
-				WARN_ON(bh->b_size != blocksize);
+				(void)WARN_ON(bh->b_size != blocksize);
 				err = get_block(inode, iblock, bh, 0);
 				if (err)
 					SetPageError(page);
@@ -2744,7 +2744,7 @@ int block_truncate_page(struct address_space *mapping,
 
 	err = 0;
 	if (!buffer_mapped(bh)) {
-		WARN_ON(bh->b_size != blocksize);
+		(void)WARN_ON(bh->b_size != blocksize);
 		err = get_block(inode, iblock, bh, 0);
 		if (err)
 			goto unlock;
@@ -2982,7 +2982,7 @@ int __sync_dirty_buffer(struct buffer_head *bh, int rw)
 {
 	int ret = 0;
 
-	WARN_ON(atomic_read(&bh->b_count) < 1);
+	(void)WARN_ON(atomic_read(&bh->b_count) < 1);
 	lock_buffer(bh);
 	if (test_clear_buffer_dirty(bh)) {
 		get_bh(bh);
diff --git a/fs/char_dev.c b/fs/char_dev.c
index 3f152b9..c046775 100644
--- a/fs/char_dev.c
+++ b/fs/char_dev.c
@@ -541,7 +541,7 @@ struct cdev *cdev_alloc(void)
  */
 void cdev_init(struct cdev *cdev, const struct file_operations *fops)
 {
-	memset(cdev, 0, sizeof *cdev);
+	(void)memset(cdev, 0, sizeof *cdev);
 	INIT_LIST_HEAD(&cdev->list);
 	kobject_init(&cdev->kobj, &ktype_cdev_default);
 	cdev->ops = fops;
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
index 24b3dfc..9194412 100644
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -727,7 +727,7 @@ static ssize_t cifs_security_flags_proc_write(struct file *file,
 	if ((count < 1) || (count > 11))
 		return -EINVAL;
 
-	memset(flags_string, 0, 12);
+	(void)memset(flags_string, 0, 12);
 
 	if (copy_from_user(flags_string, buffer, count))
 		return -EFAULT;
diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c
index 63c460e..5cbed7f 100644
--- a/fs/cifs/cifsencrypt.c
+++ b/fs/cifs/cifsencrypt.c
@@ -127,7 +127,7 @@ int cifs_sign_smb2(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,
 
 	rc = cifs_calc_signature(iov, n_vec, server, smb_signature);
 	if (rc)
-		memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
+		(void)memset(cifs_pdu->Signature.SecuritySignature, 0, 8);
 	else
 		memcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);
 
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 8b7794c..35fd478 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -148,7 +148,7 @@ cifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)
 	 * greater than cifs socket timeout which is 7 seconds
 	 */
 	while (server->tcpStatus == CifsNeedReconnect) {
-		wait_event_interruptible_timeout(server->response_q,
+		(void)wait_event_interruptible_timeout(server->response_q,
 			(server->tcpStatus != CifsNeedReconnect), 10 * HZ);
 
 		/* are we still trying to reconnect? */
@@ -3976,7 +3976,7 @@ QInfRetry:
 
 		/* decode response */
 		/* BB FIXME - add time zone adjustment BB */
-		memset(pFinfo, 0, sizeof(FILE_ALL_INFO));
+		(void)memset(pFinfo, 0, sizeof(FILE_ALL_INFO));
 		ts.tv_nsec = 0;
 		ts.tv_sec = time;
 		/* decode time fields */
@@ -6062,7 +6062,7 @@ setPermsRetry:
 	data_offset =
 	    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +
 				      offset);
-	memset(data_offset, 0, count);
+	(void)memset(data_offset, 0, count);
 	pSMB->DataOffset = cpu_to_le16(offset);
 	pSMB->ParameterOffset = cpu_to_le16(param_offset);
 	pSMB->SetupCount = 1;
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 986709a..a48347a 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -946,7 +946,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 	 * informational, only used for servers that do not support
 	 * port 445 and it can be overridden at mount time
 	 */
-	memset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
+	(void)memset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
 	for (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)
 		vol->source_rfc1001_name[i] = toupper(nodename[i]);
 
@@ -1340,7 +1340,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 			if (!value || !*value || (*value == ' ')) {
 				cFYI(1, "invalid (empty) netbiosname");
 			} else {
-				memset(vol->source_rfc1001_name, 0x20,
+				(void)memset(vol->source_rfc1001_name, 0x20,
 					RFC1001_NAME_LEN);
 				/*
 				 * FIXME: are there cases in which a comma can
@@ -1365,7 +1365,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 				cFYI(1, "empty server netbiosname specified");
 			} else {
 				/* last byte, type, is 0x20 for servr type */
-				memset(vol->target_rfc1001_name, 0x20,
+				(void)memset(vol->target_rfc1001_name, 0x20,
 					RFC1001_NAME_LEN_WITH_NULL);
 
 				for (i = 0; i < 15; i++) {
@@ -1648,7 +1648,7 @@ srcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)
 		return ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);
 	}
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false; /* don't expect to be here */
 	}
 }
@@ -1673,7 +1673,7 @@ match_port(struct TCP_Server_Info *server, struct sockaddr *addr)
 		port = ((struct sockaddr_in6 *) addr)->sin6_port;
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false;
 	}
 
@@ -1715,7 +1715,7 @@ match_address(struct TCP_Server_Info *server, struct sockaddr *addr,
 		break;
 	}
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return false; /* don't expect to be here */
 	}
 
@@ -1854,7 +1854,7 @@ cifs_get_tcp_session(struct smb_vol *volume_info)
 	struct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;
 	int rc;
 
-	memset(&addr, 0, sizeof(struct sockaddr_storage));
+	(void)memset(&addr, 0, sizeof(struct sockaddr_storage));
 
 	cFYI(1, "UNC: %s ip: %s", volume_info->UNC, volume_info->UNCip);
 
@@ -2504,7 +2504,7 @@ cifs_match_super(struct super_block *sb, void *data)
 	struct sockaddr_storage addr;
 	int rc = 0;
 
-	memset(&addr, 0, sizeof(struct sockaddr_storage));
+	(void)memset(&addr, 0, sizeof(struct sockaddr_storage));
 
 	spin_lock(&cifs_tcp_ses_lock);
 	cifs_sb = CIFS_SB(sb);
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 4dd9283..3ff565e 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -2648,7 +2648,7 @@ static int cifs_readpage_worker(struct file *file, struct page *page,
 		current_fs_time(file->f_path.dentry->d_inode->i_sb);
 
 	if (PAGE_CACHE_SIZE > rc)
-		memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
+		(void)memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
 
 	flush_dcache_page(page);
 	SetPageUptodate(page);
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index a5f54b7..460a1de 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -192,7 +192,7 @@ void
 cifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,
 			 struct cifs_sb_info *cifs_sb)
 {
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_uniqueid = le64_to_cpu(info->UniqueId);
 	fattr->cf_bytes = le64_to_cpu(info->NumOfBytes);
 	fattr->cf_eof = le64_to_cpu(info->EndOfFile);
@@ -275,7 +275,7 @@ cifs_create_dfs_fattr(struct cifs_fattr *fattr, struct super_block *sb)
 
 	cFYI(1, "creating fake fattr for DFS referral");
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;
 	fattr->cf_uid = cifs_sb->mnt_uid;
 	fattr->cf_gid = cifs_sb->mnt_gid;
@@ -509,7 +509,7 @@ cifs_all_info_to_fattr(struct cifs_fattr *fattr, FILE_ALL_INFO *info,
 {
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_cifsattrs = le32_to_cpu(info->Attributes);
 	if (info->DeletePending)
 		fattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;
@@ -1403,7 +1403,7 @@ mkdir_get_info:
 				struct cifsInodeInfo *cifsInode;
 				u32 dosattrs;
 
-				memset(&pInfo, 0, sizeof(pInfo));
+				(void)memset(&pInfo, 0, sizeof(pInfo));
 				cifsInode = CIFS_I(newinode);
 				dosattrs = cifsInode->cifsAttrs|ATTR_READONLY;
 				pInfo.Attributes = cpu_to_le32(dosattrs);
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index 703ef5c..4e323c8 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -97,7 +97,7 @@ sesInfoFree(struct cifs_ses *buf_to_free)
 	kfree(buf_to_free->serverDomain);
 	kfree(buf_to_free->serverNOS);
 	if (buf_to_free->password) {
-		memset(buf_to_free->password, 0, strlen(buf_to_free->password));
+		(void)memset(buf_to_free->password, 0, strlen(buf_to_free->password));
 		kfree(buf_to_free->password);
 	}
 	kfree(buf_to_free->user_name);
@@ -133,7 +133,7 @@ tconInfoFree(struct cifs_tcon *buf_to_free)
 	atomic_dec(&tconInfoAllocCount);
 	kfree(buf_to_free->nativeFileSystem);
 	if (buf_to_free->password) {
-		memset(buf_to_free->password, 0, strlen(buf_to_free->password));
+		(void)memset(buf_to_free->password, 0, strlen(buf_to_free->password));
 		kfree(buf_to_free->password);
 	}
 	kfree(buf_to_free);
@@ -153,7 +153,7 @@ cifs_buf_get(void)
 	/* clear the first few header bytes */
 	/* for most paths, more is cleared in header_assemble */
 	if (ret_buf) {
-		memset(ret_buf, 0, sizeof(struct smb_hdr) + 3);
+		(void)memset(ret_buf, 0, sizeof(struct smb_hdr) + 3);
 		atomic_inc(&bufAllocCount);
 #ifdef CONFIG_CIFS_STATS2
 		atomic_inc(&totBufAllocCount);
@@ -302,7 +302,7 @@ header_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,
 	struct cifs_ses *ses;
 	char *temp = (char *) buffer;
 
-	memset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */
+	(void)memset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */
 
 	buffer->smb_buf_length = cpu_to_be32(
 	    (2 * word_count) + sizeof(struct smb_hdr) -
diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
index e2bbc68..a266e98 100644
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@ -152,7 +152,7 @@ static void
 cifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,
 		       struct cifs_sb_info *cifs_sb)
 {
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);
 	fattr->cf_eof = le64_to_cpu(info->EndOfFile);
 	fattr->cf_bytes = le64_to_cpu(info->AllocationSize);
@@ -170,7 +170,7 @@ cifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,
 {
 	int offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;
 
-	memset(fattr, 0, sizeof(*fattr));
+	(void)memset(fattr, 0, sizeof(*fattr));
 	fattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,
 					    info->LastAccessTime, offset);
 	fattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index d85efad..e8b66e4 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -418,7 +418,7 @@ static void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
 	NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;
 	__u32 flags;
 
-	memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
+	(void)memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
 	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
 	sec_blob->MessageType = NtLmNegotiate;
 
diff --git a/fs/cifs/smbencrypt.c b/fs/cifs/smbencrypt.c
index d5cd9aa..a5108f0 100644
--- a/fs/cifs/smbencrypt.c
+++ b/fs/cifs/smbencrypt.c
@@ -184,9 +184,9 @@ SMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)
 	int rc;
 	unsigned char p14[14], p16[16], p21[21];
 
-	memset(p14, '\0', 14);
-	memset(p16, '\0', 16);
-	memset(p21, '\0', 21);
+	(void)memset(p14, '\0', 14);
+	(void)memset(p16, '\0', 16);
+	(void)memset(p21, '\0', 21);
 
 	memcpy(p14, passwd, 14);
 	rc = E_P16(p14, p16);
@@ -233,8 +233,8 @@ SMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,
 	int rc;
 	unsigned char p16[16], p21[21];
 
-	memset(p16, '\0', 16);
-	memset(p21, '\0', 21);
+	(void)memset(p16, '\0', 16);
+	(void)memset(p21, '\0', 21);
 
 	rc = E_md4hash(passwd, p16, codepage);
 	if (rc) {
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index 0cc9584..7256f6d 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -57,7 +57,7 @@ AllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)
 	if (temp == NULL)
 		return temp;
 	else {
-		memset(temp, 0, sizeof(struct mid_q_entry));
+		(void)memset(temp, 0, sizeof(struct mid_q_entry));
 		temp->mid = smb_buffer->Mid;	/* always LE */
 		temp->pid = current->pid;
 		temp->command = smb_buffer->Command;
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index a2ee8f9..4c50286 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -213,7 +213,7 @@ static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned i
 			kunmap(page);
 			page_cache_release(page);
 		} else
-			memset(data, 0, PAGE_CACHE_SIZE);
+			(void)memset(data, 0, PAGE_CACHE_SIZE);
 		data += PAGE_CACHE_SIZE;
 	}
 	return read_buffers[buffer] + offset;
@@ -520,7 +520,7 @@ static int cramfs_readpage(struct file *file, struct page * page)
 		}
 	}
 
-	memset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);
+	(void)memset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);
 	flush_dcache_page(page);
 	kunmap(page);
 	SetPageUptodate(page);
diff --git a/fs/dcache.c b/fs/dcache.c
index 16a53cc..0ef8232 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -141,7 +141,7 @@ static void __d_free(struct rcu_head *head)
 {
 	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
 
-	WARN_ON(!list_empty(&dentry->d_alias));
+	(void)WARN_ON(!list_empty(&dentry->d_alias));
 	if (dname_external(dentry))
 		kfree(dentry->d_name.name);
 	kmem_cache_free(dentry_cache, dentry); 
@@ -1285,7 +1285,7 @@ EXPORT_SYMBOL(d_alloc_name);
 
 void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)
 {
-	WARN_ON_ONCE(dentry->d_op);
+	(void)WARN_ON_ONCE(dentry->d_op);
 	WARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH	|
 				DCACHE_OP_COMPARE	|
 				DCACHE_OP_REVALIDATE	|
@@ -2507,7 +2507,7 @@ global_root:
 	 */
 	if (IS_ROOT(dentry) &&
 	    (dentry->d_name.len != 1 || dentry->d_name.name[0] != '/')) {
-		WARN(1, "Root dentry has weird name <%.*s>\n",
+		(void)WARN(1, "Root dentry has weird name <%.*s>\n",
 		     (int) dentry->d_name.len, dentry->d_name.name);
 	}
 	if (!slash)
diff --git a/fs/direct-io.c b/fs/direct-io.c
index 4a588db..8ace3d8 100644
--- a/fs/direct-io.c
+++ b/fs/direct-io.c
@@ -1152,7 +1152,7 @@ do_blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	 * performance regression in a database benchmark.  So, we take
 	 * care to only zero out what's needed.
 	 */
-	memset(dio, 0, offsetof(struct dio, pages));
+	(void)memset(dio, 0, offsetof(struct dio, pages));
 
 	dio->flags = flags;
 	if (dio->flags & DIO_LOCKING) {
diff --git a/fs/exec.c b/fs/exec.c
index aeb135c..d6edac6 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1064,7 +1064,7 @@ void set_task_comm(struct task_struct *tsk, char *buf)
 	 * Readers without a lock may see incomplete new
 	 * names but are safe from non-terminating string reads.
 	 */
-	memset(tsk->comm, 0, TASK_COMM_LEN);
+	(void)memset(tsk->comm, 0, TASK_COMM_LEN);
 	wmb();
 	strlcpy(tsk->comm, buf, sizeof(tsk->comm));
 	task_unlock(tsk);
@@ -1310,7 +1310,7 @@ int prepare_binprm(struct linux_binprm *bprm)
 		return retval;
 	bprm->cred_prepared = 1;
 
-	memset(bprm->buf, 0, BINPRM_BUF_SIZE);
+	(void)memset(bprm->buf, 0, BINPRM_BUF_SIZE);
 	return kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);
 }
 
@@ -1896,7 +1896,7 @@ static inline int zap_threads(struct task_struct *tsk, struct mm_struct *mm,
 		do {
 			if (p->mm) {
 				if (unlikely(p->mm == mm)) {
-					lock_task_sighand(p, &flags);
+					(void)lock_task_sighand(p, &flags);
 					nr += zap_process(p, exit_code);
 					unlock_task_sighand(p, &flags);
 				}
diff --git a/fs/ext2/ialloc.c b/fs/ext2/ialloc.c
index 8b15cf8..25d13bc 100644
--- a/fs/ext2/ialloc.c
+++ b/fs/ext2/ialloc.c
@@ -555,7 +555,7 @@ got:
 	inode->i_ino = ino;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_flags =
 		ext2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);
 	ei->i_faddr = 0;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 740cad8..ada0c51 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -494,7 +494,7 @@ static int ext2_alloc_branch(struct inode *inode,
 		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
 		branch[n].bh = bh;
 		lock_buffer(bh);
-		memset(bh->b_data, 0, blocksize);
+		(void)memset(bh->b_data, 0, blocksize);
 		branch[n].p = (__le32 *) bh->b_data + offsets[n];
 		branch[n].key = cpu_to_le32(new_blocks[n]);
 		*branch[n].p = branch[n].key;
@@ -1426,7 +1426,7 @@ static int __ext2_write_inode(struct inode *inode, int do_sync)
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ei->i_state & EXT2_STATE_NEW)
-		memset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);
 
 	ext2_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index 6dcafc7..a49a871 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -531,7 +531,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 		size_t size = EXT2_XATTR_LEN(name_len);
 		size_t rest = (char *)last - (char *)here;
 		memmove((char *)here + size, here, rest);
-		memset(here, 0, size);
+		(void)memset(here, 0, size);
 		here->e_name_index = name_index;
 		here->e_name_len = name_len;
 		memcpy(here->e_name, name, name_len);
@@ -547,7 +547,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 				/* The old and the new value have the same
 				   size. Just replace. */
 				here->e_value_size = cpu_to_le32(value_len);
-				memset(val + size - EXT2_XATTR_PAD, 0,
+				(void)memset(val + size - EXT2_XATTR_PAD, 0,
 				       EXT2_XATTR_PAD); /* Clear pad bytes. */
 				memcpy(val, value, value_len);
 				goto skip_replace;
@@ -555,7 +555,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 
 			/* Remove the old value. */
 			memmove(first_val + size, first_val, val - first_val);
-			memset(first_val, 0, size);
+			(void)memset(first_val, 0, size);
 			here->e_value_offs = 0;
 			min_offs += size;
 
@@ -575,7 +575,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 			last = ENTRY((char *)last - size);
 			memmove(here, (char*)here + size,
 				(char*)last - (char*)here);
-			memset(last, 0, size);
+			(void)memset(last, 0, size);
 		}
 	}
 
@@ -587,7 +587,7 @@ bad_block:		ext2_error(sb, "ext2_xattr_set",
 			char *val = (char *)header + min_offs - size;
 			here->e_value_offs =
 				cpu_to_le16((char *)val - (char *)header);
-			memset(val + size - EXT2_XATTR_PAD, 0,
+			(void)memset(val + size - EXT2_XATTR_PAD, 0,
 			       EXT2_XATTR_PAD); /* Clear the pad bytes. */
 			memcpy(val, value, value_len);
 		}
diff --git a/fs/ext3/ialloc.c b/fs/ext3/ialloc.c
index 1cde284..b01869bb 100644
--- a/fs/ext3/ialloc.c
+++ b/fs/ext3/ialloc.c
@@ -504,7 +504,7 @@ got:
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index 2d0afec..43b45d8 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -696,7 +696,7 @@ static int ext3_alloc_branch(handle_t *handle, struct inode *inode,
 			goto failed;
 		}
 
-		memset(bh->b_data, 0, blocksize);
+		(void)memset(bh->b_data, 0, blocksize);
 		branch[n].p = (__le32 *) bh->b_data + offsets[n];
 		branch[n].key = cpu_to_le32(new_blocks[n]);
 		*branch[n].p = branch[n].key;
@@ -1079,7 +1079,7 @@ struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,
 	 */
 	if (err > 0) {
 		if (err > 1)
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		err = 0;
 	}
 	*errp = err;
@@ -1105,7 +1105,7 @@ struct buffer_head *ext3_getblk(handle_t *handle, struct inode *inode,
 			BUFFER_TRACE(bh, "call get_create_access");
 			fatal = ext3_journal_get_create_access(handle, bh);
 			if (!fatal && !buffer_uptodate(bh)) {
-				memset(bh->b_data,0,inode->i_sb->s_blocksize);
+				(void)memset(bh->b_data,0,inode->i_sb->s_blocksize);
 				set_buffer_uptodate(bh);
 			}
 			unlock_buffer(bh);
@@ -2812,7 +2812,7 @@ static int __ext3_get_inode_loc(struct inode *inode,
 			brelse(bitmap_bh);
 			if (i == start + inodes_per_buffer) {
 				/* all other inodes are free, so skip I/O */
-				memset(bh->b_data, 0, bh->b_size);
+				(void)memset(bh->b_data, 0, bh->b_size);
 				set_buffer_uptodate(bh);
 				unlock_buffer(bh);
 				goto has_buffer;
@@ -3083,7 +3083,7 @@ again:
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ext3_test_inode_state(inode, EXT3_STATE_NEW))
-		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
 
 	ext3_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index e8e2117..f94cfea 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -1398,7 +1398,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	/* Initialize the root; the dot dirents already exist */
 	de = (struct ext3_dir_entry_2 *) (&root->dotdot);
 	de->rec_len = ext3_rec_len_to_disk(blocksize - EXT3_DIR_REC_LEN(2));
-	memset (&root->info, 0, sizeof(root->info));
+	(void)memset (&root->info, 0, sizeof(root->info));
 	root->info.info_length = sizeof(root->info);
 	root->info.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;
 	entries = root->entries;
@@ -1550,7 +1550,7 @@ static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			goto cleanup;
 		node2 = (struct dx_node *)(bh2->b_data);
 		entries2 = node2->entries;
-		memset(&node2->fake, 0, sizeof(struct fake_dirent));
+		(void)memset(&node2->fake, 0, sizeof(struct fake_dirent));
 		node2->fake.rec_len = ext3_rec_len_to_disk(sb->s_blocksize);
 		BUFFER_TRACE(frame->bh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, frame->bh);
diff --git a/fs/ext3/resize.c b/fs/ext3/resize.c
index 7916e4c..dc561e7 100644
--- a/fs/ext3/resize.c
+++ b/fs/ext3/resize.c
@@ -126,7 +126,7 @@ static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,
 		bh = ERR_PTR(err);
 	} else {
 		lock_buffer(bh);
-		memset(bh->b_data, 0, sb->s_blocksize);
+		(void)memset(bh->b_data, 0, sb->s_blocksize);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 	}
@@ -150,7 +150,7 @@ static void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 	for (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)
 		ext3_set_bit(i, bitmap);
 	if (i < end_bit)
-		memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
+		(void)memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
 }
 
 /*
@@ -526,7 +526,7 @@ static int add_new_gdb(handle_t *handle, struct inode *inode,
 	err = ext3_mark_iloc_dirty(handle, inode, &iloc);
 	if (err)
 		goto exit_group_desc;
-	memset((*primary)->b_data, 0, sb->s_blocksize);
+	(void)memset((*primary)->b_data, 0, sb->s_blocksize);
 	err = ext3_journal_dirty_metadata(handle, *primary);
 	if (err)
 		goto exit_group_desc;
@@ -738,7 +738,7 @@ static void update_backups(struct super_block *sb,
 		lock_buffer(bh);
 		memcpy(bh->b_data, data, size);
 		if (rest)
-			memset(bh->b_data + size, 0, rest);
+			(void)memset(bh->b_data + size, 0, rest);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 		err = ext3_journal_dirty_metadata(handle, bh);
diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 726c7ef..58706cb 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -744,7 +744,7 @@ static int bdev_try_to_free_page(struct super_block *sb, struct page *page,
 {
 	journal_t *journal = EXT3_SB(sb)->s_journal;
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
diff --git a/fs/ext3/xattr.c b/fs/ext3/xattr.c
index d565759..3116621 100644
--- a/fs/ext3/xattr.c
+++ b/fs/ext3/xattr.c
@@ -562,7 +562,7 @@ ext3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)
 		size_t size = EXT3_XATTR_LEN(name_len);
 		size_t rest = (void *)last - (void *)s->here + sizeof(__u32);
 		memmove((void *)s->here + size, s->here, rest);
-		memset(s->here, 0, size);
+		(void)memset(s->here, 0, size);
 		s->here->e_name_index = i->name_index;
 		s->here->e_name_len = name_len;
 		memcpy(s->here->e_name, i->name, name_len);
@@ -579,7 +579,7 @@ ext3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)
 				   size. Just replace. */
 				s->here->e_value_size =
 					cpu_to_le32(i->value_len);
-				memset(val + size - EXT3_XATTR_PAD, 0,
+				(void)memset(val + size - EXT3_XATTR_PAD, 0,
 				       EXT3_XATTR_PAD); /* Clear pad bytes. */
 				memcpy(val, i->value, i->value_len);
 				return 0;
@@ -587,7 +587,7 @@ ext3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)
 
 			/* Remove the old value. */
 			memmove(first_val + size, first_val, val - first_val);
-			memset(first_val, 0, size);
+			(void)memset(first_val, 0, size);
 			s->here->e_value_size = 0;
 			s->here->e_value_offs = 0;
 			min_offs += size;
@@ -609,7 +609,7 @@ ext3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)
 			last = ENTRY((void *)last - size);
 			memmove(s->here, (void *)s->here + size,
 				(void *)last - (void *)s->here + sizeof(__u32));
-			memset(last, 0, size);
+			(void)memset(last, 0, size);
 		}
 	}
 
@@ -620,7 +620,7 @@ ext3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)
 			size_t size = EXT3_XATTR_SIZE(i->value_len);
 			void *val = s->base + min_offs - size;
 			s->here->e_value_offs = cpu_to_le16(min_offs - size);
-			memset(val + size - EXT3_XATTR_PAD, 0,
+			(void)memset(val + size - EXT3_XATTR_PAD, 0,
 			       EXT3_XATTR_PAD); /* Clear the pad bytes. */
 			memcpy(val, i->value, i->value_len);
 		}
@@ -977,7 +977,7 @@ ext3_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,
 
 	if (ext3_test_inode_state(inode, EXT3_STATE_NEW)) {
 		struct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);
-		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
 		ext3_clear_inode_state(inode, EXT3_STATE_NEW);
 	}
 
diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index f9e2cd8..d18a37e 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -501,7 +501,7 @@ ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,
 	struct ext4_allocation_request ar;
 	ext4_fsblk_t ret;
 
-	memset(&ar, 0, sizeof(ar));
+	(void)memset(&ar, 0, sizeof(ar));
 	/* Fill with neighbour allocated blocks */
 	ar.inode = inode;
 	ar.goal = goal;
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 74f23c2..a1d7330 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1563,7 +1563,7 @@ static int ext4_ext_try_to_merge_right(struct inode *inode,
 		}
 		le16_add_cpu(&eh->eh_entries, -1);
 		merge_done = 1;
-		WARN_ON(eh->eh_entries == 0);
+		(void)WARN_ON(eh->eh_entries == 0);
 		if (!eh->eh_entries)
 			EXT4_ERROR_INODE(inode, "eh->eh_entries = 0!");
 	}
@@ -2412,7 +2412,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 					sizeof(struct ext4_extent));
 
 				/* Now get rid of the one at the end */
-				memset(EXT_LAST_EXTENT(eh), 0,
+				(void)memset(EXT_LAST_EXTENT(eh), 0,
 					sizeof(struct ext4_extent));
 			}
 			le16_add_cpu(&eh->eh_entries, -1);
@@ -2560,7 +2560,7 @@ again:
 			/* go to the next level */
 			ext_debug("move to level %d (block %llu)\n",
 				  i + 1, ext4_idx_pblock(path[i].p_idx));
-			memset(path + i + 1, 0, sizeof(*path));
+			(void)memset(path + i + 1, 0, sizeof(*path));
 			bh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));
 			if (!bh) {
 				/* should we reset i_size? */
@@ -3029,7 +3029,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 		}
 	}
 
-	WARN_ON(map->m_lblk < ee_block);
+	(void)WARN_ON(map->m_lblk < ee_block);
 	/*
 	 * It is safe to convert extent to initialized via explicit
 	 * zeroout only if extent is fully insde i_size or new_size.
@@ -4435,7 +4435,7 @@ int ext4_convert_unwritten_extents(struct inode *inode, loff_t offset,
 		ret = ext4_map_blocks(handle, inode, &map,
 				      EXT4_GET_BLOCKS_IO_CONVERT_EXT);
 		if (ret <= 0) {
-			WARN_ON(ret <= 0);
+			(void)WARN_ON(ret <= 0);
 			printk(KERN_ERR "%s: ext4_ext_map_blocks "
 				    "returned error inode#%lu, block=%u, "
 				    "max_blocks=%u", __func__,
@@ -4847,7 +4847,7 @@ int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 	while (iblock < last_block) {
 		max_blocks = last_block - iblock;
 		num_blocks = 1;
-		memset(&map, 0, sizeof(map));
+		(void)memset(&map, 0, sizeof(map));
 		map.m_lblk = iblock;
 		map.m_len = max_blocks;
 		ret = ext4_ext_map_blocks(handle, inode, &map,
@@ -4864,7 +4864,7 @@ int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 			 * put it in the cache.  So we can get the hole
 			 * out of the cache
 			 */
-			memset(&cache_ex, 0, sizeof(cache_ex));
+			(void)memset(&cache_ex, 0, sizeof(cache_ex));
 			if ((ext4_ext_check_cache(inode, iblock, &cache_ex)) &&
 				!cache_ex.ec_start) {
 
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index cb70f18..b9aec18 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -176,7 +176,7 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 		 * when trying to sort through large numbers of block
 		 * devices or filesystem images.
 		 */
-		memset(buf, 0, sizeof(buf));
+		(void)memset(buf, 0, sizeof(buf));
 		path.mnt = mnt;
 		path.dentry = mnt->mnt_root;
 		cp = d_path(&path, buf, sizeof(buf));
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 00a2cb7..96beaaa 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -152,7 +152,7 @@ static int ext4_sync_parent(struct inode *inode)
 		ret = sync_mapping_buffers(inode->i_mapping);
 		if (ret)
 			break;
-		memset(&wbc, 0, sizeof(wbc));
+		(void)memset(&wbc, 0, sizeof(wbc));
 		wbc.sync_mode = WB_SYNC_ALL;
 		wbc.nr_to_write = 0;         /* only write out the inode */
 		ret = sync_inode(inode, &wbc);
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 25d8c97..bd399b8 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -61,7 +61,7 @@ void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 	for (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)
 		ext4_set_bit(i, bitmap);
 	if (i < end_bit)
-		memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
+		(void)memset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);
 }
 
 /* Initializes an uninitialized inode bitmap */
@@ -81,11 +81,11 @@ static unsigned ext4_init_inode_bitmap(struct super_block *sb,
 		ext4_free_group_clusters_set(sb, gdp, 0);
 		ext4_free_inodes_set(sb, gdp, 0);
 		ext4_itable_unused_set(sb, gdp, 0);
-		memset(bh->b_data, 0xff, sb->s_blocksize);
+		(void)memset(bh->b_data, 0xff, sb->s_blocksize);
 		return 0;
 	}
 
-	memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
+	(void)memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
 	ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8,
 			bh->b_data);
 
@@ -869,7 +869,7 @@ got:
 	inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =
 						       ext4_current_time(inode);
 
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index feaa82f..729fe4a 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -275,7 +275,7 @@ void ext4_da_update_reserve_space(struct inode *inode,
 			 "with only %d reserved data blocks\n",
 			 __func__, inode->i_ino, used,
 			 ei->i_reserved_data_blocks);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		used = ei->i_reserved_data_blocks;
 	}
 
@@ -672,7 +672,7 @@ struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
 		BUFFER_TRACE(bh, "call get_create_access");
 		fatal = ext4_journal_get_create_access(handle, bh);
 		if (!fatal && !buffer_uptodate(bh)) {
-			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
+			(void)memset(bh->b_data, 0, inode->i_sb->s_blocksize);
 			set_buffer_uptodate(bh);
 		}
 		unlock_buffer(bh);
@@ -1167,7 +1167,7 @@ static void ext4_da_release_space(struct inode *inode, int to_free)
 			 "ino %lu, to_free %d with only %d reserved "
 			 "data blocks\n", inode->i_ino, to_free,
 			 ei->i_reserved_data_blocks);
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		to_free = ei->i_reserved_data_blocks;
 	}
 	ei->i_reserved_data_blocks -= to_free;
@@ -1265,7 +1265,7 @@ static int mpage_da_submit_io(struct mpage_da_data *mpd,
 	struct ext4_io_submit io_submit;
 
 	BUG_ON(mpd->next_page <= mpd->first_page);
-	memset(&io_submit, 0, sizeof(io_submit));
+	(void)memset(&io_submit, 0, sizeof(io_submit));
 	/*
 	 * We need to start from the first_page to the next_page - 1
 	 * to make sure we also write the mapped dirty buffer_heads.
@@ -2013,7 +2013,7 @@ static int write_cache_pages_da(struct address_space *mapping,
 	long			nr_to_write = wbc->nr_to_write;
 	int			i, tag, ret = 0;
 
-	memset(mpd, 0, sizeof(struct mpage_da_data));
+	(void)memset(mpd, 0, sizeof(struct mpage_da_data));
 	mpd->wbc = wbc;
 	mpd->inode = inode;
 	pagevec_init(&pvec, 0);
@@ -2725,7 +2725,7 @@ static int ext4_releasepage(struct page *page, gfp_t wait)
 
 	trace_ext4_releasepage(page);
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
@@ -3483,7 +3483,7 @@ static int __ext4_get_inode_loc(struct inode *inode,
 			brelse(bitmap_bh);
 			if (i == start + inodes_per_block) {
 				/* all other inodes are free, so skip I/O */
-				memset(bh->b_data, 0, bh->b_size);
+				(void)memset(bh->b_data, 0, bh->b_size);
 				set_buffer_uptodate(bh);
 				unlock_buffer(bh);
 				goto has_buffer;
@@ -3863,7 +3863,7 @@ static int ext4_do_update_inode(handle_t *handle,
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ext4_test_inode_state(inode, EXT4_STATE_NEW))
-		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
 
 	ext4_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
@@ -4372,7 +4372,7 @@ static int ext4_expand_extra_isize(struct inode *inode,
 	/* No extended attributes present */
 	if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||
 	    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {
-		memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,
+		(void)memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,
 			new_extra_isize);
 		EXT4_I(inode)->i_extra_isize = new_extra_isize;
 		return 0;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index cb990b2..4312f93 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -930,7 +930,7 @@ static int ext4_mb_init_cache(struct page *page, char *incore)
 			trace_ext4_mb_buddy_bitmap_load(sb, group);
 			grinfo = ext4_get_group_info(sb, group);
 			grinfo->bb_fragments = 0;
-			memset(grinfo->bb_counters, 0,
+			(void)memset(grinfo->bb_counters, 0,
 			       sizeof(*grinfo->bb_counters) *
 				(sb->s_blocksize_bits+2));
 			/*
@@ -938,7 +938,7 @@ static int ext4_mb_init_cache(struct page *page, char *incore)
 			 */
 			ext4_lock_group(sb, group);
 			/* init the buddy */
-			memset(data, 0xff, blocksize);
+			(void)memset(data, 0xff, blocksize);
 			ext4_mb_generate_buddy(sb, data, incore, group);
 			ext4_unlock_group(sb, group);
 			incore = NULL;
@@ -1883,7 +1883,7 @@ void ext4_mb_scan_aligned(struct ext4_allocation_context *ac,
 	first_group_block = ext4_group_first_block_no(sb, e4b->bd_group);
 
 	a = first_group_block + sbi->s_stripe - 1;
-	do_div(a, sbi->s_stripe);
+	(void)do_div(a, sbi->s_stripe);
 	i = (a * sbi->s_stripe) - first_group_block;
 
 	while (i < EXT4_CLUSTERS_PER_GROUP(sb)) {
@@ -2241,7 +2241,7 @@ int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
 		ext4_msg(sb, KERN_ERR, "EXT4-fs: can't allocate buddy mem");
 		goto exit_group_info;
 	}
-	memset(meta_group_info[i], 0, kmem_cache_size(cachep));
+	(void)memset(meta_group_info[i], 0, kmem_cache_size(cachep));
 	set_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,
 		&(meta_group_info[i]->bb_state));
 
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index e7d6bb0..1aead42 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -520,7 +520,7 @@ int ext4_ext_migrate(struct inode *inode)
 
 	ei = EXT4_I(inode);
 	i_data = ei->i_data;
-	memset(&lb, 0, sizeof(lb));
+	(void)memset(&lb, 0, sizeof(lb));
 
 	/* 32 bit block address 4 bytes */
 	max_entries = inode->i_sb->s_blocksize >> 2;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 2043f48..b009cff 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -1391,7 +1391,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	de = (struct ext4_dir_entry_2 *) (&root->dotdot);
 	de->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2),
 					   blocksize);
-	memset (&root->info, 0, sizeof(root->info));
+	(void)memset (&root->info, 0, sizeof(root->info));
 	root->info.info_length = sizeof(root->info);
 	root->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;
 	entries = root->entries;
@@ -1551,7 +1551,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			goto cleanup;
 		node2 = (struct dx_node *)(bh2->b_data);
 		entries2 = node2->entries;
-		memset(&node2->fake, 0, sizeof(struct fake_dirent));
+		(void)memset(&node2->fake, 0, sizeof(struct fake_dirent));
 		node2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,
 							   sb->s_blocksize);
 		BUFFER_TRACE(frame->bh, "get_write_access");
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index f9d948f..135f929 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -990,7 +990,7 @@ static void update_backups(struct super_block *sb,
 		lock_buffer(bh);
 		memcpy(bh->b_data, data, size);
 		if (rest)
-			memset(bh->b_data + size, 0, rest);
+			(void)memset(bh->b_data + size, 0, rest);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 		err = ext4_handle_dirty_metadata(handle, NULL, bh);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 502c61f..6a0fa0a 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -896,7 +896,7 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 
 	ei->vfs_inode.i_version = 1;
 	ei->vfs_inode.i_data.writeback_index = 0;
-	memset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));
+	(void)memset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));
 	INIT_LIST_HEAD(&ei->i_prealloc_list);
 	spin_lock_init(&ei->i_prealloc_lock);
 	ei->i_reserved_data_blocks = 0;
@@ -1218,7 +1218,7 @@ static int bdev_try_to_free_page(struct super_block *sb, struct page *page,
 {
 	journal_t *journal = EXT4_SB(sb)->s_journal;
 
-	WARN_ON(PageChecked(page));
+	(void)WARN_ON(PageChecked(page));
 	if (!page_has_buffers(page))
 		return 0;
 	if (journal)
@@ -3514,7 +3514,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	blocks_count = (ext4_blocks_count(es) -
 			le32_to_cpu(es->s_first_data_block) +
 			EXT4_BLOCKS_PER_GROUP(sb) - 1);
-	do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
+	(void)do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
 	if (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {
 		ext4_msg(sb, KERN_WARNING, "groups count too large: %u "
 		       "(block count %llu, first data block %u, "
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 93a00d8..548e71b 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -572,7 +572,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 		size_t size = EXT4_XATTR_LEN(name_len);
 		size_t rest = (void *)last - (void *)s->here + sizeof(__u32);
 		memmove((void *)s->here + size, s->here, rest);
-		memset(s->here, 0, size);
+		(void)memset(s->here, 0, size);
 		s->here->e_name_index = i->name_index;
 		s->here->e_name_len = name_len;
 		memcpy(s->here->e_name, i->name, name_len);
@@ -589,7 +589,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 				   size. Just replace. */
 				s->here->e_value_size =
 					cpu_to_le32(i->value_len);
-				memset(val + size - EXT4_XATTR_PAD, 0,
+				(void)memset(val + size - EXT4_XATTR_PAD, 0,
 				       EXT4_XATTR_PAD); /* Clear pad bytes. */
 				memcpy(val, i->value, i->value_len);
 				return 0;
@@ -597,7 +597,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 
 			/* Remove the old value. */
 			memmove(first_val + size, first_val, val - first_val);
-			memset(first_val, 0, size);
+			(void)memset(first_val, 0, size);
 			s->here->e_value_size = 0;
 			s->here->e_value_offs = 0;
 			min_offs += size;
@@ -619,7 +619,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 			last = ENTRY((void *)last - size);
 			memmove(s->here, (void *)s->here + size,
 				(void *)last - (void *)s->here + sizeof(__u32));
-			memset(last, 0, size);
+			(void)memset(last, 0, size);
 		}
 	}
 
@@ -630,7 +630,7 @@ ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)
 			size_t size = EXT4_XATTR_SIZE(i->value_len);
 			void *val = s->base + min_offs - size;
 			s->here->e_value_offs = cpu_to_le16(min_offs - size);
-			memset(val + size - EXT4_XATTR_PAD, 0,
+			(void)memset(val + size - EXT4_XATTR_PAD, 0,
 			       EXT4_XATTR_PAD); /* Clear the pad bytes. */
 			memcpy(val, i->value, i->value_len);
 		}
@@ -997,7 +997,7 @@ ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,
 
 	if (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {
 		struct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);
-		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
 		ext4_clear_inode_state(inode, EXT4_STATE_NEW);
 	}
 
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index aca191b..e651e47 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -1047,7 +1047,7 @@ static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,
 			err = -ENOMEM;
 			goto error;
 		}
-		memset(bhs[n]->b_data, 0, sb->s_blocksize);
+		(void)memset(bhs[n]->b_data, 0, sb->s_blocksize);
 		set_buffer_uptodate(bhs[n]);
 		mark_buffer_dirty_inode(bhs[n], dir);
 
@@ -1127,7 +1127,7 @@ int fat_alloc_new_dir(struct inode *dir, struct timespec *ts)
 	de[1].start = cpu_to_le16(MSDOS_I(dir)->i_logstart);
 	de[1].starthi = cpu_to_le16(MSDOS_I(dir)->i_logstart >> 16);
 	de[0].size = de[1].size = 0;
-	memset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));
+	(void)memset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));
 	set_buffer_uptodate(bhs[0]);
 	mark_buffer_dirty_inode(bhs[0], dir);
 
@@ -1199,7 +1199,7 @@ static int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,
 		}
 	} while (++i < *nr_cluster);
 
-	memset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);
+	(void)memset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);
 	offset = copy - sizeof(struct msdos_dir_entry);
 	get_bh(bhs[n]);
 	*bh = bhs[n];
diff --git a/fs/fat/fatent.c b/fs/fat/fatent.c
index 2e81ac0..a204755 100644
--- a/fs/fat/fatent.c
+++ b/fs/fat/fatent.c
@@ -26,7 +26,7 @@ static void fat12_ent_blocknr(struct super_block *sb, int entry,
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	int bytes = entry + (entry >> 1);
-	WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
+	(void)WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
 	*offset = bytes & (sb->s_blocksize - 1);
 	*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);
 }
@@ -36,7 +36,7 @@ static void fat_ent_blocknr(struct super_block *sb, int entry,
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	int bytes = (entry << sbi->fatent_shift);
-	WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
+	(void)WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
 	*offset = bytes & (sb->s_blocksize - 1);
 	*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);
 }
@@ -45,11 +45,11 @@ static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
 	struct buffer_head **bhs = fatent->bhs;
 	if (fatent->nr_bhs == 1) {
-		WARN_ON(offset >= (bhs[0]->b_size - 1));
+		(void)WARN_ON(offset >= (bhs[0]->b_size - 1));
 		fatent->u.ent12_p[0] = bhs[0]->b_data + offset;
 		fatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);
 	} else {
-		WARN_ON(offset != (bhs[0]->b_size - 1));
+		(void)WARN_ON(offset != (bhs[0]->b_size - 1));
 		fatent->u.ent12_p[0] = bhs[0]->b_data + offset;
 		fatent->u.ent12_p[1] = bhs[1]->b_data;
 	}
@@ -57,13 +57,13 @@ static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)
 
 static void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
-	WARN_ON(offset & (2 - 1));
+	(void)WARN_ON(offset & (2 - 1));
 	fatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);
 }
 
 static void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
-	WARN_ON(offset & (4 - 1));
+	(void)WARN_ON(offset & (4 - 1));
 	fatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);
 }
 
@@ -72,7 +72,7 @@ static int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 {
 	struct buffer_head **bhs = fatent->bhs;
 
-	WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
+	(void)WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
 	fatent->fat_inode = MSDOS_SB(sb)->fat_inode;
 
 	bhs[0] = sb_bread(sb, blocknr);
@@ -104,7 +104,7 @@ static int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 {
 	struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;
 
-	WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
+	(void)WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
 	fatent->fat_inode = MSDOS_SB(sb)->fat_inode;
 	fatent->bhs[0] = sb_bread(sb, blocknr);
 	if (!fatent->bhs[0]) {
@@ -138,7 +138,7 @@ static int fat12_ent_get(struct fat_entry *fatent)
 static int fat16_ent_get(struct fat_entry *fatent)
 {
 	int next = le16_to_cpu(*fatent->u.ent16_p);
-	WARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));
+	(void)WARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));
 	if (next >= BAD_FAT16)
 		next = FAT_ENT_EOF;
 	return next;
@@ -147,7 +147,7 @@ static int fat16_ent_get(struct fat_entry *fatent)
 static int fat32_ent_get(struct fat_entry *fatent)
 {
 	int next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;
-	WARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));
+	(void)WARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));
 	if (next >= BAD_FAT32)
 		next = FAT_ENT_EOF;
 	return next;
@@ -189,7 +189,7 @@ static void fat32_ent_put(struct fat_entry *fatent, int new)
 	if (new == FAT_ENT_EOF)
 		new = EOF_FAT32;
 
-	WARN_ON(new & 0xf0000000);
+	(void)WARN_ON(new & 0xf0000000);
 	new |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;
 	*fatent->u.ent32_p = cpu_to_le32(new);
 	mark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);
@@ -203,16 +203,16 @@ static int fat12_ent_next(struct fat_entry *fatent)
 
 	fatent->entry++;
 	if (fatent->nr_bhs == 1) {
-		WARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 2)));
-		WARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
+		(void)WARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 2)));
+		(void)WARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
 		if (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {
 			ent12_p[0] = nextp - 1;
 			ent12_p[1] = nextp;
 			return 1;
 		}
 	} else {
-		WARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
-		WARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);
+		(void)WARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
+		(void)WARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);
 		ent12_p[0] = nextp - 1;
 		ent12_p[1] = nextp;
 		brelse(bhs[0]);
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index a81eb23..36a9068 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -432,7 +432,7 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,
 	 * any bad symbols (lowercase transformed to uppercase).
 	 */
 
-	memset(name_res, ' ', MSDOS_NAME);
+	(void)memset(name_res, ' ', MSDOS_NAME);
 	memcpy(name_res, base, baselen);
 	memcpy(name_res + 8, ext, extlen);
 	*lcase = 0;
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 22764c7..b27355d 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -326,7 +326,7 @@ static int f_getown_ex(struct file *filp, unsigned long arg)
 		break;
 
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		ret = -EINVAL;
 		break;
 	}
diff --git a/fs/file.c b/fs/file.c
index 4c6992d..b53e865 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -129,14 +129,14 @@ static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)
 	cpy = ofdt->max_fds * sizeof(struct file *);
 	set = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);
 	memcpy(nfdt->fd, ofdt->fd, cpy);
-	memset((char *)(nfdt->fd) + cpy, 0, set);
+	(void)memset((char *)(nfdt->fd) + cpy, 0, set);
 
 	cpy = ofdt->max_fds / BITS_PER_BYTE;
 	set = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;
 	memcpy(nfdt->open_fds, ofdt->open_fds, cpy);
-	memset((char *)(nfdt->open_fds) + cpy, 0, set);
+	(void)memset((char *)(nfdt->open_fds) + cpy, 0, set);
 	memcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);
-	memset((char *)(nfdt->close_on_exec) + cpy, 0, set);
+	(void)memset((char *)(nfdt->close_on_exec) + cpy, 0, set);
 }
 
 static struct fdtable * alloc_fdtable(unsigned int nr)
@@ -376,14 +376,14 @@ struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)
 	size = (new_fdt->max_fds - open_files) * sizeof(struct file *);
 
 	/* This is long word aligned thus could use a optimized version */
-	memset(new_fds, 0, size);
+	(void)memset(new_fds, 0, size);
 
 	if (new_fdt->max_fds > open_files) {
 		int left = (new_fdt->max_fds-open_files)/8;
 		int start = open_files / (8 * sizeof(unsigned long));
 
-		memset(&new_fdt->open_fds->fds_bits[start], 0, left);
-		memset(&new_fdt->close_on_exec->fds_bits[start], 0, left);
+		(void)memset(&new_fdt->open_fds->fds_bits[start], 0, left);
+		(void)memset(&new_fdt->close_on_exec->fds_bits[start], 0, left);
 	}
 
 	rcu_assign_pointer(newf->fdt, new_fdt);
diff --git a/fs/file_table.c b/fs/file_table.c
index 20002e3..7dd23bc 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -188,7 +188,7 @@ struct file *alloc_file(struct path *path, fmode_t mode,
 	 */
 	if ((mode & FMODE_WRITE) && !special_file(path->dentry->d_inode->i_mode)) {
 		file_take_write(file);
-		WARN_ON(mnt_clone_write(path->mnt));
+		(void)WARN_ON(mnt_clone_write(path->mnt));
 	}
 	if ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
 		i_readcount_inc(path->dentry->d_inode);
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index f855916..92635f3 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -370,9 +370,9 @@ writeback_single_inode(struct inode *inode, struct bdi_writeback *wb,
 	assert_spin_locked(&inode->i_lock);
 
 	if (!atomic_read(&inode->i_count))
-		WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
+		(void)WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
 	else
-		WARN_ON(inode->i_state & I_WILL_FREE);
+		(void)WARN_ON(inode->i_state & I_WILL_FREE);
 
 	if (inode->i_state & I_SYNC) {
 		/*
@@ -1118,7 +1118,7 @@ void __mark_inode_dirty(struct inode *inode, int flags)
 			bdi = inode_to_bdi(inode);
 
 			if (bdi_cap_writeback_dirty(bdi)) {
-				WARN(!test_bit(BDI_registered, &bdi->state),
+				(void)WARN(!test_bit(BDI_registered, &bdi->state),
 				     "bdi-%s not registered\n", bdi->name);
 
 				/*
@@ -1173,7 +1173,7 @@ static void wait_sb_inodes(struct super_block *sb)
 	 * We need to be protected against the filesystem going from
 	 * r/o to r/w or vice versa.
 	 */
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	spin_lock(&inode_sb_list_lock);
 
@@ -1242,7 +1242,7 @@ void writeback_inodes_sb_nr(struct super_block *sb,
 		.reason			= reason,
 	};
 
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 	bdi_queue_work(sb->s_bdi, &work);
 	wait_for_completion(&done);
 }
@@ -1325,7 +1325,7 @@ void sync_inodes_sb(struct super_block *sb)
 		.reason		= WB_REASON_SYNC,
 	};
 
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	bdi_queue_work(sb->s_bdi, &work);
 	wait_for_completion(&done);
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 5f3368a..b566364 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -36,7 +36,7 @@ static struct fuse_conn *fuse_get_conn(struct file *file)
 
 static void fuse_request_init(struct fuse_req *req)
 {
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 	INIT_LIST_HEAD(&req->list);
 	INIT_LIST_HEAD(&req->intr_entry);
 	init_waitqueue_head(&req->waitq);
@@ -331,7 +331,7 @@ __acquires(fc->lock)
 		return;
 
 	spin_unlock(&fc->lock);
-	wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
+	(void)wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
 	spin_lock(&fc->lock);
 }
 
@@ -549,7 +549,7 @@ static void fuse_copy_init(struct fuse_copy_state *cs, struct fuse_conn *fc,
 			   int write,
 			   const struct iovec *iov, unsigned long nr_segs)
 {
-	memset(cs, 0, sizeof(*cs));
+	(void)memset(cs, 0, sizeof(*cs));
 	cs->fc = fc;
 	cs->write = write;
 	cs->iov = iov;
@@ -957,8 +957,8 @@ __releases(fc->lock)
 
 	list_del_init(&req->intr_entry);
 	req->intr_unique = fuse_get_unique(fc);
-	memset(&ih, 0, sizeof(ih));
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&ih, 0, sizeof(ih));
+	(void)memset(&arg, 0, sizeof(arg));
 	ih.len = reqsize;
 	ih.opcode = FUSE_INTERRUPT;
 	ih.unique = req->intr_unique;
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index 2066328..d90d1e3 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -116,7 +116,7 @@ static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_req *req,
 			     u64 nodeid, struct qstr *name,
 			     struct fuse_entry_out *outarg)
 {
-	memset(outarg, 0, sizeof(struct fuse_entry_out));
+	(void)memset(outarg, 0, sizeof(struct fuse_entry_out));
 	req->in.h.opcode = FUSE_LOOKUP;
 	req->in.h.nodeid = nodeid;
 	req->in.numargs = 1;
@@ -408,8 +408,8 @@ static int fuse_create_open(struct inode *dir, struct dentry *entry,
 		mode &= ~current_umask();
 
 	flags &= ~O_NOCTTY;
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outentry, 0, sizeof(outentry));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outentry, 0, sizeof(outentry));
 	inarg.flags = flags;
 	inarg.mode = mode;
 	inarg.umask = current_umask();
@@ -493,7 +493,7 @@ static int create_new_entry(struct fuse_conn *fc, struct fuse_req *req,
 		return -ENOMEM;
 	}
 
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	req->in.h.nodeid = get_node_id(dir);
 	req->out.numargs = 1;
 	if (fc->minor < 9)
@@ -559,7 +559,7 @@ static int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,
 	if (!fc->dont_mask)
 		mode &= ~current_umask();
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
 	inarg.rdev = new_encode_dev(rdev);
 	inarg.umask = current_umask();
@@ -596,7 +596,7 @@ static int fuse_mkdir(struct inode *dir, struct dentry *entry, umode_t mode)
 	if (!fc->dont_mask)
 		mode &= ~current_umask();
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
 	inarg.umask = current_umask();
 	req->in.h.opcode = FUSE_MKDIR;
@@ -695,7 +695,7 @@ static int fuse_rename(struct inode *olddir, struct dentry *oldent,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.newdir = get_node_id(newdir);
 	req->in.h.opcode = FUSE_RENAME;
 	req->in.h.nodeid = get_node_id(olddir);
@@ -747,7 +747,7 @@ static int fuse_link(struct dentry *entry, struct inode *newdir,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.oldnodeid = get_node_id(inode);
 	req->in.h.opcode = FUSE_LINK;
 	req->in.numargs = 2;
@@ -804,8 +804,8 @@ static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
 
 	attr_version = fuse_get_attr_version(fc);
 
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	/* Directories have separate file-handle space */
 	if (file && S_ISREG(inode->i_mode)) {
 		struct fuse_file *ff = file->private_data;
@@ -982,7 +982,7 @@ static int fuse_access(struct inode *inode, int mask)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);
 	req->in.h.opcode = FUSE_ACCESS;
 	req->in.h.nodeid = get_node_id(inode);
@@ -1366,8 +1366,8 @@ static int fuse_do_setattr(struct dentry *entry, struct iattr *attr,
 	if (is_truncate)
 		fuse_set_nowrite(inode);
 
-	memset(&inarg, 0, sizeof(inarg));
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	iattr_to_fattr(attr, &inarg);
 	if (file) {
 		struct fuse_file *ff = file->private_data;
@@ -1471,7 +1471,7 @@ static int fuse_setxattr(struct dentry *entry, const char *name,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	inarg.flags = flags;
 	req->in.h.opcode = FUSE_SETXATTR;
@@ -1510,7 +1510,7 @@ static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	req->in.h.opcode = FUSE_GETXATTR;
 	req->in.h.nodeid = get_node_id(inode);
@@ -1562,7 +1562,7 @@ static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.size = size;
 	req->in.h.opcode = FUSE_LISTXATTR;
 	req->in.h.nodeid = get_node_id(inode);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 4a199fd..7cd10cc 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -29,7 +29,7 @@ static int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);
 	if (!fc->atomic_o_trunc)
 		inarg.flags &= ~O_TRUNC;
@@ -283,7 +283,7 @@ static int fuse_release(struct inode *inode, struct file *file)
 
 void fuse_sync_release(struct fuse_file *ff, int flags)
 {
-	WARN_ON(atomic_read(&ff->count) > 1);
+	(void)WARN_ON(atomic_read(&ff->count) > 1);
 	fuse_prepare_release(ff, flags, FUSE_RELEASE);
 	ff->reserved_req->force = 1;
 	fuse_request_send(ff->fc, ff->reserved_req);
@@ -373,7 +373,7 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 		return 0;
 
 	req = fuse_get_req_nofail(fc, file);
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.fh = ff->fh;
 	inarg.lock_owner = fuse_lock_owner_id(fc, id);
 	req->in.h.opcode = FUSE_FLUSH;
@@ -446,7 +446,7 @@ int fuse_fsync_common(struct file *file, loff_t start, loff_t end,
 		goto out;
 	}
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.fh = ff->fh;
 	inarg.fsync_flags = datasync ? 1 : 0;
 	req->in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;
@@ -937,7 +937,7 @@ static ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	ssize_t err;
 	struct iov_iter i;
 
-	WARN_ON(iocb->ki_pos != pos);
+	(void)WARN_ON(iocb->ki_pos != pos);
 
 	err = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);
 	if (err)
@@ -1530,7 +1530,7 @@ static sector_t fuse_bmap(struct address_space *mapping, sector_t block)
 	if (IS_ERR(req))
 		return 0;
 
-	memset(&inarg, 0, sizeof(inarg));
+	(void)memset(&inarg, 0, sizeof(inarg));
 	inarg.block = block;
 	inarg.blocksize = inode->i_sb->s_blocksize;
 	req->in.h.opcode = FUSE_BMAP;
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 64cf8d0..90e2abb 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -379,7 +379,7 @@ static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
-	memset(&outarg, 0, sizeof(outarg));
+	(void)memset(&outarg, 0, sizeof(outarg));
 	req->in.numargs = 0;
 	req->in.h.opcode = FUSE_STATFS;
 	req->in.h.nodeid = get_node_id(dentry->d_inode);
@@ -422,7 +422,7 @@ static const match_table_t tokens = {
 static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)
 {
 	char *p;
-	memset(d, 0, sizeof(struct fuse_mount_data));
+	(void)memset(d, 0, sizeof(struct fuse_mount_data));
 	d->max_read = ~0;
 	d->blksize = FUSE_DEFAULT_BLKSIZE;
 
@@ -517,7 +517,7 @@ static int fuse_show_options(struct seq_file *m, struct dentry *root)
 
 void fuse_conn_init(struct fuse_conn *fc)
 {
-	memset(fc, 0, sizeof(*fc));
+	(void)memset(fc, 0, sizeof(*fc));
 	spin_lock_init(&fc->lock);
 	mutex_init(&fc->inst_mutex);
 	init_rwsem(&fc->killsb);
@@ -565,7 +565,7 @@ EXPORT_SYMBOL_GPL(fuse_conn_get);
 static struct inode *fuse_get_root_inode(struct super_block *sb, unsigned mode)
 {
 	struct fuse_attr attr;
-	memset(&attr, 0, sizeof(attr));
+	(void)memset(&attr, 0, sizeof(attr));
 
 	attr.mode = mode;
 	attr.ino = FUSE_ROOT_ID;
diff --git a/fs/inode.c b/fs/inode.c
index fb10d86..7c9cd50 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -244,7 +244,7 @@ void __destroy_inode(struct inode *inode)
 	security_inode_free(inode);
 	fsnotify_inode_delete(inode);
 	if (!inode->i_nlink) {
-		WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
+		(void)WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
 		atomic_long_dec(&inode->i_sb->s_remove_count);
 	}
 
@@ -287,7 +287,7 @@ static void destroy_inode(struct inode *inode)
  */
 void drop_nlink(struct inode *inode)
 {
-	WARN_ON(inode->i_nlink == 0);
+	(void)WARN_ON(inode->i_nlink == 0);
 	inode->__i_nlink--;
 	if (!inode->i_nlink)
 		atomic_long_inc(&inode->i_sb->s_remove_count);
@@ -352,7 +352,7 @@ EXPORT_SYMBOL(inc_nlink);
 
 void address_space_init_once(struct address_space *mapping)
 {
-	memset(mapping, 0, sizeof(*mapping));
+	(void)memset(mapping, 0, sizeof(*mapping));
 	INIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);
 	spin_lock_init(&mapping->tree_lock);
 	mutex_init(&mapping->i_mmap_mutex);
@@ -370,7 +370,7 @@ EXPORT_SYMBOL(address_space_init_once);
  */
 void inode_init_once(struct inode *inode)
 {
-	memset(inode, 0, sizeof(*inode));
+	(void)memset(inode, 0, sizeof(*inode));
 	INIT_HLIST_NODE(&inode->i_hash);
 	INIT_LIST_HEAD(&inode->i_devices);
 	INIT_LIST_HEAD(&inode->i_wb_list);
@@ -403,7 +403,7 @@ void __iget(struct inode *inode)
  */
 void ihold(struct inode *inode)
 {
-	WARN_ON(atomic_inc_return(&inode->i_count) < 2);
+	(void)WARN_ON(atomic_inc_return(&inode->i_count) < 2);
 }
 EXPORT_SYMBOL(ihold);
 
@@ -760,7 +760,7 @@ void prune_icache_sb(struct super_block *sb, int nr_to_scan)
 				continue;
 			}
 		}
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state |= I_FREEING;
 		spin_unlock(&inode->i_lock);
 
@@ -964,7 +964,7 @@ void unlock_new_inode(struct inode *inode)
 {
 	lockdep_annotate_inode_mutex_key(inode);
 	spin_lock(&inode->i_lock);
-	WARN_ON(!(inode->i_state & I_NEW));
+	(void)WARN_ON(!(inode->i_state & I_NEW));
 	inode->i_state &= ~I_NEW;
 	wake_up_bit(&inode->i_state, __I_NEW);
 	spin_unlock(&inode->i_lock);
@@ -1395,7 +1395,7 @@ static void iput_final(struct inode *inode)
 	const struct super_operations *op = inode->i_sb->s_op;
 	int drop;
 
-	WARN_ON(inode->i_state & I_NEW);
+	(void)WARN_ON(inode->i_state & I_NEW);
 
 	if (op->drop_inode)
 		drop = op->drop_inode(inode);
@@ -1415,7 +1415,7 @@ static void iput_final(struct inode *inode)
 		spin_unlock(&inode->i_lock);
 		write_inode_now(inode, 1);
 		spin_lock(&inode->i_lock);
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state &= ~I_WILL_FREE;
 	}
 
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 066836e..7c38139 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -104,7 +104,7 @@ int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,
 	if (flags & SET_NOT_ALIGNED_FLAGS)
 		flags |= FIEMAP_EXTENT_NOT_ALIGNED;
 
-	memset(&extent, 0, sizeof(extent));
+	(void)memset(&extent, 0, sizeof(extent));
 	extent.fe_logical = logical;
 	extent.fe_physical = phys;
 	extent.fe_length = len;
@@ -288,7 +288,7 @@ int __generic_block_fiemap(struct inode *inode,
 		 * we set b_size to the total size we want so it will map as
 		 * many contiguous blocks as possible at once
 		 */
-		memset(&map_bh, 0, sizeof(struct buffer_head));
+		(void)memset(&map_bh, 0, sizeof(struct buffer_head));
 		map_bh.b_size = len;
 
 		ret = get_block(inode, start_blk, &map_bh, 0);
diff --git a/fs/jbd/checkpoint.c b/fs/jbd/checkpoint.c
index 5d1a00a..a294934 100644
--- a/fs/jbd/checkpoint.c
+++ b/fs/jbd/checkpoint.c
@@ -167,7 +167,7 @@ void __log_wait_for_space(journal_t *journal)
 				       __func__, nblocks, space_left);
 				printk(KERN_ERR "%s: no way to get more "
 				       "journal space\n", __func__);
-				WARN_ON(1);
+				(void)WARN_ON(1);
 				journal_abort(journal, 0);
 			}
 			spin_lock(&journal->j_state_lock);
diff --git a/fs/jbd/journal.c b/fs/jbd/journal.c
index 59c09f9..05c4985 100644
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -461,7 +461,7 @@ int __log_start_commit(journal_t *journal, tid_t target)
 		/* This should never happen, but if it does, preserve
 		   the evidence before kjournald goes into a loop and
 		   increments j_commit_sequence beyond all recognition. */
-		WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
+		(void)WARN_ONCE(1, "jbd: bad log_start_commit: %u %u %u %u\n",
 		    journal->j_commit_request, journal->j_commit_sequence,
 		    target, journal->j_running_transaction ?
 		    journal->j_running_transaction->t_tid : 0);
@@ -690,7 +690,7 @@ struct journal_head *journal_get_descriptor_buffer(journal_t *journal)
 	if (!bh)
 		return NULL;
 	lock_buffer(bh);
-	memset(bh->b_data, 0, journal->j_blocksize);
+	(void)memset(bh->b_data, 0, journal->j_blocksize);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
 	BUFFER_TRACE(bh, "return this buffer");
@@ -967,7 +967,7 @@ int journal_create(journal_t *journal)
 		if (unlikely(!bh))
 			return -ENOMEM;
 		lock_buffer(bh);
-		memset (bh->b_data, 0, journal->j_blocksize);
+		(void)memset (bh->b_data, 0, journal->j_blocksize);
 		BUFFER_TRACE(bh, "marking dirty");
 		mark_buffer_dirty(bh);
 		BUFFER_TRACE(bh, "marking uptodate");
@@ -1426,7 +1426,7 @@ static int journal_convert_superblock_v1(journal_t *journal,
 	/* Pre-initialise new fields to zero */
 	offset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);
 	blocksize = be32_to_cpu(sb->s_blocksize);
-	memset(&sb->s_feature_compat, 0, blocksize-offset);
+	(void)memset(&sb->s_feature_compat, 0, blocksize-offset);
 
 	sb->s_nr_users = cpu_to_be32(1);
 	sb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);
@@ -1845,7 +1845,7 @@ struct journal_head *journal_add_journal_head(struct buffer_head *bh)
 repeat:
 	if (!buffer_jbd(bh)) {
 		new_jh = journal_alloc_journal_head();
-		memset(new_jh, 0, sizeof(*new_jh));
+		(void)memset(new_jh, 0, sizeof(*new_jh));
 	}
 
 	jbd_lock_bh_journal_head(bh);
diff --git a/fs/jbd/recovery.c b/fs/jbd/recovery.c
index 5b43e96..6337578 100644
--- a/fs/jbd/recovery.c
+++ b/fs/jbd/recovery.c
@@ -227,7 +227,7 @@ int journal_recover(journal_t *journal)
 
 	struct recovery_info	info;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	sb = journal->j_superblock;
 
 	/*
@@ -285,7 +285,7 @@ int journal_skip_recovery(journal_t *journal)
 	int			err;
 	struct recovery_info	info;
 
-	memset (&info, 0, sizeof(info));
+	(void)memset (&info, 0, sizeof(info));
 
 	err = do_one_pass(journal, &info, PASS_SCAN);
 
diff --git a/fs/jbd/transaction.c b/fs/jbd/transaction.c
index 7fce94b..dc5e823 100644
--- a/fs/jbd/transaction.c
+++ b/fs/jbd/transaction.c
@@ -245,7 +245,7 @@ static handle_t *new_handle(int nblocks)
 	handle_t *handle = jbd_alloc_handle(GFP_NOFS);
 	if (!handle)
 		return NULL;
-	memset(handle, 0, sizeof(*handle));
+	(void)memset(handle, 0, sizeof(*handle));
 	handle->h_buffer_credits = nblocks;
 	handle->h_ref = 1;
 
@@ -714,7 +714,7 @@ done:
 		int offset;
 		char *source;
 
-		J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
+		(void)J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
 			    "Possible IO failure.\n");
 		page = jh2bh(jh)->b_page;
 		offset = offset_in_page(jh2bh(jh)->b_data);
diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index d49d202..552bfab 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -168,7 +168,7 @@ void __jbd2_log_wait_for_space(journal_t *journal)
 				printk(KERN_ERR "%s: no way to get more "
 				       "journal space in %s\n", __func__,
 				       journal->j_devname);
-				WARN_ON(1);
+				(void)WARN_ON(1);
 				jbd2_journal_abort(journal, 0);
 			}
 			write_lock(&journal->j_state_lock);
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index c0a5f9f..c37fede 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -737,7 +737,7 @@ struct journal_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)
 	if (!bh)
 		return NULL;
 	lock_buffer(bh);
-	memset(bh->b_data, 0, journal->j_blocksize);
+	(void)memset(bh->b_data, 0, journal->j_blocksize);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
 	BUFFER_TRACE(bh, "return this buffer");
@@ -1590,7 +1590,7 @@ static int journal_convert_superblock_v1(journal_t *journal,
 	/* Pre-initialise new fields to zero */
 	offset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);
 	blocksize = be32_to_cpu(sb->s_blocksize);
-	memset(&sb->s_feature_compat, 0, blocksize-offset);
+	(void)memset(&sb->s_feature_compat, 0, blocksize-offset);
 
 	sb->s_nr_users = cpu_to_be32(1);
 	sb->s_header.h_blocktype = cpu_to_be32(JBD2_SUPERBLOCK_V2);
@@ -2121,7 +2121,7 @@ struct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh)
 repeat:
 	if (!buffer_jbd(bh)) {
 		new_jh = journal_alloc_journal_head();
-		memset(new_jh, 0, sizeof(*new_jh));
+		(void)memset(new_jh, 0, sizeof(*new_jh));
 	}
 
 	jbd_lock_bh_journal_head(bh);
diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c
index da6d7ba..f3d5080 100644
--- a/fs/jbd2/recovery.c
+++ b/fs/jbd2/recovery.c
@@ -229,7 +229,7 @@ int jbd2_journal_recover(journal_t *journal)
 
 	struct recovery_info	info;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	sb = journal->j_superblock;
 
 	/*
@@ -288,7 +288,7 @@ int jbd2_journal_skip_recovery(journal_t *journal)
 
 	struct recovery_info	info;
 
-	memset (&info, 0, sizeof(info));
+	(void)memset (&info, 0, sizeof(info));
 
 	err = do_one_pass(journal, &info, PASS_SCAN);
 
diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 35ae096..efb307c 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -296,7 +296,7 @@ static handle_t *new_handle(int nblocks)
 	handle_t *handle = jbd2_alloc_handle(GFP_NOFS);
 	if (!handle)
 		return NULL;
-	memset(handle, 0, sizeof(*handle));
+	(void)memset(handle, 0, sizeof(*handle));
 	handle->h_buffer_credits = nblocks;
 	handle->h_ref = 1;
 
@@ -779,7 +779,7 @@ done:
 		int offset;
 		char *source;
 
-		J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
+		(void)J_EXPECT_JH(jh, buffer_uptodate(jh2bh(jh)),
 			    "Possible IO failure.\n");
 		page = jh2bh(jh)->b_page;
 		offset = offset_in_page(jh2bh(jh)->b_data);
diff --git a/fs/jffs2/compr.c b/fs/jffs2/compr.c
index 5b6c9d1..d06dfbf 100644
--- a/fs/jffs2/compr.c
+++ b/fs/jffs2/compr.c
@@ -266,7 +266,7 @@ int jffs2_decompress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 		none_stat_decompr_blocks++;
 		break;
 	case JFFS2_COMPR_ZERO:
-		memset(data_out, 0, datalen);
+		(void)memset(data_out, 0, datalen);
 		break;
 	default:
 		spin_lock(&jffs2_compressor_list_lock);
diff --git a/fs/jffs2/compr_rtime.c b/fs/jffs2/compr_rtime.c
index 16a5047..cc3cc46 100644
--- a/fs/jffs2/compr_rtime.c
+++ b/fs/jffs2/compr_rtime.c
@@ -37,7 +37,7 @@ static int jffs2_rtime_compress(unsigned char *data_in,
 	int outpos = 0;
 	int pos=0;
 
-	memset(positions,0,sizeof(positions));
+	(void)memset(positions,0,sizeof(positions));
 
 	while (pos < (*sourcelen) && outpos <= (*dstlen)-2) {
 		int backpos, runlen=0;
@@ -78,7 +78,7 @@ static int jffs2_rtime_decompress(unsigned char *data_in,
 	int outpos = 0;
 	int pos=0;
 
-	memset(positions,0,sizeof(positions));
+	(void)memset(positions,0,sizeof(positions));
 
 	while (outpos<destlen) {
 		unsigned char value;
diff --git a/fs/jffs2/erase.c b/fs/jffs2/erase.c
index a01cdad..91ba7a2 100644
--- a/fs/jffs2/erase.c
+++ b/fs/jffs2/erase.c
@@ -62,7 +62,7 @@ static void jffs2_erase_block(struct jffs2_sb_info *c,
 		return;
 	}
 
-	memset(instr, 0, sizeof(*instr));
+	(void)memset(instr, 0, sizeof(*instr));
 
 	instr->mtd = c->mtd;
 	instr->addr = jeb->offset;
diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 61e6723..94a072b 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -162,7 +162,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 			goto out_page;
 
 		mutex_lock(&f->sem);
-		memset(&ri, 0, sizeof(ri));
+		(void)memset(&ri, 0, sizeof(ri));
 
 		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 		ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 2e01238..28fca94 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -427,7 +427,7 @@ struct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode, struct jffs2_r
 	jffs2_init_inode_info(f);
 	mutex_lock(&f->sem);
 
-	memset(ri, 0, sizeof(*ri));
+	(void)memset(ri, 0, sizeof(*ri));
 	/* Set OS-specific defaults for new inodes */
 	ri->uid = cpu_to_je16(current_fsuid());
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 31dce61..ef2115d 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -759,7 +759,7 @@ static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_
 	else
 		ilen = JFFS2_F_I_SIZE(f);
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 	ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 	ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
 	ri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);
@@ -967,7 +967,7 @@ static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eras
 	D1(printk(KERN_DEBUG "Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\n",
 		  f->inocache->ino, start, end));
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 
 	if(fn->frags > 1) {
 		size_t readlen;
@@ -1115,7 +1115,7 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 	unsigned long pg;
 	unsigned char *pg_ptr;
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 
 	D1(printk(KERN_DEBUG "Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\n",
 		  f->inocache->ino, start, end));
diff --git a/fs/jffs2/read.c b/fs/jffs2/read.c
index 3f39be1..a1d88cd 100644
--- a/fs/jffs2/read.c
+++ b/fs/jffs2/read.c
@@ -74,7 +74,7 @@ int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 
 
 	if (ri->compr == JFFS2_COMPR_ZERO) {
-		memset(buf, 0, len);
+		(void)memset(buf, 0, len);
 		goto out_ri;
 	}
 
@@ -177,14 +177,14 @@ int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 				holesize = min(holesize, frag->ofs - offset);
 			}
 			D1(printk(KERN_DEBUG "Filling non-frag hole from %d-%d\n", offset, offset+holesize));
-			memset(buf, 0, holesize);
+			(void)memset(buf, 0, holesize);
 			buf += holesize;
 			offset += holesize;
 			continue;
 		} else if (unlikely(!frag->node)) {
 			uint32_t holeend = min(end, frag->ofs + frag->size);
 			D1(printk(KERN_DEBUG "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n", offset, holeend, frag->ofs, frag->ofs + frag->size));
-			memset(buf, 0, holeend - offset);
+			(void)memset(buf, 0, holeend - offset);
 			buf += holeend - offset;
 			offset = holeend;
 			frag = frag_next(frag);
@@ -202,7 +202,7 @@ int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			D2(printk(KERN_DEBUG "node read done\n"));
 			if (ret) {
 				D1(printk(KERN_DEBUG"jffs2_read_inode_range error %d\n",ret));
-				memset(buf, 0, readlen);
+				(void)memset(buf, 0, readlen);
 				return ret;
 			}
 			buf += readlen;
diff --git a/fs/jffs2/readinode.c b/fs/jffs2/readinode.c
index 3093ac4..2e244dc 100644
--- a/fs/jffs2/readinode.c
+++ b/fs/jffs2/readinode.c
@@ -1149,7 +1149,7 @@ static int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,
 	dbg_readinode("ino #%u pino/nlink is %d\n", f->inocache->ino,
 		      f->inocache->pino_nlink);
 
-	memset(&rii, 0, sizeof(rii));
+	(void)memset(&rii, 0, sizeof(rii));
 
 	/* Grab all nodes relevant to this ino */
 	ret = jffs2_get_inode_nodes(c, f, &rii);
@@ -1381,7 +1381,7 @@ int jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			return -ENOMEM;
 		}
 		dbg_readinode("creating inocache for root inode\n");
-		memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
+		(void)memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
 		f->inocache->ino = f->inocache->pino_nlink = 1;
 		f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
 		f->inocache->state = INO_STATE_READING;
diff --git a/fs/jffs2/scan.c b/fs/jffs2/scan.c
index f994648..ab29f45 100644
--- a/fs/jffs2/scan.c
+++ b/fs/jffs2/scan.c
@@ -938,7 +938,7 @@ struct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uin
 		printk(KERN_NOTICE "jffs2_scan_make_inode_cache(): allocation of inode cache failed\n");
 		return NULL;
 	}
-	memset(ic, 0, sizeof(*ic));
+	(void)memset(ic, 0, sizeof(*ic));
 
 	ic->ino = ino;
 	ic->nodes = (void *)ic;
diff --git a/fs/jffs2/super.c b/fs/jffs2/super.c
index f2d96b5..d6b7628 100644
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@ -91,7 +91,7 @@ static const char *jffs2_compr_name(unsigned int compr)
 #endif
 	default:
 		/* should never happen; programmer error */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return "";
 	}
 }
diff --git a/fs/jffs2/wbuf.c b/fs/jffs2/wbuf.c
index 30e8f47..b932596 100644
--- a/fs/jffs2/wbuf.c
+++ b/fs/jffs2/wbuf.c
@@ -601,7 +601,7 @@ static int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)
 
 		/* Pad with JFFS2_DIRTY_BITMASK initially.  this helps out ECC'd NOR
 		   with 8 byte page size */
-		memset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);
+		(void)memset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);
 
 		if ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {
 			struct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);
@@ -677,7 +677,7 @@ static int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)
 	jffs2_clear_wbuf_ino_list(c);
 	spin_unlock(&c->erase_completion_lock);
 
-	memset(c->wbuf,0xff,c->wbuf_pagesize);
+	(void)memset(c->wbuf,0xff,c->wbuf_pagesize);
 	/* adjust write buffer offset, else we get a non contiguous write bug */
 	c->wbuf_ofs += c->wbuf_pagesize;
 	c->wbuf_len = 0;
@@ -798,7 +798,7 @@ int jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,
 	if (c->wbuf_ofs == 0xFFFFFFFF) {
 		c->wbuf_ofs = PAGE_DIV(to);
 		c->wbuf_len = PAGE_MOD(to);
-		memset(c->wbuf,0xff,c->wbuf_pagesize);
+		(void)memset(c->wbuf,0xff,c->wbuf_pagesize);
 	}
 
 	/*
diff --git a/fs/jffs2/write.c b/fs/jffs2/write.c
index 30d175b..3b81141 100644
--- a/fs/jffs2/write.c
+++ b/fs/jffs2/write.c
@@ -28,7 +28,7 @@ int jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 		return -ENOMEM;
 	}
 
-	memset(ic, 0, sizeof(*ic));
+	(void)memset(ic, 0, sizeof(*ic));
 
 	f->inocache = ic;
 	f->inocache->pino_nlink = 1; /* Will be overwritten shortly for directories */
@@ -222,7 +222,7 @@ struct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jff
 		printk(KERN_CRIT "Directory inode #%u, name at *0x%p \"%s\"->ino #%u, name_crc 0x%08x\n",
 		       je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),
 		       je32_to_cpu(rd->name_crc));
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return ERR_PTR(-EIO);
 	}
 
diff --git a/fs/libfs.c b/fs/libfs.c
index 5b2dbb3..4a42414 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -362,7 +362,7 @@ int simple_setattr(struct dentry *dentry, struct iattr *iattr)
 	struct inode *inode = dentry->d_inode;
 	int error;
 
-	WARN_ON_ONCE(inode->i_op->truncate);
+	(void)WARN_ON_ONCE(inode->i_op->truncate);
 
 	error = inode_change_ok(inode, iattr);
 	if (error)
diff --git a/fs/lockd/clnt4xdr.c b/fs/lockd/clnt4xdr.c
index f848b52..361470b 100644
--- a/fs/lockd/clnt4xdr.c
+++ b/fs/lockd/clnt4xdr.c
@@ -183,7 +183,7 @@ static int decode_cookie(struct xdr_stream *xdr,
 	return 0;
 out_hpux:
 	cookie->len = 4;
-	memset(cookie->data, 0, 4);
+	(void)memset(cookie->data, 0, 4);
 	return 0;
 out_size:
 	dprintk("NFS: returned cookie was too long: %u\n", length);
@@ -290,7 +290,7 @@ static int decode_nlm4_holder(struct xdr_stream *xdr, struct nlm_res *result)
 	__be32 *p;
 	s32 end;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(fl);
 
 	p = xdr_inline_decode(xdr, 4 + 4);
diff --git a/fs/lockd/clntproc.c b/fs/lockd/clntproc.c
index 8392cb8..2f03ae8 100644
--- a/fs/lockd/clntproc.c
+++ b/fs/lockd/clntproc.c
@@ -622,7 +622,7 @@ nlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl)
 	int		status;
 
 	req = &reqst;
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 	locks_init_lock(&req->a_args.lock.fl);
 	locks_init_lock(&req->a_res.lock.fl);
 	req->a_host  = host;
diff --git a/fs/lockd/clntxdr.c b/fs/lockd/clntxdr.c
index 180ac34..39bacd5 100644
--- a/fs/lockd/clntxdr.c
+++ b/fs/lockd/clntxdr.c
@@ -180,7 +180,7 @@ static int decode_cookie(struct xdr_stream *xdr,
 	return 0;
 out_hpux:
 	cookie->len = 4;
-	memset(cookie->data, 0, 4);
+	(void)memset(cookie->data, 0, 4);
 	return 0;
 out_size:
 	dprintk("NFS: returned cookie was too long: %u\n", length);
@@ -284,7 +284,7 @@ static int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)
 	__be32 *p;
 	s32 end;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(fl);
 
 	p = xdr_inline_decode(xdr, 4 + 4);
diff --git a/fs/lockd/mon.c b/fs/lockd/mon.c
index 65ba36b..6fe8ba4 100644
--- a/fs/lockd/mon.c
+++ b/fs/lockd/mon.c
@@ -107,7 +107,7 @@ static int nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res)
 		goto out;
 	}
 
-	memset(res, 0, sizeof(*res));
+	(void)memset(res, 0, sizeof(*res));
 
 	msg.rpc_proc = &clnt->cl_procinfo[proc];
 	status = rpc_call_sync(clnt, &msg, 0);
diff --git a/fs/lockd/xdr.c b/fs/lockd/xdr.c
index 964666c..da4fb04 100644
--- a/fs/lockd/xdr.c
+++ b/fs/lockd/xdr.c
@@ -88,7 +88,7 @@ nlm_decode_fh(__be32 *p, struct nfs_fh *f)
 		return NULL;
 	}
 	f->size = NFS2_FHSIZE;
-	memset(f->data, 0, sizeof(f->data));
+	(void)memset(f->data, 0, sizeof(f->data));
 	memcpy(f->data, p, NFS2_FHSIZE);
 	return p + XDR_QUADLEN(NFS2_FHSIZE);
 }
@@ -263,7 +263,7 @@ nlmsvc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(&lock->fl);
 	lock->svid = ~(u32) 0;
 	lock->fl.fl_pid = (pid_t)lock->svid;
diff --git a/fs/lockd/xdr4.c b/fs/lockd/xdr4.c
index dfa4789..d552084 100644
--- a/fs/lockd/xdr4.c
+++ b/fs/lockd/xdr4.c
@@ -82,7 +82,7 @@ nlm4_encode_cookie(__be32 *p, struct nlm_cookie *c)
 static __be32 *
 nlm4_decode_fh(__be32 *p, struct nfs_fh *f)
 {
-	memset(f->data, 0, sizeof(f->data));
+	(void)memset(f->data, 0, sizeof(f->data));
 	f->size = ntohl(*p++);
 	if (f->size > NFS_MAXFHSIZE) {
 		dprintk("lockd: bad fhandle size %d (should be <=%d)\n",
@@ -254,7 +254,7 @@ nlm4svc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(&lock->fl);
 	lock->svid = ~(u32) 0;
 	lock->fl.fl_pid = (pid_t)lock->svid;
diff --git a/fs/locks.c b/fs/locks.c
index 637694b..9a0f6b5 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -223,7 +223,7 @@ EXPORT_SYMBOL(locks_free_lock);
 
 void locks_init_lock(struct file_lock *fl)
 {
-	memset(fl, 0, sizeof(struct file_lock));
+	(void)memset(fl, 0, sizeof(struct file_lock));
 	locks_init_lock_heads(fl);
 }
 
diff --git a/fs/minix/bitmap.c b/fs/minix/bitmap.c
index 4bc50da..2c1f588 100644
--- a/fs/minix/bitmap.c
+++ b/fs/minix/bitmap.c
@@ -255,7 +255,7 @@ struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)
 	inode->i_ino = j;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 	inode->i_blocks = 0;
-	memset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));
+	(void)memset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
 
diff --git a/fs/minix/dir.c b/fs/minix/dir.c
index 085a926..c529091 100644
--- a/fs/minix/dir.c
+++ b/fs/minix/dir.c
@@ -276,10 +276,10 @@ got_it:
 		goto out_unlock;
 	memcpy (namx, name, namelen);
 	if (sbi->s_version == MINIX_V3) {
-		memset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);
+		(void)memset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);
 		de3->inode = inode->i_ino;
 	} else {
-		memset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);
+		(void)memset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);
 		de->inode = inode->i_ino;
 	}
 	err = dir_commit_chunk(page, pos, sbi->s_dirsize);
diff --git a/fs/minix/itree_common.c b/fs/minix/itree_common.c
index a731cab..806686b 100644
--- a/fs/minix/itree_common.c
+++ b/fs/minix/itree_common.c
@@ -85,7 +85,7 @@ static int alloc_branch(struct inode *inode,
 		branch[n].key = cpu_to_block(nr);
 		bh = sb_getblk(inode->i_sb, parent);
 		lock_buffer(bh);
-		memset(bh->b_data, 0, bh->b_size);
+		(void)memset(bh->b_data, 0, bh->b_size);
 		branch[n].bh = bh;
 		branch[n].p = (block_t*) bh->b_data + offsets[n];
 		*branch[n].p = branch[n].key;
diff --git a/fs/namei.c b/fs/namei.c
index 208c6aa..c5c1982 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1776,7 +1776,7 @@ struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
 	unsigned long hash;
 	unsigned int c;
 
-	WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
+	(void)WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
 
 	this.name = name;
 	this.len = len;
diff --git a/fs/namespace.c b/fs/namespace.c
index e608199..6597abe 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -792,7 +792,7 @@ static inline void mntfree(struct mount *mnt)
 	 * The locking used to deal with mnt_count decrement provides barriers,
 	 * so mnt_get_writers() below is safe.
 	 */
-	WARN_ON(mnt_get_writers(mnt));
+	(void)WARN_ON(mnt_get_writers(mnt));
 	fsnotify_vfsmount_delete(m);
 	dput(m->mnt_root);
 	free_vfsmnt(mnt);
@@ -2048,7 +2048,7 @@ static long exact_copy_from_user(void *to, const void __user * from,
 
 	while (n) {
 		if (__get_user(c, f)) {
-			memset(t, 0, n);
+			(void)memset(t, 0, n);
 			break;
 		}
 		*t++ = c;
@@ -2086,7 +2086,7 @@ int copy_mount_options(const void __user * data, unsigned long *where)
 		return -EFAULT;
 	}
 	if (i != PAGE_SIZE)
-		memset((char *)page + i, 0, PAGE_SIZE - i);
+		(void)memset((char *)page + i, 0, PAGE_SIZE - i);
 	*where = page;
 	return 0;
 }
diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c
index d50b274..042cc43 100644
--- a/fs/nfs/callback_xdr.c
+++ b/fs/nfs/callback_xdr.c
@@ -111,7 +111,7 @@ static __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)
 	if (unlikely(p == NULL))
 		return htonl(NFS4ERR_RESOURCE);
 	memcpy(&fh->data[0], p, fh->size);
-	memset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);
+	(void)memset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);
 	return 0;
 }
 
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index fd9a872..8636cb6 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -639,7 +639,7 @@ int nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page,
 		status = PTR_ERR(array);
 		goto out;
 	}
-	memset(array, 0, sizeof(struct nfs_cache_array));
+	(void)memset(array, 0, sizeof(struct nfs_cache_array));
 	array->eof_index = -1;
 
 	status = nfs_readdir_large_page(pages, array_size);
@@ -869,7 +869,7 @@ static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	 * to either find the entry with the appropriate number or
 	 * revalidate the cookie.
 	 */
-	memset(desc, 0, sizeof(*desc));
+	(void)memset(desc, 0, sizeof(*desc));
 
 	desc->file = filp;
 	desc->dir_cookie = &dir_ctx->dir_cookie;
@@ -1249,7 +1249,7 @@ static void nfs_d_release(struct dentry *dentry)
 	/* free cached devname value, if it survived that far */
 	if (unlikely(dentry->d_fsdata)) {
 		if (dentry->d_flags & DCACHE_NFSFS_RENAMED)
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		else
 			kfree(dentry->d_fsdata);
 	}
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 1940f1a..9031fa0 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -494,7 +494,7 @@ static void nfs_direct_write_reschedule(struct nfs_direct_req *dreq)
 		 */
 		nfs_fattr_init(&data->fattr);
 		data->res.count = data->args.count;
-		memset(&data->verf, 0, sizeof(data->verf));
+		(void)memset(&data->verf, 0, sizeof(data->verf));
 
 		/*
 		 * Reuse data->task; data->args should not have changed
diff --git a/fs/nfs/dns_resolve.c b/fs/nfs/dns_resolve.c
index a6e711a..18b3a90 100644
--- a/fs/nfs/dns_resolve.c
+++ b/fs/nfs/dns_resolve.c
@@ -234,7 +234,7 @@ static int nfs_dns_parse(struct cache_detail *cd, char *buf, int buflen)
 
 	key.hostname = buf1;
 	key.namelen = len;
-	memset(&key.h, 0, sizeof(key.h));
+	(void)memset(&key.h, 0, sizeof(key.h));
 
 	ttl = get_expiry(&buf);
 	if (ttl == 0)
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index f649fba..95ecd05 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -151,7 +151,7 @@ static void nfs_zap_caches_locked(struct inode *inode)
 	nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
 	nfsi->attrtimeo_timestamp = jiffies;
 
-	memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
+	(void)memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
 	if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
 	else
@@ -316,16 +316,16 @@ nfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)
 		else
 			init_special_inode(inode, inode->i_mode, fattr->rdev);
 
-		memset(&inode->i_atime, 0, sizeof(inode->i_atime));
-		memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
-		memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
+		(void)memset(&inode->i_atime, 0, sizeof(inode->i_atime));
+		(void)memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
+		(void)memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
 		inode->i_version = 0;
 		inode->i_size = 0;
 		clear_nlink(inode);
 		inode->i_uid = -2;
 		inode->i_gid = -2;
 		inode->i_blocks = 0;
-		memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
+		(void)memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
 
 		nfsi->read_cache_jiffies = fattr->time_start;
 		nfsi->attr_gencount = fattr->gencount;
@@ -859,7 +859,7 @@ static int nfs_invalidate_mapping(struct inode *inode, struct address_space *map
 	spin_lock(&inode->i_lock);
 	nfsi->cache_validity &= ~NFS_INO_INVALID_DATA;
 	if (S_ISDIR(inode->i_mode))
-		memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
+		(void)memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
 	spin_unlock(&inode->i_lock);
 	nfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);
 	nfs_fscache_reset_inode_cookie(inode);
diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
index 8102391..a5aaf78 100644
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@ -91,7 +91,7 @@ rename_retry:
 	if (!base) {
 		spin_unlock(&dentry->d_lock);
 		rcu_read_unlock();
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return end;
 	}
 	namelen = strlen(base);
diff --git a/fs/nfs/nfs3proc.c b/fs/nfs/nfs3proc.c
index 9194395..4f328eb 100644
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -33,7 +33,7 @@ nfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EJUKEBOX && res != -EKEYEXPIRED)
 			break;
-		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		(void)freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c
index 183c6b1..879be75 100644
--- a/fs/nfs/nfs3xdr.c
+++ b/fs/nfs/nfs3xdr.c
@@ -477,7 +477,7 @@ out_overflow:
 
 static void zero_nfs_fh3(struct nfs_fh *fh)
 {
-	memset(fh, 0, sizeof(*fh));
+	(void)memset(fh, 0, sizeof(*fh));
 }
 
 /*
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index f0c849c..7f2a6ad 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -182,7 +182,7 @@ static void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dent
 	}
 
 	readdir->cookie = 0;
-	memset(&readdir->verifier, 0, sizeof(readdir->verifier));
+	(void)memset(&readdir->verifier, 0, sizeof(readdir->verifier));
 	if (cookie == 2)
 		return;
 	
@@ -1159,8 +1159,8 @@ static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmod
 
 	opendata->o_arg.open_flags = 0;
 	opendata->o_arg.fmode = fmode;
-	memset(&opendata->o_res, 0, sizeof(opendata->o_res));
-	memset(&opendata->c_res, 0, sizeof(opendata->c_res));
+	(void)memset(&opendata->o_res, 0, sizeof(opendata->o_res));
+	(void)memset(&opendata->c_res, 0, sizeof(opendata->c_res));
 	nfs4_init_opendata_res(opendata);
 	ret = _nfs4_recover_proc_open(opendata);
 	if (ret != 0)
@@ -2338,7 +2338,7 @@ static int nfs4_get_referral(struct inode *dir, const struct qstr *name,
 
 	/* replace the lookup nfs_fattr with the locations nfs_fattr */
 	memcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));
-	memset(fhandle, 0, sizeof(struct nfs_fh));
+	(void)memset(fhandle, 0, sizeof(struct nfs_fh));
 out:
 	if (page)
 		__free_page(page);
@@ -2458,7 +2458,7 @@ static int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,
 
 void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr, struct nfs_fh *fh)
 {
-	memset(fh, 0, sizeof(struct nfs_fh));
+	(void)memset(fh, 0, sizeof(struct nfs_fh));
 	fattr->fsid.major = 1;
 	fattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |
 		NFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_FSID | NFS_ATTR_FATTR_MOUNTPOINT;
@@ -3173,7 +3173,7 @@ static int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle
 
 	/* None of the pathconf attributes are mandatory to implement */
 	if ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {
-		memset(pathconf, 0, sizeof(*pathconf));
+		(void)memset(pathconf, 0, sizeof(*pathconf));
 		return 0;
 	}
 
diff --git a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c
index 95e92e4..7ec1753 100644
--- a/fs/nfs/nfs4xdr.c
+++ b/fs/nfs/nfs4xdr.c
@@ -3343,7 +3343,7 @@ static int decode_attr_filehandle(struct xdr_stream *xdr, uint32_t *bitmap, stru
 	int len;
 
 	if (fh != NULL)
-		memset(fh, 0, sizeof(*fh));
+		(void)memset(fh, 0, sizeof(*fh));
 
 	if (unlikely(bitmap[0] & (FATTR4_WORD0_FILEHANDLE - 1U)))
 		return -EIO;
@@ -4568,7 +4568,7 @@ static int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)
 	int status;
 
 	/* Zero handle first to allow comparisons */
-	memset(fh, 0, sizeof(*fh));
+	(void)memset(fh, 0, sizeof(*fh));
 
 	status = decode_op_hdr(xdr, OP_GETFH);
 	if (status)
diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index 0c672588..c4daf72 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -60,7 +60,7 @@ nfs_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EKEYEXPIRED)
 			break;
-		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		(void)freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 3dfa4f1..e0c99fc 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -1784,7 +1784,7 @@ static int nfs_validate_mount_data(void *options,
 		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 			goto out_no_sec;
 	case 5:
-		memset(data->context, 0, sizeof(data->context));
+		(void)memset(data->context, 0, sizeof(data->context));
 	case 6:
 		if (data->flags & NFS_MOUNT_VER3) {
 			if (data->root.size > NFS3_FHSIZE || data->root.size == 0)
@@ -1799,7 +1799,7 @@ static int nfs_validate_mount_data(void *options,
 
 		memcpy(mntfh->data, data->root.data, mntfh->size);
 		if (mntfh->size < sizeof(mntfh->data))
-			memset(mntfh->data + mntfh->size, 0,
+			(void)memset(mntfh->data + mntfh->size, 0,
 			       sizeof(mntfh->data) - mntfh->size);
 
 		/*
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 834f0fe..cf5e76d 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -55,7 +55,7 @@ struct nfs_write_data *nfs_commitdata_alloc(void)
 	struct nfs_write_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOFS);
 
 	if (p) {
-		memset(p, 0, sizeof(*p));
+		(void)memset(p, 0, sizeof(*p));
 		INIT_LIST_HEAD(&p->pages);
 	}
 	return p;
@@ -75,7 +75,7 @@ struct nfs_write_data *nfs_writedata_alloc(unsigned int pagecount)
 	struct nfs_write_data *p = mempool_alloc(nfs_wdata_mempool, GFP_NOFS);
 
 	if (p) {
-		memset(p, 0, sizeof(*p));
+		(void)memset(p, 0, sizeof(*p));
 		INIT_LIST_HEAD(&p->pages);
 		p->npages = pagecount;
 		if (pagecount <= ARRAY_SIZE(p->page_array))
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 68454e7..566ed62 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -548,7 +548,7 @@ fh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,
 
 	if (fhp->fh_handle.fh_version == 0xca) {
 		/* old style filehandle please */
-		memset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);
+		(void)memset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);
 		fhp->fh_handle.fh_size = NFS_FHSIZE;
 		fhp->fh_handle.ofh_dcookie = 0xfeebbaca;
 		fhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);
diff --git a/fs/nfsd/nfsfh.h b/fs/nfsd/nfsfh.h
index e5e6707..c35ccbf 100644
--- a/fs/nfsd/nfsfh.h
+++ b/fs/nfsd/nfsfh.h
@@ -110,7 +110,7 @@ void	fh_put(struct svc_fh *);
 static __inline__ struct svc_fh *
 fh_copy(struct svc_fh *dst, struct svc_fh *src)
 {
-	WARN_ON(src->fh_dentry || src->fh_locked);
+	(void)WARN_ON(src->fh_dentry || src->fh_locked);
 			
 	*dst = *src;
 	return dst;
@@ -126,7 +126,7 @@ fh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)
 static __inline__ struct svc_fh *
 fh_init(struct svc_fh *fhp, int maxsize)
 {
-	memset(fhp, 0, sizeof(*fhp));
+	(void)memset(fhp, 0, sizeof(*fhp));
 	fhp->fh_maxsize = maxsize;
 	return fhp;
 }
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index eda7d7e..adb1729 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -311,7 +311,7 @@ int nfsd_create_serv(void)
 {
 	int err = 0;
 
-	WARN_ON(!mutex_is_locked(&nfsd_mutex));
+	(void)WARN_ON(!mutex_is_locked(&nfsd_mutex));
 	if (nfsd_serv) {
 		svc_get(nfsd_serv);
 		return 0;
@@ -370,7 +370,7 @@ int nfsd_set_nrthreads(int n, int *nthreads)
 	int tot = 0;
 	int err = 0;
 
-	WARN_ON(!mutex_is_locked(&nfsd_mutex));
+	(void)WARN_ON(!mutex_is_locked(&nfsd_mutex));
 
 	if (nfsd_serv == NULL || n <= 0)
 		return 0;
diff --git a/fs/notify/inotify/inotify_fsnotify.c b/fs/notify/inotify/inotify_fsnotify.c
index e3cbd74..fc0068e 100644
--- a/fs/notify/inotify/inotify_fsnotify.c
+++ b/fs/notify/inotify/inotify_fsnotify.c
@@ -177,7 +177,7 @@ static int idr_callback(int id, void *p, void *data)
 	fsn_mark = p;
 	i_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);
 
-	WARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "
+	(void)WARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "
 		"idr.  Probably leaking memory\n", id, p, data);
 
 	/*
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 8445fbc..3e94f2b 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -454,7 +454,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	 * if it wasn't....
 	 */
 	if (wd == -1) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
 			" i_mark->inode=%p\n", __func__, i_mark, i_mark->wd,
 			i_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);
 		goto out;
@@ -463,7 +463,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	/* Lets look in the idr to see if we find it */
 	found_i_mark = inotify_idr_find_locked(group, wd);
 	if (unlikely(!found_i_mark)) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
 			" i_mark->inode=%p\n", __func__, i_mark, i_mark->wd,
 			i_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);
 		goto out;
@@ -475,7 +475,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	 * fucked up somewhere.
 	 */
 	if (unlikely(found_i_mark != i_mark)) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p "
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p "
 			"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d "
 			"found_i_mark->group=%p found_i_mark->inode=%p\n",
 			__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index f104d56..72a14eb 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -328,7 +328,7 @@ void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *ol
 void fsnotify_init_mark(struct fsnotify_mark *mark,
 			void (*free_mark)(struct fsnotify_mark *mark))
 {
-	memset(mark, 0, sizeof(*mark));
+	(void)memset(mark, 0, sizeof(*mark));
 	spin_lock_init(&mark->lock);
 	atomic_set(&mark->refcnt, 1);
 	mark->free_mark = free_mark;
@@ -352,7 +352,7 @@ static int fsnotify_mark_destroy(void *ignored)
 			fsnotify_put_mark(mark);
 		}
 
-		wait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));
+		(void)wait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));
 	}
 
 	return 0;
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 9cde9edf..5d6910e 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -937,7 +937,7 @@ static ssize_t oom_adjust_write(struct file *file, const char __user *buf,
 	unsigned long flags;
 	int err;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count)) {
@@ -1038,7 +1038,7 @@ static ssize_t oom_score_adj_write(struct file *file, const char __user *buf,
 	int oom_score_adj;
 	int err;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count)) {
@@ -1384,7 +1384,7 @@ static ssize_t comm_write(struct file *file, const char __user *buf,
 	struct task_struct *p;
 	char buffer[TASK_COMM_LEN];
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
@@ -2739,7 +2739,7 @@ static ssize_t proc_coredump_filter_write(struct file *file,
 	unsigned long mask;
 
 	ret = -EFAULT;
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 2edf34f..7bde9be 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -320,7 +320,7 @@ static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,
 				break;
 		}
 		if (!de) {
-			WARN(1, "name '%s'\n", name);
+			(void)WARN(1, "name '%s'\n", name);
 			return -ENOENT;
 		}
 		cp += len + 1;
@@ -582,7 +582,7 @@ static int proc_register(struct proc_dir_entry * dir, struct proc_dir_entry * dp
 
 	for (tmp = dir->subdir; tmp; tmp = tmp->next)
 		if (strcmp(tmp->name, dp->name) == 0) {
-			WARN(1, KERN_WARNING "proc_dir_entry '%s/%s' already registered\n",
+			(void)WARN(1, KERN_WARNING "proc_dir_entry '%s/%s' already registered\n",
 				dir->name, dp->name);
 			break;
 		}
@@ -619,7 +619,7 @@ static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
 	ent = kmalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
 	if (!ent) goto out;
 
-	memset(ent, 0, sizeof(struct proc_dir_entry));
+	(void)memset(ent, 0, sizeof(struct proc_dir_entry));
 	memcpy(ent->name, fn, len + 1);
 	ent->namelen = len;
 	ent->mode = mode;
@@ -805,7 +805,7 @@ void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
 	}
 	spin_unlock(&proc_subdir_lock);
 	if (!de) {
-		WARN(1, "name '%s'\n", name);
+		(void)WARN(1, "name '%s'\n", name);
 		return;
 	}
 
@@ -844,7 +844,7 @@ void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
 	if (S_ISDIR(de->mode))
 		parent->nlink--;
 	de->nlink = 0;
-	WARN(de->subdir, KERN_WARNING "%s: removing non-empty directory "
+	(void)WARN(de->subdir, KERN_WARNING "%s: removing non-empty directory "
 			"'%s/%s', leaking at least '%s'\n", __func__,
 			de->parent->name, de->name, de->subdir->name);
 	pde_put(de);
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 7dcd2a2..97611cf 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -434,7 +434,7 @@ static int show_smap(struct seq_file *m, void *v)
 		.private = &mss,
 	};
 
-	memset(&mss, 0, sizeof mss);
+	(void)memset(&mss, 0, sizeof mss);
 	mss.vma = vma;
 	/* mmap_sem is held in m_start */
 	if (vma->vm_mm && !is_vm_hugetlb_page(vma))
@@ -544,7 +544,7 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 	int type;
 	int rv;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
diff --git a/fs/romfs/super.c b/fs/romfs/super.c
index bb36ab7..f4f8195 100644
--- a/fs/romfs/super.c
+++ b/fs/romfs/super.c
@@ -128,7 +128,7 @@ static int romfs_readpage(struct file *file, struct page *page)
 	}
 
 	if (fillsize < PAGE_SIZE)
-		memset(buf + fillsize, 0, PAGE_SIZE - fillsize);
+		(void)memset(buf + fillsize, 0, PAGE_SIZE - fillsize);
 	if (ret == 0)
 		SetPageUptodate(page);
 
diff --git a/fs/select.c b/fs/select.c
index d33418f..da03888 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -307,7 +307,7 @@ static int poll_select_copy_remaining(struct timespec *end_time, void __user *p,
 
 	if (timeval) {
 		if (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))
-			memset(&rtv, 0, sizeof(rtv));
+			(void)memset(&rtv, 0, sizeof(rtv));
 		rtv.tv_sec = rts.tv_sec;
 		rtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;
 
diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4023d6b..73974ac 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -37,7 +37,7 @@ int seq_open(struct file *file, const struct seq_operations *op)
 			return -ENOMEM;
 		file->private_data = p;
 	}
-	memset(p, 0, sizeof(*p));
+	(void)memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
 
diff --git a/fs/splice.c b/fs/splice.c
index 1ec0493..b978e50 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -47,7 +47,7 @@ static int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,
 
 	mapping = page_mapping(page);
 	if (mapping) {
-		WARN_ON(!PageUptodate(page));
+		(void)WARN_ON(!PageUptodate(page));
 
 		/*
 		 * At least for ext2 with nobh option, we need to wait on
diff --git a/fs/stat.c b/fs/stat.c
index 8806b89..550fb13 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -202,7 +202,7 @@ static int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)
 		return -EOVERFLOW;
 #endif
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 #if BITS_PER_LONG == 32
 	tmp.st_dev = old_encode_dev(stat->dev);
 #else
@@ -331,7 +331,7 @@ static long cp_new_stat64(struct kstat *stat, struct stat64 __user *statbuf)
 {
 	struct stat64 tmp;
 
-	memset(&tmp, 0, sizeof(struct stat64));
+	(void)memset(&tmp, 0, sizeof(struct stat64));
 #ifdef CONFIG_MIPS
 	/* mips has weird padding, so we don't get 64 bits there */
 	if (!new_valid_dev(stat->dev) || !new_valid_dev(stat->rdev))
diff --git a/fs/statfs.c b/fs/statfs.c
index 2aa6a22..ec22033 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -53,7 +53,7 @@ static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)
 	if (!dentry->d_sb->s_op->statfs)
 		return -ENOSYS;
 
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	retval = security_sb_statfs(dentry);
 	if (retval)
 		return retval;
@@ -131,7 +131,7 @@ static int do_statfs_native(struct kstatfs *st, struct statfs __user *p)
 		buf.f_namelen = st->f_namelen;
 		buf.f_frsize = st->f_frsize;
 		buf.f_flags = st->f_flags;
-		memset(buf.f_spare, 0, sizeof(buf.f_spare));
+		(void)memset(buf.f_spare, 0, sizeof(buf.f_spare));
 	}
 	if (copy_to_user(p, &buf, sizeof(buf)))
 		return -EFAULT;
@@ -155,7 +155,7 @@ static int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)
 		buf.f_namelen = st->f_namelen;
 		buf.f_frsize = st->f_frsize;
 		buf.f_flags = st->f_flags;
-		memset(buf.f_spare, 0, sizeof(buf.f_spare));
+		(void)memset(buf.f_spare, 0, sizeof(buf.f_spare));
 	}
 	if (copy_to_user(p, &buf, sizeof(buf)))
 		return -EFAULT;
@@ -226,7 +226,7 @@ SYSCALL_DEFINE2(ustat, unsigned, dev, struct ustat __user *, ubuf)
 	if (err)
 		return err;
 
-	memset(&tmp,0,sizeof(struct ustat));
+	(void)memset(&tmp,0,sizeof(struct ustat));
 	tmp.f_tfree = sbuf.f_bfree;
 	tmp.f_tinode = sbuf.f_ffree;
 
diff --git a/fs/super.c b/fs/super.c
index 6015c02..685c9147 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -201,7 +201,7 @@ static inline void destroy_super(struct super_block *s)
 	free_percpu(s->s_files);
 #endif
 	security_sb_free(s);
-	WARN_ON(!list_empty(&s->s_mounts));
+	(void)WARN_ON(!list_empty(&s->s_mounts));
 	kfree(s->s_subtype);
 	kfree(s->s_options);
 	kfree(s);
@@ -738,7 +738,7 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 			if (!force)
 				goto cancel_readonly;
 			/* If forced remount, go ahead despite any errors */
-			WARN(1, "forced remount of a %s fs returned %i\n",
+			(void)WARN(1, "forced remount of a %s fs returned %i\n",
 			     sb->s_type->name, retval);
 		}
 	}
@@ -1027,7 +1027,7 @@ void kill_block_super(struct super_block *sb)
 	bdev->bd_super = NULL;
 	generic_shutdown_super(sb);
 	sync_blockdev(bdev);
-	WARN_ON_ONCE(!(mode & FMODE_EXCL));
+	(void)WARN_ON_ONCE(!(mode & FMODE_EXCL));
 	blkdev_put(bdev, mode | FMODE_EXCL);
 }
 
@@ -1111,8 +1111,8 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	}
 	sb = root->d_sb;
 	BUG_ON(!sb);
-	WARN_ON(!sb->s_bdi);
-	WARN_ON(sb->s_bdi == &default_backing_dev_info);
+	(void)WARN_ON(!sb->s_bdi);
+	(void)WARN_ON(sb->s_bdi == &default_backing_dev_info);
 	sb->s_flags |= MS_BORN;
 
 	error = security_sb_kern_mount(sb, flags, secdata);
@@ -1125,7 +1125,7 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	 * this warning for a little while to try and catch filesystems that
 	 * violate this rule.
 	 */
-	WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
+	(void)WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
 		"negative value (%lld)\n", type->name, sb->s_maxbytes);
 
 	up_write(&sb->s_umount);
diff --git a/fs/sync.c b/fs/sync.c
index f3501ef..ac5a649 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -62,7 +62,7 @@ int sync_filesystem(struct super_block *sb)
 	 * We need to be protected against the filesystem going from
 	 * r/o to r/w or vice versa.
 	 */
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	/*
 	 * No point in syncing out anything if the filesystem is read-only.
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 7fdf6a7..a5dbef4 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -373,7 +373,7 @@ struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)
 void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 		       struct sysfs_dirent *parent_sd)
 {
-	memset(acxt, 0, sizeof(*acxt));
+	(void)memset(acxt, 0, sizeof(*acxt));
 	acxt->parent_sd = parent_sd;
 
 	mutex_lock(&sysfs_mutex);
@@ -404,7 +404,7 @@ int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
 	struct sysfs_inode_attrs *ps_iattr;
 
 	if (!!sysfs_ns_type(acxt->parent_sd) != !!sd->s_ns) {
-		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+		(void)WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 			sysfs_ns_type(acxt->parent_sd)? "required": "invalid",
 			acxt->parent_sd->s_name, sd->s_name);
 		return -EINVAL;
@@ -474,7 +474,7 @@ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
 	ret = __sysfs_add_one(acxt, sd);
 	if (ret == -EEXIST) {
 		char *path = kzalloc(PATH_MAX, GFP_KERNEL);
-		WARN(1, KERN_WARNING
+		(void)WARN(1, KERN_WARNING
 		     "sysfs: cannot create duplicate filename '%s'\n",
 		     (path == NULL) ? sd->s_name :
 		     strcat(strcat(sysfs_pathname(acxt->parent_sd, path), "/"),
@@ -569,7 +569,7 @@ struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 	struct sysfs_dirent *found = NULL;
 
 	if (!!sysfs_ns_type(parent_sd) != !!ns) {
-		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+		(void)WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 			sysfs_ns_type(parent_sd)? "required": "invalid",
 			parent_sd->s_name, name);
 		return NULL;
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 62f4fb3..4f60de2 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -339,7 +339,7 @@ static int sysfs_open_file(struct inode *inode, struct file *file)
 	if (kobj->ktype && kobj->ktype->sysfs_ops)
 		ops = kobj->ktype->sysfs_ops;
 	else {
-		WARN(1, KERN_ERR "missing sysfs attribute operations for "
+		(void)WARN(1, KERN_ERR "missing sysfs attribute operations for "
 		       "kobject: %s\n", kobject_name(kobj));
 		goto err_out;
 	}
@@ -494,7 +494,7 @@ int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 	int err;
 
 	if (!dir_sd) {
-		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
+		(void)WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 			kobject_name(kobj));
 		return -ENOENT;
 	}
@@ -510,7 +510,7 @@ int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 	ns = ops->namespace(kobj, attr);
 out:
 	if (err) {
-		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
+		(void)WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 		     "kobject: %s\n", kobject_name(kobj));
 	}
 	*pns = ns;
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index dd1701c..b550730 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -134,7 +134,7 @@ void sysfs_remove_group(struct kobject * kobj,
 	if (grp->name) {
 		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
 		if (!sd) {
-			WARN(!sd, KERN_WARNING "sysfs group %p not found for "
+			(void)WARN(!sd, KERN_WARNING "sysfs group %p not found for "
 				"kobject '%s'\n", grp, kobject_name(kobj));
 			return;
 		}
diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c
index 85eb816..1420eca 100644
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@ -319,7 +319,7 @@ int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const void *ns, const cha
 	struct sysfs_dirent *sd;
 
 	if (!dir_sd) {
-		WARN(1, KERN_WARNING "sysfs: can not remove '%s', no directory\n",
+		(void)WARN(1, KERN_WARNING "sysfs: can not remove '%s', no directory\n",
 			name);
 		return -ENOENT;
 	}
diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c
index a7ac78f..c2ff2aa 100644
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@ -75,7 +75,7 @@ static int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,
 			error = __sysfs_add_one(&acxt, sd);
 	} else {
 		error = -EINVAL;
-		WARN(1, KERN_WARNING
+		(void)WARN(1, KERN_WARNING
 			"sysfs: symlink across ns_types %s/%s -> %s/%s\n",
 			parent_sd->s_name,
 			sd->s_name,
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index 7484a36..40c463d 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -192,7 +192,7 @@ int sysfs_rename(struct sysfs_dirent *sd,
 static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
 {
 	if (sd) {
-		WARN_ON(!atomic_read(&sd->s_count));
+		(void)WARN_ON(!atomic_read(&sd->s_count));
 		atomic_inc(&sd->s_count);
 	}
 	return sd;
diff --git a/fs/xattr.c b/fs/xattr.c
index 82f4337..24570cc 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -198,7 +198,7 @@ vfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,
 		value = krealloc(*xattr_value, error + 1, flags);
 		if (!value)
 			return -ENOMEM;
-		memset(value, 0, error + 1);
+		(void)memset(value, 0, error + 1);
 	}
 
 	error = inode->i_op->getxattr(dentry, name, value, error);
diff --git a/include/linux/acct.h b/include/linux/acct.h
index d537aa0..7677788 100644
--- a/include/linux/acct.h
+++ b/include/linux/acct.h
@@ -193,7 +193,7 @@ static inline u32 jiffies_to_AHZ(unsigned long x)
 static inline u64 nsec_to_AHZ(u64 x)
 {
 #if (NSEC_PER_SEC % AHZ) == 0
-	do_div(x, (NSEC_PER_SEC / AHZ));
+	(void)do_div(x, (NSEC_PER_SEC / AHZ));
 #elif (AHZ % 512) == 0
 	x *= AHZ/512;
 	do_div(x, (NSEC_PER_SEC / 512));
diff --git a/include/linux/ata.h b/include/linux/ata.h
index 32df2b6..f615524 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -1039,7 +1039,7 @@ static inline unsigned ata_set_lba_range_entries(void *_buffer,
 	}
 
 	used_bytes = ALIGN(i * 8, 512);
-	memset(buffer + i, 0, used_bytes - i * 8);
+	(void)memset(buffer + i, 0, used_bytes - i * 8);
 	return used_bytes;
 }
 
diff --git a/include/linux/bitmap.h b/include/linux/bitmap.h
index 7ad6345..ad78dba 100644
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -162,7 +162,7 @@ static inline void bitmap_zero(unsigned long *dst, int nbits)
 		*dst = 0UL;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memset(dst, 0, len);
+		(void)memset(dst, 0, len);
 	}
 }
 
@@ -171,7 +171,7 @@ static inline void bitmap_fill(unsigned long *dst, int nbits)
 	size_t nlongs = BITS_TO_LONGS(nbits);
 	if (!small_const_nbits(nbits)) {
 		int len = (nlongs - 1) * sizeof(unsigned long);
-		memset(dst, 0xff,  len);
+		(void)memset(dst, 0xff,  len);
 	}
 	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
 }
@@ -183,7 +183,7 @@ static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
 		*dst = *src;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memcpy(dst, src, len);
+		(void)memcpy(dst, src, len);
 	}
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 6c6a1f0..d69f132 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -448,7 +448,7 @@ static inline void queue_flag_set_unlocked(unsigned int flag,
 static inline int queue_flag_test_and_clear(unsigned int flag,
 					    struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (test_bit(flag, &q->queue_flags)) {
 		__clear_bit(flag, &q->queue_flags);
@@ -461,7 +461,7 @@ static inline int queue_flag_test_and_clear(unsigned int flag,
 static inline int queue_flag_test_and_set(unsigned int flag,
 					  struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (!test_bit(flag, &q->queue_flags)) {
 		__set_bit(flag, &q->queue_flags);
@@ -473,7 +473,7 @@ static inline int queue_flag_test_and_set(unsigned int flag,
 
 static inline void queue_flag_set(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__set_bit(flag, &q->queue_flags);
 }
 
@@ -490,7 +490,7 @@ static inline int queue_in_flight(struct request_queue *q)
 
 static inline void queue_flag_clear(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__clear_bit(flag, &q->queue_flags);
 }
 
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 81e803e..b945988 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -123,7 +123,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 {
 	uint64_t tmp = ((uint64_t)ticks) << shift;
 
-	do_div(tmp, nsec);
+	(void)do_div(tmp, nsec);
 	return (unsigned long) tmp;
 }
 
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147d..456d605 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -230,7 +230,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 	u64 tmp = ((u64)1000000) << shift_constant;
 
 	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
+	(void)do_div(tmp, khz);
 
 	return (u32)tmp;
 }
@@ -256,7 +256,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	u64 tmp = ((u64)1000000000) << shift_constant;
 
 	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
+	(void)do_div(tmp, hz);
 
 	return (u32)tmp;
 }
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6216115..bf97e8e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -147,7 +147,7 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mu
 #if BITS_PER_LONG == 32
 
 	u64 result = ((u64) old) * ((u64) mult);
-	do_div(result, div);
+	(void)do_div(result, div);
 	return (unsigned long) result;
 
 #elif BITS_PER_LONG == 64
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index e13117c..35df364 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -126,7 +126,7 @@ static inline void *dma_zalloc_coherent(struct device *dev, size_t size,
 {
 	void *ret = dma_alloc_coherent(dev, size, dma_handle, flag);
 	if (ret)
-		memset(ret, 0, size);
+		(void)memset(ret, 0, size);
 	return ret;
 }

diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index fe23ee7..b83a7e9 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -315,7 +315,7 @@ static inline void part_stat_set_all(struct hd_struct *part, int value)
 	int i;
 
 	for_each_possible_cpu(i)
-		memset(per_cpu_ptr(part->dkstats, i), value,
+		(void)memset(per_cpu_ptr(part->dkstats, i), value,
 				sizeof(struct disk_stats));
 }
 
@@ -343,7 +343,7 @@ static inline void free_part_stats(struct hd_struct *part)
 
 static inline void part_stat_set_all(struct hd_struct *part, int value)
 {
-	memset(&part->dkstats, value, sizeof(struct disk_stats));
+	(void)memset(&part->dkstats, value, sizeof(struct disk_stats));
 }
 
 static inline int init_part_stats(struct hd_struct *part)
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 581e74b..79bfd6e 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -151,7 +151,7 @@ struct vm_area_struct;
 /* Convert GFP flags to their corresponding migrate type */
 static inline int allocflags_to_migratetype(gfp_t gfp_flags)
 {
-	WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
+	(void)WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 
 	if (unlikely(page_group_by_mobility_disabled))
 		return MIGRATE_UNMOVABLE;
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index 38ac48b..625e61c 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -64,7 +64,7 @@ static inline void gpio_free(unsigned gpio)
 	might_sleep();
 
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline void gpio_free_array(const struct gpio *array, size_t num)
@@ -72,7 +72,7 @@ static inline void gpio_free_array(const struct gpio *array, size_t num)
 	might_sleep();
 
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_direction_input(unsigned gpio)
@@ -93,40 +93,40 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline void gpio_set_value(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested or set as output */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_cansleep(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline int gpio_get_value_cansleep(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline void gpio_set_value_cansleep(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested or set as output */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_export(unsigned gpio, bool direction_may_change)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
@@ -134,34 +134,34 @@ static inline int gpio_export_link(struct device *dev, const char *name,
 				unsigned gpio)
 {
 	/* GPIO can never have been exported */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline int gpio_sysfs_set_active_low(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline void gpio_unexport(unsigned gpio)
 {
 	/* GPIO can never have been exported */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_to_irq(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as input */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline int irq_to_gpio(unsigned irq)
 {
 	/* irq can never have been returned from gpio_to_irq() */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index 3a93f73..63ed5d1 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -194,10 +194,10 @@ static inline void zero_user_segments(struct page *page,
 	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);
 
 	if (end1 > start1)
-		memset(kaddr + start1, 0, end1 - start1);
+		(void)memset(kaddr + start1, 0, end1 - start1);
 
 	if (end2 > start2)
-		memset(kaddr + start2, 0, end2 - start2);
+		(void)memset(kaddr + start2, 0, end2 - start2);
 
 	kunmap_atomic(kaddr, KM_USER0);
 	flush_dcache_page(page);
diff --git a/include/linux/irqflags.h b/include/linux/irqflags.h
index d176d65..c02806e 100644
--- a/include/linux/irqflags.h
+++ b/include/linux/irqflags.h
@@ -60,22 +60,22 @@
 #define raw_local_irq_enable()		arch_local_irq_enable()
 #define raw_local_irq_save(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_irq_save();		\
 	} while (0)
 #define raw_local_irq_restore(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_local_irq_restore(flags);		\
 	} while (0)
 #define raw_local_save_flags(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_save_flags();	\
 	} while (0)
 #define raw_irqs_disabled_flags(flags)			\
 	({						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_irqs_disabled_flags(flags);	\
 	})
 #define raw_irqs_disabled()		(arch_irqs_disabled())
diff --git a/include/linux/kref.h b/include/linux/kref.h
index 9c07dce..516b7a3 100644
--- a/include/linux/kref.h
+++ b/include/linux/kref.h
@@ -38,7 +38,7 @@ static inline void kref_init(struct kref *kref)
  */
 static inline void kref_get(struct kref *kref)
 {
-	WARN_ON(!atomic_read(&kref->refcount));
+	(void)WARN_ON(!atomic_read(&kref->refcount));
 	atomic_inc(&kref->refcount);
 }
 
@@ -63,7 +63,7 @@ static inline void kref_get(struct kref *kref)
 static inline int kref_sub(struct kref *kref, unsigned int count,
 	     void (*release)(struct kref *kref))
 {
-	WARN_ON(release == NULL);
+	(void)WARN_ON(release == NULL);
 
 	if (atomic_sub_and_test((int) count, &kref->refcount)) {
 		release(kref);
diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index d36619e..ece7af1 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -536,13 +536,13 @@ static inline void print_irqtrace_events(struct task_struct *curr)
 #ifdef CONFIG_PROVE_LOCKING
 # define might_lock(lock) 						\
 do {									\
-	typecheck(struct lockdep_map *, &(lock)->dep_map);		\
+	(void)typecheck(struct lockdep_map *, &(lock)->dep_map);		\
 	lock_acquire(&(lock)->dep_map, 0, 0, 0, 2, NULL, _THIS_IP_);	\
 	lock_release(&(lock)->dep_map, 0, _THIS_IP_);			\
 } while (0)
 # define might_lock_read(lock) 						\
 do {									\
-	typecheck(struct lockdep_map *, &(lock)->dep_map);		\
+	(void)typecheck(struct lockdep_map *, &(lock)->dep_map);		\
 	lock_acquire(&(lock)->dep_map, 0, 0, 1, 2, NULL, _THIS_IP_);	\
 	lock_release(&(lock)->dep_map, 0, _THIS_IP_);			\
 } while (0)
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 1a81fde..9e8a8bd 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -456,7 +456,7 @@ static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->erasesize_shift)
 		return sz >> mtd->erasesize_shift;
-	do_div(sz, mtd->erasesize);
+	(void)do_div(sz, mtd->erasesize);
 	return sz;
 }
 
@@ -471,7 +471,7 @@ static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->writesize_shift)
 		return sz >> mtd->writesize_shift;
-	do_div(sz, mtd->writesize);
+	(void)do_div(sz, mtd->writesize);
 	return sz;
 }
 
diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index 9121595..6fb630e 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -144,7 +144,7 @@ extern int __must_check mutex_lock_killable_nested(struct mutex *lock,
 
 #define mutex_lock_nest_lock(lock, nest_lock)				\
 do {									\
-	typecheck(struct lockdep_map *, &(nest_lock)->dep_map);		\
+	(void)typecheck(struct lockdep_map *, &(nest_lock)->dep_map);		\
 	_mutex_lock_nest_lock(lock, &(nest_lock)->dep_map);		\
 } while (0)
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0eac07c..c4fced5 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1323,8 +1323,8 @@ static inline
 void netdev_reset_tc(struct net_device *dev)
 {
 	dev->num_tc = 0;
-	memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
-	memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
+	(void)memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
+	(void)memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
 }
 
 static inline
diff --git a/include/linux/poll.h b/include/linux/poll.h
index cf40010..5273a23 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -110,7 +110,7 @@ int get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 	if (ufdset)
 		return copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;
 
-	memset(fdset, 0, nr);
+	(void)memset(fdset, 0, nr);
 	return 0;
 }
 
@@ -125,7 +125,7 @@ set_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 static inline
 void zero_fd_set(unsigned long nr, unsigned long *fdset)
 {
-	memset(fdset, 0, FDS_BYTES(nr));
+	(void)memset(fdset, 0, FDS_BYTES(nr));
 }
 
 #define MAX_INT64_SECONDS (((s64)(~((u64)0)>>1)/HZ)-1)
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index c2f1f6a..d52e4ca 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -363,7 +363,7 @@ extern void user_single_step_siginfo(struct task_struct *tsk,
 static inline void user_single_step_siginfo(struct task_struct *tsk,
 				struct pt_regs *regs, siginfo_t *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->si_signo = SIGTRAP;
 }
 #endif
diff --git a/include/linux/regset.h b/include/linux/regset.h
index 8abee65..3c3e979 100644
--- a/include/linux/regset.h
+++ b/include/linux/regset.h
@@ -283,7 +283,7 @@ static inline int user_regset_copyout_zero(unsigned int *pos,
 		unsigned int copy = (end_pos < 0 ? *count
 				     : min(*count, end_pos - *pos));
 		if (*kbuf) {
-			memset(*kbuf, 0, copy);
+			(void)memset(*kbuf, 0, copy);
 			*kbuf += copy;
 		} else if (__clear_user(*ubuf, copy))
 			return -EFAULT;
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index 8e872ea..4a5eb58 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -732,7 +732,7 @@ __rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 	return rta;
 }
 
diff --git a/include/linux/rwlock.h b/include/linux/rwlock.h
index bc2994e..970f1a8 100644
--- a/include/linux/rwlock.h
+++ b/include/linux/rwlock.h
@@ -68,12 +68,12 @@ do {								\
 
 #define read_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_read_lock_irqsave(lock);	\
 	} while (0)
 #define write_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_write_lock_irqsave(lock);	\
 	} while (0)
 
@@ -81,12 +81,12 @@ do {								\
 
 #define read_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_read_lock_irqsave(lock, flags);	\
 	} while (0)
 #define write_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_write_lock_irqsave(lock, flags);	\
 	} while (0)
 
@@ -103,14 +103,14 @@ do {								\
 
 #define read_unlock_irqrestore(lock, flags)			\
 	do {							\
-		typecheck(unsigned long, flags);		\
+		(void)typecheck(unsigned long, flags);		\
 		_raw_read_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define read_unlock_bh(lock)		_raw_read_unlock_bh(lock)
 
 #define write_unlock_irqrestore(lock, flags)		\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_write_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define write_unlock_bh(lock)		_raw_write_unlock_bh(lock)
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7987ce74..2256c0a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -159,7 +159,7 @@ static inline void sigemptyset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, 0, sizeof(sigset_t));
+		(void)memset(set, 0, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1:	set->sig[0] = 0;
@@ -171,7 +171,7 @@ static inline void sigfillset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, -1, sizeof(sigset_t));
+		(void)memset(set, -1, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1:	set->sig[0] = -1;
@@ -201,7 +201,7 @@ static inline void siginitset(sigset_t *set, unsigned long mask)
 	set->sig[0] = mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1: ;
@@ -213,7 +213,7 @@ static inline void siginitsetinv(sigset_t *set, unsigned long mask)
 	set->sig[0] = ~mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1: ;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 50db9b0..622c720 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -510,7 +510,7 @@ static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
 	/* If refdst was not refcounted, check we still are in a 
 	 * rcu_read_lock section
 	 */
-	WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
+	(void)WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
 		!rcu_read_lock_held() &&
 		!rcu_read_lock_bh_held());
 	return (struct dst_entry *)(skb->_skb_refdst & SKB_DST_PTRMASK);
@@ -1543,7 +1543,7 @@ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 {
 	if (unlikely(skb_is_nonlinear(skb))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	skb->len = len;
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 176fce9..cf6e6a7 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -521,7 +521,7 @@ struct spi_message {
 
 static inline void spi_message_init(struct spi_message *m)
 {
-	memset(m, 0, sizeof *m);
+	(void)memset(m, 0, sizeof *m);
 	INIT_LIST_HEAD(&m->transfers);
 }
 
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 7df6c17..b58581b 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -175,7 +175,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 # define raw_spin_lock_nest_lock(lock, nest_lock)			\
 	 do {								\
-		 typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
+		 (void)typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
 		 _raw_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);	\
 	 } while (0)
 #else
@@ -187,20 +187,20 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_spin_lock_irqsave(lock);	\
 	} while (0)
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave_nested(lock, subclass);	\
 	} while (0)
 #else
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave(lock);			\
 	} while (0)
 #endif
@@ -209,7 +209,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)		\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_spin_lock_irqsave(lock, flags);	\
 	} while (0)
 
@@ -225,7 +225,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_unlock_irqrestore(lock, flags)		\
 	do {							\
-		typecheck(unsigned long, flags);		\
+		(void)typecheck(unsigned long, flags);		\
 		_raw_spin_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define raw_spin_unlock_bh(lock)	_raw_spin_unlock_bh(lock)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 69d8457..97416de 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1597,10 +1597,10 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 	unsigned			epnum = usb_pipeendpoint(pipe);
 
 	if (is_out) {
-		WARN_ON(usb_pipein(pipe));
+		(void)WARN_ON(usb_pipein(pipe));
 		ep = udev->ep_out[epnum];
 	} else {
-		WARN_ON(usb_pipeout(pipe));
+		(void)WARN_ON(usb_pipeout(pipe));
 		ep = udev->ep_in[epnum];
 	}
 	if (!ep)
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 65efb92..35ca2a3 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -181,7 +181,7 @@ extern void zone_statistics(struct zone *, struct zone *, gfp_t gfp);
 
 static inline void zap_zone_vm_stats(struct zone *zone)
 {
-	memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
+	(void)memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
 }
 
 extern void inc_zone_state(struct zone *, enum zone_stat_item);
diff --git a/include/media/lirc_dev.h b/include/media/lirc_dev.h
index 168dd0b..25c7db4 100644
--- a/include/media/lirc_dev.h
+++ b/include/media/lirc_dev.h
@@ -41,7 +41,7 @@ static inline void lirc_buffer_clear(struct lirc_buffer *buf)
 		kfifo_reset(&buf->fifo);
 		spin_unlock_irqrestore(&buf->fifo_lock, flags);
 	} else
-		WARN(1, "calling %s on an uninitialized lirc_buffer\n",
+		(void)WARN(1, "calling %s on an uninitialized lirc_buffer\n",
 		     __func__);
 }
 
@@ -68,7 +68,7 @@ static inline void lirc_buffer_free(struct lirc_buffer *buf)
 		kfifo_free(&buf->fifo);
 		buf->fifo_initialized = 0;
 	} else
-		WARN(1, "calling %s on an uninitialized lirc_buffer\n",
+		(void)WARN(1, "calling %s on an uninitialized lirc_buffer\n",
 		     __func__);
 }
 
diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b0c494a..ca2c1de 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -185,7 +185,7 @@ struct ir_raw_event {
 
 static inline void init_ir_raw_event(struct ir_raw_event *ev)
 {
-	memset(ev, 0, sizeof(*ev));
+	(void)memset(ev, 0, sizeof(*ev));
 }
 
 #define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
diff --git a/include/net/dst.h b/include/net/dst.h
index 344c8dd..cbae81d 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -173,7 +173,7 @@ dst_metric_raw(const struct dst_entry *dst, const int metric)
 static inline u32
 dst_metric(const struct dst_entry *dst, const int metric)
 {
-	WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
+	(void)WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
 		     metric == RTAX_ADVMSS ||
 		     metric == RTAX_MTU);
 	return dst_metric_raw(dst, metric);
@@ -303,7 +303,7 @@ static inline void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb
 static inline void skb_dst_force(struct sk_buff *skb)
 {
 	if (skb_dst_is_noref(skb)) {
-		WARN_ON(!rcu_read_lock_held());
+		(void)WARN_ON(!rcu_read_lock_held());
 		skb->_skb_refdst &= ~SKB_DST_NOREF;
 		dst_clone(skb_dst(skb));
 	}
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index dbf9aab..0bb043e 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -172,7 +172,7 @@ static inline int inet_csk_ack_scheduled(const struct sock *sk)
 
 static inline void inet_csk_delack_init(struct sock *sk)
 {
-	memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
+	(void)memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
 }
 
 extern void inet_csk_delete_keepalive_timer(struct sock *sk);
diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index 06b795d..52ac08a 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -102,7 +102,7 @@ extern bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);
  */
 static inline void inet_peer_refcheck(const struct inet_peer *p)
 {
-	WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
+	(void)WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
 }
 
 
diff --git a/include/net/ip.h b/include/net/ip.h
index 775009f..52a58a8 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -364,8 +364,8 @@ static __inline__ void inet_reset_saddr(struct sock *sk)
 	if (sk->sk_family == PF_INET6) {
 		struct ipv6_pinfo *np = inet6_sk(sk);
 
-		memset(&np->saddr, 0, sizeof(np->saddr));
-		memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));
+		(void)memset(&np->saddr, 0, sizeof(np->saddr));
+		(void)memset(&np->rcv_saddr, 0, sizeof(np->rcv_saddr));
 	}
 #endif
 }
@@ -384,7 +384,7 @@ static inline int sk_mc_loop(struct sock *sk)
 		return inet6_sk(sk)->mc_loop;
 #endif
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 1;
 }
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index e4170a2..7081938 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -317,7 +317,7 @@ static inline void ipv6_addr_prefix(struct in6_addr *pfx,
 	int o = plen >> 3,
 	    b = plen & 0x7;
 
-	memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
+	(void)memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
 	memcpy(pfx->s6_addr, addr, o);
 	if (b != 0)
 		pfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);
diff --git a/include/net/netfilter/nf_tproxy_core.h b/include/net/netfilter/nf_tproxy_core.h
index 75ca929..e988bbf 100644
--- a/include/net/netfilter/nf_tproxy_core.h
+++ b/include/net/netfilter/nf_tproxy_core.h
@@ -97,7 +97,7 @@ nf_tproxy_get_sock_v4(struct net *net, const u8 protocol,
 						    in->ifindex);
 			break;
 		default:
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			sk = NULL;
 			break;
 		}
@@ -121,7 +121,7 @@ nf_tproxy_get_sock_v4(struct net *net, const u8 protocol,
 		}
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		sk = NULL;
 	}
 
@@ -166,7 +166,7 @@ nf_tproxy_get_sock_v6(struct net *net, const u8 protocol,
 							in->ifindex);
 			break;
 		default:
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			sk = NULL;
 			break;
 		}
@@ -190,7 +190,7 @@ nf_tproxy_get_sock_v6(struct net *net, const u8 protocol,
 		}
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		sk = NULL;
 	}
 
diff --git a/include/net/netfilter/xt_log.h b/include/net/netfilter/xt_log.h
index 0dfb34a..b9d8f35 100644
--- a/include/net/netfilter/xt_log.h
+++ b/include/net/netfilter/xt_log.h
@@ -47,7 +47,7 @@ static void sb_close(struct sbuff *m)
 	if (likely(m != &emergency))
 		kfree(m);
 	else {
-		xchg(&emergency_ptr, m);
+		(void)xchg(&emergency_ptr, m);
 		local_bh_enable();
 	}
 }
diff --git a/include/net/netlabel.h b/include/net/netlabel.h
index f674409..6b50c2a 100644
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@ -303,7 +303,7 @@ static inline void netlbl_secattr_catmap_free(
  */
 static inline void netlbl_secattr_init(struct netlbl_lsm_secattr *secattr)
 {
-	memset(secattr, 0, sizeof(*secattr));
+	(void)memset(secattr, 0, sizeof(*secattr));
 }
 
 /**
diff --git a/include/net/request_sock.h b/include/net/request_sock.h
index 4c0766e..2c68508 100644
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@ -181,7 +181,7 @@ static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue
 {
 	struct request_sock *req = queue->rskq_accept_head;
 
-	WARN_ON(req == NULL);
+	(void)WARN_ON(req == NULL);
 
 	queue->rskq_accept_head = req->dl_next;
 	if (queue->rskq_accept_head == NULL)
@@ -196,7 +196,7 @@ static inline struct sock *reqsk_queue_get_child(struct request_sock_queue *queu
 	struct request_sock *req = reqsk_queue_remove(queue);
 	struct sock *child = req->sk;
 
-	WARN_ON(child == NULL);
+	(void)WARN_ON(child == NULL);
 
 	sk_acceptq_removed(parent);
 	__reqsk_free(req);
diff --git a/include/net/route.h b/include/net/route.h
index 91855d1..8e809d7 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -156,7 +156,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->flowi4_oif = oif;
 	fl4->daddr = daddr;
 	fl4->saddr = saddr;
diff --git a/include/net/scm.h b/include/net/scm.h
index d456f4c..3fd7dfc 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -73,7 +73,7 @@ static __inline__ void scm_destroy(struct scm_cookie *scm)
 static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 			       struct scm_cookie *scm)
 {
-	memset(scm, 0, sizeof(*scm));
+	(void)memset(scm, 0, sizeof(*scm));
 	unix_get_peersec_dgram(sock, scm);
 	if (msg->msg_controllen <= 0)
 		return 0;
diff --git a/include/net/sock.h b/include/net/sock.h
index bb972d2..54d7904 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -474,7 +474,7 @@ static __inline__ int sk_del_node_init(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
@@ -496,7 +496,7 @@ static __inline__ int sk_nulls_del_node_init_rcu(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
--- a/block/blk-exec.c
+++ b/block/blk-exec.c


diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index f494f1e..a352c2b 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -68,12 +68,12 @@ static inline size_t snd_mask_sizeof(void)
 
 static inline void snd_mask_none(struct snd_mask *mask)
 {
-	memset(mask, 0, sizeof(*mask));
+	(void)memset(mask, 0, sizeof(*mask));
 }
 
 static inline void snd_mask_any(struct snd_mask *mask)
 {
-	memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
+	(void)memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
 static inline int snd_mask_empty(const struct snd_mask *mask)
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index 887629e..a1c76ef 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -71,7 +71,7 @@ identify_ramdisk_image(int fd, int start_block, decompress_fn *decompressor)
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
 	squashfsb = (struct squashfs_super_block *) buf;
-	memset(buf, 0xe5, size);
+	(void)memset(buf, 0xe5, size);
 
 	/*
 	 * Read block 0 to test for compressed kernel
diff --git a/init/initramfs.c b/init/initramfs.c
index 8216c30..5e6b06b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -507,7 +507,7 @@ static void __init free_initrd(void)
 		 * Initialize initrd memory region since the kexec boot does
 		 * not do.
 		 */
-		memset((void *)initrd_start, 0, initrd_end - initrd_start);
+		(void)memset((void *)initrd_start, 0, initrd_end - initrd_start);
 		if (initrd_start < crashk_start)
 			free_initrd_mem(initrd_start, crashk_start);
 		if (initrd_end > crashk_end)
@@ -530,11 +530,11 @@ static void __init clean_rootfs(void)
 	int num;
 
 	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
-	WARN_ON(fd < 0);
+	(void)WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
 	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
-	WARN_ON(!buf);
+	(void)WARN_ON(!buf);
 	if (!buf) {
 		sys_close(fd);
 		return;
@@ -548,7 +548,7 @@ static void __init clean_rootfs(void)
 			int ret;
 
 			ret = sys_newlstat(dirp->d_name, &st);
-			WARN_ON_ONCE(ret);
+			(void)WARN_ON_ONCE(ret);
 			if (!ret) {
 				if (S_ISDIR(st.st_mode))
 					sys_rmdir(dirp->d_name);
@@ -560,7 +560,7 @@ static void __init clean_rootfs(void)
 			dirp = (void *)dirp + dirp->d_reclen;
 		}
 		dirp = buf;
-		memset(buf, 0, BUF_SIZE);
+		(void)memset(buf, 0, BUF_SIZE);
 		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
diff --git a/ipc/ipcns_notifier.c b/ipc/ipcns_notifier.c
index b9b31a4..668f79d 100644
--- a/ipc/ipcns_notifier.c
+++ b/ipc/ipcns_notifier.c
@@ -57,7 +57,7 @@ int register_ipcns_notifier(struct ipc_namespace *ns)
 {
 	int rc;
 
-	memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
+	(void)memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
 	ns->ipcns_nb.notifier_call = ipcns_callback;
 	ns->ipcns_nb.priority = IPCNS_CALLBACK_PRI;
 	rc = blocking_notifier_chain_register(&ipcns_chain, &ns->ipcns_nb);
@@ -70,7 +70,7 @@ int cond_register_ipcns_notifier(struct ipc_namespace *ns)
 {
 	int rc;
 
-	memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
+	(void)memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
 	ns->ipcns_nb.notifier_call = ipcns_callback;
 	ns->ipcns_nb.priority = IPCNS_CALLBACK_PRI;
 	rc = blocking_notifier_chain_cond_register(&ipcns_chain,
diff --git a/ipc/msg.c b/ipc/msg.c
index 7385de2..1025ef2 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -337,7 +337,7 @@ copy_msqid_to_user(void __user *buf, struct msqid64_ds *in, int version)
 	{
 		struct msqid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 
 		ipc64_perm_to_ipc_perm(&in->msg_perm, &out.msg_perm);
 
@@ -496,7 +496,7 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&msginfo, 0, sizeof(msginfo));
+		(void)memset(&msginfo, 0, sizeof(msginfo));
 		msginfo.msgmni = ns->msg_ctlmni;
 		msginfo.msgmax = ns->msg_ctlmax;
 		msginfo.msgmnb = ns->msg_ctlmnb;
@@ -546,7 +546,7 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 		if (err)
 			goto out_unlock;
 
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 
 		kernel_to_ipc64_perm(&msq->q_perm, &tbuf.msg_perm);
 		tbuf.msg_stime  = msq->q_stime;
diff --git a/ipc/sem.c b/ipc/sem.c
index 5215a81..1fd4151 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -302,7 +302,7 @@ static int newary(struct ipc_namespace *ns, struct ipc_params *params)
 	if (!sma) {
 		return -ENOMEM;
 	}
-	memset (sma, 0, size);
+	(void)memset (sma, 0, size);
 
 	sma->sem_perm.mode = (semflg & S_IRWXUGO);
 	sma->sem_perm.key = key;
@@ -783,7 +783,7 @@ static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in,
 	    {
 		struct semid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 
 		ipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);
 
@@ -815,7 +815,7 @@ static int semctl_nolock(struct ipc_namespace *ns, int semid,
 		if (err)
 			return err;
 		
-		memset(&seminfo,0,sizeof(seminfo));
+		(void)memset(&seminfo,0,sizeof(seminfo));
 		seminfo.semmni = ns->sc_semmni;
 		seminfo.semmns = ns->sc_semmns;
 		seminfo.semmsl = ns->sc_semmsl;
@@ -864,7 +864,7 @@ static int semctl_nolock(struct ipc_namespace *ns, int semid,
 		if (err)
 			goto out_unlock;
 
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 
 		kernel_to_ipc64_perm(&sma->sem_perm, &tbuf.sem_perm);
 		tbuf.sem_otime  = sma->sem_otime;
diff --git a/ipc/shm.c b/ipc/shm.c
index b76be5b..0703af5 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -587,7 +587,7 @@ static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_
 	    {
 		struct shmid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 		ipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);
 		out.shm_segsz	= in->shm_segsz;
 		out.shm_atime	= in->shm_atime;
@@ -782,7 +782,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&shminfo, 0, sizeof(shminfo));
+		(void)memset(&shminfo, 0, sizeof(shminfo));
 		shminfo.shmmni = shminfo.shmseg = ns->shm_ctlmni;
 		shminfo.shmmax = ns->shm_ctlmax;
 		shminfo.shmall = ns->shm_ctlall;
@@ -807,7 +807,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&shm_info, 0, sizeof(shm_info));
+		(void)memset(&shm_info, 0, sizeof(shm_info));
 		down_read(&shm_ids(ns).rw_mutex);
 		shm_info.used_ids = shm_ids(ns).in_use;
 		shm_get_stat (ns, &shm_info.shm_rss, &shm_info.shm_swp);
@@ -851,7 +851,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		err = security_shm_shmctl(shp, cmd);
 		if (err)
 			goto out_unlock;
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 		kernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);
 		tbuf.shm_segsz	= shp->shm_segsz;
 		tbuf.shm_atime	= shp->shm_atim;
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index a5d3b53..8cea321 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -1109,7 +1109,7 @@ static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
 	mask = ~(1UL << cpuset_subsys_id);
 #endif
 
-	memset(opts, 0, sizeof(*opts));
+	(void)memset(opts, 0, sizeof(*opts));
 
 	while ((token = strsep(&o, ",")) != NULL) {
 		if (!*token)
@@ -4757,7 +4757,7 @@ void __css_put(struct cgroup_subsys_state *css, int count)
 		cgroup_wakeup_rmdir_waiter(cgrp);
 	}
 	rcu_read_unlock();
-	WARN_ON_ONCE(val < 1);
+	(void)WARN_ON_ONCE(val < 1);
 }
 EXPORT_SYMBOL_GPL(__css_put);
 
diff --git a/kernel/exit.c b/kernel/exit.c
index 294b170..8b137c6 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -894,7 +894,7 @@ void do_exit(long code)
 
 	profile_task_exit(tsk);
 
-	WARN_ON(blk_needs_flush_plug(tsk));
+	(void)WARN_ON(blk_needs_flush_plug(tsk));
 
 	if (unlikely(in_interrupt()))
 		panic("Aiee, killing interrupt handler!");
diff --git a/kernel/fork.c b/kernel/fork.c
index 051f090..528c464 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -188,9 +188,9 @@ static inline void put_signal_struct(struct signal_struct *sig)
 
 void __put_task_struct(struct task_struct *tsk)
 {
-	WARN_ON(!tsk->exit_state);
-	WARN_ON(atomic_read(&tsk->usage));
-	WARN_ON(tsk == current);
+	(void)WARN_ON(!tsk->exit_state);
+	(void)WARN_ON(atomic_read(&tsk->usage));
+	(void)WARN_ON(tsk == current);
 
 	exit_creds(tsk);
 	delayacct_tsk_free(tsk);
@@ -493,7 +493,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)
 		(current->mm->flags & MMF_INIT_MASK) : default_dump_filter;
 	mm->core_state = NULL;
 	mm->nr_ptes = 0;
-	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
+	(void)memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
 	spin_lock_init(&mm->page_table_lock);
 	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	mm->cached_hole_size = ~0UL;
@@ -521,7 +521,7 @@ struct mm_struct *mm_alloc(void)
 	if (!mm)
 		return NULL;
 
-	memset(mm, 0, sizeof(*mm));
+	(void)memset(mm, 0, sizeof(*mm));
 	mm_init_cpumask(mm);
 	return mm_init(mm, current);
 }
@@ -702,7 +702,7 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 			 * We don't check the error code - if userspace has
 			 * not set up a proper pointer then tough luck.
 			 */
-			put_user(0, tsk->clear_child_tid);
+			(void)put_user(0, tsk->clear_child_tid);
 			sys_futex(tsk->clear_child_tid, FUTEX_WAKE,
 					1, NULL, NULL, 0);
 		}
@@ -1427,7 +1427,7 @@ fork_out:
 
 noinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)
 {
-	memset(regs, 0, sizeof(struct pt_regs));
+	(void)memset(regs, 0, sizeof(struct pt_regs));
 	return regs;
 }
 
@@ -1520,7 +1520,7 @@ long do_fork(unsigned long clone_flags,
 		nr = task_pid_vnr(p);
 
 		if (clone_flags & CLONE_PARENT_SETTID)
-			put_user(nr, parent_tidptr);
+			(void)put_user(nr, parent_tidptr);
 
 		if (clone_flags & CLONE_VFORK) {
 			p->vfork_done = &vfork;
diff --git a/kernel/futex.c b/kernel/futex.c
index 1614be2..c9811af 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -199,7 +199,7 @@ static void drop_futex_key_refs(union futex_key *key)
 {
 	if (!key->both.ptr) {
 		/* If we're here then we tried to put a key we failed to get */
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return;
 	}
 
@@ -476,7 +476,7 @@ static struct futex_pi_state * alloc_pi_state(void)
 {
 	struct futex_pi_state *pi_state = current->pi_state_cache;
 
-	WARN_ON(!pi_state);
+	(void)WARN_ON(!pi_state);
 	current->pi_state_cache = NULL;
 
 	return pi_state;
@@ -571,8 +571,8 @@ void exit_pi_state_list(struct task_struct *curr)
 			continue;
 		}
 
-		WARN_ON(pi_state->owner != curr);
-		WARN_ON(list_empty(&pi_state->list));
+		(void)WARN_ON(pi_state->owner != curr);
+		(void)WARN_ON(list_empty(&pi_state->list));
 		list_del_init(&pi_state->list);
 		pi_state->owner = NULL;
 		raw_spin_unlock_irq(&curr->pi_lock);
@@ -611,7 +611,7 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 			if (unlikely(!pi_state))
 				return -EINVAL;
 
-			WARN_ON(!atomic_read(&pi_state->refcount));
+			(void)WARN_ON(!atomic_read(&pi_state->refcount));
 
 			/*
 			 * When pi_state->owner is NULL then the owner died
@@ -680,7 +680,7 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	/* Store the key for possible exit cleanups: */
 	pi_state->key = *key;
 
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &p->pi_state_list);
 	pi_state->owner = p;
 	raw_spin_unlock_irq(&p->pi_lock);
@@ -910,12 +910,12 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 	}
 
 	raw_spin_lock_irq(&pi_state->owner->pi_lock);
-	WARN_ON(list_empty(&pi_state->list));
+	(void)WARN_ON(list_empty(&pi_state->list));
 	list_del_init(&pi_state->list);
 	raw_spin_unlock_irq(&pi_state->owner->pi_lock);
 
 	raw_spin_lock_irq(&new_owner->pi_lock);
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &new_owner->pi_state_list);
 	pi_state->owner = new_owner;
 	raw_spin_unlock_irq(&new_owner->pi_lock);
@@ -1151,7 +1151,7 @@ void requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,
 
 	__unqueue_futex(q);
 
-	WARN_ON(!q->rt_waiter);
+	(void)WARN_ON(!q->rt_waiter);
 	q->rt_waiter = NULL;
 
 	q->lock_ptr = &hb->lock;
@@ -1340,7 +1340,7 @@ retry_private:
 		 * reference to it.
 		 */
 		if (ret == 1) {
-			WARN_ON(pi_state);
+			(void)WARN_ON(pi_state);
 			drop_count++;
 			task_count++;
 			ret = get_futex_value_locked(&curval2, uaddr2);
@@ -1632,7 +1632,7 @@ retry:
 	 */
 	if (pi_state->owner != NULL) {
 		raw_spin_lock_irq(&pi_state->owner->pi_lock);
-		WARN_ON(list_empty(&pi_state->list));
+		(void)WARN_ON(list_empty(&pi_state->list));
 		list_del_init(&pi_state->list);
 		raw_spin_unlock_irq(&pi_state->owner->pi_lock);
 	}
@@ -1640,7 +1640,7 @@ retry:
 	pi_state->owner = newowner;
 
 	raw_spin_lock_irq(&newowner->pi_lock);
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &newowner->pi_state_list);
 	raw_spin_unlock_irq(&newowner->pi_lock);
 	return 0;
@@ -2018,7 +2018,7 @@ retry_private:
 	 */
 	queue_me(&q, hb);
 
-	WARN_ON(!q.pi_state);
+	(void)WARN_ON(!q.pi_state);
 	/*
 	 * Block on the PI mutex:
 	 */
@@ -2201,7 +2201,7 @@ int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,
 	 * support a PI aware source futex for requeue.
 	 */
 	if (!match_futex(&q->key, key2)) {
-		WARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));
+		(void)WARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));
 		/*
 		 * We were woken prior to requeue by a timeout or a signal.
 		 * Unqueue the futex_q and determine which it was.
@@ -2342,7 +2342,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		 * signal.  futex_unlock_pi() will not destroy the lock_ptr nor
 		 * the pi_state.
 		 */
-		WARN_ON(!&q.pi_state);
+		(void)WARN_ON(!&q.pi_state);
 		pi_mutex = &q.pi_state->pi_mutex;
 		ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);
 		debug_rt_mutex_free_waiter(&rt_waiter);
diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index ae34bf5..86324c7 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -321,7 +321,7 @@ u64 ktime_divns(const ktime_t kt, s64 div)
 		div >>= 1;
 	}
 	dclc >>= sft;
-	do_div(dclc, (unsigned long) div);
+	(void)do_div(dclc, (unsigned long) div);
 
 	return dclc;
 }
@@ -582,7 +582,7 @@ static int hrtimer_reprogram(struct hrtimer *timer,
 	ktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);
 	int res;
 
-	WARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);
+	(void)WARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);
 
 	/*
 	 * When the callback is running, we do not reprogram the clock event
@@ -761,7 +761,7 @@ void clock_was_set(void)
  */
 void hrtimers_resume(void)
 {
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		  KERN_INFO "hrtimers_resume() called with IRQs enabled!");
 
 	retrigger_next_event(NULL);
@@ -1142,7 +1142,7 @@ static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
 	struct hrtimer_cpu_base *cpu_base;
 	int base;
 
-	memset(timer, 0, sizeof(struct hrtimer));
+	(void)memset(timer, 0, sizeof(struct hrtimer));
 
 	cpu_base = &__raw_get_cpu_var(hrtimer_bases);
 
@@ -1156,7 +1156,7 @@ static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
 #ifdef CONFIG_TIMER_STATS
 	timer->start_site = NULL;
 	timer->start_pid = -1;
-	memset(timer->start_comm, 0, TASK_COMM_LEN);
+	(void)memset(timer->start_comm, 0, TASK_COMM_LEN);
 #endif
 }
 
@@ -1201,7 +1201,7 @@ static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)
 	enum hrtimer_restart (*fn)(struct hrtimer *);
 	int restart;
 
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	debug_deactivate(timer);
 	__remove_hrtimer(timer, base, HRTIMER_STATE_CALLBACK, 0);
@@ -1229,7 +1229,7 @@ static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)
 		enqueue_hrtimer(timer, base);
 	}
 
-	WARN_ON_ONCE(!(timer->state & HRTIMER_STATE_CALLBACK));
+	(void)WARN_ON_ONCE(!(timer->state & HRTIMER_STATE_CALLBACK));
 
 	timer->state &= ~HRTIMER_STATE_CALLBACK;
 }
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index a9a9dbe..aeae73a 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -418,7 +418,7 @@ void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume)
 	switch (desc->depth) {
 	case 0:
  err_out:
-		WARN(1, KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);
+		(void)WARN(1, KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);
 		break;
 	case 1: {
 		if (desc->istate & IRQS_SUSPENDED)
@@ -510,7 +510,7 @@ int irq_set_irq_wake(unsigned int irq, unsigned int on)
 		}
 	} else {
 		if (desc->wake_depth == 0) {
-			WARN(1, "Unbalanced IRQ %d wake disable\n", irq);
+			(void)WARN(1, "Unbalanced IRQ %d wake disable\n", irq);
 		} else if (--desc->wake_depth == 0) {
 			ret = set_irq_wake_real(irq, on);
 			if (ret)
@@ -617,7 +617,7 @@ static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)
  */
 static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)
 {
-	WARN(1, "Primary handler called for nested irq %d\n", irq);
+	(void)WARN(1, "Primary handler called for nested irq %d\n", irq);
 	return IRQ_NONE;
 }
 
@@ -1144,7 +1144,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 	struct irqaction *action, **action_ptr;
 	unsigned long flags;
 
-	WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
+	(void)WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
 
 	if (!desc)
 		return NULL;
@@ -1160,7 +1160,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 		action = *action_ptr;
 
 		if (!action) {
-			WARN(1, "Trying to free already-free IRQ %d\n", irq);
+			(void)WARN(1, "Trying to free already-free IRQ %d\n", irq);
 			raw_spin_unlock_irqrestore(&desc->lock, flags);
 
 			return NULL;
@@ -1438,7 +1438,7 @@ void enable_percpu_irq(unsigned int irq, unsigned int type)
 		ret = __irq_set_trigger(desc, irq, type);
 
 		if (ret) {
-			WARN(1, "failed to set type for IRQ%d\n", irq);
+			(void)WARN(1, "failed to set type for IRQ%d\n", irq);
 			goto out;
 		}
 	}
@@ -1470,7 +1470,7 @@ static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_
 	struct irqaction *action;
 	unsigned long flags;
 
-	WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
+	(void)WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
 
 	if (!desc)
 		return NULL;
@@ -1479,12 +1479,12 @@ static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_
 
 	action = desc->action;
 	if (!action || action->percpu_dev_id != dev_id) {
-		WARN(1, "Trying to free already-free IRQ %d\n", irq);
+		(void)WARN(1, "Trying to free already-free IRQ %d\n", irq);
 		goto bad;
 	}
 
 	if (!cpumask_empty(desc->percpu_enabled)) {
-		WARN(1, "percpu IRQ %d still enabled on CPU%d!\n",
+		(void)WARN(1, "percpu IRQ %d still enabled on CPU%d!\n",
 		     irq, cpumask_first(desc->percpu_enabled));
 		goto bad;
 	}
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index 4bd4faa..c2d34d3 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -296,7 +296,7 @@ void register_handler_proc(unsigned int irq, struct irqaction *action)
 					!name_unique(irq, action))
 		return;
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	snprintf(name, MAX_NAMELEN, "%s", action->name);
 
 	/* create /proc/irq/1234/handler/ */
@@ -314,7 +314,7 @@ void register_irq_proc(unsigned int irq, struct irq_desc *desc)
 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip) || desc->dir)
 		return;
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	sprintf(name, "%d", irq);
 
 	/* create /proc/irq/1234 */
@@ -357,7 +357,7 @@ void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)
 #endif
 	remove_proc_entry("spurious", desc->dir);
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	sprintf(name, "%u", irq);
 	remove_proc_entry(name, root_irq_dir);
 }
diff --git a/kernel/itimer.c b/kernel/itimer.c
index 22000c3..f531700 100644
--- a/kernel/itimer.c
+++ b/kernel/itimer.c
@@ -285,7 +285,7 @@ SYSCALL_DEFINE3(setitimer, int, which, struct itimerval __user *, value,
 		if(copy_from_user(&set_buffer, value, sizeof(set_buffer)))
 			return -EFAULT;
 	} else
-		memset((char *) &set_buffer, 0, sizeof(set_buffer));
+		(void)memset((char *) &set_buffer, 0, sizeof(set_buffer));
 
 	error = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);
 	if (error || !ovalue)
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 29f5b65..7f683e6 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -167,7 +167,7 @@ static kprobe_opcode_t __kprobes *__get_insn_slot(struct kprobe_insn_cache *c)
 			}
 			/* kip->nused is broken. Fix it. */
 			kip->nused = slots_per_page(c);
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		}
 	}
 
@@ -191,7 +191,7 @@ static kprobe_opcode_t __kprobes *__get_insn_slot(struct kprobe_insn_cache *c)
 		return NULL;
 	}
 	INIT_LIST_HEAD(&kip->list);
-	memset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));
+	(void)memset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));
 	kip->slot_used[0] = SLOT_USED;
 	kip->nused = 1;
 	kip->ngarbage = 0;
@@ -264,7 +264,7 @@ static void __kprobes __free_insn_slot(struct kprobe_insn_cache *c,
 		long idx = ((long)slot - (long)kip->insns) /
 				(c->insn_size * sizeof(kprobe_opcode_t));
 		if (idx >= 0 && idx < slots_per_page(c)) {
-			WARN_ON(kip->slot_used[idx] != SLOT_USED);
+			(void)WARN_ON(kip->slot_used[idx] != SLOT_USED);
 			if (dirty) {
 				kip->slot_used[idx] = SLOT_DIRTY;
 				kip->ngarbage++;
@@ -276,7 +276,7 @@ static void __kprobes __free_insn_slot(struct kprobe_insn_cache *c,
 		}
 	}
 	/* Could not free this slot. */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 void __kprobes free_insn_slot(kprobe_opcode_t * slot, int dirty)
@@ -1477,7 +1477,7 @@ static int __kprobes __unregister_kprobe_top(struct kprobe *p)
 		goto disarmed;
 
 	/* Following process expects this probe is an aggrprobe */
-	WARN_ON(!kprobe_aggrprobe(ap));
+	(void)WARN_ON(!kprobe_aggrprobe(ap));
 
 	if (list_is_singular(&ap->list) && kprobe_disarmed(ap))
 		/*
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 3d3de63..7270281 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -223,7 +223,7 @@ void kthread_bind(struct task_struct *p, unsigned int cpu)
 {
 	/* Must have done schedule() in kthread() before we set_task_cpu */
 	if (!wait_task_inactive(p, TASK_UNINTERRUPTIBLE)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -340,7 +340,7 @@ int kthread_worker_fn(void *worker_ptr)
 	struct kthread_worker *worker = worker_ptr;
 	struct kthread_work *work;
 
-	WARN_ON(worker->task);
+	(void)WARN_ON(worker->task);
 	worker->task = current;
 repeat:
 	set_current_state(TASK_INTERRUPTIBLE);	/* mb paired w/ kthread_stop */
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index 8889f7d..e35a283 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -2924,7 +2924,7 @@ static int mark_lock(struct task_struct *curr, struct held_lock *this,
 	default:
 		if (!debug_locks_off_graph_unlock())
 			return 0;
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
@@ -3804,7 +3804,7 @@ void lockdep_reset(void)
 	current->curr_chain_key = 0;
 	current->lockdep_depth = 0;
 	current->lockdep_recursion = 0;
-	memset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));
+	(void)memset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));
 	nr_hardirq_chains = 0;
 	nr_softirq_chains = 0;
 	nr_process_chains = 0;
diff --git a/kernel/module.c b/kernel/module.c
index 2c93276..de18616 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1537,7 +1537,7 @@ static int mod_sysfs_init(struct module *mod)
 
 	mod->mkobj.mod = mod;
 
-	memset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));
+	(void)memset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));
 	mod->mkobj.kobj.kset = module_kset;
 	err = kobject_init_and_add(&mod->mkobj.kobj, &module_ktype, NULL,
 				   "%s", mod->name);
@@ -2641,7 +2641,7 @@ static int move_module(struct module *mod, struct load_info *info)
 	if (!ptr)
 		return -ENOMEM;
 
-	memset(ptr, 0, mod->core_size);
+	(void)memset(ptr, 0, mod->core_size);
 	mod->module_core = ptr;
 
 	ptr = module_alloc_update_bounds(mod->init_size);
@@ -2656,7 +2656,7 @@ static int move_module(struct module *mod, struct load_info *info)
 		module_free(mod, mod->module_core);
 		return -ENOMEM;
 	}
-	memset(ptr, 0, mod->init_size);
+	(void)memset(ptr, 0, mod->init_size);
 	mod->module_init = ptr;
 
 	/* Transfer each section which specifies SHF_ALLOC */
diff --git a/kernel/params.c b/kernel/params.c
index 32ee043..3c3c618 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -638,9 +638,9 @@ static __modinit int add_sysfs_param(struct module_kobject *mk,
 	}
 
 	/* Sysfs wants everything zeroed. */
-	memset(new, 0, sizeof(*new));
-	memset(&new->attrs[num], 0, sizeof(new->attrs[num]));
-	memset(&attrs[num], 0, sizeof(attrs[num]));
+	(void)memset(new, 0, sizeof(*new));
+	(void)memset(&new->attrs[num], 0, sizeof(new->attrs[num]));
+	(void)memset(&attrs[num], 0, sizeof(attrs[num]));
 	new->grp.name = "parameters";
 	new->grp.attrs = attrs;
 
diff --git a/kernel/posix-cpu-timers.c b/kernel/posix-cpu-timers.c
index 125cb67..e31eff9 100644
--- a/kernel/posix-cpu-timers.c
+++ b/kernel/posix-cpu-timers.c
@@ -1400,7 +1400,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 	/*
 	 * Set up a temporary timer and then wait for it to go off.
 	 */
-	memset(&timer, 0, sizeof timer);
+	(void)memset(&timer, 0, sizeof timer);
 	spin_lock_init(&timer.it_lock);
 	timer.it_clock = which_clock;
 	timer.it_overrun = -1;
@@ -1409,7 +1409,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 	if (!error) {
 		static struct itimerspec zero_it;
 
-		memset(it, 0, sizeof *it);
+		(void)memset(it, 0, sizeof *it);
 		it->it_value = *rqtp;
 
 		spin_lock_irq(&timer.it_lock);
@@ -1597,7 +1597,7 @@ static __init int init_posix_cpu_timers(void)
 
 	cputime_to_timespec(cputime_one_jiffy, &ts);
 	onecputick = ts.tv_nsec;
-	WARN_ON(ts.tv_sec != 0);
+	(void)WARN_ON(ts.tv_sec != 0);
 
 	return 0;
 }
diff --git a/kernel/posix-timers.c b/kernel/posix-timers.c
index 69185ae..46300e8 100644
--- a/kernel/posix-timers.c
+++ b/kernel/posix-timers.c
@@ -487,7 +487,7 @@ static struct k_itimer * alloc_posix_timer(void)
 		kmem_cache_free(posix_timers_cache, tmr);
 		return NULL;
 	}
-	memset(&tmr->sigq->info, 0, sizeof(siginfo_t));
+	(void)memset(&tmr->sigq->info, 0, sizeof(siginfo_t));
 	return tmr;
 }
 
@@ -676,7 +676,7 @@ common_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 	ktime_t now, remaining, iv;
 	struct hrtimer *timer = &timr->it.real.timer;
 
-	memset(cur_setting, 0, sizeof(struct itimerspec));
+	(void)memset(cur_setting, 0, sizeof(struct itimerspec));
 
 	iv = timr->it.real.interval;
 
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 77274c9..f6fa746 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -87,7 +87,7 @@ static int try_to_freeze_tasks(bool user_only)
 
 	do_gettimeofday(&end);
 	elapsed_csecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);
-	do_div(elapsed_csecs64, NSEC_PER_SEC / 100);
+	(void)do_div(elapsed_csecs64, NSEC_PER_SEC / 100);
 	elapsed_csecs = elapsed_csecs64;
 
 	if (todo) {
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 995e3bd..e31bc0a 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -249,7 +249,7 @@ void pm_qos_add_request(struct pm_qos_request *req,
 		return;
 
 	if (pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
+		(void)WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
 		return;
 	}
 	req->pm_qos_class = pm_qos_class;
@@ -275,7 +275,7 @@ void pm_qos_update_request(struct pm_qos_request *req,
 		return;
 
 	if (!pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
 		return;
 	}
 
@@ -301,14 +301,14 @@ void pm_qos_remove_request(struct pm_qos_request *req)
 		/* silent return to keep pcm code cleaner */
 
 	if (!pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
 		return;
 	}
 
 	pm_qos_update_target(pm_qos_array[req->pm_qos_class]->constraints,
 			     &req->node, PM_QOS_REMOVE_REQ,
 			     PM_QOS_DEFAULT_VALUE);
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 }
 EXPORT_SYMBOL_GPL(pm_qos_remove_request);
 
diff --git a/kernel/profile.c b/kernel/profile.c
index 76b8e77..79d7c3e 100644
--- a/kernel/profile.c
+++ b/kernel/profile.c
@@ -218,7 +218,7 @@ EXPORT_SYMBOL_GPL(register_timer_hook);
 
 void unregister_timer_hook(int (*hook)(struct pt_regs *))
 {
-	WARN_ON(hook != timer_hook);
+	(void)WARN_ON(hook != timer_hook);
 	timer_hook = NULL;
 	/* make sure all CPUs see the NULL hook */
 	synchronize_sched();  /* Allow ongoing interrupts to complete. */
@@ -298,7 +298,7 @@ static void profile_discard_flip_buffers(void)
 	on_each_cpu(__profile_flip_buffers, NULL, 1);
 	for_each_online_cpu(cpu) {
 		struct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];
-		memset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));
+		(void)memset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));
 	}
 	mutex_unlock(&profile_flip_mutex);
 }
@@ -548,7 +548,7 @@ static ssize_t write_profile(struct file *file, const char __user *buf,
 	}
 #endif
 	profile_discard_flip_buffers();
-	memset(prof_buffer, 0, prof_len * sizeof(atomic_t));
+	(void)memset(prof_buffer, 0, prof_len * sizeof(atomic_t));
 	return count;
 }
 
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 00ab2ca..338c719 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -157,7 +157,7 @@ int ptrace_check_attach(struct task_struct *child, bool ignore_state)
 		 * does ptrace_unlink() before __exit_signal().
 		 */
 		spin_lock_irq(&child->sighand->siglock);
-		WARN_ON_ONCE(task_is_stopped(child));
+		(void)WARN_ON_ONCE(task_is_stopped(child));
 		if (ignore_state || (task_is_traced(child) &&
 				     !(child->jobctl & JOBCTL_LISTENING)))
 			ret = 0;
diff --git a/kernel/rcutiny.c b/kernel/rcutiny.c
index 977296d..df20d79 100644
--- a/kernel/rcutiny.c
+++ b/kernel/rcutiny.c
@@ -70,7 +70,7 @@ static void rcu_idle_enter_common(long long oldval)
 		RCU_TRACE(trace_rcu_dyntick("Error on entry: not idle task",
 					    oldval, rcu_dynticks_nesting));
 		ftrace_dump(DUMP_ALL);
-		WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
+		(void)WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
 			  current->pid, current->comm,
 			  idle->pid, idle->comm); /* must be idle task! */
 	}
@@ -104,7 +104,7 @@ void rcu_irq_exit(void)
 	local_irq_save(flags);
 	oldval = rcu_dynticks_nesting;
 	rcu_dynticks_nesting--;
-	WARN_ON_ONCE(rcu_dynticks_nesting < 0);
+	(void)WARN_ON_ONCE(rcu_dynticks_nesting < 0);
 	rcu_idle_enter_common(oldval);
 	local_irq_restore(flags);
 }
@@ -124,7 +124,7 @@ static void rcu_idle_exit_common(long long oldval)
 		RCU_TRACE(trace_rcu_dyntick("Error on exit: not idle task",
 			  oldval, rcu_dynticks_nesting));
 		ftrace_dump(DUMP_ALL);
-		WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
+		(void)WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
 			  current->pid, current->comm,
 			  idle->pid, idle->comm); /* must be idle task! */
 	}
@@ -157,7 +157,7 @@ void rcu_irq_enter(void)
 	local_irq_save(flags);
 	oldval = rcu_dynticks_nesting;
 	rcu_dynticks_nesting++;
-	WARN_ON_ONCE(rcu_dynticks_nesting == 0);
+	(void)WARN_ON_ONCE(rcu_dynticks_nesting == 0);
 	rcu_idle_exit_common(oldval);
 	local_irq_restore(flags);
 }
diff --git a/kernel/rcutree.c b/kernel/rcutree.c
index 6c4a672..dc25751 100644
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -538,7 +538,7 @@ void rcu_nmi_enter(void)
 	atomic_inc(&rdtp->dynticks);
 	/* CPUs seeing atomic_inc() must see later RCU read-side crit sects */
 	smp_mb__after_atomic_inc();  /* See above. */
-	WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
+	(void)WARN_ON_ONCE(!(atomic_read(&rdtp->dynticks) & 0x1));
 }
 
 /**
@@ -559,7 +559,7 @@ void rcu_nmi_exit(void)
 	smp_mb__before_atomic_inc();  /* See above. */
 	atomic_inc(&rdtp->dynticks);
 	smp_mb__after_atomic_inc();  /* Force delay to next write. */
-	WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
+	(void)WARN_ON_ONCE(atomic_read(&rdtp->dynticks) & 0x1);
 }
 
 #ifdef CONFIG_PROVE_RCU
@@ -1056,7 +1056,7 @@ static void rcu_report_qs_rsp(struct rcu_state *rsp, unsigned long flags)
 	struct rcu_node *rnp = rcu_get_root(rsp);
 	struct rcu_data *rdp = this_cpu_ptr(rsp->rda);
 
-	WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
+	(void)WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
 
 	/*
 	 * Ensure that all grace-period and pre-grace-period activity
@@ -1150,7 +1150,7 @@ rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,
 		rnp_c = rnp;
 		rnp = rnp->parent;
 		raw_spin_lock_irqsave(&rnp->lock, flags);
-		WARN_ON_ONCE(rnp_c->qsmask);
+		(void)WARN_ON_ONCE(rnp_c->qsmask);
 	}
 
 	/*
@@ -1635,7 +1635,7 @@ __rcu_process_callbacks(struct rcu_state *rsp, struct rcu_data *rdp)
 {
 	unsigned long flags;
 
-	WARN_ON_ONCE(rdp->beenonline == 0);
+	(void)WARN_ON_ONCE(rdp->beenonline == 0);
 
 	/*
 	 * If an RCU GP has gone long enough, go check for dyntick
@@ -2167,8 +2167,8 @@ static int __cpuinit rcu_cpu_notify(struct notifier_block *self,
  */
 void rcu_scheduler_starting(void)
 {
-	WARN_ON(num_online_cpus() != 1);
-	WARN_ON(nr_context_switches() > 0);
+	(void)WARN_ON(num_online_cpus() != 1);
+	(void)WARN_ON(nr_context_switches() > 0);
 	rcu_scheduler_active = 1;
 }
 
diff --git a/kernel/rcutree_plugin.h b/kernel/rcutree_plugin.h
index 8bb35d7..311eb92 100644
--- a/kernel/rcutree_plugin.h
+++ b/kernel/rcutree_plugin.h
@@ -186,8 +186,8 @@ static void rcu_preempt_note_context_switch(int cpu)
 		 * But first, note that the current CPU must still be
 		 * on line!
 		 */
-		WARN_ON_ONCE((rdp->grpmask & rnp->qsmaskinit) == 0);
-		WARN_ON_ONCE(!list_empty(&t->rcu_node_entry));
+		(void)WARN_ON_ONCE((rdp->grpmask & rnp->qsmaskinit) == 0);
+		(void)WARN_ON_ONCE(!list_empty(&t->rcu_node_entry));
 		if ((rnp->qsmask & rdp->grpmask) && rnp->gp_tasks != NULL) {
 			list_add(&t->rcu_node_entry, rnp->gp_tasks->prev);
 			rnp->gp_tasks = &t->rcu_node_entry;
@@ -442,7 +442,7 @@ void __rcu_read_unlock(void)
 	{
 		int rrln = ACCESS_ONCE(t->rcu_read_lock_nesting);
 
-		WARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);
+		(void)WARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);
 	}
 #endif /* #ifdef CONFIG_PROVE_LOCKING */
 }
@@ -532,10 +532,10 @@ static void rcu_preempt_stall_reset(void)
  */
 static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)
 {
-	WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp));
+	(void)WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp));
 	if (!list_empty(&rnp->blkd_tasks))
 		rnp->gp_tasks = rnp->blkd_tasks.next;
-	WARN_ON_ONCE(rnp->qsmask);
+	(void)WARN_ON_ONCE(rnp->qsmask);
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -565,12 +565,12 @@ static int rcu_preempt_offline_tasks(struct rcu_state *rsp,
 	struct task_struct *t;
 
 	if (rnp == rnp_root) {
-		WARN_ONCE(1, "Last CPU thought to be offlined?");
+		(void)WARN_ONCE(1, "Last CPU thought to be offlined?");
 		return 0;  /* Shouldn't happen: at least one CPU online. */
 	}
 
 	/* If we are on an internal node, complain bitterly. */
-	WARN_ON_ONCE(rnp != rdp->mynode);
+	(void)WARN_ON_ONCE(rnp != rdp->mynode);
 
 	/*
 	 * Move tasks up to root rcu_node.  Don't try to get fancy for
@@ -1782,7 +1782,7 @@ static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)
 
 static void invoke_rcu_callbacks_kthread(void)
 {
-	WARN_ON_ONCE(1);
+	(void)WARN_ON_ONCE(1);
 }
 
 static bool rcu_is_callbacks_kthread(void)
diff --git a/kernel/resource.c b/kernel/resource.c
index 7640b3a..2aa88ff 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -1018,7 +1018,7 @@ void __devm_release_region(struct device *dev, struct resource *parent,
 	struct region_devres match_data = { parent, start, n };
 
 	__release_region(parent, start, n);
-	WARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,
+	(void)WARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,
 			       &match_data));
 }
 EXPORT_SYMBOL(__devm_release_region);
diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index a242e69..f8fe7e1 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -523,7 +523,7 @@ static void remove_waiter(struct rt_mutex *lock,
 		raw_spin_unlock_irqrestore(&owner->pi_lock, flags);
 	}
 
-	WARN_ON(!plist_node_empty(&waiter->pi_list_entry));
+	(void)WARN_ON(!plist_node_empty(&waiter->pi_list_entry));
 
 	if (!chain_walk)
 		return;
@@ -869,7 +869,7 @@ EXPORT_SYMBOL_GPL(rt_mutex_unlock);
  */
 void rt_mutex_destroy(struct rt_mutex *lock)
 {
-	WARN_ON(rt_mutex_is_locked(lock));
+	(void)WARN_ON(rt_mutex_is_locked(lock));
 #ifdef CONFIG_DEBUG_RT_MUTEXES
 	lock->magic = NULL;
 #endif
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index df00cb0..7a5d563 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2010,7 +2010,7 @@ asmlinkage void schedule_tail(struct task_struct *prev)
 	preempt_enable();
 #endif
 	if (current->set_child_tid)
-		put_user(task_pid_vnr(current), current->set_child_tid);
+		(void)put_user(task_pid_vnr(current), current->set_child_tid);
 }
 
 /*
@@ -2940,7 +2940,7 @@ void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = (__force u64) rtime;
 
 		temp *= (__force u64) utime;
-		do_div(temp, (__force u32) total);
+		(void)do_div(temp, (__force u32) total);
 		utime = (__force cputime_t) temp;
 	} else
 		utime = rtime;
@@ -2973,7 +2973,7 @@ void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = (__force u64) rtime;
 
 		temp *= (__force u64) cputime.utime;
-		do_div(temp, (__force u32) total);
+		(void)do_div(temp, (__force u32) total);
 		utime = (__force cputime_t) temp;
 	} else
 		utime = rtime;
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 2a075e1..41c5f34 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -39,10 +39,10 @@ static long long nsec_high(unsigned long long nsec)
 {
 	if ((long long)nsec < 0) {
 		nsec = -nsec;
-		do_div(nsec, 1000000);
+		(void)do_div(nsec, 1000000);
 		return -nsec;
 	}
-	do_div(nsec, 1000000);
+	(void)do_div(nsec, 1000000);
 
 	return nsec;
 }
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 3640ebb..6056850 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -1023,7 +1023,7 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
 	int prio = rt_se_prio(rt_se);
 
-	WARN_ON(!rt_prio(prio));
+	(void)WARN_ON(!rt_prio(prio));
 	rt_rq->rt_nr_running++;
 
 	inc_rt_prio(rt_rq, prio);
@@ -1034,8 +1034,8 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 static inline
 void dec_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
-	WARN_ON(!rt_prio(rt_se_prio(rt_se)));
-	WARN_ON(!rt_rq->rt_nr_running);
+	(void)WARN_ON(!rt_prio(rt_se_prio(rt_se)));
+	(void)WARN_ON(!rt_rq->rt_nr_running);
 	rt_rq->rt_nr_running--;
 
 	dec_rt_prio(rt_rq, rt_se_prio(rt_se));
diff --git a/kernel/signal.c b/kernel/signal.c
index c73c428..555bdfbb 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -324,7 +324,7 @@ static bool task_participate_group_stop(struct task_struct *task)
 	struct signal_struct *sig = task->signal;
 	bool consume = task->jobctl & JOBCTL_STOP_CONSUME;
 
-	WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));
+	(void)WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));
 
 	task_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);
 
@@ -838,7 +838,7 @@ static int check_kill_permission(int sig, struct siginfo *info,
  */
 static void ptrace_trap_notify(struct task_struct *t)
 {
-	WARN_ON_ONCE(!(t->ptrace & PT_SEIZED));
+	(void)WARN_ON_ONCE(!(t->ptrace & PT_SEIZED));
 	assert_spin_locked(&t->sighand->siglock);
 
 	task_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);
@@ -1949,7 +1949,7 @@ static void ptrace_do_notify(int signr, int exit_code, int why)
 {
 	siginfo_t info;
 
-	memset(&info, 0, sizeof info);
+	(void)memset(&info, 0, sizeof info);
 	info.si_signo = signr;
 	info.si_code = exit_code;
 	info.si_pid = task_pid_vnr(current);
@@ -2000,7 +2000,7 @@ static bool do_signal_stop(int signr)
 		struct task_struct *t;
 
 		/* signr will be recorded in task->jobctl for retries */
-		WARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);
+		(void)WARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);
 
 		if (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||
 		    unlikely(signal_group_exit(sig)))
@@ -2116,11 +2116,11 @@ static void do_jobctl_trap(void)
 		if (!signal->group_stop_count &&
 		    !(signal->flags & SIGNAL_STOP_STOPPED))
 			signr = SIGTRAP;
-		WARN_ON_ONCE(!signr);
+		(void)WARN_ON_ONCE(!signr);
 		ptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),
 				 CLD_STOPPED);
 	} else {
-		WARN_ON_ONCE(!signr);
+		(void)WARN_ON_ONCE(!signr);
 		ptrace_stop(signr, CLD_STOPPED, 0, NULL);
 		current->exit_code = 0;
 	}
@@ -2910,7 +2910,7 @@ SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,
 	 */
 	if (info.si_code >= 0 || info.si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info.si_code < 0);
+		(void)WARN_ON_ONCE(info.si_code < 0);
 		return -EPERM;
 	}
 	info.si_signo = sig;
@@ -2930,7 +2930,7 @@ long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 	 */
 	if (info->si_code >= 0 || info->si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info->si_code < 0);
+		(void)WARN_ON_ONCE(info->si_code < 0);
 		return -EPERM;
 	}
 	info->si_signo = sig;
diff --git a/kernel/smp.c b/kernel/smp.c
index db197d6..08a8025 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -118,7 +118,7 @@ static void csd_lock(struct call_single_data *data)
 
 static void csd_unlock(struct call_single_data *data)
 {
-	WARN_ON(!(data->flags & CSD_FLAG_LOCK));
+	(void)WARN_ON(!(data->flags & CSD_FLAG_LOCK));
 
 	/*
 	 * ensure we're all done before releasing data:
@@ -175,7 +175,7 @@ void generic_smp_call_function_interrupt(void)
 	/*
 	 * Shouldn't receive this interrupt on a cpu that is not yet online.
 	 */
-	WARN_ON_ONCE(!cpu_online(cpu));
+	(void)WARN_ON_ONCE(!cpu_online(cpu));
 
 	/*
 	 * Ensure entry is visible on call_function_queue after we have
@@ -221,17 +221,17 @@ void generic_smp_call_function_interrupt(void)
 		 * on this cpu.  That nested execution decremented refs.
 		 */
 		if (!cpumask_test_and_clear_cpu(cpu, data->cpumask)) {
-			WARN(1, "%pf enabled interrupts and double executed\n", func);
+			(void)WARN(1, "%pf enabled interrupts and double executed\n", func);
 			continue;
 		}
 
 		refs = atomic_dec_return(&data->refs);
-		WARN_ON(refs < 0);
+		(void)WARN_ON(refs < 0);
 
 		if (refs)
 			continue;
 
-		WARN_ON(!cpumask_empty(data->cpumask));
+		(void)WARN_ON(!cpumask_empty(data->cpumask));
 
 		raw_spin_lock(&call_function.lock);
 		list_del_rcu(&data->csd.list);
@@ -255,7 +255,7 @@ void generic_smp_call_function_single_interrupt(void)
 	/*
 	 * Shouldn't receive this interrupt on a cpu that is not yet online.
 	 */
-	WARN_ON_ONCE(!cpu_online(smp_processor_id()));
+	(void)WARN_ON_ONCE(!cpu_online(smp_processor_id()));
 
 	raw_spin_lock(&q->lock);
 	list_replace_init(&q->list, &list);
@@ -316,7 +316,7 @@ int smp_call_function_single(int cpu, smp_call_func_t func, void *info,
 	 * send smp call function interrupt to this cpu and as such deadlocks
 	 * can't happen.
 	 */
-	WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
+	(void)WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
 		     && !oops_in_progress);
 
 	if (cpu == this_cpu) {
@@ -414,7 +414,7 @@ void __smp_call_function_single(int cpu, struct call_single_data *data,
 	 * send smp call function interrupt to this cpu and as such deadlocks
 	 * can't happen.
 	 */
-	WARN_ON_ONCE(cpu_online(smp_processor_id()) && wait && irqs_disabled()
+	(void)WARN_ON_ONCE(cpu_online(smp_processor_id()) && wait && irqs_disabled()
 		     && !oops_in_progress);
 
 	if (cpu == this_cpu) {
@@ -455,7 +455,7 @@ void smp_call_function_many(const struct cpumask *mask,
 	 * send smp call function interrupt to this cpu and as such deadlocks
 	 * can't happen.
 	 */
-	WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
+	(void)WARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()
 		     && !oops_in_progress && !early_boot_irqs_disabled);
 
 	/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 4eb3a0f..658c89b 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -95,7 +95,7 @@ static void __local_bh_disable(unsigned long ip, unsigned int cnt)
 {
 	unsigned long flags;
 
-	WARN_ON_ONCE(in_irq());
+	(void)WARN_ON_ONCE(in_irq());
 
 	raw_local_irq_save(flags);
 	/*
@@ -134,8 +134,8 @@ EXPORT_SYMBOL(local_bh_disable);
 
 static void __local_bh_enable(unsigned int cnt)
 {
-	WARN_ON_ONCE(in_irq());
-	WARN_ON_ONCE(!irqs_disabled());
+	(void)WARN_ON_ONCE(in_irq());
+	(void)WARN_ON_ONCE(!irqs_disabled());
 
 	if (softirq_count() == cnt)
 		trace_softirqs_on((unsigned long)__builtin_return_address(0));
@@ -156,7 +156,7 @@ EXPORT_SYMBOL(_local_bh_enable);
 
 static inline void _local_bh_enable_ip(unsigned long ip)
 {
-	WARN_ON_ONCE(in_irq() || irqs_disabled());
+	(void)WARN_ON_ONCE(in_irq() || irqs_disabled());
 #ifdef CONFIG_TRACE_IRQFLAGS
 	local_irq_disable();
 #endif
@@ -731,7 +731,7 @@ void __init softirq_init(void)
 			INIT_LIST_HEAD(&per_cpu(softirq_work_list[i], cpu));
 	}
 
-	register_hotcpu_notifier(&remote_softirq_cpu_notifier);
+	(void)register_hotcpu_notifier(&remote_softirq_cpu_notifier);
 
 	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
 	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
diff --git a/kernel/srcu.c b/kernel/srcu.c
index 0febf61..77e25b7 100644
--- a/kernel/srcu.c
+++ b/kernel/srcu.c
@@ -113,7 +113,7 @@ void cleanup_srcu_struct(struct srcu_struct *sp)
 	int sum;
 
 	sum = srcu_readers_active(sp);
-	WARN_ON(sum);  /* Leakage unless caller handles error. */
+	(void)WARN_ON(sum);  /* Leakage unless caller handles error. */
 	if (sum != 0)
 		return;
 	free_percpu(sp->per_cpu_ref);
diff --git a/kernel/stacktrace.c b/kernel/stacktrace.c
index 00fe55c..db1ff1b 100644
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@ -33,7 +33,7 @@ EXPORT_SYMBOL_GPL(print_stack_trace);
 __weak void
 save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
-	WARN_ONCE(1, KERN_INFO "save_stack_trace_tsk() not implemented yet.\n");
+	(void)WARN_ONCE(1, KERN_INFO "save_stack_trace_tsk() not implemented yet.\n");
 }
 
 __weak void
diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index 2f194e9..0d48e3e 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -45,7 +45,7 @@ static bool stop_machine_initialized = false;
 
 static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)
 {
-	memset(done, 0, sizeof(*done));
+	(void)memset(done, 0, sizeof(*done));
 	atomic_set(&done->nr_todo, nr_todo);
 	init_completion(&done->completion);
 }
@@ -284,7 +284,7 @@ repeat:
 
 		/* restore preemption and check it's still balanced */
 		preempt_enable();
-		WARN_ONCE(preempt_count(),
+		(void)WARN_ONCE(preempt_count(),
 			  "cpu_stop: %s(%p) leaked preempt count\n",
 			  kallsyms_lookup((unsigned long)fn, NULL, NULL, NULL,
 					  ksym_buf), arg);
diff --git a/kernel/sys.c b/kernel/sys.c
index 4070153..bd40a01 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1284,7 +1284,7 @@ SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->nodename, tmp, len);
-		memset(u->nodename + len, 0, sizeof(u->nodename) - len);
+		(void)memset(u->nodename + len, 0, sizeof(u->nodename) - len);
 		errno = 0;
 	}
 	uts_proc_notify(UTS_PROC_HOSTNAME);
@@ -1335,7 +1335,7 @@ SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->domainname, tmp, len);
-		memset(u->domainname + len, 0, sizeof(u->domainname) - len);
+		(void)memset(u->domainname + len, 0, sizeof(u->domainname) - len);
 		errno = 0;
 	}
 	uts_proc_notify(UTS_PROC_DOMAINNAME);
@@ -1604,7 +1604,7 @@ static void k_getrusage(struct task_struct *p, int who, struct rusage *r)
 	cputime_t tgutime, tgstime, utime, stime;
 	unsigned long maxrss = 0;
 
-	memset((char *) r, 0, sizeof *r);
+	(void)memset((char *) r, 0, sizeof *r);
 	utime = stime = 0;
 
 	if (who == RUSAGE_THREAD) {
diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c
index 8a46f5d..c92849a 100644
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@ -524,7 +524,7 @@ static int alarm_timer_create(struct k_itimer *new_timer)
 static void alarm_timer_get(struct k_itimer *timr,
 				struct itimerspec *cur_setting)
 {
-	memset(cur_setting, 0, sizeof(struct itimerspec));
+	(void)memset(cur_setting, 0, sizeof(struct itimerspec));
 
 	cur_setting->it_interval =
 			ktime_to_timespec(timr->it.alarm.interval);
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index 9cd928f..5107f0e 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -43,10 +43,10 @@ u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)
 
 	if (unlikely(!evt->mult)) {
 		evt->mult = 1;
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	}
 
-	do_div(clc, evt->mult);
+	(void)do_div(clc, evt->mult);
 	if (clc < 1000)
 		clc = 1000;
 	if (clc > KTIME_MAX)
@@ -77,7 +77,7 @@ void clockevents_set_mode(struct clock_event_device *dev,
 		if (mode == CLOCK_EVT_MODE_ONESHOT) {
 			if (unlikely(!dev->mult)) {
 				dev->mult = 1;
-				WARN_ON(1);
+				(void)WARN_ON(1);
 			}
 		}
 	}
@@ -206,7 +206,7 @@ int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,
 	int rc;
 
 	if (unlikely(expires.tv64 < 0)) {
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return -ETIME;
 	}
 
@@ -283,7 +283,7 @@ void clockevents_register_device(struct clock_event_device *dev)
 
 	BUG_ON(dev->mode != CLOCK_EVT_MODE_UNUSED);
 	if (!dev->cpumask) {
-		WARN_ON(num_possible_cpus() > 1);
+		(void)WARN_ON(num_possible_cpus() > 1);
 		dev->cpumask = cpumask_of(smp_processor_id());
 	}
 
@@ -311,7 +311,7 @@ static void clockevents_config(struct clock_event_device *dev,
 	 * 32bit ticks so we still get reasonable conversion values.
 	 */
 	sec = dev->max_delta_ticks;
-	do_div(sec, freq);
+	(void)do_div(sec, freq);
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && dev->max_delta_ticks > UINT_MAX)
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index a45ca16..d436d36 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -153,7 +153,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)
 	for (sft = 32; sft > 0; sft--) {
 		tmp = (u64) to << sft;
 		tmp += from / 2;
-		do_div(tmp, from);
+		(void)do_div(tmp, from);
 		if ((tmp >> sftacc) == 0)
 			break;
 	}
@@ -503,7 +503,7 @@ static u32 clocksource_max_adjustment(struct clocksource *cs)
 	 * We won't try to correct for more then 11% adjustments (110,000 ppm),
 	 */
 	ret = (u64)cs->mult * 11;
-	do_div(ret,100);
+	(void)do_div(ret,100);
 	return (u32)ret;
 }
 
@@ -670,8 +670,8 @@ void __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq)
 	 * margin as we do in clocksource_max_deferment()
 	 */
 	sec = (cs->mask - (cs->mask >> 3));
-	do_div(sec, freq);
-	do_div(sec, scale);
+	(void)do_div(sec, freq);
+	(void)do_div(sec, scale);
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && cs->mask > UINT_MAX)
@@ -735,7 +735,7 @@ int clocksource_register(struct clocksource *cs)
 {
 	/* calculate max adjustment for given mult/shift */
 	cs->maxadj = clocksource_max_adjustment(cs);
-	WARN_ONCE(cs->mult + cs->maxadj < cs->mult,
+	(void)WARN_ONCE(cs->mult + cs->maxadj < cs->mult,
 		"Clocksource %s might overflow on 11%% adjustment\n",
 		cs->name);
 
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 0c63581..f319425 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -74,7 +74,7 @@ static void timekeeper_setup_internals(struct clocksource *clock)
 	tmp <<= clock->shift;
 	ntpinterval = tmp;
 	tmp += clock->mult/2;
-	do_div(tmp, clock->mult);
+	(void)do_div(tmp, clock->mult);
 	if (tmp == 0)
 		tmp = 1;
 
@@ -219,7 +219,7 @@ void getnstimeofday(struct timespec *ts)
 	unsigned long seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -242,7 +242,7 @@ ktime_t ktime_get(void)
 	unsigned int seq;
 	s64 secs, nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -275,7 +275,7 @@ void ktime_get_ts(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -854,7 +854,7 @@ static void timekeeping_adjust(s64 offset)
 	} else /* No adjustment needed */
 		return;
 
-	WARN_ONCE(timekeeper.clock->maxadj &&
+	(void)WARN_ONCE(timekeeper.clock->maxadj &&
 			(timekeeper.mult + adj > timekeeper.clock->mult +
 						timekeeper.clock->maxadj),
 			"Adjusting %s more then 11%% (%ld vs %ld)\n",
@@ -1098,7 +1098,7 @@ void get_monotonic_boottime(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
diff --git a/kernel/time/timer_stats.c b/kernel/time/timer_stats.c
index 0b537f2..6b3bd56 100644
--- a/kernel/time/timer_stats.c
+++ b/kernel/time/timer_stats.c
@@ -138,8 +138,8 @@ static struct entry *tstat_hash_table[TSTAT_HASH_SIZE] __read_mostly;
 static void reset_entries(void)
 {
 	nr_entries = 0;
-	memset(entries, 0, sizeof(entries));
-	memset(tstat_hash_table, 0, sizeof(tstat_hash_table));
+	(void)memset(entries, 0, sizeof(entries));
+	(void)memset(tstat_hash_table, 0, sizeof(tstat_hash_table));
 	atomic_set(&overflow_count, 0);
 }
 
diff --git a/kernel/timer.c b/kernel/timer.c
index a297ffc..d4e01c0 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -608,7 +608,7 @@ static void __init_timer(struct timer_list *timer,
 #ifdef CONFIG_TIMER_STATS
 	timer->start_site = NULL;
 	timer->start_pid = -1;
-	memset(timer->start_comm, 0, TASK_COMM_LEN);
+	(void)memset(timer->start_comm, 0, TASK_COMM_LEN);
 #endif
 	lockdep_init_map(&timer->lockdep_map, name, key, 0);
 }
@@ -1058,7 +1058,7 @@ int del_timer_sync(struct timer_list *timer)
 	 * don't use it in hardirq context, because it
 	 * could lead to deadlock.
 	 */
-	WARN_ON(in_irq());
+	(void)WARN_ON(in_irq());
 	for (;;) {
 		int ret = try_to_del_timer_sync(timer);
 		if (ret >= 0)
@@ -1118,7 +1118,7 @@ static void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),
 	lock_map_release(&lockdep_map);
 
 	if (preempt_count != preempt_count()) {
-		WARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",
+		(void)WARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",
 			  fn, preempt_count, preempt_count());
 		/*
 		 * Restore the preempt count. That gives us a decent
@@ -1573,7 +1573,7 @@ int do_sysinfo(struct sysinfo *info)
 	unsigned int mem_unit, bitcount;
 	struct timespec tp;
 
-	memset(info, 0, sizeof(struct sysinfo));
+	(void)memset(info, 0, sizeof(struct sysinfo));
 
 	ktime_get_ts(&tp);
 	monotonic_to_bootbased(&tp);
@@ -1663,7 +1663,7 @@ static int __cpuinit init_timers_cpu(int cpu)
 
 			/* Make sure that tvec_base is 2 byte aligned */
 			if (tbase_get_deferrable(base)) {
-				WARN_ON(1);
+				(void)WARN_ON(1);
 				kfree(base);
 				return -ENOMEM;
 			}
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index f5b7b5c..0b28398 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -841,7 +841,7 @@ rb_set_head_page(struct ring_buffer_per_cpu *cpu_buffer)
 		} while (page != head);
 	}
 
-	RB_WARN_ON(cpu_buffer, 1);
+	(void)RB_WARN_ON(cpu_buffer, 1);
 
 	return NULL;
 }
@@ -1002,7 +1002,7 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 	LIST_HEAD(pages);
 	unsigned i;
 
-	WARN_ON(!nr_pages);
+	(void)WARN_ON(!nr_pages);
 
 	for (i = 0; i < nr_pages; i++) {
 		struct page *page;
@@ -1563,7 +1563,7 @@ rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)
 
 		local_set(&cpu_buffer->commit_page->page->commit,
 			  rb_page_write(cpu_buffer->commit_page));
-		RB_WARN_ON(cpu_buffer,
+		(void)RB_WARN_ON(cpu_buffer,
 			   local_read(&cpu_buffer->commit_page->page->commit) &
 			   ~RB_WRITE_MASK);
 		barrier();
@@ -1741,7 +1741,7 @@ rb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,
 		 */
 		return 1;
 	default:
-		RB_WARN_ON(cpu_buffer, 1); /* WTF??? */
+		(void)RB_WARN_ON(cpu_buffer, 1); /* WTF??? */
 		return -1;
 	}
 
@@ -1779,7 +1779,7 @@ rb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,
 		/* OK */
 		break;
 	default:
-		RB_WARN_ON(cpu_buffer, 1);
+		(void)RB_WARN_ON(cpu_buffer, 1);
 		return -1;
 	}
 
@@ -2203,7 +2203,7 @@ rb_reserve_next_event(struct ring_buffer *buffer,
 #ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
 			local_clock_stable = sched_clock_stable;
 #endif
-			WARN_ONCE(delta > (1ULL << 59),
+			(void)WARN_ONCE(delta > (1ULL << 59),
 				  KERN_WARNING "Delta way too big! %llu ts=%llu write stamp = %llu\n%s",
 				  (unsigned long long)delta,
 				  (unsigned long long)ts,
@@ -2248,7 +2248,7 @@ static noinline void trace_recursive_fail(void)
 		    softirq_count() >> SOFTIRQ_SHIFT,
 		    in_nmi());
 
-	WARN_ON_ONCE(1);
+	(void)WARN_ON_ONCE(1);
 }
 
 static inline int trace_recursive_lock(void)
@@ -2265,7 +2265,7 @@ static inline int trace_recursive_lock(void)
 
 static inline void trace_recursive_unlock(void)
 {
-	WARN_ON_ONCE(!trace_recursion_buffer());
+	(void)WARN_ON_ONCE(!trace_recursion_buffer());
 
 	trace_recursion_dec();
 }
@@ -2452,7 +2452,7 @@ rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,
 	} while (bpage != start);
 
 	/* commit not part of this buffer?? */
-	RB_WARN_ON(cpu_buffer, 1);
+	(void)RB_WARN_ON(cpu_buffer, 1);
 }
 
 /**
@@ -2491,7 +2491,7 @@ void ring_buffer_discard_commit(struct ring_buffer *buffer,
 	 * committed yet. Thus we can assume that preemption
 	 * is still disabled.
 	 */
-	RB_WARN_ON(buffer, !local_read(&cpu_buffer->committing));
+	(void)RB_WARN_ON(buffer, !local_read(&cpu_buffer->committing));
 
 	rb_decrement_entry(cpu_buffer, event);
 	if (rb_try_to_discard(cpu_buffer, event))
@@ -3172,7 +3172,7 @@ rb_buffer_peek(struct ring_buffer_per_cpu *cpu_buffer, u64 *ts,
 	switch (event->type_len) {
 	case RINGBUF_TYPE_PADDING:
 		if (rb_null_event(event))
-			RB_WARN_ON(cpu_buffer, 1);
+			(void)RB_WARN_ON(cpu_buffer, 1);
 		/*
 		 * Because the writer could be discarding every
 		 * event it creates (which would probably be bad)
@@ -4029,7 +4029,7 @@ int ring_buffer_read_page(struct ring_buffer *buffer,
 	 * This page may be off to user land. Zero it out here.
 	 */
 	if (commit < BUF_PAGE_SIZE)
-		memset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);
+		(void)memset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);
 
  out_unlock:
 	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
@@ -4118,7 +4118,7 @@ static int rb_cpu_notify(struct notifier_block *self,
 		buffer->buffers[cpu] =
 			rb_allocate_cpu_buffer(buffer, cpu);
 		if (!buffer->buffers[cpu]) {
-			WARN(1, "failed to allocate ring buffer on CPU %ld\n",
+			(void)WARN(1, "failed to allocate ring buffer on CPU %ld\n",
 			     cpu);
 			return NOTIFY_OK;
 		}
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index a3f1bc5..0619d31 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -153,7 +153,7 @@ __setup("ftrace_dump_on_oops", set_ftrace_dump_on_oops);
 unsigned long long ns2usecs(cycle_t nsec)
 {
 	nsec += 500;
-	do_div(nsec, 1000);
+	(void)do_div(nsec, 1000);
 	return nsec;
 }
 
@@ -447,7 +447,7 @@ int trace_clock_id;
  */
 int trace_parser_get_init(struct trace_parser *parser, int size)
 {
-	memset(parser, 0, sizeof(*parser));
+	(void)memset(parser, 0, sizeof(*parser));
 
 	parser->buffer = kmalloc(size, GFP_KERNEL);
 	if (!parser->buffer)
@@ -924,8 +924,8 @@ static atomic_t trace_record_cmdline_disabled __read_mostly;
 
 static void trace_init_cmdlines(void)
 {
-	memset(&map_pid_to_cmdline, NO_CMDLINE_MAP, sizeof(map_pid_to_cmdline));
-	memset(&map_cmdline_to_pid, NO_CMDLINE_MAP, sizeof(map_cmdline_to_pid));
+	(void)memset(&map_pid_to_cmdline, NO_CMDLINE_MAP, sizeof(map_pid_to_cmdline));
+	(void)memset(&map_cmdline_to_pid, NO_CMDLINE_MAP, sizeof(map_cmdline_to_pid));
 	cmdline_idx = 0;
 }
 
@@ -967,7 +967,7 @@ void tracing_start(void)
 	if (--trace_stop_count) {
 		if (trace_stop_count < 0) {
 			/* Someone screwed up their debugging */
-			WARN_ON_ONCE(1);
+			(void)WARN_ON_ONCE(1);
 			trace_stop_count = 0;
 		}
 		goto out;
@@ -1418,7 +1418,7 @@ ftrace_trace_userstack(struct ring_buffer *buffer, unsigned long flags, int pc)
 	entry	= ring_buffer_event_data(event);
 
 	entry->tgid		= current->tgid;
-	memset(&entry->caller, 0, sizeof(entry->caller));
+	(void)memset(&entry->caller, 0, sizeof(entry->caller));
 
 	trace.nr_entries	= 0;
 	trace.max_entries	= FTRACE_STACK_ENTRIES;
@@ -1724,7 +1724,7 @@ static void *s_next(struct seq_file *m, void *v, loff_t *pos)
 	int i = (int)*pos;
 	void *ent;
 
-	WARN_ON_ONCE(iter->leftover);
+	(void)WARN_ON_ONCE(iter->leftover);
 
 	(*pos)++;
 
@@ -2872,7 +2872,7 @@ tracing_ctrl_write(struct file *filp, const char __user *ubuf,
 	if (tracer_enabled ^ val) {
 
 		/* Only need to warn if this is used to change the state */
-		WARN_ONCE(1, "tracing_enabled is deprecated. Use tracing_on");
+		(void)WARN_ONCE(1, "tracing_enabled is deprecated. Use tracing_on");
 
 		if (val) {
 			tracer_enabled = 1;
@@ -2955,7 +2955,7 @@ static int __tracing_resize_ring_buffer(unsigned long size)
 			 * happen, but if it does, warn and kill all
 			 * tracing.
 			 */
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			tracing_disabled = 1;
 		}
 		return ret;
@@ -3384,7 +3384,7 @@ waitagain:
 		cnt = PAGE_SIZE - 1;
 
 	/* reset all but tr, trace, and overruns */
-	memset(&iter->seq, 0,
+	(void)memset(&iter->seq, 0,
 	       sizeof(struct trace_iterator) -
 	       offsetof(struct trace_iterator, seq));
 	iter->pos = -1;
@@ -3412,7 +3412,7 @@ waitagain:
 		 * size and we should leave by partial output condition above.
 		 * One of the trace_seq_* functions is not used properly.
 		 */
-		WARN_ONCE(iter->seq.full, "full flag set for trace type %d",
+		(void)WARN_ONCE(iter->seq.full, "full flag set for trace type %d",
 			  iter->ent->type);
 	}
 	trace_access_unlock(iter->cpu_file);
@@ -4078,13 +4078,13 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos,
 		return -ENOMEM;
 
 	if (*ppos & (PAGE_SIZE - 1)) {
-		WARN_ONCE(1, "Ftrace: previous read must page-align\n");
+		(void)WARN_ONCE(1, "Ftrace: previous read must page-align\n");
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (len & (PAGE_SIZE - 1)) {
-		WARN_ONCE(1, "Ftrace: splice_read should page-align\n");
+		(void)WARN_ONCE(1, "Ftrace: splice_read should page-align\n");
 		if (len < PAGE_SIZE) {
 			ret = -EINVAL;
 			goto out;
@@ -4125,7 +4125,7 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos,
 		 */
 		size = ring_buffer_page_len(ref->page);
 		if (size < PAGE_SIZE)
-			memset(ref->page + size, 0, PAGE_SIZE - size);
+			(void)memset(ref->page + size, 0, PAGE_SIZE - size);
 
 		page = virt_to_page(ref->page);
 
@@ -4785,7 +4785,7 @@ __ftrace_dump(bool disable_tracing, enum ftrace_dump_mode oops_dump_mode)
 		cnt++;
 
 		/* reset all but tr, trace, and overruns */
-		memset(&iter.seq, 0,
+		(void)memset(&iter.seq, 0,
 		       sizeof(struct trace_iterator) -
 		       offsetof(struct trace_iterator, seq));
 		iter.iter_flags |= TRACE_FILE_LAT_FMT;
@@ -4859,7 +4859,7 @@ __init static int tracer_alloc_buffers(void)
 	global_trace.buffer = ring_buffer_alloc(ring_buf_size, rb_flags);
 	if (!global_trace.buffer) {
 		printk(KERN_ERR "tracer: failed to allocate ring buffer!\n");
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out_free_cpumask;
 	}
 	global_trace.entries = ring_buffer_size(global_trace.buffer);
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index c212a7f..354dbb1 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -248,7 +248,7 @@ static void __put_system(struct event_subsystem *system)
 {
 	struct event_filter *filter = system->filter;
 
-	WARN_ON_ONCE(system->ref_count == 0);
+	(void)WARN_ON_ONCE(system->ref_count == 0);
 	if (--system->ref_count)
 		return;
 
@@ -262,7 +262,7 @@ static void __put_system(struct event_subsystem *system)
 
 static void __get_system(struct event_subsystem *system)
 {
-	WARN_ON_ONCE(system->ref_count == 0);
+	(void)WARN_ON_ONCE(system->ref_count == 0);
 	system->ref_count++;
 }
 
diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c
index 24aee71..66e29d4 100644
--- a/kernel/trace/trace_events_filter.c
+++ b/kernel/trace/trace_events_filter.c
@@ -618,7 +618,7 @@ static void append_filter_err(struct filter_parse_state *ps,
 		return;
 
 	append_filter_string(filter, "\n");
-	memset(buf, ' ', PAGE_SIZE);
+	(void)memset(buf, ' ', PAGE_SIZE);
 	if (pos > PAGE_SIZE - 128)
 		pos = 0;
 	buf[pos] = '^';
@@ -1017,7 +1017,7 @@ static void parse_init(struct filter_parse_state *ps,
 		       struct filter_op *ops,
 		       char *infix_string)
 {
-	memset(ps, '\0', sizeof(*ps));
+	(void)memset(ps, '\0', sizeof(*ps));
 
 	ps->infix.string = infix_string;
 	ps->infix.cnt = strlen(infix_string);
@@ -1095,7 +1095,7 @@ static int infix_get_op(struct filter_parse_state *ps, char firstc)
 
 static inline void clear_operand_string(struct filter_parse_state *ps)
 {
-	memset(ps->operand.string, '\0', MAX_FILTER_STR_VAL);
+	(void)memset(ps->operand.string, '\0', MAX_FILTER_STR_VAL);
 	ps->operand.tail = 0;
 }
 
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index 0d6ff35..234a235 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -809,7 +809,7 @@ int register_ftrace_event(struct trace_event *event)
 
 	} else if (event->type > __TRACE_LAST_TYPE) {
 		printk(KERN_WARNING "Need to add type to trace.h\n");
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out;
 	} else {
 		/* Is this event already used */
@@ -1312,7 +1312,7 @@ __init static int init_events(void)
 		if (!ret) {
 			printk(KERN_WARNING "event %d failed to register\n",
 			       event->type);
-			WARN_ON_ONCE(1);
+			(void)WARN_ON_ONCE(1);
 		}
 	}
 
diff --git a/kernel/trace/trace_sched_switch.c b/kernel/trace/trace_sched_switch.c
index 7e62c0a..0efe426 100644
--- a/kernel/trace/trace_sched_switch.c
+++ b/kernel/trace/trace_sched_switch.c
@@ -208,7 +208,7 @@ void tracing_stop_cmdline_record(void)
 void tracing_start_sched_switch_record(void)
 {
 	if (unlikely(!ctx_trace)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -228,7 +228,7 @@ void tracing_stop_sched_switch_record(void)
 {
 	mutex_lock(&sched_register_mutex);
 	tracer_enabled--;
-	WARN_ON(tracer_enabled < 0);
+	(void)WARN_ON(tracer_enabled < 0);
 	mutex_unlock(&sched_register_mutex);
 
 	tracing_stop_sched_switch();
diff --git a/kernel/tracepoint.c b/kernel/tracepoint.c
index f1539de..aa76d8f 100644
--- a/kernel/tracepoint.c
+++ b/kernel/tracepoint.c
@@ -112,7 +112,7 @@ tracepoint_entry_add_probe(struct tracepoint_entry *entry,
 	int nr_probes = 0;
 	struct tracepoint_func *old, *new;
 
-	WARN_ON(!probe);
+	(void)WARN_ON(!probe);
 
 	debug_print_probes(entry);
 	old = entry->funcs;
@@ -254,7 +254,7 @@ static inline void remove_tracepoint(struct tracepoint_entry *e)
 static void set_tracepoint(struct tracepoint_entry **entry,
 	struct tracepoint *elem, int active)
 {
-	WARN_ON(strcmp((*entry)->name, elem->name) != 0);
+	(void)WARN_ON(strcmp((*entry)->name, elem->name) != 0);
 
 	if (elem->regfunc && !jump_label_enabled(&elem->key) && active)
 		elem->regfunc();
diff --git a/kernel/up.c b/kernel/up.c
index c54c75e..44f6edc 100644
--- a/kernel/up.c
+++ b/kernel/up.c
@@ -10,7 +10,7 @@
 int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 				int wait)
 {
-	WARN_ON(cpu != 0);
+	(void)WARN_ON(cpu != 0);
 
 	local_irq_disable();
 	(func)(info);
diff --git a/kernel/watchdog.c b/kernel/watchdog.c
index 1d7bca7..8121d3a 100644
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@ -422,7 +422,7 @@ static void watchdog_prepare_cpu(int cpu)
 {
 	struct hrtimer *hrtimer = &per_cpu(watchdog_hrtimer, cpu);
 
-	WARN_ON(per_cpu(softlockup_watchdog, cpu));
+	(void)WARN_ON(per_cpu(softlockup_watchdog, cpu));
 	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	hrtimer->function = watchdog_timer_fn;
 }
@@ -584,7 +584,7 @@ void __init lockup_detector_init(void)
 	int err;
 
 	err = cpu_callback(&cpu_nfb, CPU_UP_PREPARE, cpu);
-	WARN_ON(notifier_to_errno(err));
+	(void)WARN_ON(notifier_to_errno(err));
 
 	cpu_callback(&cpu_nfb, CPU_ONLINE, cpu);
 	register_cpu_notifier(&cpu_nfb);
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index bec7b5b..c35220b 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -738,7 +738,7 @@ static inline void worker_set_flags(struct worker *worker, unsigned int flags,
 {
 	struct global_cwq *gcwq = worker->gcwq;
 
-	WARN_ON_ONCE(worker->task != current);
+	(void)WARN_ON_ONCE(worker->task != current);
 
 	/*
 	 * If transitioning into NOT_RUNNING, adjust nr_running and
@@ -775,7 +775,7 @@ static inline void worker_clr_flags(struct worker *worker, unsigned int flags)
 	struct global_cwq *gcwq = worker->gcwq;
 	unsigned int oflags = worker->flags;
 
-	WARN_ON_ONCE(worker->task != current);
+	(void)WARN_ON_ONCE(worker->task != current);
 
 	worker->flags &= ~flags;
 
@@ -1214,7 +1214,7 @@ static void worker_enter_idle(struct worker *worker)
 		wake_up_all(&gcwq->trustee_wait);
 
 	/* sanity check nr_running */
-	WARN_ON_ONCE(gcwq->nr_workers == gcwq->nr_idle &&
+	(void)WARN_ON_ONCE(gcwq->nr_workers == gcwq->nr_idle &&
 		     atomic_read(get_gcwq_nr_running(gcwq->cpu)));
 }
 
@@ -3438,7 +3438,7 @@ static int __cpuinit trustee_thread(void *__gcwq)
 	 * Tell the remaining busy ones to rebind once it finishes the
 	 * currently scheduled works by scheduling the rebind_work.
 	 */
-	WARN_ON(!list_empty(&gcwq->idle_list));
+	(void)WARN_ON(!list_empty(&gcwq->idle_list));
 
 	for_each_busy_worker(worker, i, pos, gcwq) {
 		struct work_struct *rebind_work = &worker->rebind_work;
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 0d4a127..07e8e20 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -134,7 +134,7 @@ void __bitmap_shift_right(unsigned long *dst,
 			dst[k] &= mask;
 	}
 	if (off)
-		memset(&dst[lim - off], 0, off*sizeof(unsigned long));
+		(void)memset(&dst[lim - off], 0, off*sizeof(unsigned long));
 }
 EXPORT_SYMBOL(__bitmap_shift_right);
 
@@ -175,7 +175,7 @@ void __bitmap_shift_left(unsigned long *dst,
 			dst[k + off] &= (1UL << left) - 1;
 	}
 	if (off)
-		memset(dst, 0, off*sizeof(unsigned long));
+		(void)memset(dst, 0, off*sizeof(unsigned long));
 }
 EXPORT_SYMBOL(__bitmap_shift_left);
 
diff --git a/lib/decompress_bunzip2.c b/lib/decompress_bunzip2.c
index 31c5f76..c0c85ca 100644
--- a/lib/decompress_bunzip2.c
+++ b/lib/decompress_bunzip2.c
@@ -641,7 +641,7 @@ static int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, int len,
 	bd = *bdp = malloc(i);
 	if (!bd)
 		return RETVAL_OUT_OF_MEMORY;
-	memset(bd, 0, sizeof(struct bunzip_data));
+	(void)memset(bd, 0, sizeof(struct bunzip_data));
 	/* Setup input buffer */
 	bd->inbuf = inbuf;
 	bd->inbufCount = len;
diff --git a/lib/devres.c b/lib/devres.c
index 9676617..9057ca3 100644
--- a/lib/devres.c
+++ b/lib/devres.c
@@ -79,7 +79,7 @@ EXPORT_SYMBOL(devm_ioremap_nocache);
  */
 void devm_iounmap(struct device *dev, void __iomem *addr)
 {
-	WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
+	(void)WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
 			       (void *)addr));
 	iounmap(addr);
 }
@@ -191,7 +191,7 @@ EXPORT_SYMBOL(devm_ioport_map);
 void devm_ioport_unmap(struct device *dev, void __iomem *addr)
 {
 	ioport_unmap(addr);
-	WARN_ON(devres_destroy(dev, devm_ioport_map_release,
+	(void)WARN_ON(devres_destroy(dev, devm_ioport_map_release,
 			       devm_ioport_map_match, (void *)addr));
 }
 EXPORT_SYMBOL(devm_ioport_unmap);
diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c
index dcdade3..9ad0281 100644
--- a/lib/dynamic_debug.c
+++ b/lib/dynamic_debug.c
@@ -299,7 +299,7 @@ static int ddebug_parse_query(char *words[], int nwords,
 	/* check we have an even number of words */
 	if (nwords % 2 != 0)
 		return -EINVAL;
-	memset(query, 0, sizeof(*query));
+	(void)memset(query, 0, sizeof(*query));
 
 	for (i = 0 ; i < nwords ; i += 2) {
 		if (!strcmp(words[i], "func"))
diff --git a/lib/flex_array.c b/lib/flex_array.c
index 9b8b894..714c49b 100644
--- a/lib/flex_array.c
+++ b/lib/flex_array.c
@@ -110,7 +110,7 @@ struct flex_array *flex_array_alloc(int element_size, unsigned int total,
 	ret->elems_per_part = elems_per_part;
 	ret->reciprocal_elems = reciprocal_elems;
 	if (elements_fit_in_base(ret) && !(flags & __GFP_ZERO))
-		memset(&ret->parts[0], FLEX_ARRAY_FREE,
+		(void)memset(&ret->parts[0], FLEX_ARRAY_FREE,
 						FLEX_ARRAY_BASE_BYTES_LEFT);
 	return ret;
 }
@@ -166,7 +166,7 @@ __fa_get_part(struct flex_array *fa, int part_nr, gfp_t flags)
 		if (!part)
 			return NULL;
 		if (!(flags & __GFP_ZERO))
-			memset(part, FLEX_ARRAY_FREE,
+			(void)memset(part, FLEX_ARRAY_FREE,
 				sizeof(struct flex_array_part));
 		fa->parts[part_nr] = part;
 	}
@@ -241,7 +241,7 @@ int flex_array_clear(struct flex_array *fa, unsigned int element_nr)
 			return -EINVAL;
 	}
 	dst = &part->elements[index_inside_part(fa, element_nr, part_nr)];
-	memset(dst, FLEX_ARRAY_FREE, fa->element_size);
+	(void)memset(dst, FLEX_ARRAY_FREE, fa->element_size);
 	return 0;
 }
 EXPORT_SYMBOL(flex_array_clear);
diff --git a/lib/idr.c b/lib/idr.c
index ed055b2..45c1f1f 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -694,7 +694,7 @@ void __init idr_init_cache(void)
  */
 void idr_init(struct idr *idp)
 {
-	memset(idp, 0, sizeof(struct idr));
+	(void)memset(idp, 0, sizeof(struct idr));
 	spin_lock_init(&idp->lock);
 }
 EXPORT_SYMBOL(idr_init);
@@ -809,7 +809,7 @@ int ida_get_new_above(struct ida *ida, int starting_id, int *p_id)
 		if (!bitmap)
 			return -EAGAIN;
 
-		memset(bitmap, 0, sizeof(struct ida_bitmap));
+		(void)memset(bitmap, 0, sizeof(struct ida_bitmap));
 		rcu_assign_pointer(pa[0]->ary[idr_id & IDR_MASK],
 				(void *)bitmap);
 		pa[0]->count++;
@@ -1004,7 +1004,7 @@ EXPORT_SYMBOL(ida_simple_remove);
  */
 void ida_init(struct ida *ida)
 {
-	memset(ida, 0, sizeof(struct ida));
+	(void)memset(ida, 0, sizeof(struct ida));
 	idr_init(&ida->idr);
 
 }
diff --git a/lib/klist.c b/lib/klist.c
index 573d606..811d8e9 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -60,13 +60,13 @@ static void knode_set_klist(struct klist_node *knode, struct klist *klist)
 {
 	knode->n_klist = klist;
 	/* no knode deserves to start its life dead */
-	WARN_ON(knode_dead(knode));
+	(void)WARN_ON(knode_dead(knode));
 }
 
 static void knode_kill(struct klist_node *knode)
 {
 	/* and no knode should die twice ever either, see we're very humane */
-	WARN_ON(knode_dead(knode));
+	(void)WARN_ON(knode_dead(knode));
 	*(unsigned long *)&knode->n_klist |= KNODE_DEAD;
 }
 
@@ -186,7 +186,7 @@ static void klist_release(struct kref *kref)
 	struct klist_waiter *waiter, *tmp;
 	struct klist_node *n = container_of(kref, struct klist_node, n_ref);
 
-	WARN_ON(!knode_dead(n));
+	(void)WARN_ON(!knode_dead(n));
 	list_del(&n->n_node);
 	spin_lock(&klist_remove_lock);
 	list_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {
diff --git a/lib/kobject.c b/lib/kobject.c
index c33d7a1..26c910a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -164,7 +164,7 @@ static int kobject_add_internal(struct kobject *kobj)
 		return -ENOENT;
 
 	if (!kobj->name || !kobj->name[0]) {
-		WARN(1, "kobject: (%p): attempted to be registered with empty "
+		(void)WARN(1, "kobject: (%p): attempted to be registered with empty "
 			 "name!\n", kobj);
 		return -EINVAL;
 	}
@@ -590,7 +590,7 @@ void kobject_put(struct kobject *kobj)
 {
 	if (kobj) {
 		if (!kobj->state_initialized)
-			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
+			(void)WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
 			       "initialized, yet kobject_put() is being "
 			       "called.\n", kobject_name(kobj), kobj);
 		kref_put(&kobj->kref, kobject_release);
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index e66e9b6..d365326 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -348,7 +348,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	int len;
 
 	if (env->envp_idx >= ARRAY_SIZE(env->envp)) {
-		WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
 		return -ENOMEM;
 	}
 
@@ -359,7 +359,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	va_end(args);
 
 	if (len >= (sizeof(env->buf) - env->buflen)) {
-		WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
 		return -ENOMEM;
 	}
 
diff --git a/lib/list_debug.c b/lib/list_debug.c
index b8029a5..64e2b8d 100644
--- a/lib/list_debug.c
+++ b/lib/list_debug.c
@@ -20,11 +20,11 @@ void __list_add(struct list_head *new,
 			      struct list_head *prev,
 			      struct list_head *next)
 {
-	WARN(next->prev != prev,
+	(void)WARN(next->prev != prev,
 		"list_add corruption. next->prev should be "
 		"prev (%p), but was %p. (next=%p).\n",
 		prev, next->prev, next);
-	WARN(prev->next != next,
+	(void)WARN(prev->next != next,
 		"list_add corruption. prev->next should be "
 		"next (%p), but was %p. (prev=%p).\n",
 		next, prev->next, prev);
diff --git a/lib/list_sort.c b/lib/list_sort.c
index d7325c6..283b83d 100644
--- a/lib/list_sort.c
+++ b/lib/list_sort.c
@@ -107,7 +107,7 @@ void list_sort(void *priv, struct list_head *head,
 	if (list_empty(head))
 		return;
 
-	memset(part, 0, sizeof(part));
+	(void)memset(part, 0, sizeof(part));
 
 	head->prev->next = NULL;
 	list = head->next;
diff --git a/lib/nlattr.c b/lib/nlattr.c
index a8408b6..70940e5 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -180,7 +180,7 @@ int nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,
 	const struct nlattr *nla;
 	int rem, err;
 
-	memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));
+	(void)memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));
 
 	nla_for_each_attr(nla, head, len, rem) {
 		u16 type = nla_type(nla);
@@ -248,7 +248,7 @@ size_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize)
 	if (dstsize > 0) {
 		size_t len = (srclen >= dstsize) ? dstsize - 1 : srclen;
 
-		memset(dst, 0, dstsize);
+		(void)memset(dst, 0, dstsize);
 		memcpy(dst, src, len);
 	}
 
@@ -329,7 +329,7 @@ struct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	nla->nla_type = attrtype;
 	nla->nla_len = nla_attr_size(attrlen);
 
-	memset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));
+	(void)memset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));
 
 	return nla;
 }
@@ -350,7 +350,7 @@ void *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)
 	void *start;
 
 	start = skb_put(skb, NLA_ALIGN(attrlen));
-	memset(start, 0, NLA_ALIGN(attrlen));
+	(void)memset(start, 0, NLA_ALIGN(attrlen));
 
 	return start;
 }
diff --git a/lib/plist.c b/lib/plist.c
index a0a4da4..5117cd1 100644
--- a/lib/plist.c
+++ b/lib/plist.c
@@ -33,7 +33,7 @@ static struct plist_head test_head;
 static void plist_check_prev_next(struct list_head *t, struct list_head *p,
 				  struct list_head *n)
 {
-	WARN(n->prev != p || p->next != n,
+	(void)WARN(n->prev != p || p->next != n,
 			"top: %p, n: %p, p: %p\n"
 			"prev: %p, n: %p, p: %p\n"
 			"next: %p, n: %p, p: %p\n",
@@ -77,8 +77,8 @@ void plist_add(struct plist_node *node, struct plist_head *head)
 	struct list_head *node_next = &head->node_list;
 
 	plist_check_head(head);
-	WARN_ON(!plist_node_empty(node));
-	WARN_ON(!list_empty(&node->prio_list));
+	(void)WARN_ON(!plist_node_empty(node));
+	(void)WARN_ON(!list_empty(&node->prio_list));
 
 	if (plist_head_empty(head))
 		goto ins_node;
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index dc63d08..f127026 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -1459,7 +1459,7 @@ EXPORT_SYMBOL(radix_tree_tagged);
 static void
 radix_tree_node_ctor(void *node)
 {
-	memset(node, 0, sizeof(struct radix_tree_node));
+	(void)memset(node, 0, sizeof(struct radix_tree_node));
 }
 
 static __init unsigned long __maxindex(unsigned int height)
diff --git a/lib/reciprocal_div.c b/lib/reciprocal_div.c
index 75510e9..fdaf046 100644
--- a/lib/reciprocal_div.c
+++ b/lib/reciprocal_div.c
@@ -5,7 +5,7 @@
 u32 reciprocal_value(u32 k)
 {
 	u64 val = (1LL << 32) + (k - 1);
-	do_div(val, k);
+	(void)do_div(val, k);
 	return (u32)val;
 }
 EXPORT_SYMBOL(reciprocal_value);
diff --git a/lib/reed_solomon/decode_rs.c b/lib/reed_solomon/decode_rs.c
index 0ec3f25..5e848f3 100644
--- a/lib/reed_solomon/decode_rs.c
+++ b/lib/reed_solomon/decode_rs.c
@@ -93,7 +93,7 @@
 	}
 
  decode:
-	memset(&lambda[1], 0, nroots * sizeof(lambda[0]));
+	(void)memset(&lambda[1], 0, nroots * sizeof(lambda[0]));
 	lambda[0] = 1;
 
 	if (no_eras > 0) {
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index 4ceb05d..af9e1f7 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -84,7 +84,7 @@ EXPORT_SYMBOL(sg_last);
  **/
 void sg_init_table(struct scatterlist *sgl, unsigned int nents)
 {
-	memset(sgl, 0, sizeof(*sgl) * nents);
+	(void)memset(sgl, 0, sizeof(*sgl) * nents);
 #ifdef CONFIG_DEBUG_SG
 	{
 		unsigned int i;
@@ -232,7 +232,7 @@ int __sg_alloc_table(struct sg_table *table, unsigned int nents,
 	BUG_ON(nents > max_ents);
 #endif
 
-	memset(table, 0, sizeof(*table));
+	(void)memset(table, 0, sizeof(*table));
 
 	left = nents;
 	prv = NULL;
@@ -333,12 +333,12 @@ EXPORT_SYMBOL(sg_alloc_table);
 void sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
 		    unsigned int nents, unsigned int flags)
 {
-	memset(miter, 0, sizeof(struct sg_mapping_iter));
+	(void)memset(miter, 0, sizeof(struct sg_mapping_iter));
 
 	miter->__sg = sgl;
 	miter->__nents = nents;
 	miter->__offset = 0;
-	WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
+	(void)WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
 	miter->__flags = flags;
 }
 EXPORT_SYMBOL(sg_miter_start);
@@ -413,7 +413,7 @@ EXPORT_SYMBOL(sg_miter_next);
  */
 void sg_miter_stop(struct sg_mapping_iter *miter)
 {
-	WARN_ON(miter->consumed > miter->length);
+	(void)WARN_ON(miter->consumed > miter->length);
 
 	/* drop resources from the last iteration */
 	if (miter->addr) {
diff --git a/lib/string_helpers.c b/lib/string_helpers.c
index ab431d4..472c8db 100644
--- a/lib/string_helpers.c
+++ b/lib/string_helpers.c
@@ -53,7 +53,7 @@ int string_get_size(u64 size, const enum string_size_units units,
 
 		if (j) {
 			remainder *= 1000;
-			do_div(remainder, divisor[units]);
+			(void)do_div(remainder, divisor[units]);
 			snprintf(tmp, sizeof(tmp), ".%03lld",
 				 (unsigned long long)remainder);
 			tmp[j+1] = '\0';
diff --git a/lib/timerqueue.c b/lib/timerqueue.c
index 191176a..e520c72 100644
--- a/lib/timerqueue.c
+++ b/lib/timerqueue.c
@@ -42,7 +42,7 @@ void timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)
 	struct timerqueue_node  *ptr;
 
 	/* Make sure we don't add nodes that are already added */
-	WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
 
 	while (*p) {
 		parent = *p;
@@ -70,7 +70,7 @@ EXPORT_SYMBOL_GPL(timerqueue_add);
  */
 void timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
 {
-	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
 
 	/* update next pointer */
 	if (head->next == node) {
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 8e75003..ef01271 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -623,7 +623,7 @@ char *ip6_compressed_string(char *p, const char *addr)
 
 	useIPv4 = ipv6_addr_v4mapped(&in6) || ipv6_addr_is_isatap(&in6);
 
-	memset(zerolength, 0, sizeof(zerolength));
+	(void)memset(zerolength, 0, sizeof(zerolength));
 
 	if (useIPv4)
 		range = 6;
diff --git a/lib/xz/xz_dec_lzma2.c b/lib/xz/xz_dec_lzma2.c
index a6cdc96..afabda4 100644
--- a/lib/xz/xz_dec_lzma2.c
+++ b/lib/xz/xz_dec_lzma2.c
@@ -859,7 +859,7 @@ static bool lzma2_lzma(struct xz_dec_lzma2 *s, struct xz_buf *b)
 		memcpy(s->temp.buf + s->temp.size, b->in + b->in_pos, tmp);
 
 		if (s->temp.size + tmp == s->lzma2.compressed) {
-			memzero(s->temp.buf + s->temp.size + tmp,
+			(void)memzero(s->temp.buf + s->temp.size + tmp,
 					sizeof(s->temp.buf)
 						- s->temp.size - tmp);
 			s->rc.in_limit = s->temp.size + tmp;
diff --git a/lib/xz/xz_dec_stream.c b/lib/xz/xz_dec_stream.c
index ac809b1..65319ee 100644
--- a/lib/xz/xz_dec_stream.c
+++ b/lib/xz/xz_dec_stream.c
@@ -803,8 +803,8 @@ XZ_EXTERN void xz_dec_reset(struct xz_dec *s)
 	s->allow_buf_error = false;
 	s->pos = 0;
 	s->crc32 = 0;
-	memzero(&s->block, sizeof(s->block));
-	memzero(&s->index, sizeof(s->index));
+	(void)memzero(&s->block, sizeof(s->block));
+	(void)memzero(&s->index, sizeof(s->index));
 	s->temp.pos = 0;
 	s->temp.size = STREAM_HEADER_SIZE;
 }
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 7ba8fea..2367f0c 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -418,7 +418,7 @@ static int bdi_forker_thread(void *ptr)
 			     bdi_cap_flush_forker(bdi))
 				continue;
 
-			WARN(!test_bit(BDI_registered, &bdi->state),
+			(void)WARN(!test_bit(BDI_registered, &bdi->state),
 			     "bdi %p/%s is not registered!\n", bdi, bdi->name);
 
 			have_dirty_io = !list_empty(&bdi->work_list) ||
@@ -640,7 +640,7 @@ EXPORT_SYMBOL(bdi_unregister);
 
 static void bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)
 {
-	memset(wb, 0, sizeof(*wb));
+	(void)memset(wb, 0, sizeof(*wb));
 
 	wb->bdi = bdi;
 	wb->last_old_flush = jiffies;
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 668e94d..419e346 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -108,7 +108,7 @@ static unsigned long __init init_bootmem_core(bootmem_data_t *bdata,
 	 * register free RAM areas explicitly.
 	 */
 	mapsize = bootmap_bytes(end - start);
-	memset(bdata->node_bootmem_map, 0xff, mapsize);
+	(void)memset(bdata->node_bootmem_map, 0xff, mapsize);
 
 	bdebug("nid=%td start=%lx map=%lx end=%lx mapsize=%lx\n",
 		bdata - bootmem_node_data, start, mapstart, end, mapsize);
@@ -556,7 +556,7 @@ find_block:
 
 		region = phys_to_virt(PFN_PHYS(bdata->node_min_pfn) +
 				start_off);
-		memset(region, 0, size);
+		(void)memset(region, 0, size);
 		/*
 		 * The min_count is set to 0 so that bootmem allocated blocks
 		 * are never reported as leaks.
diff --git a/mm/bounce.c b/mm/bounce.c
index 4e9ae72..de58b6c 100644
--- a/mm/bounce.c
+++ b/mm/bounce.c
@@ -200,7 +200,7 @@ static void __blk_queue_bounce(struct request_queue *q, struct bio **bio_orig,
 			unsigned int cnt = (*bio_orig)->bi_vcnt;
 
 			bio = bio_alloc(GFP_NOIO, cnt);
-			memset(bio->bi_io_vec, 0, cnt * sizeof(struct bio_vec));
+			(void)memset(bio->bi_io_vec, 0, cnt * sizeof(struct bio_vec));
 		}
 			
 
diff --git a/mm/dmapool.c b/mm/dmapool.c
index c5ab33b..fe64d88 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -224,7 +224,7 @@ static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)
 					 &page->dma, mem_flags);
 	if (page->vaddr) {
 #ifdef	DMAPOOL_DEBUG
-		memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
+		(void)memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
 #endif
 		pool_initialise_page(pool, page);
 		list_add(&page->page_list, &pool->page_list);
@@ -247,7 +247,7 @@ static void pool_free_page(struct dma_pool *pool, struct dma_page *page)
 	dma_addr_t dma = page->dma;
 
 #ifdef	DMAPOOL_DEBUG
-	memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
+	(void)memset(page->vaddr, POOL_POISON_FREED, pool->allocation);
 #endif
 	dma_free_coherent(pool->dev, pool->allocation, page->vaddr, dma);
 	list_del(&page->page_list);
@@ -346,7 +346,7 @@ void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 	retval = offset + page->vaddr;
 	*handle = offset + page->dma;
 #ifdef	DMAPOOL_DEBUG
-	memset(retval, POOL_POISON_ALLOCATED, pool->size);
+	(void)memset(retval, POOL_POISON_ALLOCATED, pool->size);
 #endif
  done:
 	spin_unlock_irqrestore(&pool->lock, flags);
@@ -429,7 +429,7 @@ void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t dma)
 			return;
 		}
 	}
-	memset(vaddr, POOL_POISON_FREED, pool->size);
+	(void)memset(vaddr, POOL_POISON_FREED, pool->size);
 #endif
 
 	page->in_use--;
@@ -501,7 +501,7 @@ void dmam_pool_destroy(struct dma_pool *pool)
 {
 	struct device *dev = pool->dev;
 
-	WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
+	(void)WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
 	dma_pool_destroy(pool);
 }
 EXPORT_SYMBOL(dmam_pool_destroy);
diff --git a/mm/filemap.c b/mm/filemap.c
index 97f49ed..5eca728 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -835,7 +835,7 @@ repeat:
 				 * when entry at index 0 moves out of or back
 				 * to root: none yet gotten, safe to restart.
 				 */
-				WARN_ON(start | i);
+				(void)WARN_ON(start | i);
 				goto restart;
 			}
 			/*
diff --git a/mm/memblock.c b/mm/memblock.c
index 2f55f19..961e38d5 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -174,7 +174,7 @@ static void __init_memblock memblock_remove_region(struct memblock_type *type, u
 
 	/* Special case for empty arrays */
 	if (type->cnt == 0) {
-		WARN_ON(type->total_size != 0);
+		(void)WARN_ON(type->total_size != 0);
 		type->cnt = 1;
 		type->regions[0].base = 0;
 		type->regions[0].size = 0;
@@ -229,7 +229,7 @@ static int __init_memblock memblock_double_array(struct memblock_type *type)
 	 * array itself that is full.
 	 */
 	memcpy(new_array, type->regions, old_size);
-	memset(new_array + type->max, 0, old_size);
+	(void)memset(new_array + type->max, 0, old_size);
 	old_array = type->regions;
 	type->regions = new_array;
 	type->max <<= 1;
@@ -332,7 +332,7 @@ static int __init_memblock memblock_add_region(struct memblock_type *type,
 
 	/* special case for empty array */
 	if (type->regions[0].size == 0) {
-		WARN_ON(type->cnt != 1 || type->total_size);
+		(void)WARN_ON(type->cnt != 1 || type->total_size);
 		type->regions[0].base = base;
 		type->regions[0].size = size;
 		memblock_set_region_node(&type->regions[0], nid);
diff --git a/mm/memory.c b/mm/memory.c
index fa2f04e..46950a7 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -572,7 +572,7 @@ void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,
 		unlink_file_vma(vma);
 
 		if (is_vm_hugetlb_page(vma)) {
-			hugetlb_free_pgd_range(tlb, addr, vma->vm_end,
+			(void)hugetlb_free_pgd_range(tlb, addr, vma->vm_end,
 				floor, next? next->vm_start: ceiling);
 		} else {
 			/*
@@ -653,7 +653,7 @@ int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)
 
 static inline void init_rss_vec(int *rss)
 {
-	memset(rss, 0, sizeof(int) * NR_MM_COUNTERS);
+	(void)memset(rss, 0, sizeof(int) * NR_MM_COUNTERS);
 }
 
 static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)
diff --git a/mm/mmap.c b/mm/mmap.c
index 3f758c7..953cc3d 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2098,7 +2098,7 @@ static inline void verify_mm_writelocked(struct mm_struct *mm)
 {
 #ifdef CONFIG_DEBUG_VM
 	if (unlikely(down_read_trylock(&mm->mmap_sem))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		up_read(&mm->mmap_sem);
 	}
 #endif
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 363ba70..8acc410 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -526,7 +526,7 @@ unsigned long bdi_dirty_limit(struct backing_dev_info *bdi, unsigned long dirty)
 
 	bdi_dirty = (dirty * (100 - bdi_min_ratio)) / 100;
 	bdi_dirty *= numerator;
-	do_div(bdi_dirty, denominator);
+	(void)do_div(bdi_dirty, denominator);
 
 	bdi_dirty += (dirty * bdi->min_ratio) / 100;
 	if (bdi_dirty > (dirty * bdi->max_ratio) / 100)
@@ -753,7 +753,7 @@ static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,
 	bw = written - bdi->written_stamp;
 	bw *= HZ;
 	if (unlikely(elapsed > period)) {
-		do_div(bw, elapsed);
+		(void)do_div(bw, elapsed);
 		avg = bw;
 		goto out;
 	}
@@ -1640,7 +1640,7 @@ void tag_pages_for_writeback(struct address_space *mapping,
 				&start, end, WRITEBACK_TAG_BATCH,
 				PAGECACHE_TAG_DIRTY, PAGECACHE_TAG_TOWRITE);
 		spin_unlock_irq(&mapping->tree_lock);
-		WARN_ON_ONCE(tagged > WRITEBACK_TAG_BATCH);
+		(void)WARN_ON_ONCE(tagged > WRITEBACK_TAG_BATCH);
 		cond_resched();
 		/* We check 'start' to handle wrapping when end == ~0UL */
 	} while (tagged >= WRITEBACK_TAG_BATCH && start);
@@ -1983,7 +1983,7 @@ int __set_page_dirty_nobuffers(struct page *page)
 		mapping2 = page_mapping(page);
 		if (mapping2) { /* Race with truncate? */
 			BUG_ON(mapping2 != mapping);
-			WARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));
+			(void)WARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));
 			account_page_dirtied(page, mapping);
 			radix_tree_tag_set(&mapping->page_tree,
 				page_index(page), PAGECACHE_TAG_DIRTY);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index d2186ec..0e1f655 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -122,7 +122,7 @@ static gfp_t saved_gfp_mask;
 
 void pm_restore_gfp_mask(void)
 {
-	WARN_ON(!mutex_is_locked(&pm_mutex));
+	(void)WARN_ON(!mutex_is_locked(&pm_mutex));
 	if (saved_gfp_mask) {
 		gfp_allowed_mask = saved_gfp_mask;
 		saved_gfp_mask = 0;
@@ -131,8 +131,8 @@ void pm_restore_gfp_mask(void)
 
 void pm_restrict_gfp_mask(void)
 {
-	WARN_ON(!mutex_is_locked(&pm_mutex));
-	WARN_ON(saved_gfp_mask);
+	(void)WARN_ON(!mutex_is_locked(&pm_mutex));
+	(void)WARN_ON(saved_gfp_mask);
 	saved_gfp_mask = gfp_allowed_mask;
 	gfp_allowed_mask &= ~GFP_IOFS;
 }
@@ -1165,7 +1165,7 @@ void drain_local_pages(void *arg)
  */
 void drain_all_pages(void)
 {
-	on_each_cpu(drain_local_pages, NULL, 1);
+	(void)on_each_cpu(drain_local_pages, NULL, 1);
 }
 
 #ifdef CONFIG_HIBERNATION
@@ -1391,7 +1391,7 @@ again:
 			 * allocate greater than order-1 page units with
 			 * __GFP_NOFAIL.
 			 */
-			WARN_ON_ONCE(order > 1);
+			(void)WARN_ON_ONCE(order > 1);
 		}
 		spin_lock_irqsave(&zone->lock, flags);
 		page = __rmqueue(zone, order, migratetype);
@@ -2201,7 +2201,7 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
 	 * too large.
 	 */
 	if (order >= MAX_ORDER) {
-		WARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));
+		(void)WARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));
 		return NULL;
 	}
 
@@ -3690,7 +3690,7 @@ static void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)
 	struct per_cpu_pages *pcp;
 	int migratetype;
 
-	memset(p, 0, sizeof(*p));
+	(void)memset(p, 0, sizeof(*p));
 
 	pcp = &p->pcp;
 	pcp->count = 0;
@@ -4957,7 +4957,7 @@ void setup_per_zone_wmarks(void)
 
 		spin_lock_irqsave(&zone->lock, flags);
 		tmp = (u64)pages_min * zone->present_pages;
-		do_div(tmp, lowmem_pages);
+		(void)do_div(tmp, lowmem_pages);
 		if (is_highmem(zone)) {
 			/*
 			 * __GFP_HIGH and PF_MEMALLOC allocations usually don't
@@ -5221,7 +5221,7 @@ void *__init alloc_large_system_hash(const char *tablename,
 		/* Make sure we've got at least a 0-order allocation.. */
 		if (unlikely(flags & HASH_SMALL)) {
 			/* Makes no sense without HASH_EARLY */
-			WARN_ON(!(flags & HASH_EARLY));
+			(void)WARN_ON(!(flags & HASH_EARLY));
 			if (!(numentries >> *_hash_shift)) {
 				numentries = 1UL << *_hash_shift;
 				BUG_ON(!numentries);
@@ -5234,7 +5234,7 @@ void *__init alloc_large_system_hash(const char *tablename,
 	/* limit allocation size to 1/16 total memory by default */
 	if (max == 0) {
 		max = ((unsigned long long)nr_all_pages << PAGE_SHIFT) >> 4;
-		do_div(max, bucketsize);
+		(void)do_div(max, bucketsize);
 	}
 
 	if (numentries > max)
diff --git a/mm/percpu-km.c b/mm/percpu-km.c
index 89633fe..7c20af3 100644
--- a/mm/percpu-km.c
+++ b/mm/percpu-km.c
@@ -38,7 +38,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 	unsigned int cpu;
 
 	for_each_possible_cpu(cpu)
-		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
+		(void)memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 
 	return 0;
 }
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index 12a48a88..77dd6b9 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -14,7 +14,7 @@ static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,
 				    unsigned int cpu, int page_idx)
 {
 	/* must not be used on pre-mapped chunk */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	return vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));
 }
@@ -177,7 +177,7 @@ static void pcpu_unmap_pages(struct pcpu_chunk *chunk,
 			struct page *page;
 
 			page = pcpu_chunk_page(chunk, cpu, i);
-			WARN_ON(!page);
+			(void)WARN_ON(!page);
 			pages[pcpu_page_idx(cpu, i)] = page;
 		}
 		__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),
@@ -316,7 +316,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 		goto clear;
 
 	/* need to allocate and map pages, this chunk can't be immutable */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	pages = pcpu_get_pages_and_bitmap(chunk, &populated, true);
 	if (!pages)
@@ -342,7 +342,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 	bitmap_copy(chunk->populated, populated, pcpu_unit_pages);
 clear:
 	for_each_possible_cpu(cpu)
-		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
+		(void)memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 	return 0;
 
 err_unmap:
@@ -385,7 +385,7 @@ static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk, int off, int size)
 		return;
 
 	/* immutable chunks can't be depopulated */
-	WARN_ON(chunk->immutable);
+	(void)WARN_ON(chunk->immutable);
 
 	/*
 	 * If control reaches here, there must have been at least one
diff --git a/mm/percpu.c b/mm/percpu.c
index f47af91..02837bb 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -714,7 +714,7 @@ static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved)
 	void __percpu *ptr;
 
 	if (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE)) {
-		WARN(true, "illegal size (%zu) or align (%zu) for "
+		(void)WARN(true, "illegal size (%zu) or align (%zu) for "
 		     "percpu allocation\n", size, align);
 		return NULL;
 	}
@@ -882,7 +882,7 @@ static void pcpu_reclaim(struct work_struct *work)
 	spin_lock_irq(&pcpu_lock);
 
 	list_for_each_entry_safe(chunk, next, head, list) {
-		WARN_ON(chunk->immutable);
+		(void)WARN_ON(chunk->immutable);
 
 		/* spare the first one */
 		if (chunk == list_first_entry(head, struct pcpu_chunk, list))
@@ -1452,8 +1452,8 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
 	unsigned int *cpu_map;
 
 	/* this function may be called multiple times */
-	memset(group_map, 0, sizeof(group_map));
-	memset(group_cnt, 0, sizeof(group_cnt));
+	(void)memset(group_map, 0, sizeof(group_map));
+	(void)memset(group_cnt, 0, sizeof(group_cnt));
 
 	/* calculate size_sum and ensure dyn_size is enough for early alloc */
 	size_sum = PFN_ALIGN(static_size + reserved_size +
diff --git a/mm/shmem.c b/mm/shmem.c
index 269d049..e33796c 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -1135,7 +1135,7 @@ static struct inode *shmem_get_inode(struct super_block *sb, const struct inode
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 		inode->i_generation = get_seconds();
 		info = SHMEM_I(inode);
-		memset(info, 0, (char *)inode - (char *)info);
+		(void)memset(info, 0, (char *)inode - (char *)info);
 		spin_lock_init(&info->lock);
 		info->flags = flags & VM_NORESERVE;
 		INIT_LIST_HEAD(&info->swaplist);
@@ -2054,7 +2054,7 @@ static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,
 			if (*rest == '%') {
 				size <<= PAGE_SHIFT;
 				size *= totalram_pages;
-				do_div(size, 100);
+				(void)do_div(size, 100);
 				rest++;
 			}
 			if (*rest)
diff --git a/mm/slub.c b/mm/slub.c
index 4907563..78a0504 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -515,7 +515,7 @@ static void set_track(struct kmem_cache *s, void *object,
 		p->pid = current->pid;
 		p->when = jiffies;
 	} else
-		memset(p, 0, sizeof(struct track));
+		(void)memset(p, 0, sizeof(struct track));
 }
 
 static void init_tracking(struct kmem_cache *s, void *object)
@@ -1368,7 +1368,7 @@ static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)
 	start = page_address(page);
 
 	if (unlikely(s->flags & SLAB_POISON))
-		memset(start, POISON_INUSE, PAGE_SIZE << compound_order(page));
+		(void)memset(start, POISON_INUSE, PAGE_SIZE << compound_order(page));
 
 	last = start;
 	for_each_object(p, s, start, page->objects) {
@@ -2333,7 +2333,7 @@ redo:
 	}
 
 	if (unlikely(gfpflags & __GFP_ZERO) && object)
-		memset(object, 0, s->objsize);
+		(void)memset(object, 0, s->objsize);
 
 	slab_post_alloc_hook(s, gfpflags, object);
 
@@ -2990,7 +2990,7 @@ static int kmem_cache_open(struct kmem_cache *s,
 		size_t align, unsigned long flags,
 		void (*ctor)(void *))
 {
-	memset(s, 0, kmem_size);
+	(void)memset(s, 0, kmem_size);
 	s->name = name;
 	s->ctor = ctor;
 	s->objsize = size;
@@ -3383,7 +3383,7 @@ size_t ksize(const void *object)
 	page = virt_to_head_page(object);
 
 	if (unlikely(!PageSlab(page))) {
-		WARN_ON(!PageCompound(page));
+		(void)WARN_ON(!PageCompound(page));
 		return PAGE_SIZE << compound_order(page);
 	}
 
diff --git a/mm/truncate.c b/mm/truncate.c
index 632b15e..a65fdce 100644
--- a/mm/truncate.c
+++ b/mm/truncate.c
@@ -235,7 +235,7 @@ void truncate_inode_pages_range(struct address_space *mapping,
 
 			if (!trylock_page(page))
 				continue;
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			if (PageWriteback(page)) {
 				unlock_page(page);
 				continue;
@@ -283,7 +283,7 @@ void truncate_inode_pages_range(struct address_space *mapping,
 				break;
 
 			lock_page(page);
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			wait_on_page_writeback(page);
 			truncate_inode_page(mapping, page);
 			unlock_page(page);
@@ -358,7 +358,7 @@ unsigned long invalidate_mapping_pages(struct address_space *mapping,
 
 			if (!trylock_page(page))
 				continue;
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			ret = invalidate_inode_page(page);
 			unlock_page(page);
 			/*
@@ -459,7 +459,7 @@ int invalidate_inode_pages2_range(struct address_space *mapping,
 				break;
 
 			lock_page(page);
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			if (page->mapping != mapping) {
 				unlock_page(page);
 				continue;
diff --git a/mm/util.c b/mm/util.c
index 136ac4f..0ddf823 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -183,7 +183,7 @@ void kzfree(const void *p)
 	if (unlikely(ZERO_OR_NULL_PTR(mem)))
 		return;
 	ks = ksize(mem);
-	memset(mem, 0, ks);
+	(void)memset(mem, 0, ks);
 	kfree(mem);
 }
 EXPORT_SYMBOL(kzfree);
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 86ce9a5..cbdf337 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -40,7 +40,7 @@ static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)
 	pte = pte_offset_kernel(pmd, addr);
 	do {
 		pte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);
-		WARN_ON(!pte_none(ptent) && !pte_present(ptent));
+		(void)WARN_ON(!pte_none(ptent) && !pte_present(ptent));
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
 
@@ -1460,13 +1460,13 @@ static void __vunmap(const void *addr, int deallocate_pages)
 		return;
 
 	if ((PAGE_SIZE-1) & (unsigned long)addr) {
-		WARN(1, KERN_ERR "Trying to vfree() bad address (%p)\n", addr);
+		(void)WARN(1, KERN_ERR "Trying to vfree() bad address (%p)\n", addr);
 		return;
 	}
 
 	area = remove_vm_area(addr);
 	if (unlikely(!area)) {
-		WARN(1, KERN_ERR "Trying to vfree() nonexistent vm area (%p)\n",
+		(void)WARN(1, KERN_ERR "Trying to vfree() nonexistent vm area (%p)\n",
 				addr);
 		return;
 	}
@@ -1910,7 +1910,7 @@ static int aligned_vread(char *buf, char *addr, unsigned long count)
 			memcpy(buf, map + offset, length);
 			kunmap_atomic(map, KM_USER0);
 		} else
-			memset(buf, 0, length);
+			(void)memset(buf, 0, length);
 
 		addr += length;
 		buf += length;
@@ -2015,7 +2015,7 @@ long vread(char *buf, char *addr, unsigned long count)
 		if (!(tmp->flags & VM_IOREMAP))
 			aligned_vread(buf, addr, n);
 		else /* IOREMAP area is treated as memory hole */
-			memset(buf, 0, n);
+			(void)memset(buf, 0, n);
 		buf += n;
 		addr += n;
 		count -= n;
@@ -2027,7 +2027,7 @@ finished:
 		return 0;
 	/* zero-fill memory holes */
 	if (buf != buf_start + buflen)
-		memset(buf, 0, buflen - (buf - buf_start));
+		(void)memset(buf, 0, buflen - (buf - buf_start));
 
 	return buflen;
 }
@@ -2371,7 +2371,7 @@ struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,
 	last_end = offsets[last_area] + sizes[last_area];
 
 	if (vmalloc_end - vmalloc_start < last_end) {
-		WARN_ON(true);
+		(void)WARN_ON(true);
 		return NULL;
 	}
 
@@ -2544,7 +2544,7 @@ static void show_numa_info(struct seq_file *m, struct vm_struct *v)
 		if (!counters)
 			return;
 
-		memset(counters, 0, nr_node_ids * sizeof(unsigned int));
+		(void)memset(counters, 0, nr_node_ids * sizeof(unsigned int));
 
 		for (nr = 0; nr < v->nr_pages; nr++)
 			counters[page_to_nid(v->pages[nr])]++;
diff --git a/mm/vmscan.c b/mm/vmscan.c
index c52b235..ed37cdb 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -293,7 +293,7 @@ unsigned long shrink_slab(struct shrink_control *shrink,
 		total_scan = nr;
 		delta = (4 * nr_pages_scanned) / shrinker->seeks;
 		delta *= max_pass;
-		do_div(delta, lru_pages + 1);
+		(void)do_div(delta, lru_pages + 1);
 		total_scan += delta;
 		if (total_scan < 0) {
 			printk(KERN_ERR "shrink_slab: %pF negative objects to "
diff --git a/mm/vmstat.c b/mm/vmstat.c
index f600557..0634033 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -29,7 +29,7 @@ static void sum_vm_events(unsigned long *ret)
 	int cpu;
 	int i;
 
-	memset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));
+	(void)memset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));
 
 	for_each_online_cpu(cpu) {
 		struct vm_event_state *this = &per_cpu(vm_event_states, cpu);
diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c
index a779ec7..da2ce4e 100644
--- a/net/bluetooth/bnep/core.c
+++ b/net/bluetooth/bnep/core.c
@@ -148,7 +148,7 @@ static int bnep_ctrl_set_netfilter(struct bnep_session *s, __be16 *data, int len
 		}
 
 		if (i < BNEP_MAX_PROTO_FILTERS)
-			memset(f + i, 0, sizeof(*f));
+			(void)memset(f + i, 0, sizeof(*f));
 
 		if (n == 0)
 			bnep_set_default_proto_filter(s);
@@ -653,7 +653,7 @@ int bnep_del_connection(struct bnep_conndel_req *req)
 
 static void __bnep_copy_ci(struct bnep_conninfo *ci, struct bnep_session *s)
 {
-	memset(ci, 0, sizeof(*ci));
+	(void)memset(ci, 0, sizeof(*ci));
 	memcpy(ci->dst, s->eh.h_source, ETH_ALEN);
 	strcpy(ci->device, s->dev->name);
 	ci->flags = s->flags;
diff --git a/net/bluetooth/bnep/netdev.c b/net/bluetooth/bnep/netdev.c
index bc40864..f59f2f9 100644
--- a/net/bluetooth/bnep/netdev.c
+++ b/net/bluetooth/bnep/netdev.c
@@ -227,7 +227,7 @@ static const struct net_device_ops bnep_netdev_ops = {
 void bnep_net_setup(struct net_device *dev)
 {
 
-	memset(dev->broadcast, 0xff, ETH_ALEN);
+	(void)memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3db4324..1467f55 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -91,7 +91,7 @@ void hci_acl_connect(struct hci_conn *conn)
 
 	conn->link_policy = hdev->link_policy;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;
 
@@ -191,7 +191,7 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	struct hci_cp_le_conn_update cp;
 	struct hci_dev *hdev = conn->hdev;
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle		= cpu_to_le16(conn->handle);
 	cp.conn_interval_min	= cpu_to_le16(min);
@@ -213,7 +213,7 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
@@ -231,7 +231,7 @@ void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 	memcpy(cp.ltk, ltk, sizeof(ltk));
@@ -247,7 +247,7 @@ void hci_le_ltk_neg_reply(struct hci_conn *conn)
 
 	BT_DBG("%p", conn);
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
 
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 845da3e..bd9e9f3 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -740,7 +740,7 @@ int hci_dev_reset_stat(__u16 dev)
 	if (!hdev)
 		return -ENODEV;
 
-	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
+	(void)memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	hci_dev_put(hdev);
 
@@ -1524,7 +1524,7 @@ int hci_register_dev(struct hci_dev *hdev)
 
 	INIT_DELAYED_WORK(&hdev->discov_off, hci_discov_off);
 
-	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
+	(void)memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	atomic_set(&hdev->promisc, 0);
 
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 001307f..f0aaa93 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1912,7 +1912,7 @@ static inline void hci_remote_features_evt(struct hci_dev *hdev, struct sk_buff
 
 	if (!ev->status) {
 		struct hci_cp_remote_name_req cp;
-		memset(&cp, 0, sizeof(cp));
+		(void)memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
@@ -2627,7 +2627,7 @@ static inline void hci_remote_ext_features_evt(struct hci_dev *hdev, struct sk_b
 
 	if (!ev->status) {
 		struct hci_cp_remote_name_req cp;
-		memset(&cp, 0, sizeof(cp));
+		(void)memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 0dcc962..f1a43e1 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -333,7 +333,7 @@ static int hci_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_le
 	if (!addr)
 		return -EINVAL;
 
-	memset(&haddr, 0, sizeof(haddr));
+	(void)memset(&haddr, 0, sizeof(haddr));
 	len = min_t(unsigned int, sizeof(haddr), addr_len);
 	memcpy(&haddr, addr, len);
 
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index d478be1..4509781 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -106,7 +106,7 @@ static void __hidp_unlink_session(struct hidp_session *session)
 
 static void __hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)
 {
-	memset(ci, 0, sizeof(*ci));
+	(void)memset(ci, 0, sizeof(*ci));
 	bacpy(&ci->bdaddr, &session->bdaddr);
 
 	ci->flags = session->flags;
@@ -652,7 +652,7 @@ static int hidp_send_frame(struct socket *sock, unsigned char *data, int len)
 	if (!len)
 		return 0;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
@@ -769,7 +769,7 @@ static int hidp_session(void *arg)
 
 	fput(session->intr_sock->file);
 
-	wait_event_timeout(*(sk_sleep(ctrl_sk)),
+	(void)wait_event_timeout(*(sk_sleep(ctrl_sk)),
 		(ctrl_sk->sk_state == BT_CLOSED), msecs_to_jiffies(500));
 
 	fput(session->ctrl_sock->file);
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index faf0b11..d41da90 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -3363,7 +3363,7 @@ static inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,
 	BT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",
 						min, max, latency, to_multiplier);
 
-	memset(&rsp, 0, sizeof(rsp));
+	(void)memset(&rsp, 0, sizeof(rsp));
 
 	err = l2cap_check_conn_param(min, max, latency, to_multiplier);
 	if (err)
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index c61d967..2df2322 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -51,7 +51,7 @@ static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&la, 0, sizeof(la));
+	(void)memset(&la, 0, sizeof(la));
 	len = min_t(unsigned int, sizeof(la), alen);
 	memcpy(&la, addr, len);
 
@@ -116,7 +116,7 @@ static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int al
 	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&la, 0, sizeof(la));
+	(void)memset(&la, 0, sizeof(la));
 	len = min_t(unsigned int, sizeof(la), alen);
 	memcpy(&la, addr, len);
 
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index bc8e59d..b834dbf 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -522,7 +522,7 @@ static int read_controller_info(struct sock *sk, u16 index)
 	if (test_and_clear_bit(HCI_PI_MGMT_INIT, &hci_pi(sk)->flags))
 		mgmt_init_hdev(hdev);
 
-	memset(&rp, 0, sizeof(rp));
+	(void)memset(&rp, 0, sizeof(rp));
 
 	bacpy(&rp.bdaddr, &hdev->bdaddr);
 
@@ -2638,7 +2638,7 @@ int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)
 	struct mgmt_cp_set_local_name ev;
 	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	(void)memset(&ev, 0, sizeof(ev));
 	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
 
 	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);
diff --git a/net/bluetooth/rfcomm/core.c b/net/bluetooth/rfcomm/core.c
index 501649b..24429f4 100644
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -754,7 +754,7 @@ static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 
 	BT_DBG("session %p len %d", s, len);
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(s->sock, &msg, &iv, 1, len);
 }
@@ -1074,7 +1074,7 @@ static int rfcomm_send_test(struct rfcomm_session *s, int cr, u8 *pattern, int l
 	iv[2].iov_base = crc;
 	iv[2].iov_len  = 1;
 
-	memset(&msg, 0, sizeof(msg));
+	(void)memset(&msg, 0, sizeof(msg));
 
 	return kernel_sendmsg(sock, &msg, iv, 3, 6 + len);
 }
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 8bf26d1..33bc035 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -714,7 +714,7 @@ static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user
 			break;
 		}
 
-		memset(&cinfo, 0, sizeof(cinfo));
+		(void)memset(&cinfo, 0, sizeof(cinfo));
 		cinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;
 		memcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);
 
diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c
index 32c47de..191e330 100644
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@ -70,7 +70,7 @@ static int smp_e(struct crypto_blkcipher *tfm, const u8 *k, u8 *r)
 
 	iv_len = crypto_blkcipher_ivsize(tfm);
 	if (iv_len) {
-		memset(&iv, 0xff, iv_len);
+		(void)memset(&iv, 0xff, iv_len);
 		crypto_blkcipher_set_iv(tfm, iv, iv_len);
 	}
 
@@ -88,7 +88,7 @@ static int smp_c1(struct crypto_blkcipher *tfm, u8 k[16], u8 r[16],
 	u8 p1[16], p2[16];
 	int err;
 
-	memset(p1, 0, 16);
+	(void)memset(p1, 0, 16);
 
 	/* p1 = pres || preq || _rat || _iat */
 	swap56(pres, p1);
@@ -96,7 +96,7 @@ static int smp_c1(struct crypto_blkcipher *tfm, u8 k[16], u8 r[16],
 	p1[14] = _rat;
 	p1[15] = _iat;
 
-	memset(p2, 0, 16);
+	(void)memset(p2, 0, 16);
 
 	/* p2 = padding || ia || ra */
 	baswap((bdaddr_t *) (p2 + 4), ia);
@@ -460,7 +460,7 @@ static void random_work(struct work_struct *work)
 		u8 stk[16], r[16], rand[8];
 		__le16 ediv;
 
-		memset(rand, 0, sizeof(rand));
+		(void)memset(rand, 0, sizeof(rand));
 		ediv = 0;
 
 		swap128(smp->prnd, r);
@@ -740,7 +740,7 @@ static u8 smp_cmd_security_req(struct l2cap_conn *conn, struct sk_buff *skb)
 
 	skb_pull(skb, sizeof(*rp));
 
-	memset(&cp, 0, sizeof(cp));
+	(void)memset(&cp, 0, sizeof(cp));
 	build_pairing_cmd(conn, &cp, NULL, rp->auth_req);
 
 	smp->preq[0] = SMP_CMD_PAIRING_REQ;
@@ -961,7 +961,7 @@ int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 		smp_send_cmd(conn, SMP_CMD_IDENT_INFO, sizeof(idinfo), &idinfo);
 
 		/* Just public address */
-		memset(&addrinfo, 0, sizeof(addrinfo));
+		(void)memset(&addrinfo, 0, sizeof(addrinfo));
 		bacpy(&addrinfo.bdaddr, conn->src);
 
 		smp_send_cmd(conn, SMP_CMD_IDENT_ADDR_INFO, sizeof(addrinfo),
diff --git a/net/core/datagram.c b/net/core/datagram.c
index 68bbf9f..a94eac3 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -326,7 +326,7 @@ int skb_copy_datagram_iovec(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -352,7 +352,7 @@ int skb_copy_datagram_iovec(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -412,7 +412,7 @@ int skb_copy_datagram_const_iovec(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -439,7 +439,7 @@ int skb_copy_datagram_const_iovec(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -502,7 +502,7 @@ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -531,7 +531,7 @@ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -587,7 +587,7 @@ static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -619,7 +619,7 @@ static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
diff --git a/net/core/dev.c b/net/core/dev.c
index 115dee1..08e2b35 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -498,7 +498,7 @@ static int netdev_boot_setup_add(char *name, struct ifmap *map)
 	s = dev_boot_setup;
 	for (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++) {
 		if (s[i].name[0] == '\0' || s[i].name[0] == ' ') {
-			memset(s[i].name, 0, sizeof(s[i].name));
+			(void)memset(s[i].name, 0, sizeof(s[i].name));
 			strlcpy(s[i].name, name, IFNAMSIZ);
 			memcpy(&s[i].map, map, sizeof(s[i].map));
 			break;
@@ -581,7 +581,7 @@ int __init netdev_boot_setup(char *str)
 		return 0;
 
 	/* Save settings */
-	memset(&map, 0, sizeof(map));
+	(void)memset(&map, 0, sizeof(map));
 	if (ints[0] > 0)
 		map.irq = ints[1];
 	if (ints[0] > 1)
@@ -1330,7 +1330,7 @@ void dev_disable_lro(struct net_device *dev)
 	netdev_update_features(dev);
 
 	if (unlikely(dev->features & NETIF_F_LRO))
-		netdev_WARN(dev, "failed to disable LRO!\n");
+		(void)netdev_WARN(dev, "failed to disable LRO!\n");
 }
 EXPORT_SYMBOL(dev_disable_lro);
 
@@ -1896,7 +1896,7 @@ static void skb_warn_bad_offload(const struct sk_buff *skb)
 	if (dev && dev->dev.parent)
 		driver = dev_driver_string(dev->dev.parent);
 
-	WARN(1, "%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d "
+	(void)WARN(1, "%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d "
 	     "gso_type=%d ip_summed=%d\n",
 	     driver, dev ? &dev->features : &null_features,
 	     skb->sk ? &skb->sk->sk_route_caps : &null_features,
@@ -2725,7 +2725,7 @@ static int get_rps_cpu(struct net_device *dev, struct sk_buff *skb,
 	if (skb_rx_queue_recorded(skb)) {
 		u16 index = skb_get_rx_queue(skb);
 		if (unlikely(index >= dev->real_num_rx_queues)) {
-			WARN_ONCE(dev->real_num_rx_queues > 1,
+			(void)WARN_ONCE(dev->real_num_rx_queues > 1,
 				  "%s received packet on queue %u, but number "
 				  "of RX queues is %u\n",
 				  dev->name, index, dev->real_num_rx_queues);
@@ -3001,7 +3001,7 @@ static void net_tx_action(struct softirq_action *h)
 			struct sk_buff *skb = clist;
 			clist = clist->next;
 
-			WARN_ON(atomic_read(&skb->users));
+			(void)WARN_ON(atomic_read(&skb->users));
 			trace_kfree_skb(skb, net_tx_action);
 			__kfree_skb(skb);
 		}
@@ -3380,7 +3380,7 @@ static int napi_gro_complete(struct sk_buff *skb)
 	rcu_read_unlock();
 
 	if (err) {
-		WARN_ON(&ptype->list == head);
+		(void)WARN_ON(&ptype->list == head);
 		kfree_skb(skb);
 		return NET_RX_SUCCESS;
 	}
@@ -3871,7 +3871,7 @@ static void net_rx_action(struct softirq_action *h)
 			trace_napi_poll(n);
 		}
 
-		WARN_ON_ONCE(work > weight);
+		(void)WARN_ON_ONCE(work > weight);
 
 		budget -= work;
 
@@ -4859,7 +4859,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 
 	case SIOCGIFHWADDR:
 		if (!dev->addr_len)
-			memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
+			(void)memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
 		else
 			memcpy(ifr->ifr_hwaddr.sa_data, dev->dev_addr,
 			       min(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));
@@ -4891,7 +4891,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 		/* dev_ioctl() should ensure this case
 		 * is never reached
 		 */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		err = -ENOTTY;
 		break;
 
@@ -5235,7 +5235,7 @@ static void rollback_registered_many(struct list_head *head)
 			pr_debug("unregister_netdevice: device %s/%p never "
 				 "was registered\n", dev->name, dev);
 
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			list_del(&dev->unreg_list);
 			continue;
 		}
@@ -5279,7 +5279,7 @@ static void rollback_registered_many(struct list_head *head)
 			dev->netdev_ops->ndo_uninit(dev);
 
 		/* Notifier chain MUST detach us from master device. */
-		WARN_ON(dev->master);
+		(void)WARN_ON(dev->master);
 
 		/* Remove entries from kobject tree */
 		netdev_unregister_kobject(dev);
@@ -5650,7 +5650,7 @@ int init_dummy_netdev(struct net_device *dev)
 	 * NAPI code and this dummy netdev is supposed to be
 	 * only ever used for NAPI polls
 	 */
-	memset(dev, 0, sizeof(struct net_device));
+	(void)memset(dev, 0, sizeof(struct net_device));
 
 	/* make sure we BUG if trying to hit standard
 	 * register/unregister code path
@@ -5821,15 +5821,15 @@ void netdev_run_todo(void)
 
 		dev->reg_state = NETREG_UNREGISTERED;
 
-		on_each_cpu(flush_backlog, dev, 1);
+		(void)on_each_cpu(flush_backlog, dev, 1);
 
 		netdev_wait_allrefs(dev);
 
 		/* paranoia */
 		BUG_ON(netdev_refcnt_read(dev));
-		WARN_ON(rcu_access_pointer(dev->ip_ptr));
-		WARN_ON(rcu_access_pointer(dev->ip6_ptr));
-		WARN_ON(dev->dn_ptr);
+		(void)WARN_ON(rcu_access_pointer(dev->ip_ptr));
+		(void)WARN_ON(rcu_access_pointer(dev->ip6_ptr));
+		(void)WARN_ON(dev->dn_ptr);
 
 		if (dev->destructor)
 			dev->destructor(dev);
@@ -5876,7 +5876,7 @@ struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,
 	const struct net_device_ops *ops = dev->netdev_ops;
 
 	if (ops->ndo_get_stats64) {
-		memset(storage, 0, sizeof(*storage));
+		(void)memset(storage, 0, sizeof(*storage));
 		ops->ndo_get_stats64(dev, storage);
 	} else if (ops->ndo_get_stats) {
 		netdev_stats_to_stats64(storage, ops->ndo_get_stats(dev));
@@ -6228,7 +6228,7 @@ int dev_change_net_namespace(struct net_device *dev, struct net *net, const char
 
 	/* Fixup kobjects */
 	err = device_rename(&dev->dev, dev->name);
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 	/* Add the device back in the hashes */
 	list_netdevice(dev);
@@ -6561,7 +6561,7 @@ static int __init net_dev_init(void)
 	for_each_possible_cpu(i) {
 		struct softnet_data *sd = &per_cpu(softnet_data, i);
 
-		memset(sd, 0, sizeof(*sd));
+		(void)memset(sd, 0, sizeof(*sd));
 		skb_queue_head_init(&sd->input_pkt_queue);
 		skb_queue_head_init(&sd->process_queue);
 		sd->completion_queue = NULL;
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index 29c07fe..d19c7a5 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -242,7 +242,7 @@ int dev_addr_init(struct net_device *dev)
 	/* rtnl_mutex must be held here */
 
 	__hw_addr_init(&dev->dev_addrs);
-	memset(addr, 0, sizeof(addr));
+	(void)memset(addr, 0, sizeof(addr));
 	err = __hw_addr_add(&dev->dev_addrs, addr, sizeof(addr),
 			    NETDEV_HW_ADDR_T_LAN);
 	if (!err) {
diff --git a/net/core/dst.c b/net/core/dst.c
index 43d94ce..0369479 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -271,7 +271,7 @@ void dst_release(struct dst_entry *dst)
 		int newrefcnt;
 
 		newrefcnt = atomic_dec_return(&dst->__refcnt);
-		WARN_ON(newrefcnt < 0);
+		(void)WARN_ON(newrefcnt < 0);
 		if (unlikely(dst->flags & DST_NOCACHE) && !newrefcnt) {
 			dst = dst_destroy(dst);
 			if (dst)
@@ -327,7 +327,7 @@ EXPORT_SYMBOL(__dst_destroy_metrics_generic);
  */
 void skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst)
 {
-	WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
+	(void)WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
 	/* If dst not in cache, we must take a reference, because
 	 * dst_release() will destroy dst as soon as its refcount becomes zero
 	 */
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 921aa2b..6e3c125 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -299,7 +299,7 @@ int __ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	if (!dev->ethtool_ops || !dev->ethtool_ops->get_settings)
 		return -EOPNOTSUPP;
 
-	memset(cmd, 0, sizeof(struct ethtool_cmd));
+	(void)memset(cmd, 0, sizeof(struct ethtool_cmd));
 	cmd->cmd = ETHTOOL_GSET;
 	return dev->ethtool_ops->get_settings(dev, cmd);
 }
@@ -338,7 +338,7 @@ static noinline_for_stack int ethtool_get_drvinfo(struct net_device *dev,
 	struct ethtool_drvinfo info;
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GDRVINFO;
 	if (ops && ops->get_drvinfo) {
 		ops->get_drvinfo(dev, &info);
@@ -397,7 +397,7 @@ static noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,
 	/* calculate size of return buffer */
 	n_bits = hweight64(sset_mask);
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GSSET_INFO;
 
 	info_buf = kzalloc(n_bits * sizeof(u32), GFP_USER);
@@ -960,7 +960,7 @@ static int ethtool_self_test(struct net_device *dev, char __user *useraddr)
 	test_len = ops->get_sset_count(dev, ETH_SS_TEST);
 	if (test_len < 0)
 		return test_len;
-	WARN_ON(test_len == 0);
+	(void)WARN_ON(test_len == 0);
 
 	if (copy_from_user(&test, useraddr, sizeof(test)))
 		return -EFAULT;
@@ -1091,7 +1091,7 @@ static int ethtool_get_stats(struct net_device *dev, void __user *useraddr)
 	n_stats = ops->get_sset_count(dev, ETH_SS_STATS);
 	if (n_stats < 0)
 		return n_stats;
-	WARN_ON(n_stats == 0);
+	(void)WARN_ON(n_stats == 0);
 
 	if (copy_from_user(&stats, useraddr, sizeof(stats)))
 		return -EFAULT;
@@ -1245,7 +1245,7 @@ static int ethtool_get_dump_data(struct net_device *dev,
 	if (copy_from_user(&dump, useraddr, sizeof(dump)))
 		return -EFAULT;
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 	tmp.cmd = ETHTOOL_GET_DUMP_FLAG;
 	ret = ops->get_dump_flag(dev, &tmp);
 	if (ret)
diff --git a/net/core/fib_rules.c b/net/core/fib_rules.c
index c02e63c..39a2a3d 100644
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@ -663,7 +663,7 @@ static void notify_rule_change(int event, struct fib_rule *rule,
 	err = fib_nl_fill_rule(skb, rule, pid, nlh->nlmsg_seq, event, 0, ops);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in fib_rule_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/core/filter.c b/net/core/filter.c
index 5dea452..041dabf 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -351,7 +351,7 @@ load_b:
 			continue;
 		}
 		default:
-			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
+			(void)WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 				       fentry->code, fentry->jt,
 				       fentry->jf, fentry->k);
 			return 0;
@@ -380,7 +380,7 @@ static int check_load_and_stores(struct sock_filter *filter, int flen)
 	masks = kmalloc(flen * sizeof(*masks), GFP_KERNEL);
 	if (!masks)
 		return -ENOMEM;
-	memset(masks, 0xff, flen * sizeof(*masks));
+	(void)memset(masks, 0xff, flen * sizeof(*masks));
 
 	for (pc = 0; pc < flen; pc++) {
 		memvalid &= masks[pc];
diff --git a/net/core/flow.c b/net/core/flow.c
index e318c7e..c848334 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -430,7 +430,7 @@ static int __init flow_cache_init(struct flow_cache *fc)
 	fc->hotcpu_notifier = (struct notifier_block){
 		.notifier_call = flow_cache_cpu,
 	};
-	register_hotcpu_notifier(&fc->hotcpu_notifier);
+	(void)register_hotcpu_notifier(&fc->hotcpu_notifier);
 
 	setup_timer(&fc->rnd_timer, flow_cache_new_hashrnd,
 		    (unsigned long) fc);
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 0985b9b..e2ca94c 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -25,7 +25,7 @@ bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
 	u8 ip_proto;
 	__be16 proto = skb->protocol;
 
-	memset(flow, 0, sizeof(*flow));
+	(void)memset(flow, 0, sizeof(*flow));
 
 again:
 	switch (proto) {
diff --git a/net/core/gen_stats.c b/net/core/gen_stats.c
index 0452eb2..876abf8 100644
--- a/net/core/gen_stats.c
+++ b/net/core/gen_stats.c
@@ -58,7 +58,7 @@ gnet_stats_start_copy_compat(struct sk_buff *skb, int type, int tc_stats_type,
 	int xstats_type, spinlock_t *lock, struct gnet_dump *d)
 	__acquires(lock)
 {
-	memset(d, 0, sizeof(*d));
+	(void)memset(d, 0, sizeof(*d));
 
 	spin_lock_bh(lock);
 	d->lock = lock;
@@ -118,7 +118,7 @@ gnet_stats_copy_basic(struct gnet_dump *d, struct gnet_stats_basic_packed *b)
 	if (d->tail) {
 		struct gnet_stats_basic sb;
 
-		memset(&sb, 0, sizeof(sb));
+		(void)memset(&sb, 0, sizeof(sb));
 		sb.bytes = b->bytes;
 		sb.packets = b->packets;
 		return gnet_stats_copy(d, TCA_STATS_BASIC, &sb, sizeof(sb));
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index e287346..9680099 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -1846,7 +1846,7 @@ static int neightbl_fill_info(struct sk_buff *skb, struct neigh_table *tbl,
 		int cpu;
 		struct ndt_stats ndst;
 
-		memset(&ndst, 0, sizeof(ndst));
+		(void)memset(&ndst, 0, sizeof(ndst));
 
 		for_each_possible_cpu(cpu) {
 			struct neigh_statistics	*st;
@@ -2227,7 +2227,7 @@ static int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
 		if (t < s_t || (family && tbl->family != family))
 			continue;
 		if (t > s_t)
-			memset(&cb->args[1], 0, sizeof(cb->args) -
+			(void)memset(&cb->args[1], 0, sizeof(cb->args) -
 						sizeof(cb->args[0]));
 		if (neigh_dump_table(tbl, skb, cb) < 0)
 			break;
@@ -2648,7 +2648,7 @@ static void __neigh_notify(struct neighbour *n, int type, int flags)
 	err = neigh_fill_info(skb, n, 0, 0, type, flags);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in neigh_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -2872,7 +2872,7 @@
 	if (dev) {
 		dev_name_source = dev->name;
 		/* Terminate the table early */
-		memset(&t->neigh_vars[NEIGH_VAR_GC_INTERVAL], 0,
+		(void)memset(&t->neigh_vars[NEIGH_VAR_GC_INTERVAL], 0,
 		       sizeof(t->neigh_vars[NEIGH_VAR_GC_INTERVAL]));
 	} else {
 		dev_name_source = neigh_path[NEIGH_CTL_PATH_DEV].procname;
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index a1727cd..2ab3e1b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -338,7 +338,7 @@ static ssize_t netstat_show(const struct device *d,
 	struct net_device *dev = to_net_dev(d);
 	ssize_t ret = -EINVAL;
 
-	WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
+	(void)WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
 			offset % sizeof(u64) != 0);
 
 	read_lock(&dev_base_lock);
@@ -742,7 +742,7 @@ static void rx_queue_release(struct kobject *kobj)
 		call_rcu(&flow_table->rcu, rps_dev_flow_table_release);
 	}
 
-	memset(kobj, 0, sizeof(*kobj));
+	(void)memset(kobj, 0, sizeof(*kobj));
 	dev_put(queue->dev);
 }
 
@@ -1228,7 +1228,7 @@ static void netdev_queue_release(struct kobject *kobj)
 	xps_queue_release(queue);
 #endif
 
-	memset(kobj, 0, sizeof(*kobj));
+	(void)memset(kobj, 0, sizeof(*kobj));
 	dev_put(queue->dev);
 }
 
diff --git a/net/core/request_sock.c b/net/core/request_sock.c
index 9b570a6..d1fe37f 100644
--- a/net/core/request_sock.c
+++ b/net/core/request_sock.c
@@ -123,7 +123,7 @@ void reqsk_queue_destroy(struct request_sock_queue *queue)
 		}
 	}
 
-	WARN_ON(lopt->qlen != 0);
+	(void)WARN_ON(lopt->qlen != 0);
 	if (lopt_size > PAGE_SIZE)
 		vfree(lopt);
 	else
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index f16444b..3df0b34 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -550,7 +550,7 @@ void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
 	memcpy(RTA_DATA(rta), data, attrlen);
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 }
 EXPORT_SYMBOL(__rta_fill);
 
@@ -1721,7 +1721,7 @@ replay:
 		if (err < 0)
 			return err;
 	} else
-		memset(linkinfo, 0, sizeof(linkinfo));
+		(void)memset(linkinfo, 0, sizeof(linkinfo));
 
 	if (linkinfo[IFLA_INFO_KIND]) {
 		nla_strlcpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));
@@ -1866,7 +1866,7 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 			       nlh->nlmsg_seq, 0, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(nskb);
 	} else
 		err = rtnl_unicast(nskb, net, NETLINK_CB(skb).pid);
@@ -1894,7 +1894,7 @@ static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)
 		    rtnl_msg_handlers[idx][type].dumpit == NULL)
 			continue;
 		if (idx > s_idx)
-			memset(&cb->args[0], 0, sizeof(cb->args));
+			(void)memset(&cb->args[0], 0, sizeof(cb->args));
 		if (rtnl_msg_handlers[idx][type].dumpit(skb, cb))
 			break;
 	}
@@ -1919,7 +1919,7 @@ void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -1984,7 +1984,7 @@ static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		return err;
 	}
 
-	memset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));
+	(void)memset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));
 
 	min_len = rtm_min[sz_idx];
 	if (nlh->nlmsg_len < min_len)
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index da0c97f..03553c4 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -206,7 +206,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	 * actually initialise below. Hence, don't put any more fields after
 	 * the tail pointer in struct sk_buff!
 	 */
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	/* Account for allocated memory : skb + skb->head */
 	skb->truesize = SKB_TRUESIZE(size);
 	atomic_set(&skb->users, 1);
@@ -220,7 +220,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -272,7 +272,7 @@ struct sk_buff *build_skb(void *data)
 
 	size = ksize(data) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->truesize = SKB_TRUESIZE(size);
 	atomic_set(&skb->users, 1);
 	skb->head = data;
@@ -285,7 +285,7 @@ struct sk_buff *build_skb(void *data)
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -449,7 +449,7 @@ static void skb_release_head_state(struct sk_buff *skb)
 	secpath_put(skb->sp);
 #endif
 	if (skb->destructor) {
-		WARN_ON(in_irq());
+		(void)WARN_ON(in_irq());
 		skb->destructor(skb);
 	}
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
@@ -549,10 +549,10 @@ void skb_recycle(struct sk_buff *skb)
 	skb_release_head_state(skb);
 
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->data = skb->head + NET_SKB_PAD;
 	skb_reset_tail_pointer(skb);
 }
@@ -1121,7 +1121,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 
 	/* If the skbuff is non linear tailroom is always zero.. */
 	if (!skb_cloned(skb) && skb_tailroom(skb) >= pad) {
-		memset(skb->data+skb->len, 0, pad);
+		(void)memset(skb->data+skb->len, 0, pad);
 		return 0;
 	}
 
@@ -1139,7 +1139,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 	if (unlikely(err))
 		goto free_skb;
 
-	memset(skb->data + skb->len, 0, pad);
+	(void)memset(skb->data + skb->len, 0, pad);
 	return 0;
 
 free_skb:
@@ -1486,7 +1486,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1512,7 +1512,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1795,7 +1795,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -1820,7 +1820,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1868,7 +1868,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1894,7 +1894,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1943,7 +1943,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1973,7 +1973,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 		__wsum csum2;
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -2989,7 +2989,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -3010,7 +3010,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -3207,7 +3207,7 @@ void skb_tstamp_tx(struct sk_buff *orig_skb,
 	}
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	(void)memset(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 
@@ -3228,7 +3228,7 @@ void skb_complete_wifi_ack(struct sk_buff *skb, bool acked)
 	skb->wifi_acked = acked;
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	(void)memset(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TXSTATUS;
 
diff --git a/net/core/sock.c b/net/core/sock.c
index 5c5af998..10d68c6 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -482,7 +482,7 @@ static int sock_bindtodevice(struct sock *sk, char __user *optval, int optlen)
 	 */
 	if (optlen > IFNAMSIZ - 1)
 		optlen = IFNAMSIZ - 1;
-	memset(devname, 0, sizeof(devname));
+	(void)memset(devname, 0, sizeof(devname));
 
 	ret = -EFAULT;
 	if (copy_from_user(devname, optval, optlen))
@@ -836,7 +836,7 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 	if (len < 0)
 		return -EINVAL;
 
-	memset(&v, 0, sizeof(v));
+	(void)memset(&v, 0, sizeof(v));
 
 	switch (optname) {
 	case SO_DEBUG:
@@ -1074,8 +1074,8 @@ static void sock_copy(struct sock *nsk, const struct sock *osk)
 static inline void sk_prot_clear_nulls(struct sock *sk, int size)
 {
 	if (offsetof(struct sock, sk_node.next) != 0)
-		memset(sk, 0, offsetof(struct sock, sk_node.next));
-	memset(&sk->sk_node.pprev, 0,
+		(void)memset(sk, 0, offsetof(struct sock, sk_node.next));
+	(void)memset(&sk->sk_node.pprev, 0,
 	       size - offsetof(struct sock, sk_node.pprev));
 }
 
@@ -1089,10 +1089,10 @@ void sk_prot_clear_portaddr_nulls(struct sock *sk, int size)
 		swap(nulls1, nulls2);
 
 	if (nulls1 != 0)
-		memset((char *)sk, 0, nulls1);
-	memset((char *)sk + nulls1 + sizeof(void *), 0,
+		(void)memset((char *)sk, 0, nulls1);
+	(void)memset((char *)sk + nulls1 + sizeof(void *), 0,
 	       nulls2 - nulls1 - sizeof(void *));
-	memset((char *)sk + nulls2 + sizeof(void *), 0,
+	(void)memset((char *)sk + nulls2 + sizeof(void *), 0,
 	       size - nulls2 - sizeof(void *));
 }
 EXPORT_SYMBOL(sk_prot_clear_portaddr_nulls);
@@ -1696,7 +1696,7 @@ static void __release_sock(struct sock *sk)
 		do {
 			struct sk_buff *next = skb->next;
 
-			WARN_ON_ONCE(skb_dst_is_noref(skb));
+			(void)WARN_ON_ONCE(skb_dst_is_noref(skb));
 			skb->next = NULL;
 			sk_backlog_rcv(sk, skb);
 
diff --git a/net/core/stream.c b/net/core/stream.c
index f5df85d..5f334aa 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -141,7 +141,7 @@ int sk_stream_wait_memory(struct sock *sk, long *timeo_p)
 
 		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 		sk->sk_write_pending++;
-		sk_wait_event(sk, &current_timeo, sk->sk_err ||
+		(void)sk_wait_event(sk, &current_timeo, sk->sk_err ||
 						  (sk->sk_shutdown & SEND_SHUTDOWN) ||
 						  (sk_stream_memory_free(sk) &&
 						  !vm_wait));
@@ -192,13 +192,13 @@ void sk_stream_kill_queues(struct sock *sk)
 	__skb_queue_purge(&sk->sk_error_queue);
 
 	/* Next, the write queue. */
-	WARN_ON(!skb_queue_empty(&sk->sk_write_queue));
+	(void)WARN_ON(!skb_queue_empty(&sk->sk_write_queue));
 
 	/* Account for returned memory. */
 	sk_mem_reclaim(sk);
 
-	WARN_ON(sk->sk_wmem_queued);
-	WARN_ON(sk->sk_forward_alloc);
+	(void)WARN_ON(sk->sk_wmem_queued);
+	(void)WARN_ON(sk->sk_forward_alloc);
 
 	/* It is _impossible_ for the backlog to contain anything
 	 * when we get here.  All user references to this socket
diff --git a/net/core/utils.c b/net/core/utils.c
index 386e263f..679d581 100644
--- a/net/core/utils.c
+++ b/net/core/utils.c
@@ -177,7 +177,7 @@ int in6_pton(const char *src, int srclen,
 	int state = IN6PTON_COLON_1_2 | IN6PTON_XDIGIT | IN6PTON_NULL;
 	int w = 0;
 
-	memset(dbuf, 0, sizeof(dbuf));
+	(void)memset(dbuf, 0, sizeof(dbuf));
 
 	s = src;
 	d = dbuf;
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index a246836..c98e70b 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -105,7 +105,7 @@ int eth_header(struct sk_buff *skb, struct net_device *dev,
 	 */
 
 	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		memset(eth->h_dest, 0, ETH_ALEN);
+		(void)memset(eth->h_dest, 0, ETH_ALEN);
 		return ETH_HLEN;
 	}
 
@@ -342,7 +342,7 @@ void ether_setup(struct net_device *dev)
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 	dev->priv_flags		|= IFF_TX_SKB_SHARING;
 
-	memset(dev->broadcast, 0xFF, ETH_ALEN);
+	(void)memset(dev->broadcast, 0xFF, ETH_ALEN);
 
 }
 EXPORT_SYMBOL(ether_setup);
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index f7b5670..d548fff 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -149,10 +149,10 @@ void inet_sock_destruct(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(sk->sk_wmem_queued);
-	WARN_ON(sk->sk_forward_alloc);
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(sk->sk_wmem_queued);
+	(void)WARN_ON(sk->sk_forward_alloc);
 
 	kfree(rcu_dereference_protected(inet->inet_opt, 1));
 	dst_release(rcu_dereference_check(sk->sk_dst_cache, 1));
@@ -237,7 +237,7 @@ void build_ehash_secret(void)
 		get_random_bytes(&rnd, sizeof(rnd));
 	} while (rnd == 0);
 
-	cmpxchg(&inet_ehash_secret, 0, rnd);
+	(void)cmpxchg(&inet_ehash_secret, 0, rnd);
 }
 EXPORT_SYMBOL(build_ehash_secret);
 
@@ -339,7 +339,7 @@ lookup_protocol:
 	answer_flags = answer->flags;
 	rcu_read_unlock();
 
-	WARN_ON(answer_prot->slab == NULL);
+	(void)WARN_ON(answer_prot->slab == NULL);
 
 	err = -ENOBUFS;
 	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);
@@ -684,7 +684,7 @@ int inet_accept(struct socket *sock, struct socket *newsock, int flags)
 	lock_sock(sk2);
 
 	sock_rps_record_flow(sk2);
-	WARN_ON(!((1 << sk2->sk_state) &
+	(void)WARN_ON(!((1 << sk2->sk_state) &
 		  (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE)));
 
 	sock_graft(sk2, newsock);
@@ -723,7 +723,7 @@ int inet_getname(struct socket *sock, struct sockaddr *uaddr,
 		sin->sin_port = inet->inet_sport;
 		sin->sin_addr.s_addr = addr;
 	}
-	memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	*uaddr_len = sizeof(*sin);
 	return 0;
 }
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 59402be..41a94dd 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -670,7 +670,7 @@ struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
 	if (target_hw != NULL)
 		memcpy(arp_ptr, target_hw, dev->addr_len);
 	else
-		memset(arp_ptr, 0, dev->addr_len);
+		(void)memset(arp_ptr, 0, dev->addr_len);
 	arp_ptr += dev->addr_len;
 	memcpy(arp_ptr, &dest_ip, 4);
 
@@ -958,7 +958,7 @@ static int arp_rcv(struct sk_buff *skb, struct net_device *dev,
 	if (skb == NULL)
 		goto out_of_mem;
 
-	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
+	(void)memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
 	return NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process);
 
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index e41c40f..e41c699 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -215,8 +215,8 @@ void in_dev_finish_destroy(struct in_device *idev)
 {
 	struct net_device *dev = idev->dev;
 
-	WARN_ON(idev->ifa_list);
-	WARN_ON(idev->mc_list);
+	(void)WARN_ON(idev->ifa_list);
+	(void)WARN_ON(idev->mc_list);
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "in_dev_finish_destroy: %p=%s\n",
 	       idev, dev ? dev->name : "NIL");
@@ -492,7 +492,7 @@ static int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)
 	}
 	ipv4_devconf_setall(in_dev);
 	if (ifa->ifa_dev != in_dev) {
-		WARN_ON(ifa->ifa_dev);
+		(void)WARN_ON(ifa->ifa_dev);
 		in_dev_hold(in_dev);
 		ifa->ifa_dev = in_dev;
 	}
@@ -722,7 +722,7 @@ int devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 		   One day we will be forced to put shlock here (I mean SMP)
 		 */
 		tryaddrmatch = (sin_orig.sin_family == AF_INET);
-		memset(sin, 0, sizeof(*sin));
+		(void)memset(sin, 0, sizeof(*sin));
 		sin->sin_family = AF_INET;
 		break;
 
@@ -940,7 +940,7 @@ static int inet_gifconf(struct net_device *dev, char __user *buf, int len)
 		}
 		if (len < (int) sizeof(ifr))
 			break;
-		memset(&ifr, 0, sizeof(struct ifreq));
+		(void)memset(&ifr, 0, sizeof(struct ifreq));
 		if (ifa->ifa_label)
 			strcpy(ifr.ifr_name, ifa->ifa_label);
 		else
@@ -1356,7 +1356,7 @@ static void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,
 	err = inet_fill_ifaddr(skb, ifa, pid, seq, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 92fc5f6..32a5c27 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -302,7 +302,7 @@ static int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,
 	__be32 addr;
 	int plen;
 
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 	cfg->fc_nlinfo.nl_net = net;
 
 	if (rt->rt_dst.sa_family != AF_INET)
@@ -495,7 +495,7 @@ static int rtm_to_fib_config(struct net *net, struct sk_buff *skb,
 	if (err < 0)
 		goto errout;
 
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	rtm = nlmsg_data(nlh);
 	cfg->fc_dst_len = rtm->rtm_dst_len;
@@ -623,7 +623,7 @@ static int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 			if (e < s_e)
 				goto next;
 			if (dumped)
-				memset(&cb->args[2], 0, sizeof(cb->args) -
+				(void)memset(&cb->args[2], 0, sizeof(cb->args) -
 						 2 * sizeof(cb->args[0]));
 			if (fib_table_dump(tb, skb, cb) < 0)
 				goto out;
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index 80106d8..a9ce800 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -331,7 +331,7 @@ void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
 			    fa->fa_tos, fa->fa_info, nlm_flags);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in fib_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 2b555a5..a8ef6ae 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -342,7 +342,7 @@ static inline int tkey_mismatch(t_key a, int offset, t_key b)
 
 static inline void check_tnode(const struct tnode *tn)
 {
-	WARN_ON(tn && tn->pos+tn->bits > 32);
+	(void)WARN_ON(tn && tn->pos+tn->bits > 32);
 }
 
 static const int halve_threshold = 25;
@@ -1957,7 +1957,7 @@ int fib_table_dump(struct fib_table *tb, struct sk_buff *skb,
 
 		++count;
 		l = trie_nextleaf(l);
-		memset(&cb->args[4], 0,
+		(void)memset(&cb->args[4], 0,
 		       sizeof(cb->args) - 4*sizeof(cb->args[0]));
 	}
 	cb->args[3] = count;
@@ -1994,7 +1994,7 @@ struct fib_table *fib_trie_table(u32 id)
 	tb->tb_num_default = 0;
 
 	t = (struct trie *) tb->tb_data;
-	memset(t, 0, sizeof(*t));
+	(void)memset(t, 0, sizeof(*t));
 
 	return tb;
 }
@@ -2084,7 +2084,7 @@ static void trie_collect_stats(struct trie *t, struct trie_stat *s)
 	struct rt_trie_node *n;
 	struct fib_trie_iter iter;
 
-	memset(s, 0, sizeof(*s));
+	(void)memset(s, 0, sizeof(*s));
 
 	rcu_read_lock();
 	for (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index ab188ae..69fa4c9 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -354,7 +354,7 @@ static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 		if (ipc.opt->opt.srr)
 			daddr = icmp_param->replyopts.opt.opt.faddr;
 	}
-	memset(&fl4, 0, sizeof(fl4));
+	(void)memset(&fl4, 0, sizeof(fl4));
 	fl4.daddr = daddr;
 	fl4.saddr = rt->rt_spec_dst;
 	fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);
@@ -383,7 +383,7 @@ static struct rtable *icmp_route_lookup(struct net *net,
 	struct flowi4 fl4_dec;
 	int err;
 
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->daddr = (param->replyopts.opt.opt.srr ?
 		      param->replyopts.opt.opt.faddr : iph->saddr);
 	fl4->saddr = saddr;
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index 450e5d2..ae4fcd1 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -2223,7 +2223,7 @@ int ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,
 		struct sockaddr_storage ss;
 
 		psin = (struct sockaddr_in *)&ss;
-		memset(&ss, 0, sizeof(ss));
+		(void)memset(&ss, 0, sizeof(ss));
 		psin->sin_family = AF_INET;
 		psin->sin_addr.s_addr = psl->sl_addr[i];
 		if (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 2e4e244..f7f1f0c 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -201,7 +201,7 @@ tb_not_found:
 success:
 	if (!inet_csk(sk)->icsk_bind_hash)
 		inet_bind_hash(sk, tb, snum);
-	WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
+	(void)WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
 	ret = 0;
 
 fail_unlock:
@@ -293,7 +293,7 @@ struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)
 	}
 
 	newsk = reqsk_queue_get_child(&icsk->icsk_accept_queue, sk);
-	WARN_ON(newsk->sk_state == TCP_SYN_RECV);
+	(void)WARN_ON(newsk->sk_state == TCP_SYN_RECV);
 out:
 	release_sock(sk);
 	return newsk;
@@ -443,7 +443,7 @@ struct request_sock *inet_csk_search_req(const struct sock *sk,
 		    ireq->rmt_addr == raddr &&
 		    ireq->loc_addr == laddr &&
 		    AF_INET_FAMILY(req->rsk_ops->family)) {
-			WARN_ON(req->sk);
+			(void)WARN_ON(req->sk);
 			*prevp = prev;
 			break;
 		}
@@ -618,7 +618,7 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,
 		newicsk->icsk_probes_out  = 0;
 
 		/* Deinitialize accept_queue to trap illegal accesses. */
-		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
+		(void)memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
 
 		security_inet_csk_clone(newsk, req);
 	}
@@ -634,14 +634,14 @@ EXPORT_SYMBOL_GPL(inet_csk_clone_lock);
  */
 void inet_csk_destroy_sock(struct sock *sk)
 {
-	WARN_ON(sk->sk_state != TCP_CLOSE);
-	WARN_ON(!sock_flag(sk, SOCK_DEAD));
+	(void)WARN_ON(sk->sk_state != TCP_CLOSE);
+	(void)WARN_ON(!sock_flag(sk, SOCK_DEAD));
 
 	/* It cannot be in hash table! */
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	/* If it has not 0 inet_sk(sk)->inet_num, it must be bound */
-	WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
+	(void)WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
 
 	sk->sk_prot->destroy(sk);
 
@@ -722,7 +722,7 @@ void inet_csk_listen_stop(struct sock *sk)
 
 		local_bh_disable();
 		bh_lock_sock(child);
-		WARN_ON(sock_owned_by_user(child));
+		(void)WARN_ON(sock_owned_by_user(child));
 		sock_hold(child);
 
 		sk->sk_prot->disconnect(child, O_NONBLOCK);
@@ -740,7 +740,7 @@ void inet_csk_listen_stop(struct sock *sk)
 		sk_acceptq_removed(sk);
 		__reqsk_free(req);
 	}
-	WARN_ON(sk->sk_ack_backlog);
+	(void)WARN_ON(sk->sk_ack_backlog);
 }
 EXPORT_SYMBOL_GPL(inet_csk_listen_stop);
 
diff --git a/net/ipv4/inet_diag.c b/net/ipv4/inet_diag.c
index fcf2818..0853ffb 100644
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@ -310,7 +310,7 @@ int inet_diag_dump_one_icsk(struct inet_hashinfo *hashinfo, struct sk_buff *in_s
 			   NETLINK_CB(in_skb).pid,
 			   nlh->nlmsg_seq, 0, nlh);
 	if (err < 0) {
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(rep);
 		goto out;
 	}
diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c
index 5ff2a51..1fd0522 100644
--- a/net/ipv4/inet_fragment.c
+++ b/net/ipv4/inet_fragment.c
@@ -134,8 +134,8 @@ void inet_frag_destroy(struct inet_frag_queue *q, struct inet_frags *f,
 	struct sk_buff *fp;
 	struct netns_frags *nf;
 
-	WARN_ON(!(q->last_in & INET_FRAG_COMPLETE));
-	WARN_ON(del_timer(&q->timer) != 0);
+	(void)WARN_ON(!(q->last_in & INET_FRAG_COMPLETE));
+	(void)WARN_ON(del_timer(&q->timer) != 0);
 
 	/* Release all fragment data. */
 	fp = q->fragments;
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 984ec65..5ea6a1e 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -339,7 +339,7 @@ unique:
 	inet->inet_num = lport;
 	inet->inet_sport = htons(lport);
 	sk->sk_hash = hash;
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	__sk_nulls_add_node_rcu(sk, &head->chain);
 	if (tw) {
 		twrefcnt = inet_twsk_unhash(tw);
@@ -381,7 +381,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	struct inet_ehash_bucket *head;
 	int twrefcnt = 0;
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	sk->sk_hash = inet_sk_ehashfn(sk);
 	head = inet_ehash_bucket(hashinfo, sk->sk_hash);
@@ -391,7 +391,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	spin_lock(lock);
 	__sk_nulls_add_node_rcu(sk, list);
 	if (tw) {
-		WARN_ON(sk->sk_hash != tw->tw_hash);
+		(void)WARN_ON(sk->sk_hash != tw->tw_hash);
 		twrefcnt = inet_twsk_unhash(tw);
 	}
 	spin_unlock(lock);
@@ -410,7 +410,7 @@ static void __inet_hash(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	ilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
 
 	spin_lock(&ilb->lock);
@@ -493,7 +493,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 				    tb->port == port) {
 					if (tb->fastreuse >= 0)
 						goto next_port;
-					WARN_ON(hlist_empty(&tb->owners));
+					(void)WARN_ON(hlist_empty(&tb->owners));
 					if (!check_established(death_row, sk,
 								port, &tw))
 						goto ok;
diff --git a/net/ipv4/inet_lro.c b/net/ipv4/inet_lro.c
index cc280a3..ae1d813 100644
--- a/net/ipv4/inet_lro.c
+++ b/net/ipv4/inet_lro.c
@@ -180,7 +180,7 @@ static void lro_init_desc(struct net_lro_desc *lro_desc, struct sk_buff *skb,
 
 static inline void lro_clear_desc(struct net_lro_desc *lro_desc)
 {
-	memset(lro_desc, 0, sizeof(struct net_lro_desc));
+	(void)memset(lro_desc, 0, sizeof(struct net_lro_desc));
 }
 
 static void lro_add_common(struct net_lro_desc *lro_desc, struct iphdr *iph,
diff --git a/net/ipv4/inet_timewait_sock.c b/net/ipv4/inet_timewait_sock.c
index 89168c6..4f79d22 100644
--- a/net/ipv4/inet_timewait_sock.c
+++ b/net/ipv4/inet_timewait_sock.c
@@ -139,7 +139,7 @@ void __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,
 			hashinfo->bhash_size)];
 	spin_lock(&bhead->lock);
 	tw->tw_tb = icsk->icsk_bind_hash;
-	WARN_ON(!icsk->icsk_bind_hash);
+	(void)WARN_ON(!icsk->icsk_bind_hash);
 	inet_twsk_add_bind_node(tw, &tw->tw_tb->owners);
 	spin_unlock(&bhead->lock);
 
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 1f23a57..d97316d 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -571,8 +571,8 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 		qp->q.fragments = head;
 	}
 
-	WARN_ON(head == NULL);
-	WARN_ON(FRAG_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(FRAG_CB(head)->offset != 0);
 
 	/* Allocate a new buffer for the datagram. */
 	ihlen = ip_hdrlen(head);
@@ -708,7 +708,7 @@ struct sk_buff *ip_check_defrag(struct sk_buff *skb, u32 user)
 		if (skb) {
 			if (pskb_trim_rcsum(skb, len))
 				return skb;
-			memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+			(void)memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 			if (ip_defrag(skb, user))
 				return NULL;
 			skb->rxhash = 0;
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 073a9b0..6ea13f7 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -435,7 +435,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	}
 
 	/* Remove any debris in the socket control block */
-	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+	(void)memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index 1e60f76..7665eab 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -64,12 +64,12 @@ void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
 		return;
 	}
 	if (opt->rr) {
-		memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
+		(void)memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
 		opt->rr = 0;
 		opt->rr_needaddr = 0;
 	}
 	if (opt->ts) {
-		memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
+		(void)memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
 		opt->ts = 0;
 		opt->ts_needaddr = opt->ts_needtime = 0;
 	}
@@ -92,7 +92,7 @@ int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)
 	int	optlen;
 	__be32	daddr;
 
-	memset(dopt, 0, sizeof(struct ip_options));
+	(void)memset(dopt, 0, sizeof(struct ip_options));
 
 	sopt = &(IPCB(skb)->opt);
 
@@ -228,7 +228,7 @@ void ip_options_fragment(struct sk_buff * skb)
 		if (optlen<2 || optlen>l)
 		  return;
 		if (!IPOPT_COPIED(*optptr))
-			memset(optptr, IPOPT_NOOP, optlen);
+			(void)memset(optptr, IPOPT_NOOP, optlen);
 		l -= optlen;
 		optptr += optlen;
 	}
@@ -481,19 +481,19 @@ void ip_options_undo(struct ip_options * opt)
 	if (opt->rr_needaddr) {
 		unsigned  char * optptr = opt->__data+opt->rr-sizeof(struct  iphdr);
 		optptr[2] -= 4;
-		memset(&optptr[optptr[2]-1], 0, 4);
+		(void)memset(&optptr[optptr[2]-1], 0, 4);
 	}
 	if (opt->ts) {
 		unsigned  char * optptr = opt->__data+opt->ts-sizeof(struct  iphdr);
 		if (opt->ts_needtime) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 			if ((optptr[3]&0xF) == IPOPT_TS_PRESPEC)
 				optptr[2] -= 4;
 		}
 		if (opt->ts_needaddr) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 		}
 	}
 }
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index ff302bd..78492e1 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -121,7 +121,7 @@ static int ip_dev_loopback_xmit(struct sk_buff *newskb)
 	__skb_pull(newskb, skb_network_offset(newskb));
 	newskb->pkt_type = PACKET_LOOPBACK;
 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
-	WARN_ON(!skb_dst(newskb));
+	(void)WARN_ON(!skb_dst(newskb));
 	skb_dst_force(newskb);
 	netif_rx_ni(newskb);
 	return 0;
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 8aa87c1..6350fc9 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -139,7 +139,7 @@ static void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = iph->daddr;
 	sin.sin_port = ports[1];
-	memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+	(void)memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
 
 	put_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);
 }
@@ -403,7 +403,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +
 						   serr->addr_offset);
 		sin->sin_port = serr->port;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
@@ -415,7 +415,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 		if (inet->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	}
@@ -647,7 +647,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (optlen >= sizeof(struct in_addr) &&
 			    copy_from_user(&mreq.imr_address, optval,
 					   sizeof(struct in_addr)))
@@ -700,7 +700,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))
 				break;
 		}
@@ -800,7 +800,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		psin = (struct sockaddr_in *)&greq.gr_group;
 		if (psin->sin_family != AF_INET)
 			goto e_inval;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		mreq.imr_multiaddr = psin->sin_addr;
 		mreq.imr_ifindex = greq.gr_interface;
 
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index 6e412a6..c73e99a 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -355,7 +355,7 @@ static int __init ic_setup_if(void)
 	struct sockaddr_in *sin = (void *) &ir.ifr_ifru.ifru_addr;
 	int err;
 
-	memset(&ir, 0, sizeof(ir));
+	(void)memset(&ir, 0, sizeof(ir));
 	strcpy(ir.ifr_ifrn.ifrn_name, ic_dev->name);
 	set_sockaddr(sin, ic_myaddr, 0);
 	if ((err = ic_devinet_ioctl(SIOCSIFADDR, &ir)) < 0) {
@@ -394,7 +394,7 @@ static int __init ic_setup_routes(void)
 		struct rtentry rm;
 		int err;
 
-		memset(&rm, 0, sizeof(rm));
+		(void)memset(&rm, 0, sizeof(rm));
 		if ((ic_gateway ^ ic_myaddr) & ic_netmask) {
 			printk(KERN_ERR "IP-Config: Gateway not on directly connected network.\n");
 			return -1;
@@ -777,7 +777,7 @@ static void __init ic_bootp_send_if(struct ic_device *d, unsigned long jiffies_d
 		return;
 	skb_reserve(skb, hlen);
 	b = (struct bootp_pkt *) skb_put(skb, sizeof(struct bootp_pkt));
-	memset(b, 0, sizeof(struct bootp_pkt));
+	(void)memset(b, 0, sizeof(struct bootp_pkt));
 
 	/* Construct IP header */
 	skb_reset_network_header(skb);
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index fd7a3f6..789730d 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -914,7 +914,7 @@ static int get_info(struct net *net, void __user *user,
 			private = &tmp;
 		}
 #endif
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		info.valid_hooks = t->valid_hooks;
 		memcpy(info.hook_entry, private->hook_entry,
 		       sizeof(info.hook_entry));
@@ -1748,7 +1748,7 @@ static int do_arpt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len
 		}
 		rev.name[sizeof(rev.name)-1] = 0;
 
-		try_then_request_module(xt_find_revision(NFPROTO_ARP, rev.name,
+		(void)try_then_request_module(xt_find_revision(NFPROTO_ARP, rev.name,
 							 rev.revision, 1, &ret),
 					"arpt_%s", rev.name);
 		break;
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 24e556e..4f80eae 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -1103,7 +1103,7 @@ static int get_info(struct net *net, void __user *user,
 			private = &tmp;
 		}
 #endif
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		info.valid_hooks = t->valid_hooks;
 		memcpy(info.hook_entry, private->hook_entry,
 		       sizeof(info.hook_entry));
@@ -2041,7 +2041,7 @@ do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 		else
 			target = 0;
 
-		try_then_request_module(xt_find_revision(AF_INET, rev.name,
+		(void)try_then_request_module(xt_find_revision(AF_INET, rev.name,
 							 rev.revision,
 							 target, &ret),
 					"ipt_%s", rev.name);
diff --git a/net/ipv4/netfilter/ipt_REJECT.c b/net/ipv4/netfilter/ipt_REJECT.c
index 51f13f8..5f510fd 100644
--- a/net/ipv4/netfilter/ipt_REJECT.c
+++ b/net/ipv4/netfilter/ipt_REJECT.c
@@ -82,7 +82,7 @@ static void send_reset(struct sk_buff *oldskb, int hook)
 	niph->daddr	= oiph->saddr;
 
 	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
-	memset(tcph, 0, sizeof(*tcph));
+	(void)memset(tcph, 0, sizeof(*tcph));
 	tcph->source	= oth->dest;
 	tcph->dest	= oth->source;
 	tcph->doff	= sizeof(struct tcphdr) / 4;
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index de9da21..334ebbe 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -249,7 +249,7 @@ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
 	const struct nf_conntrack_tuple_hash *h;
 	struct nf_conntrack_tuple tuple;
 
-	memset(&tuple, 0, sizeof(tuple));
+	(void)memset(&tuple, 0, sizeof(tuple));
 	tuple.src.u3.ip = inet->inet_rcv_saddr;
 	tuple.src.u.tcp.port = inet->inet_sport;
 	tuple.dst.u3.ip = inet->inet_daddr;
@@ -279,7 +279,7 @@ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
 			.tuple.dst.u.tcp.port;
 		sin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]
 			.tuple.dst.u3.ip;
-		memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+		(void)memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
 
 		pr_debug("SO_ORIGINAL_DST: %pI4 %u\n",
 			 &sin.sin_addr.s_addr, ntohs(sin.sin_port));
diff --git a/net/ipv4/netfilter/nf_nat_core.c b/net/ipv4/netfilter/nf_nat_core.c
index a708933..d1afec4 100644
--- a/net/ipv4/netfilter/nf_nat_core.c
+++ b/net/ipv4/netfilter/nf_nat_core.c
@@ -601,7 +601,7 @@ nfnetlink_parse_nat(const struct nlattr *nat,
 	struct nlattr *tb[CTA_NAT_MAX+1];
 	int err;
 
-	memset(range, 0, sizeof(*range));
+	(void)memset(range, 0, sizeof(*range));
 
 	err = nla_parse_nested(tb, CTA_NAT_MAX, nat, nat_nla_policy);
 	if (err < 0)
@@ -669,7 +669,7 @@ static int clean_nat(struct nf_conn *i, void *data)
 
 	if (!nat)
 		return 0;
-	memset(nat, 0, sizeof(*nat));
+	(void)memset(nat, 0, sizeof(*nat));
 	i->status &= ~(IPS_NAT_MASK | IPS_NAT_DONE_MASK | IPS_SEQ_ADJUST);
 	return 0;
 }
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index aea5a19..3cac97d 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -661,7 +661,7 @@ static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_family = AF_INET;
 		sin->sin_port = 0 /* skb->h.uh->source */;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (isk->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index 3ccda5a..ad004e9 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -717,7 +717,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
@@ -736,7 +736,7 @@ static int raw_init(struct sock *sk)
 	struct raw_sock *rp = raw_sk(sk);
 
 	if (inet_sk(sk)->inet_num == IPPROTO_ICMP)
-		memset(&rp->filter, 0, sizeof(rp->filter));
+		(void)memset(&rp->filter, 0, sizeof(rp->filter));
 	return 0;
 }
 
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bcacf54..6209d52 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -849,7 +849,7 @@ static void rt_check_expire(void)
 	expires_ljiffies = jiffies;
 	mult = ((u64)delta) << rt_hash_log;
 	if (ip_rt_gc_timeout > 1)
-		do_div(mult, ip_rt_gc_timeout);
+		(void)do_div(mult, ip_rt_gc_timeout);
 	goal = (unsigned int)mult;
 	if (goal > rt_hash_mask)
 		goal = rt_hash_mask + 1;
@@ -1847,7 +1847,7 @@ static int ip_rt_bug(struct sk_buff *skb)
 		&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,
 		skb->dev ? skb->dev->name : "?");
 	kfree_skb(skb);
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
@@ -1873,7 +1873,7 @@ void ip_rt_get_source(u8 *addr, struct sk_buff *skb, struct rtable *rt)
 
 		iph = ip_hdr(skb);
 
-		memset(&fl4, 0, sizeof(fl4));
+		(void)memset(&fl4, 0, sizeof(fl4));
 		fl4.daddr = iph->daddr;
 		fl4.saddr = iph->saddr;
 		fl4.flowi4_tos = RT_TOS(iph->tos);
@@ -3476,7 +3476,7 @@ int __init ip_rt_init(void)
 					&rt_hash_log,
 					&rt_hash_mask,
 					rhash_entries ? 0 : 512 * 1024);
-	memset(rt_hash_table, 0, (rt_hash_mask + 1) * sizeof(struct rt_hash_bucket));
+	(void)memset(rt_hash_table, 0, (rt_hash_mask + 1) * sizeof(struct rt_hash_bucket));
 	rt_hash_lock_init();
 
 	ipv4_dst_ops.gc_thresh = (rt_hash_mask + 1);
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 9bcdec3..14d6111 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1198,7 +1198,7 @@ void tcp_cleanup_rbuf(struct sock *sk, int copied)
 
 	struct sk_buff *skb = skb_peek(&sk->sk_receive_queue);
 
-	WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
+	(void)WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
 	     "cleanup rbuf bug: copied %X seq %X rcvnxt %X\n",
 	     tp->copied_seq, TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt);
 
@@ -1492,7 +1492,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 				goto found_ok_skb;
 			if (tcp_hdr(skb)->fin)
 				goto found_fin_ok;
-			WARN(!(flags & MSG_PEEK),
+			(void)WARN(!(flags & MSG_PEEK),
 			     "recvmsg bug 2: copied %X seq %X rcvnxt %X fl %X\n",
 			     *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);
 		}
@@ -1555,7 +1555,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 			tp->ucopy.len = len;
 
-			WARN_ON(tp->copied_seq != tp->rcv_nxt &&
+			(void)WARN_ON(tp->copied_seq != tp->rcv_nxt &&
 				!(flags & (MSG_PEEK | MSG_TRUNC)));
 
 			/* Ugly... If prequeue is not empty, we have to
@@ -1972,7 +1972,7 @@ adjudge_to_death:
 	 */
 	local_bh_disable();
 	bh_lock_sock(sk);
-	WARN_ON(sock_owned_by_user(sk));
+	(void)WARN_ON(sock_owned_by_user(sk));
 
 	percpu_counter_inc(sk->sk_prot->orphan_count);
 
@@ -2101,10 +2101,10 @@ int tcp_disconnect(struct sock *sk, int flags)
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
 	tcp_init_send_head(sk);
-	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
+	(void)memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
 	__sk_dst_reset(sk);
 
-	WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
+	(void)WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
 
 	sk->sk_error_report(sk);
 	return err;
@@ -2437,7 +2437,7 @@ void tcp_get_info(const struct sock *sk, struct tcp_info *info)
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	u32 now = tcp_time_stamp;
 
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 
 	info->tcpi_state = sk->sk_state;
 	info->tcpi_ca_state = icsk->icsk_ca_state;
@@ -2585,7 +2585,7 @@ static int do_tcp_getsockopt(struct sock *sk, int level,
 		if (len < sizeof(ctd))
 			return -EINVAL;
 
-		memset(&ctd, 0, sizeof(ctd));
+		(void)memset(&ctd, 0, sizeof(ctd));
 		ctd.tcpct_flags = (tp->rx_opt.cookie_in_always ?
 				   TCP_COOKIE_IN_ALWAYS : 0)
 				| (tp->rx_opt.cookie_out_never ?
@@ -3295,8 +3295,8 @@ void __init tcp_init(void)
 
 	tcp_register_congestion_control(&tcp_reno);
 
-	memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
-	memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
+	(void)memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
+	(void)memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
 	tcp_secret_one.expires = jiffy; /* past due */
 	tcp_secret_two.expires = jiffy; /* past due */
 	tcp_secret_generating = &tcp_secret_one;
diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c
index fc6d475..3e03f5a 100644
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@ -220,7 +220,7 @@ int tcp_set_allowed_congestion_control(char *val)
 	/* pass 3 mark as allowed */
 	while ((name = strsep(&val, " ")) && *name) {
 		ca = tcp_ca_find(name);
-		WARN_ON(!ca);
+		(void)WARN_ON(!ca);
 		if (ca)
 			ca->flags |= TCP_CONG_NON_RESTRICTED;
 	}
diff --git a/net/ipv4/tcp_cubic.c b/net/ipv4/tcp_cubic.c
index f376b05..68cf6e4 100644
--- a/net/ipv4/tcp_cubic.c
+++ b/net/ipv4/tcp_cubic.c
@@ -469,7 +469,7 @@ static int __init cubictcp_register(void)
 	cube_factor = 1ull << (10+3*BICTCP_HZ); /* 2^40 */
 
 	/* divide by bic_scale and by constant Srtt (100ms) */
-	do_div(cube_factor, bic_scale * 10);
+	(void)do_div(cube_factor, bic_scale * 10);
 
 	/* hystart needs ms clock resolution */
 	if (hystart && HZ < 1000)
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 2877c3e..6be2d34 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1925,7 +1925,7 @@ advance_sp:
 
 	tcp_mark_lost_retrans(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	if ((state.reord < tp->fackets_out) &&
 	    ((icsk->icsk_ca_state != TCP_CA_Loss) || tp->undo_marker) &&
@@ -1935,10 +1935,10 @@ advance_sp:
 out:
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
-	WARN_ON((int)tcp_packets_in_flight(tp) < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tcp_packets_in_flight(tp) < 0);
 #endif
 	return state.flag;
 }
@@ -1978,7 +1978,7 @@ static void tcp_add_reno_sack(struct sock *sk)
 	struct tcp_sock *tp = tcp_sk(sk);
 	tp->sacked_out++;
 	tcp_check_reno_reordering(sk, 0);
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Account for ACK, ACKing some data in Reno Recovery phase. */
@@ -1995,7 +1995,7 @@ static void tcp_remove_reno_sacks(struct sock *sk, int acked)
 			tp->sacked_out -= acked - 1;
 	}
 	tcp_check_reno_reordering(sk, acked);
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 static inline void tcp_reset_reno_sack(struct tcp_sock *tp)
@@ -2108,7 +2108,7 @@ void tcp_enter_frto(struct sock *sk)
 		TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
 		tp->retrans_out -= tcp_skb_pcount(skb);
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Too bad if TCP was application limited */
 	tp->snd_cwnd = min(tp->snd_cwnd, tcp_packets_in_flight(tp) + 1);
@@ -2178,7 +2178,7 @@ static void tcp_enter_frto_loss(struct sock *sk, int allowed_segments, int flag)
 			tp->retransmit_high = TCP_SKB_CB(skb)->end_seq;
 		}
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	tp->snd_cwnd = tcp_packets_in_flight(tp) + allowed_segments;
 	tp->snd_cwnd_cnt = 0;
@@ -2263,7 +2263,7 @@ void tcp_enter_loss(struct sock *sk, int how)
 			tp->retransmit_high = TCP_SKB_CB(skb)->end_seq;
 		}
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	tp->reordering = min_t(unsigned int, tp->reordering,
 			       sysctl_tcp_reordering);
@@ -2512,7 +2512,7 @@ static void tcp_timeout_skbs(struct sock *sk)
 
 	tp->scoreboard_skb_hint = skb;
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Mark head of queue up as lost. With RFC3517 SACK, the packets is
@@ -2526,7 +2526,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 	int err;
 	unsigned int mss;
 
-	WARN_ON(packets > tp->packets_out);
+	(void)WARN_ON(packets > tp->packets_out);
 	if (tp->lost_skb_hint) {
 		skb = tp->lost_skb_hint;
 		cnt = tp->lost_cnt_hint;
@@ -2571,7 +2571,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 		if (mark_head)
 			break;
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Account newly detected lost packet(s) */
@@ -2871,7 +2871,7 @@ static void tcp_try_to_open(struct sock *sk, int flag)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	if (!tp->frto_counter && !tcp_any_retrans_done(sk))
 		tp->retrans_stamp = 0;
@@ -2948,7 +2948,7 @@ void tcp_simple_retransmit(struct sock *sk)
 	if (tcp_is_reno(tp))
 		tcp_limit_reno_sacked(tp);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Don't muck with the congestion window here.
 	 * Reason is that we do not increase amount of _data_
@@ -3032,7 +3032,7 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked,
 		return;
 
 	/* C. Check consistency of the current state. */
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* D. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
@@ -3048,7 +3048,7 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked,
 	/* E. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
 	if (icsk->icsk_ca_state == TCP_CA_Open) {
-		WARN_ON(tp->retrans_out != 0);
+		(void)WARN_ON(tp->retrans_out != 0);
 		tp->retrans_stamp = 0;
 	} else if (!before(tp->snd_una, tp->high_seq)) {
 		switch (icsk->icsk_ca_state) {
@@ -3413,9 +3413,9 @@ static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,
 	}
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
 	if (!tp->packets_out && tcp_is_sack(tp)) {
 		icsk = inet_csk(sk);
 		if (tp->lost_out) {
@@ -3585,7 +3585,7 @@ static int tcp_process_frto(struct sock *sk, int flag)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Duplicate the behavior from Loss state (fastretrans_alert) */
 	if (flag & FLAG_DATA_ACKED)
@@ -4361,7 +4361,7 @@ static void tcp_sack_remove(struct tcp_sock *tp)
 			int i;
 
 			/* RCV.NXT must cover all the block! */
-			WARN_ON(before(tp->rcv_nxt, sp->end_seq));
+			(void)WARN_ON(before(tp->rcv_nxt, sp->end_seq));
 
 			/* Zap this SACK, by moving forward any other SACKS. */
 			for (i=this_sack+1; i < num_sacks; i++)
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 1eb4ad5..0d28b10 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -472,7 +472,7 @@ void tcp_v4_err(struct sk_buff *icmp_skb, u32 info)
 		/* ICMPs are not backlogged, hence we cannot get
 		   an established socket here.
 		 */
-		WARN_ON(req->sk);
+		(void)WARN_ON(req->sk);
 
 		if (seq != tcp_rsk(req)->snt_isn) {
 			NET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -612,7 +612,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 		return;
 
 	/* Swap the send and the receive. */
-	memset(&rep, 0, sizeof(rep));
+	(void)memset(&rep, 0, sizeof(rep));
 	rep.th.dest   = th->source;
 	rep.th.source = th->dest;
 	rep.th.doff   = sizeof(struct tcphdr) / 4;
@@ -626,7 +626,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 				       skb->len - (th->doff << 2));
 	}
 
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&arg, 0, sizeof(arg));
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
 
@@ -682,8 +682,8 @@ static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack,
 	struct ip_reply_arg arg;
 	struct net *net = dev_net(skb_dst(skb)->dev);
 
-	memset(&rep.th, 0, sizeof(struct tcphdr));
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&rep.th, 0, sizeof(struct tcphdr));
+	(void)memset(&arg, 0, sizeof(arg));
 
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
@@ -1121,7 +1121,7 @@ static int tcp_v4_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 
@@ -1171,7 +1171,7 @@ int tcp_v4_md5_hash_skb(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 EXPORT_SYMBOL(tcp_v4_md5_hash_skb);
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 8c8de27..a5d4c47 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -826,7 +826,7 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 	inet = inet_sk(sk);
 	tp = tcp_sk(sk);
 	tcb = TCP_SKB_CB(skb);
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 
 	if (unlikely(tcb->tcp_flags & TCPHDR_SYN))
 		tcp_options_size = tcp_syn_options(sk, skb, &opts, &md5);
@@ -988,7 +988,7 @@ static void tcp_adjust_pcount(struct sock *sk, const struct sk_buff *skb, int de
 	    (tcp_is_fack(tp) || (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)))
 		tp->lost_cnt_hint -= decr;
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Function to create two new TCP segments.  Shrinks the given segment
@@ -2478,7 +2478,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 		ireq->rcv_wscale = rcv_wscale;
 	}
 
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 #ifdef CONFIG_SYN_COOKIES
 	if (unlikely(req->cookie_ts))
 		TCP_SKB_CB(skb)->when = cookie_init_timestamp(req);
@@ -2493,7 +2493,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 	skb_reset_transport_header(skb);
 
 	th = tcp_hdr(skb);
-	memset(th, 0, sizeof(struct tcphdr));
+	(void)memset(th, 0, sizeof(struct tcphdr));
 	th->syn = 1;
 	th->ack = 1;
 	TCP_ECN_make_synack(req, th);
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index a516d1e..c8222a4 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -325,7 +325,7 @@ void tcp_retransmit_timer(struct sock *sk)
 	if (!tp->packets_out)
 		goto out;
 
-	WARN_ON(tcp_write_queue_empty(sk));
+	(void)WARN_ON(tcp_write_queue_empty(sk));
 
 	if (!tp->snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
 	    !((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 5d075b5..2d969bb 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1230,7 +1230,7 @@ try_again:
 		sin->sin_family = AF_INET;
 		sin->sin_port = udp_hdr(skb)->source;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/ipv4/xfrm4_mode_beet.c b/net/ipv4/xfrm4_mode_beet.c
index 6341818..8aa4207 100644
--- a/net/ipv4/xfrm4_mode_beet.c
+++ b/net/ipv4/xfrm4_mode_beet.c
@@ -69,7 +69,7 @@ static int xfrm4_beet_output(struct xfrm_state *x, struct sk_buff *skb)
 		ph->hdrlen = optlen / 8;
 		ph->nexthdr = top_iph->protocol;
 		if (ph->padlen)
-			memset(ph + 1, IPOPT_NOP, ph->padlen);
+			(void)memset(ph + 1, IPOPT_NOP, ph->padlen);
 
 		top_iph->protocol = IPPROTO_BEETPH;
 		top_iph->ihl = sizeof(struct iphdr) / 4;
diff --git a/net/ipv4/xfrm4_output.c b/net/ipv4/xfrm4_output.c
index 327a617..0aa2a46 100644
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@ -65,7 +65,7 @@ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err)
 		return err;
 
-	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
+	(void)memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 	IPCB(skb)->flags |= IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED;
 
 	skb->protocol = htons(ETH_P_IP);
diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index a0b4c5d..daeb189 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -25,7 +25,7 @@ static struct dst_entry *__xfrm4_dst_lookup(struct net *net, struct flowi4 *fl4,
 {
 	struct rtable *rt;
 
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->daddr = daddr->a4;
 	fl4->flowi4_tos = tos;
 	if (saddr)
@@ -114,7 +114,7 @@ _decode_session4(struct sk_buff *skb, struct flowi *fl, int reverse)
 	u8 *xprth = skb_network_header(skb) + iph->ihl * 4;
 	struct flowi4 *fl4 = &fl->u.ip4;
 
-	memset(fl4, 0, sizeof(struct flowi4));
+	(void)memset(fl4, 0, sizeof(struct flowi4));
 	fl4->flowi4_mark = skb->mark;
 
 	if (!ip_is_fragment(iph)) {
diff --git a/net/ipv4/xfrm4_state.c b/net/ipv4/xfrm4_state.c
index 9258e75..f96bfed 100644
--- a/net/ipv4/xfrm4_state.c
+++ b/net/ipv4/xfrm4_state.c
@@ -64,7 +64,7 @@ int xfrm4_extract_header(struct sk_buff *skb)
 	XFRM_MODE_SKB_CB(skb)->tos = iph->tos;
 	XFRM_MODE_SKB_CB(skb)->ttl = iph->ttl;
 	XFRM_MODE_SKB_CB(skb)->optlen = iph->ihl * 4 - sizeof(*iph);
-	memset(XFRM_MODE_SKB_CB(skb)->flow_lbl, 0,
+	(void)memset(XFRM_MODE_SKB_CB(skb)->flow_lbl, 0,
 	       sizeof(XFRM_MODE_SKB_CB(skb)->flow_lbl));
 
 	return 0;
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index a225d5e..3b39bb3 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -322,8 +322,8 @@ void in6_dev_finish_destroy(struct inet6_dev *idev)
 {
 	struct net_device *dev = idev->dev;
 
-	WARN_ON(!list_empty(&idev->addr_list));
-	WARN_ON(idev->mc_list != NULL);
+	(void)WARN_ON(!list_empty(&idev->addr_list));
+	(void)WARN_ON(idev->mc_list != NULL);
 
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "in6_dev_finish_destroy: %s\n", dev ? dev->name : "NIL");
@@ -533,7 +533,7 @@ static int addrconf_fixup_forwarding(struct ctl_table *table, int *p, int old)
 /* Nobody refers to this ifaddr, destroy it */
 void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)
 {
-	WARN_ON(!hlist_unhashed(&ifp->addr_lst));
+	(void)WARN_ON(!hlist_unhashed(&ifp->addr_lst));
 
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "inet6_ifa_finish_destroy\n");
@@ -1516,7 +1516,7 @@ static int addrconf_ifid_arcnet(u8 *eui, struct net_device *dev)
 	/* XXX: inherit EUI-64 from other interface -- yoshfuji */
 	if (dev->addr_len != ARCNET_ALEN)
 		return -1;
-	memset(eui, 0, 7);
+	(void)memset(eui, 0, 7);
 	eui[7] = *(u8*)dev->dev_addr;
 	return 0;
 }
@@ -2132,7 +2132,7 @@ int addrconf_set_dstaddr(struct net *net, void __user *arg)
 		if (!(ipv6_addr_type(&ireq.ifr6_addr) & IPV6_ADDR_COMPATv4))
 			goto err_exit;
 
-		memset(&p, 0, sizeof(p));
+		(void)memset(&p, 0, sizeof(p));
 		p.iph.daddr = ireq.ifr6_addr.s6_addr32[3];
 		p.iph.saddr = 0;
 		p.iph.version = 4;
@@ -2343,7 +2343,7 @@ static void sit_add_v4_addrs(struct inet6_dev *idev)
 
 	ASSERT_RTNL();
 
-	memset(&addr, 0, sizeof(struct in6_addr));
+	(void)memset(&addr, 0, sizeof(struct in6_addr));
 	memcpy(&addr.s6_addr32[3], idev->dev->dev_addr, 4);
 
 	if (idev->dev->flags&IFF_POINTOPOINT) {
@@ -2445,7 +2445,7 @@ static void addrconf_dev_config(struct net_device *dev)
 	if (IS_ERR(idev))
 		return;
 
-	memset(&addr, 0, sizeof(struct in6_addr));
+	(void)memset(&addr, 0, sizeof(struct in6_addr));
 	addr.s6_addr32[0] = htonl(0xFE800000);
 
 	if (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)
@@ -3830,7 +3830,7 @@ static int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr* nlh,
 				nlh->nlmsg_seq, RTM_NEWADDR, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout_ifa;
 	}
@@ -3854,7 +3854,7 @@ static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)
 	err = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -3870,7 +3870,7 @@ static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
 {
 	BUG_ON(bytes < (DEVCONF_MAX * 4));
 
-	memset(array, 0, bytes);
+	(void)memset(array, 0, bytes);
 	array[DEVCONF_FORWARDING] = cnf->forwarding;
 	array[DEVCONF_HOPLIMIT] = cnf->hop_limit;
 	array[DEVCONF_MTU6] = cnf->mtu6;
@@ -3946,7 +3946,7 @@ static inline void __snmp6_fill_statsdev(u64 *stats, atomic_long_t *mib,
 	for (i = 1; i < items; i++)
 		put_unaligned(atomic_long_read(&mib[i]), &stats[i]);
 
-	memset(&stats[items], 0, pad);
+	(void)memset(&stats[items], 0, pad);
 }
 
 static inline void __snmp6_fill_stats64(u64 *stats, void __percpu **mib,
@@ -3961,7 +3961,7 @@ static inline void __snmp6_fill_stats64(u64 *stats, void __percpu **mib,
 	for (i = 1; i < items; i++)
 		put_unaligned(snmp_fold_field64(mib, i, syncpoff), &stats[i]);
 
-	memset(&stats[items], 0, pad);
+	(void)memset(&stats[items], 0, pad);
 }
 
 static void snmp6_fill_stats(u64 *stats, struct inet6_dev *idev, int attrtype,
@@ -4132,7 +4132,7 @@ void inet6_ifinfo_notify(int event, struct inet6_dev *idev)
 	err = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_if_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -4203,7 +4203,7 @@ static void inet6_prefix_notify(int event, struct inet6_dev *idev,
 	err = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet6_prefix_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -4856,7 +4856,7 @@ void addrconf_cleanup(void)
 	 */
 	spin_lock_bh(&addrconf_hash_lock);
 	for (i = 0; i < IN6_ADDR_HSIZE; i++)
-		WARN_ON(!hlist_empty(&inet6_addr_lst[i]));
+		(void)WARN_ON(!hlist_empty(&inet6_addr_lst[i]));
 	spin_unlock_bh(&addrconf_hash_lock);
 
 	del_timer(&addr_chk_timer);
diff --git a/net/ipv6/addrlabel.c b/net/ipv6/addrlabel.c
index 2d8ddba..fe83185 100644
--- a/net/ipv6/addrlabel.c
+++ b/net/ipv6/addrlabel.c
@@ -580,7 +580,7 @@ static int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr* nlh,
 	ip6addrlbl_put(p);
 
 	if (err < 0) {
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto out;
 	}
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 273f48d..dddbef5 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -169,7 +169,7 @@ lookup_protocol:
 	answer_flags = answer->flags;
 	rcu_read_unlock();
 
-	WARN_ON(answer_prot->slab == NULL);
+	(void)WARN_ON(answer_prot->slab == NULL);
 
 	err = -ENOBUFS;
 	sk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot);
@@ -658,7 +658,7 @@ int inet6_sk_rebuild_header(struct sock *sk)
 		struct in6_addr *final_p, final;
 		struct flowi6 fl6;
 
-		memset(&fl6, 0, sizeof(fl6));
+		(void)memset(&fl6, 0, sizeof(fl6));
 		fl6.flowi6_proto = sk->sk_protocol;
 		fl6.daddr = np->daddr;
 		fl6.saddr = np->saddr;
diff --git a/net/ipv6/ah6.c b/net/ipv6/ah6.c
index 2ae79db..5e3e80c 100644
--- a/net/ipv6/ah6.c
+++ b/net/ipv6/ah6.c
@@ -135,7 +135,7 @@ static int zero_out_mutable_opts(struct ipv6_opt_hdr *opthdr)
 			if (len < optlen)
 				goto bad;
 			if (opt[off] & 0x20)
-				memset(&opt[off+2], 0, opt[off+1]);
+				(void)memset(&opt[off+2], 0, opt[off+1]);
 			break;
 		}
 
@@ -368,7 +368,7 @@ static int ah6_output(struct xfrm_state *x, struct sk_buff *skb)
 	sg = ah_req_sg(ahash, req);
 
 	ah = ip_auth_hdr(skb);
-	memset(ah->auth_data, 0, ahp->icv_trunc_len);
+	(void)memset(ah->auth_data, 0, ahp->icv_trunc_len);
 
 	top_iph = ipv6_hdr(skb);
 	top_iph->payload_len = htons(skb->len - sizeof(*top_iph));
@@ -557,7 +557,7 @@ static int ah6_input(struct xfrm_state *x, struct sk_buff *skb)
 
 	memcpy(work_iph, ip6h, hdr_len);
 	memcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);
-	memset(ah->auth_data, 0, ahp->icv_trunc_len);
+	(void)memset(ah->auth_data, 0, ahp->icv_trunc_len);
 
 	if (ipv6_clear_mutable_options(ip6h, hdr_len, XFRM_POLICY_IN))
 		goto out_free;
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 251e7cd..0d38050 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -64,7 +64,7 @@ int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	if (usin->sin6_family != AF_INET6)
 		return -EAFNOSUPPORT;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	if (np->sndflow) {
 		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
 		if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.c
index 1ac7938..e248cd8 100644
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@ -212,7 +212,7 @@ static int esp6_output(struct xfrm_state *x, struct sk_buff *skb)
 	/* Fill padding... */
 	tail = skb_tail_pointer(trailer);
 	if (tfclen) {
-		memset(tail, 0, tfclen);
+		(void)memset(tail, 0, tfclen);
 		tail += tfclen;
 	}
 	do {
diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
index 3d641b6..e101366 100644
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -811,7 +811,7 @@ ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,
 	if (!opt2)
 		return ERR_PTR(-ENOBUFS);
 
-	memset(opt2, 0, tot_len);
+	(void)memset(opt2, 0, tot_len);
 
 	opt2->tot_len = tot_len;
 	p = (char *)(opt2 + 1);
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index 01d46bf..581bc64 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -443,7 +443,7 @@ void icmpv6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info)
 
 	mip6_addr_swap(skb);
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_ICMPV6;
 	fl6.daddr = hdr->saddr;
 	if (saddr)
@@ -537,7 +537,7 @@ static void icmpv6_echo_reply(struct sk_buff *skb)
 	memcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));
 	tmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_ICMPV6;
 	fl6.daddr = ipv6_hdr(skb)->saddr;
 	if (saddr)
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index 02dd203..5924cef 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -63,7 +63,7 @@ struct dst_entry *inet6_csk_route_req(struct sock *sk,
 	struct dst_entry *dst;
 	struct flowi6 fl6;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_TCP;
 	fl6.daddr = treq->rmt_addr;
 	final_p = fl6_update_dst(&fl6, np->opt, &final);
@@ -124,7 +124,7 @@ struct request_sock *inet6_csk_search_req(const struct sock *sk,
 		    ipv6_addr_equal(&treq->rmt_addr, raddr) &&
 		    ipv6_addr_equal(&treq->loc_addr, laddr) &&
 		    (!treq->iif || treq->iif == iif)) {
-			WARN_ON(req->sk != NULL);
+			(void)WARN_ON(req->sk != NULL);
 			*prevp = prev;
 			return req;
 		}
@@ -213,7 +213,7 @@ int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)
 	struct in6_addr *final_p, final;
 	int res;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = sk->sk_protocol;
 	fl6.daddr = np->daddr;
 	fl6.saddr = np->saddr;
diff --git a/net/ipv6/inet6_hashtables.c b/net/ipv6/inet6_hashtables.c
index 73f1a00..615b7b1 100644
--- a/net/ipv6/inet6_hashtables.c
+++ b/net/ipv6/inet6_hashtables.c
@@ -28,7 +28,7 @@ int __inet6_hash(struct sock *sk, struct inet_timewait_sock *tw)
 	struct inet_hashinfo *hashinfo = sk->sk_prot->h.hashinfo;
 	int twrefcnt = 0;
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	if (sk->sk_state == TCP_LISTEN) {
 		struct inet_listen_hashbucket *ilb;
@@ -48,7 +48,7 @@ int __inet6_hash(struct sock *sk, struct inet_timewait_sock *tw)
 		spin_lock(lock);
 		__sk_nulls_add_node_rcu(sk, list);
 		if (tw) {
-			WARN_ON(sk->sk_hash != tw->tw_hash);
+			(void)WARN_ON(sk->sk_hash != tw->tw_hash);
 			twrefcnt = inet_twsk_unhash(tw);
 		}
 		spin_unlock(lock);
@@ -259,7 +259,7 @@ unique:
 	inet->inet_num = lport;
 	inet->inet_sport = htons(lport);
 	sk->sk_hash = hash;
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	__sk_nulls_add_node_rcu(sk, &head->chain);
 	if (tw) {
 		twrefcnt = inet_twsk_unhash(tw);
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index b82bcde..d02c7f8 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -281,7 +281,7 @@ static int fib6_dump_node(struct fib6_walker_t *w)
 			w->leaf = rt;
 			return 1;
 		}
-		WARN_ON(res == 0);
+		(void)WARN_ON(res == 0);
 	}
 	w->leaf = NULL;
 	return 0;
@@ -875,7 +875,7 @@ out:
 			pn->leaf = fib6_find_prefix(info->nl_net, pn);
 #if RT6_DEBUG >= 2
 			if (!pn->leaf) {
-				WARN_ON(pn->leaf == NULL);
+				(void)WARN_ON(pn->leaf == NULL);
 				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
 			}
 #endif
@@ -1037,7 +1037,7 @@ struct fib6_node * fib6_locate(struct fib6_node *root,
 
 #ifdef CONFIG_IPV6_SUBTREES
 	if (src_len) {
-		WARN_ON(saddr == NULL);
+		(void)WARN_ON(saddr == NULL);
 		if (fn && fn->subtree)
 			fn = fib6_locate_1(fn->subtree, saddr, src_len,
 					   offsetof(struct rt6_info, rt6i_src));
@@ -1090,9 +1090,9 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 		RT6_TRACE("fixing tree: plen=%d iter=%d\n", fn->fn_bit, iter);
 		iter++;
 
-		WARN_ON(fn->fn_flags & RTN_RTINFO);
-		WARN_ON(fn->fn_flags & RTN_TL_ROOT);
-		WARN_ON(fn->leaf != NULL);
+		(void)WARN_ON(fn->fn_flags & RTN_RTINFO);
+		(void)WARN_ON(fn->fn_flags & RTN_TL_ROOT);
+		(void)WARN_ON(fn->leaf != NULL);
 
 		children = 0;
 		child = NULL;
@@ -1119,17 +1119,17 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 		pn = fn->parent;
 #ifdef CONFIG_IPV6_SUBTREES
 		if (FIB6_SUBTREE(pn) == fn) {
-			WARN_ON(!(fn->fn_flags & RTN_ROOT));
+			(void)WARN_ON(!(fn->fn_flags & RTN_ROOT));
 			FIB6_SUBTREE(pn) = NULL;
 			nstate = FWS_L;
 		} else {
-			WARN_ON(fn->fn_flags & RTN_ROOT);
+			(void)WARN_ON(fn->fn_flags & RTN_ROOT);
 #endif
 			if (pn->right == fn) pn->right = child;
 			else if (pn->left == fn) pn->left = child;
 #if RT6_DEBUG >= 2
 			else
-				WARN_ON(1);
+				(void)WARN_ON(1);
 #endif
 			if (child)
 				child->parent = pn;
@@ -1370,7 +1370,7 @@ static int fib6_walk_continue(struct fib6_walker_t *w)
 			w->node = pn;
 #ifdef CONFIG_IPV6_SUBTREES
 			if (FIB6_SUBTREE(pn) == fn) {
-				WARN_ON(!(fn->fn_flags & RTN_ROOT));
+				(void)WARN_ON(!(fn->fn_flags & RTN_ROOT));
 				w->state = FWS_L;
 				continue;
 			}
@@ -1385,7 +1385,7 @@ static int fib6_walk_continue(struct fib6_walker_t *w)
 				continue;
 			}
 #if RT6_DEBUG >= 2
-			WARN_ON(1);
+			(void)WARN_ON(1);
 #endif
 		}
 	}
@@ -1427,7 +1427,7 @@ static int fib6_clean_node(struct fib6_walker_t *w)
 			}
 			return 0;
 		}
-		WARN_ON(res != 0);
+		(void)WARN_ON(res != 0);
 	}
 	w->leaf = rt;
 	return 0;
diff --git a/net/ipv6/ip6_flowlabel.c b/net/ipv6/ip6_flowlabel.c
index b7867a1..72b7e1c 100644
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -351,7 +351,7 @@ fl_create(struct net *net, struct sock *sk, struct in6_flowlabel_req *freq,
 		if (fl->opt == NULL)
 			goto done;
 
-		memset(fl->opt, 0, sizeof(*fl->opt));
+		(void)memset(fl->opt, 0, sizeof(*fl->opt));
 		fl->opt->tot_len = sizeof(*fl->opt) + olen;
 		err = -EFAULT;
 		if (copy_from_user(fl->opt+1, optval+CMSG_ALIGN(sizeof(*freq)), olen))
@@ -359,7 +359,7 @@ fl_create(struct net *net, struct sock *sk, struct in6_flowlabel_req *freq,
 
 		msg.msg_controllen = olen;
 		msg.msg_control = (void*)(fl->opt+1);
-		memset(&flowi6, 0, sizeof(flowi6));
+		(void)memset(&flowi6, 0, sizeof(flowi6));
 
 		err = datagram_send_ctl(net, sk, &msg, &flowi6, fl->opt, &junk,
 					&junk, &junk);
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 1ca5d45..49bbcf0 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -79,7 +79,7 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 		goto drop;
 	}
 
-	memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
+	(void)memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
 
 	/*
 	 * Store incoming device index. When the packet will
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index d97e071..5b3b433 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -90,7 +90,7 @@ static int ip6_dev_loopback_xmit(struct sk_buff *newskb)
 	__skb_pull(newskb, skb_network_offset(newskb));
 	newskb->pkt_type = PACKET_LOOPBACK;
 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
-	WARN_ON(!skb_dst(newskb));
+	(void)WARN_ON(!skb_dst(newskb));
 
 	netif_rx_ni(newskb);
 	return 0;
@@ -1004,7 +1004,7 @@ static int ip6_dst_lookup_tail(struct sock *sk,
 			 */
 			dst_release(*dst);
 			memcpy(&fl_gw6, fl6, sizeof(struct flowi6));
-			memset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));
+			(void)memset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));
 			*dst = ip6_route_output(net, sk, &fl_gw6);
 			if ((err = (*dst)->error))
 				goto out_err_release;
@@ -1553,7 +1553,7 @@ static void ip6_cork_release(struct inet_sock *inet, struct ipv6_pinfo *np)
 		inet->cork.base.dst = NULL;
 		inet->cork.base.flags &= ~IPCORK_ALLFRAG;
 	}
-	memset(&inet->cork.fl, 0, sizeof(inet->cork.fl));
+	(void)memset(&inet->cork.fl, 0, sizeof(inet->cork.fl));
 }
 
 int ip6_push_pending_frames(struct sock *sk)
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index aa21da6..d99ed1a 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -757,7 +757,7 @@ static int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,
 		skb_reset_network_header(skb);
 		skb->protocol = htons(protocol);
 		skb->pkt_type = PACKET_HOST;
-		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
+		(void)memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
 
 		tstats = this_cpu_ptr(t->dev->tstats);
 		tstats->rx_packets++;
@@ -799,7 +799,7 @@ struct ipv6_tel_txoption {
 
 static void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)
 {
-	memset(opt, 0, sizeof(struct ipv6_tel_txoption));
+	(void)memset(opt, 0, sizeof(struct ipv6_tel_txoption));
 
 	opt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;
 	opt->dst_opt[3] = 1;
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index 18a2719..976f7bb 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -447,7 +447,7 @@ sticky_done:
 		struct flowi6 fl6;
 		int junk;
 
-		memset(&fl6, 0, sizeof(fl6));
+		(void)memset(&fl6, 0, sizeof(fl6));
 		fl6.flowi6_oif = sk->sk_bound_dev_if;
 		fl6.flowi6_mark = sk->sk_mark;
 
@@ -466,7 +466,7 @@ sticky_done:
 		if (opt == NULL)
 			break;
 
-		memset(opt, 0, sizeof(*opt));
+		(void)memset(opt, 0, sizeof(*opt));
 		opt->tot_len = sizeof(*opt) + optlen;
 		retv = -EFAULT;
 		if (copy_from_user(opt+1, optval, optlen))
@@ -1102,7 +1102,7 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
 			return -EINVAL;
 
 		len = sizeof(mtuinfo);
-		memset(&mtuinfo, 0, sizeof(mtuinfo));
+		(void)memset(&mtuinfo, 0, sizeof(mtuinfo));
 
 		rcu_read_lock();
 		dst = __sk_dst_get(sk);
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index b853f06..dc70820 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -594,7 +594,7 @@ int ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,
 		struct sockaddr_storage ss;
 
 		psin6 = (struct sockaddr_in6 *)&ss;
-		memset(&ss, 0, sizeof(ss));
+		(void)memset(&ss, 0, sizeof(ss));
 		psin6->sin6_family = AF_INET6;
 		psin6->sin6_addr = psl->sl_addr[i];
 		if (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))
@@ -1767,7 +1767,7 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 	memcpy(skb_put(skb, sizeof(ra)), ra, sizeof(ra));
 
 	hdr = (struct mld_msg *) skb_put(skb, sizeof(struct mld_msg));
-	memset(hdr, 0, sizeof(struct mld_msg));
+	(void)memset(hdr, 0, sizeof(struct mld_msg));
 	hdr->mld_type = type;
 	hdr->mld_mca = *addr;
 
diff --git a/net/ipv6/mip6.c b/net/ipv6/mip6.c
index 7e1e0fb..165b2e1 100644
--- a/net/ipv6/mip6.c
+++ b/net/ipv6/mip6.c
@@ -49,7 +49,7 @@ static inline void *mip6_padn(__u8 *data, __u8 padlen)
 		data[0] = IPV6_TLV_PADN;
 		data[1] = padlen - 2;
 		if (padlen > 2)
-			memset(data+2, 0, data[1]);
+			(void)memset(data+2, 0, data[1]);
 	}
 	return data + padlen;
 }
@@ -174,7 +174,7 @@ static int mip6_destopt_output(struct xfrm_state *x, struct sk_buff *skb)
 	memcpy(&iph->saddr, x->coaddr, sizeof(iph->saddr));
 	spin_unlock_bh(&x->lock);
 
-	WARN_ON(len != x->props.header_len);
+	(void)WARN_ON(len != x->props.header_len);
 	dstopt->hdrlen = (x->props.header_len >> 3) - 1;
 
 	return 0;
@@ -233,7 +233,7 @@ static int mip6_destopt_reject(struct xfrm_state *x, struct sk_buff *skb,
 				  opt->iif))
 		goto out;
 
-	memset(&sel, 0, sizeof(sel));
+	(void)memset(&sel, 0, sizeof(sel));
 	memcpy(&sel.daddr, (xfrm_address_t *)&ipv6_hdr(skb)->daddr,
 	       sizeof(sel.daddr));
 	sel.prefixlen_d = 128;
@@ -320,7 +320,7 @@ static int mip6_destopt_init_state(struct xfrm_state *x)
 	x->props.header_len = sizeof(struct ipv6_destopt_hdr) +
 		calc_padlen(sizeof(struct ipv6_destopt_hdr), 6) +
 		sizeof(struct ipv6_destopt_hao);
-	WARN_ON(x->props.header_len != 24);
+	(void)WARN_ON(x->props.header_len != 24);
 
 	return 0;
 }
@@ -382,9 +382,9 @@ static int mip6_rthdr_output(struct xfrm_state *x, struct sk_buff *skb)
 	rt2->rt_hdr.hdrlen = (x->props.header_len >> 3) - 1;
 	rt2->rt_hdr.type = IPV6_SRCRT_TYPE_2;
 	rt2->rt_hdr.segments_left = 1;
-	memset(&rt2->reserved, 0, sizeof(rt2->reserved));
+	(void)memset(&rt2->reserved, 0, sizeof(rt2->reserved));
 
-	WARN_ON(rt2->rt_hdr.hdrlen != 2);
+	(void)WARN_ON(rt2->rt_hdr.hdrlen != 2);
 
 	memcpy(&rt2->addr, &iph->daddr, sizeof(rt2->addr));
 	spin_lock_bh(&x->lock);
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index d8f02ef..0ad7076 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -201,7 +201,7 @@ static u8 *ndisc_fill_addr_option(u8 *opt, int type, void *data, int data_len,
 	opt[0] = type;
 	opt[1] = space>>3;
 
-	memset(opt + 2, 0, pad);
+	(void)memset(opt + 2, 0, pad);
 	opt   += pad;
 	space -= pad;
 
@@ -209,7 +209,7 @@ static u8 *ndisc_fill_addr_option(u8 *opt, int type, void *data, int data_len,
 	data_len += 2;
 	opt += data_len;
 	if ((space -= data_len) > 0)
-		memset(opt, 0, space);
+		(void)memset(opt, 0, space);
 	return opt + space;
 }
 
@@ -249,7 +249,7 @@ static struct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,
 
 	if (!nd_opt || opt_len < 0 || !ndopts)
 		return NULL;
-	memset(ndopts, 0, sizeof(*ndopts));
+	(void)memset(ndopts, 0, sizeof(*ndopts));
 	while (opt_len) {
 		int l;
 		if (opt_len < sizeof(struct nd_opt_hdr))
@@ -1601,7 +1601,7 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
 	skb_put(buff, len);
 	icmph = icmp6_hdr(buff);
 
-	memset(icmph, 0, sizeof(struct icmp6hdr));
+	(void)memset(icmph, 0, sizeof(struct icmp6hdr));
 	icmph->icmp6_type = NDISC_REDIRECT;
 
 	/*
@@ -1627,7 +1627,7 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
 	 *	build redirect option and copy skb over to the new packet.
 	 */
 
-	memset(opt, 0, 8);
+	(void)memset(opt, 0, 8);
 	*(opt++) = ND_OPT_REDIRECT_HDR;
 	*(opt++) = (rd_len >> 3);
 	opt += 6;
@@ -1687,7 +1687,7 @@ int ndisc_rcv(struct sk_buff *skb)
 		return 0;
 	}
 
-	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
+	(void)memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
 	switch (msg->icmph.icmp6_type) {
 	case NDISC_NEIGHBOUR_SOLICITATION:
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 94874b0..4964c53 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -1125,7 +1125,7 @@ static int get_info(struct net *net, void __user *user,
 			private = &tmp;
 		}
 #endif
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		info.valid_hooks = t->valid_hooks;
 		memcpy(info.hook_entry, private->hook_entry,
 		       sizeof(info.hook_entry));
@@ -2063,7 +2063,7 @@ do_ip6t_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 		else
 			target = 0;
 
-		try_then_request_module(xt_find_revision(AF_INET6, rev.name,
+		(void)try_then_request_module(xt_find_revision(AF_INET6, rev.name,
 							 rev.revision,
 							 target, &ret),
 					"ip6t_%s", rev.name);
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 38f00b0..152bbc8 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -344,8 +344,8 @@ nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)
 
 	fq_kill(fq);
 
-	WARN_ON(head == NULL);
-	WARN_ON(NFCT_FRAG6_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(NFCT_FRAG6_CB(head)->offset != 0);
 
 	/* Unfragmented part is taken from the first segment. */
 	payload_len = ((head->data - skb_network_header(head)) -
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index d02f7e4..534132a 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -758,7 +758,7 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 	/*
 	 *	Get and verify the address.
 	 */
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	fl6.flowi6_mark = sk->sk_mark;
 
@@ -817,7 +817,7 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 
 	if (msg->msg_controllen) {
 		opt = &opt_space;
-		memset(opt, 0, sizeof(struct ipv6_txoptions));
+		(void)memset(opt, 0, sizeof(struct ipv6_txoptions));
 		opt->tot_len = sizeof(struct ipv6_txoptions);
 
 		err = datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index b69fae7..9faff89 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -438,8 +438,8 @@ static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,
 		fq->q.fragments = head;
 	}
 
-	WARN_ON(head == NULL);
-	WARN_ON(FRAG6_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(FRAG6_CB(head)->offset != 0);
 
 	/* Unfragmented part is taken from the first segment. */
 	payload_len = ((head->data - skb_network_header(head)) -
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 8c2e3ab..b610057 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -919,7 +919,7 @@ struct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_ori
 
 	rt = dst_alloc(&ip6_dst_blackhole_ops, ort->dst.dev, 1, 0, 0);
 	if (rt) {
-		memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
+		(void)memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
 
 		new = &rt->dst;
 
@@ -1948,7 +1948,7 @@ static void rtmsg_to_fib6_config(struct net *net,
 				 struct in6_rtmsg *rtmsg,
 				 struct fib6_config *cfg)
 {
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	cfg->fc_table = RT6_TABLE_MAIN;
 	cfg->fc_ifindex = rtmsg->rtmsg_ifindex;
@@ -2256,7 +2256,7 @@ static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	err = -EINVAL;
 	rtm = nlmsg_data(nlh);
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	cfg->fc_table = rtm->rtm_table;
 	cfg->fc_dst_len = rtm->rtm_dst_len;
@@ -2527,7 +2527,7 @@ static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void
 		goto errout;
 
 	err = -EINVAL;
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (tb[RTA_SRC]) {
 		if (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))
@@ -2604,7 +2604,7 @@ void inet6_rt_notify(int event, struct rt6_info *rt, struct nl_info *info)
 				event, info->pid, seq, 0, 0, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 133768e..5a10e7c 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -808,7 +808,7 @@ static netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,
 	skb->transport_header = skb->network_header;
 	skb_push(skb, sizeof(struct iphdr));
 	skb_reset_network_header(skb);
-	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
+	(void)memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
 	IPCB(skb)->flags = 0;
 	skb_dst_drop(skb);
 	skb_dst_set(skb, &rt->dst);
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 906c7ca..0c3130c 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -144,7 +144,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 	if (usin->sin6_family != AF_INET6)
 		return -EAFNOSUPPORT;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (np->sndflow) {
 		fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
@@ -396,7 +396,7 @@ static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 			   to handle rthdr case. Ignore this complexity
 			   for now.
 			 */
-			memset(&fl6, 0, sizeof(fl6));
+			(void)memset(&fl6, 0, sizeof(fl6));
 			fl6.flowi6_proto = IPPROTO_TCP;
 			fl6.daddr = np->daddr;
 			fl6.saddr = np->saddr;
@@ -440,7 +440,7 @@ static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		/* ICMPs are not backlogged, hence we cannot get
 		 * an established socket here.
 		 */
-		WARN_ON(req->sk != NULL);
+		(void)WARN_ON(req->sk != NULL);
 
 		if (seq != tcp_rsk(req)->snt_isn) {
 			NET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -487,7 +487,7 @@ static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,
 	struct dst_entry *dst;
 	int err;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_TCP;
 	fl6.daddr = treq->rmt_addr;
 	fl6.saddr = treq->loc_addr;
@@ -1008,7 +1008,7 @@ static void tcp_v6_send_response(struct sk_buff *skb, u32 seq, u32 ack, u32 win,
 	skb_reset_transport_header(buff);
 
 	/* Swap the send and the receive. */
-	memset(t1, 0, sizeof(*t1));
+	(void)memset(t1, 0, sizeof(*t1));
 	t1->dest = th->source;
 	t1->source = th->dest;
 	t1->doff = tot_len / 4;
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 4f96b5c..b2866fd 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1039,7 +1039,7 @@ do_udp_sendmsg:
 	}
 	ulen += sizeof(struct udphdr);
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 
 	if (sin6) {
 		if (sin6->sin6_port == 0)
@@ -1090,7 +1090,7 @@ do_udp_sendmsg:
 
 	if (msg->msg_controllen) {
 		opt = &opt_space;
-		memset(opt, 0, sizeof(struct ipv6_txoptions));
+		(void)memset(opt, 0, sizeof(struct ipv6_txoptions));
 		opt->tot_len = sizeof(*opt);
 
 		err = datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
diff --git a/net/ipv6/xfrm6_mode_beet.c b/net/ipv6/xfrm6_mode_beet.c
index a81ce94..1cbd888 100644
--- a/net/ipv6/xfrm6_mode_beet.c
+++ b/net/ipv6/xfrm6_mode_beet.c
@@ -67,7 +67,7 @@ static int xfrm6_beet_output(struct xfrm_state *x, struct sk_buff *skb)
 		ph->hdrlen = optlen / 8;
 		ph->nexthdr = top_iph->nexthdr;
 		if (ph->padlen)
-			memset(ph + 1, IPOPT_NOP, ph->padlen);
+			(void)memset(ph + 1, IPOPT_NOP, ph->padlen);
 
 		top_iph->nexthdr = IPPROTO_BEETPH;
 	}
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index 4eeff89..cb38420 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -110,7 +110,7 @@ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err)
 		return err;
 
-	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+	(void)memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
 #ifdef CONFIG_NETFILTER
 	IP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;
 #endif
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 8ea65e0..9cfcd43 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -34,7 +34,7 @@ static struct dst_entry *xfrm6_dst_lookup(struct net *net, int tos,
 	struct dst_entry *dst;
 	int err;
 
-	memset(&fl6, 0, sizeof(fl6));
+	(void)memset(&fl6, 0, sizeof(fl6));
 	memcpy(&fl6.daddr, daddr, sizeof(fl6.daddr));
 	if (saddr)
 		memcpy(&fl6.saddr, saddr, sizeof(fl6.saddr));
@@ -129,7 +129,7 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 	const unsigned char *nh = skb_network_header(skb);
 	u8 nexthdr = nh[IP6CB(skb)->nhoff];
 
-	memset(fl6, 0, sizeof(struct flowi6));
+	(void)memset(fl6, 0, sizeof(struct flowi6));
 	fl6->flowi6_mark = skb->mark;
 
 	fl6->daddr = reverse ? hdr->saddr : hdr->daddr;
diff --git a/net/ipv6/xfrm6_state.c b/net/ipv6/xfrm6_state.c
index 3f2f7c4..7d7a3d4 100644
--- a/net/ipv6/xfrm6_state.c
+++ b/net/ipv6/xfrm6_state.c
@@ -63,7 +63,7 @@ __xfrm6_sort(void **dst, void **src, int n, int (*cmp)(void *p), int maxclass)
 	int class[XFRM_MAX_DEPTH];
 	int count[maxclass];
 
-	memset(count, 0, sizeof(count));
+	(void)memset(count, 0, sizeof(count));
 
 	for (i = 0; i < n; i++) {
 		int c;
diff --git a/net/netfilter/nf_conntrack_amanda.c b/net/netfilter/nf_conntrack_amanda.c
index 13fd2c5..7d7c3b0 100644
--- a/net/netfilter/nf_conntrack_amanda.c
+++ b/net/netfilter/nf_conntrack_amanda.c
@@ -112,14 +112,14 @@ static int amanda_help(struct sk_buff *skb,
 		return NF_ACCEPT;
 	}
 
-	memset(&ts, 0, sizeof(ts));
+	(void)memset(&ts, 0, sizeof(ts));
 	start = skb_find_text(skb, dataoff, skb->len,
 			      search[SEARCH_CONNECT].ts, &ts);
 	if (start == UINT_MAX)
 		goto out;
 	start += dataoff + search[SEARCH_CONNECT].len;
 
-	memset(&ts, 0, sizeof(ts));
+	(void)memset(&ts, 0, sizeof(ts));
 	stop = skb_find_text(skb, start, skb->len,
 			     search[SEARCH_NEWLINE].ts, &ts);
 	if (stop == UINT_MAX)
@@ -127,7 +127,7 @@ static int amanda_help(struct sk_buff *skb,
 	stop += start;
 
 	for (i = SEARCH_DATA; i <= SEARCH_INDEX; i++) {
-		memset(&ts, 0, sizeof(ts));
+		(void)memset(&ts, 0, sizeof(ts));
 		off = skb_find_text(skb, start, stop, search[i].ts, &ts);
 		if (off == UINT_MAX)
 			continue;
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 76613f5..d8aa039 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -115,7 +115,7 @@ nf_ct_get_tuple(const struct sk_buff *skb,
 		const struct nf_conntrack_l3proto *l3proto,
 		const struct nf_conntrack_l4proto *l4proto)
 {
-	memset(tuple, 0, sizeof(*tuple));
+	(void)memset(tuple, 0, sizeof(*tuple));
 
 	tuple->src.l3num = l3num;
 	if (l3proto->pkt_to_tuple(skb, nhoff, tuple) == 0)
@@ -162,7 +162,7 @@ nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
 		   const struct nf_conntrack_l3proto *l3proto,
 		   const struct nf_conntrack_l4proto *l4proto)
 {
-	memset(inverse, 0, sizeof(*inverse));
+	(void)memset(inverse, 0, sizeof(*inverse));
 
 	inverse->src.l3num = orig->src.l3num;
 	if (l3proto->invert_tuple(inverse, orig) == 0)
@@ -624,7 +624,7 @@ void init_nf_conntrack_hash_rnd(void)
 	do {
 		get_random_bytes(&rand, sizeof(rand));
 	} while (!rand);
-	cmpxchg(&nf_conntrack_hash_rnd, 0, rand);
+	(void)cmpxchg(&nf_conntrack_hash_rnd, 0, rand);
 }
 
 static struct nf_conn *
@@ -669,7 +669,7 @@ __nf_conntrack_alloc(struct net *net, u16 zone,
 	 * Let ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.next
 	 * and ct->tuplehash[IP_CT_DIR_REPLY].hnnode.next unchanged.
 	 */
-	memset(&ct->tuplehash[IP_CT_DIR_MAX], 0,
+	(void)memset(&ct->tuplehash[IP_CT_DIR_MAX], 0,
 	       offsetof(struct nf_conn, proto) -
 	       offsetof(struct nf_conn, tuplehash[IP_CT_DIR_MAX]));
 	spin_lock_init(&ct->lock);
diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c
index 4147ba3..dddb509 100644
--- a/net/netfilter/nf_conntrack_expect.c
+++ b/net/netfilter/nf_conntrack_expect.c
@@ -268,15 +268,15 @@ void nf_ct_expect_init(struct nf_conntrack_expect *exp, unsigned int class,
 		memcpy(&exp->tuple.src.u3, saddr, len);
 		if (sizeof(exp->tuple.src.u3) > len)
 			/* address needs to be cleared for nf_ct_tuple_equal */
-			memset((void *)&exp->tuple.src.u3 + len, 0x00,
+			(void)memset((void *)&exp->tuple.src.u3 + len, 0x00,
 			       sizeof(exp->tuple.src.u3) - len);
-		memset(&exp->mask.src.u3, 0xFF, len);
+		(void)memset(&exp->mask.src.u3, 0xFF, len);
 		if (sizeof(exp->mask.src.u3) > len)
-			memset((void *)&exp->mask.src.u3 + len, 0x00,
+			(void)memset((void *)&exp->mask.src.u3 + len, 0x00,
 			       sizeof(exp->mask.src.u3) - len);
 	} else {
-		memset(&exp->tuple.src.u3, 0x00, sizeof(exp->tuple.src.u3));
-		memset(&exp->mask.src.u3, 0x00, sizeof(exp->mask.src.u3));
+		(void)memset(&exp->tuple.src.u3, 0x00, sizeof(exp->tuple.src.u3));
+		(void)memset(&exp->mask.src.u3, 0x00, sizeof(exp->mask.src.u3));
 	}
 
 	if (src) {
@@ -290,7 +290,7 @@ void nf_ct_expect_init(struct nf_conntrack_expect *exp, unsigned int class,
 	memcpy(&exp->tuple.dst.u3, daddr, len);
 	if (sizeof(exp->tuple.dst.u3) > len)
 		/* address needs to be cleared for nf_ct_tuple_equal */
-		memset((void *)&exp->tuple.dst.u3 + len, 0x00,
+		(void)memset((void *)&exp->tuple.dst.u3 + len, 0x00,
 		       sizeof(exp->tuple.dst.u3) - len);
 
 	exp->tuple.dst.u.all = *dst;
diff --git a/net/netfilter/nf_conntrack_extend.c b/net/netfilter/nf_conntrack_extend.c
index 641ff5f..7bac0d9 100644
--- a/net/netfilter/nf_conntrack_extend.c
+++ b/net/netfilter/nf_conntrack_extend.c
@@ -114,7 +114,7 @@ void *__nf_ct_ext_add(struct nf_conn *ct, enum nf_ct_ext_id id, gfp_t gfp)
 
 	new->offset[id] = newoff;
 	new->len = newlen;
-	memset((void *)new + newoff, 0, newlen - newoff);
+	(void)memset((void *)new + newoff, 0, newlen - newoff);
 	return (void *)new + newoff;
 }
 EXPORT_SYMBOL(__nf_ct_ext_add);
diff --git a/net/netfilter/nf_conntrack_ftp.c b/net/netfilter/nf_conntrack_ftp.c
index 8c5c95c..18b0c63 100644
--- a/net/netfilter/nf_conntrack_ftp.c
+++ b/net/netfilter/nf_conntrack_ftp.c
@@ -119,7 +119,7 @@ static int try_number(const char *data, size_t dlen, u_int32_t array[],
 {
 	u_int32_t i, len;
 
-	memset(array, 0, sizeof(array[0])*array_size);
+	(void)memset(array, 0, sizeof(array[0])*array_size);
 
 	/* Keep data pointing at next char. */
 	for (i = 0, len = 0; len < dlen && i < array_size; len++, data++) {
diff --git a/net/netfilter/nf_conntrack_h323_main.c b/net/netfilter/nf_conntrack_h323_main.c
index 722291f..00418db 100644
--- a/net/netfilter/nf_conntrack_h323_main.c
+++ b/net/netfilter/nf_conntrack_h323_main.c
@@ -242,7 +242,7 @@ static int get_h245_addr(struct nf_conn *ct, const unsigned char *data,
 	}
 
 	memcpy(addr, p, len);
-	memset((void *)addr + len, 0, sizeof(*addr) - len);
+	(void)memset((void *)addr + len, 0, sizeof(*addr) - len);
 	memcpy(port, p + len, sizeof(__be16));
 
 	return 1;
@@ -651,7 +651,7 @@ int get_h225_addr(struct nf_conn *ct, unsigned char *data,
 	}
 
 	memcpy(addr, p, len);
-	memset((void *)addr + len, 0, sizeof(*addr) - len);
+	(void)memset((void *)addr + len, 0, sizeof(*addr) - len);
 	memcpy(port, p + len, sizeof(__be16));
 
 	return 1;
@@ -725,10 +725,10 @@ static int callforward_do_filter(const union nf_inet_addr *src,
 		struct flowi4 fl1, fl2;
 		struct rtable *rt1, *rt2;
 
-		memset(&fl1, 0, sizeof(fl1));
+		(void)memset(&fl1, 0, sizeof(fl1));
 		fl1.daddr = src->ip;
 
-		memset(&fl2, 0, sizeof(fl2));
+		(void)memset(&fl2, 0, sizeof(fl2));
 		fl2.daddr = dst->ip;
 		if (!afinfo->route(&init_net, (struct dst_entry **)&rt1,
 				   flowi4_to_flowi(&fl1), false)) {
@@ -1216,7 +1216,7 @@ static struct nf_conntrack_expect *find_expect(struct nf_conn *ct,
 	struct nf_conntrack_expect *exp;
 	struct nf_conntrack_tuple tuple;
 
-	memset(&tuple.src.u3, 0, sizeof(tuple.src.u3));
+	(void)memset(&tuple.src.u3, 0, sizeof(tuple.src.u3));
 	tuple.src.u.tcp.port = 0;
 	memcpy(&tuple.dst.u3, addr, sizeof(tuple.dst.u3));
 	tuple.dst.u.tcp.port = port;
diff --git a/net/netfilter/nf_conntrack_helper.c b/net/netfilter/nf_conntrack_helper.c
index bbe23ba..fefd7ab 100644
--- a/net/netfilter/nf_conntrack_helper.c
+++ b/net/netfilter/nf_conntrack_helper.c
@@ -142,7 +142,7 @@ int __nf_ct_try_assign_helper(struct nf_conn *ct, struct nf_conn *tmpl,
 			goto out;
 		}
 	} else {
-		memset(&help->help, 0, sizeof(help->help));
+		(void)memset(&help->help, 0, sizeof(help->help));
 	}
 
 	rcu_assign_pointer(help->helper, helper);
diff --git a/net/netfilter/nf_conntrack_l3proto_generic.c b/net/netfilter/nf_conntrack_l3proto_generic.c
index e7eb807..3e233dc 100644
--- a/net/netfilter/nf_conntrack_l3proto_generic.c
+++ b/net/netfilter/nf_conntrack_l3proto_generic.c
@@ -34,8 +34,8 @@
 static bool generic_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 				 struct nf_conntrack_tuple *tuple)
 {
-	memset(&tuple->src.u3, 0, sizeof(tuple->src.u3));
-	memset(&tuple->dst.u3, 0, sizeof(tuple->dst.u3));
+	(void)memset(&tuple->src.u3, 0, sizeof(tuple->src.u3));
+	(void)memset(&tuple->dst.u3, 0, sizeof(tuple->dst.u3));
 
 	return true;
 }
@@ -43,8 +43,8 @@ static bool generic_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 static bool generic_invert_tuple(struct nf_conntrack_tuple *tuple,
 				 const struct nf_conntrack_tuple *orig)
 {
-	memset(&tuple->src.u3, 0, sizeof(tuple->src.u3));
-	memset(&tuple->dst.u3, 0, sizeof(tuple->dst.u3));
+	(void)memset(&tuple->src.u3, 0, sizeof(tuple->src.u3));
+	(void)memset(&tuple->dst.u3, 0, sizeof(tuple->dst.u3));
 
 	return true;
 }
diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 9307b03..639f93c 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -818,7 +818,7 @@ ctnetlink_parse_tuple(const struct nlattr * const cda[],
 	struct nlattr *tb[CTA_TUPLE_MAX+1];
 	int err;
 
-	memset(tuple, 0, sizeof(*tuple));
+	(void)memset(tuple, 0, sizeof(*tuple));
 
 	nla_parse_nested(tb, CTA_TUPLE_MAX, cda[type], tuple_nla_policy);
 
@@ -1166,7 +1166,7 @@ ctnetlink_change_helper(struct nf_conn *ct, const struct nlattr * const cda[])
 		if (help->helper)
 			return -EBUSY;
 		/* need to zero data of old helper */
-		memset(&help->help, 0, sizeof(help->help));
+		(void)memset(&help->help, 0, sizeof(help->help));
 	} else {
 		/* we cannot set a helper for an existing conntrack */
 		return -EOPNOTSUPP;
@@ -1433,7 +1433,7 @@ ctnetlink_create_conntrack(struct net *net, u16 zone,
 	}
 #endif
 
-	memset(&ct->proto, 0, sizeof(ct->proto));
+	(void)memset(&ct->proto, 0, sizeof(ct->proto));
 	if (cda[CTA_PROTOINFO]) {
 		err = ctnetlink_change_protoinfo(ct, cda);
 		if (err < 0)
@@ -1617,7 +1617,7 @@ ctnetlink_exp_dump_mask(struct sk_buff *skb,
 	struct nf_conntrack_tuple m;
 	struct nlattr *nest_parms;
 
-	memset(&m, 0xFF, sizeof(m));
+	(void)memset(&m, 0xFF, sizeof(m));
 	memcpy(&m.src.u3, &mask->src.u3, sizeof(m.src.u3));
 	m.src.u.all = mask->src.u.all;
 	m.dst.protonum = tuple->dst.protonum;
diff --git a/net/netfilter/nf_conntrack_proto_sctp.c b/net/netfilter/nf_conntrack_proto_sctp.c
index afa6913..0d41c2f 100644
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@ -413,7 +413,7 @@ static bool sctp_new(struct nf_conn *ct, const struct sk_buff *skb,
 	    test_bit(SCTP_CID_COOKIE_ACK, map))
 		return false;
 
-	memset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));
+	(void)memset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));
 	new_state = SCTP_CONNTRACK_MAX;
 	for_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {
 		/* Don't need lock here: this conntrack not in circulation yet */
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index 97b9f3e..ce3aa3e 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -912,7 +912,7 @@ static int tcp_packet(struct nf_conn *ct,
 				ct->proto.tcp.last_wscale;
 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].flags =
 				ct->proto.tcp.last_flags;
-			memset(&ct->proto.tcp.seen[dir], 0,
+			(void)memset(&ct->proto.tcp.seen[dir], 0,
 			       sizeof(struct ip_ct_tcp_state));
 			break;
 		}
@@ -1075,7 +1075,7 @@ static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 	}
 
 	if (new_state == TCP_CONNTRACK_SYN_SENT) {
-		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+		(void)memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
 		/* SYN packet */
 		ct->proto.tcp.seen[0].td_end =
 			segment_seq_plus_len(ntohl(th->seq), skb->len,
@@ -1091,7 +1091,7 @@ static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		/* Don't try to pick up connections. */
 		return false;
 	} else {
-		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+		(void)memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
 		/*
 		 * We are in the middle of a connection,
 		 * its history is lost for us.
diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c
index 93faf6a..293141a 100644
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@ -193,7 +193,7 @@ static int parse_addr(const struct nf_conn *ct, const char *cp,
 	if (!ct)
 		return 0;
 
-	memset(addr, 0, sizeof(*addr));
+	(void)memset(addr, 0, sizeof(*addr));
 	switch (nf_ct_l3num(ct)) {
 	case AF_INET:
 		ret = in4_pton(cp, limit - cp, (u8 *)&addr->ip, -1, &end);
@@ -546,7 +546,7 @@ int ct_sip_parse_header_uri(const struct nf_conn *ct, const char *dptr,
 
 	ret = ct_sip_walk_headers(ct, dptr, dataoff ? *dataoff : 0, datalen,
 				  type, in_header, matchoff, matchlen);
-	WARN_ON(ret < 0);
+	(void)WARN_ON(ret < 0);
 	if (ret == 0)
 		return ret;
 
@@ -869,7 +869,7 @@ static int set_expected_rtp_rtcp(struct sk_buff *skb, unsigned int dataoff,
 	 * outside, and additionally need to expect the direct RTP stream
 	 * in case it passes through us even without NAT.
 	 */
-	memset(&tuple, 0, sizeof(tuple));
+	(void)memset(&tuple, 0, sizeof(tuple));
 	if (saddr)
 		tuple.src.u3 = *saddr;
 	tuple.src.l3num		= nf_ct_l3num(ct);
@@ -1562,7 +1562,7 @@ static int __init nf_conntrack_sip_init(void)
 		ports[ports_c++] = SIP_PORT;
 
 	for (i = 0; i < ports_c; i++) {
-		memset(&sip[i], 0, sizeof(sip[i]));
+		(void)memset(&sip[i], 0, sizeof(sip[i]));
 
 		sip[i][0].tuple.src.l3num = AF_INET;
 		sip[i][0].tuple.dst.protonum = IPPROTO_UDP;
diff --git a/net/netfilter/nf_conntrack_tftp.c b/net/netfilter/nf_conntrack_tftp.c
index 75466fd..6bf5b5b 100644
--- a/net/netfilter/nf_conntrack_tftp.c
+++ b/net/netfilter/nf_conntrack_tftp.c
@@ -118,7 +118,7 @@ static int __init nf_conntrack_tftp_init(void)
 		ports[ports_c++] = TFTP_PORT;
 
 	for (i = 0; i < ports_c; i++) {
-		memset(&tftp[i], 0, sizeof(tftp[i]));
+		(void)memset(&tftp[i], 0, sizeof(tftp[i]));
 
 		tftp[i][0].tuple.src.l3num = AF_INET;
 		tftp[i][1].tuple.src.l3num = AF_INET6;
diff --git a/net/netfilter/xt_connlimit.c b/net/netfilter/xt_connlimit.c
index c6d5a83..5f12355 100644
--- a/net/netfilter/xt_connlimit.c
+++ b/net/netfilter/xt_connlimit.c
@@ -231,7 +231,7 @@ static int connlimit_mt_check(const struct xt_mtchk_param *par)
 		do {
 			get_random_bytes(&rand, sizeof(rand));
 		} while (!rand);
-		cmpxchg(&connlimit_rnd, 0, rand);
+		(void)cmpxchg(&connlimit_rnd, 0, rand);
 	}
 	ret = nf_ct_l3proto_try_module_get(par->family);
 	if (ret < 0) {
diff --git a/net/netfilter/xt_hashlimit.c b/net/netfilter/xt_hashlimit.c
index d95f9c9..5411a88 100644
--- a/net/netfilter/xt_hashlimit.c
+++ b/net/netfilter/xt_hashlimit.c
@@ -447,7 +447,7 @@ hashlimit_init_dst(const struct xt_hashlimit_htable *hinfo,
 	u8 nexthdr;
 	int poff;
 
-	memset(dst, 0, sizeof(*dst));
+	(void)memset(dst, 0, sizeof(*dst));
 
 	switch (hinfo->family) {
 	case NFPROTO_IPV4:
diff --git a/net/netfilter/xt_string.c b/net/netfilter/xt_string.c
index d3c48b1..c97b7ce 100644
--- a/net/netfilter/xt_string.c
+++ b/net/netfilter/xt_string.c
@@ -29,7 +29,7 @@ string_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	struct ts_state state;
 	bool invert;
 
-	memset(&state, 0, sizeof(struct ts_state));
+	(void)memset(&state, 0, sizeof(struct ts_state));
 	invert = conf->u.v1.flags & XT_STRING_FLAG_INVERT;
 
 	return (skb_find_text((struct sk_buff *)skb, conf->from_offset,
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 629b061..1514cd9 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -166,9 +166,9 @@ static void netlink_sock_destruct(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(nlk_sk(sk)->groups);
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(nlk_sk(sk)->groups);
 }
 
 /* This lock without WQ_FLAG_EXCLUSIVE is good on UP and it is _very_ bad on
@@ -618,7 +618,7 @@ static int netlink_realloc_groups(struct sock *sk)
 		err = -ENOMEM;
 		goto out_unlock;
 	}
-	memset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,
+	(void)memset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,
 	       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));
 
 	nlk->groups = new_groups;
@@ -1447,7 +1447,7 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
 		netlink_cmsg_recv_pktinfo(msg, skb);
 
 	if (NULL == siocb->scm) {
-		memset(&scm, 0, sizeof(scm));
+		(void)memset(&scm, 0, sizeof(scm));
 		siocb->scm = &scm;
 	}
 	siocb->scm->creds = *NETLINK_CREDS(skb);
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index c29d256..1da4edc 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -555,7 +555,7 @@ static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	info.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;
 	info.attrs = family->attrbuf;
 	genl_info_net_set(&info, net);
-	memset(&info.user_ptr, 0, sizeof(info.user_ptr));
+	(void)memset(&info.user_ptr, 0, sizeof(info.user_ptr));
 
 	if (family->pre_doit) {
 		err = family->pre_doit(ops, skb, &info);
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 2dbb32b..8f756c5 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -420,7 +420,7 @@ static void __packet_set_status(struct packet_sock *po, void *frame, int status)
 		break;
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 	}
 
@@ -447,7 +447,7 @@ static int __packet_get_status(struct packet_sock *po, void *frame)
 		return h.h2->tp_status;
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 		return 0;
 	}
@@ -588,7 +588,7 @@ static void init_prb_bdqc(struct packet_sock *po,
 	struct tpacket_kbdq_core *p1 = &rb->prb_bdqc;
 	struct tpacket_block_desc *pbd;
 
-	memset(p1, 0x0, sizeof(*p1));
+	(void)memset(p1, 0x0, sizeof(*p1));
 
 	p1->knxt_seq_num = 1;
 	p1->pkbdq = pg_vec;
@@ -840,7 +840,7 @@ static void prb_open_block(struct tpacket_kbdq_core *pkc1,
 		return;
 	}
 
-	WARN(1, "ERROR block:%p is NOT FREE status:%d kactive_blk_num:%d\n",
+	(void)WARN(1, "ERROR block:%p is NOT FREE status:%d kactive_blk_num:%d\n",
 		pbd1, BLOCK_STATUS(pbd1), pkc1->kactive_blk_num);
 	dump_stack();
 	BUG();
@@ -935,7 +935,7 @@ static void prb_retire_current_block(struct tpacket_kbdq_core *pkc,
 		return;
 	}
 
-	WARN(1, "ERROR-pbd[%d]:%p\n", pkc->kactive_blk_num, pbd);
+	(void)WARN(1, "ERROR-pbd[%d]:%p\n", pkc->kactive_blk_num, pbd);
 	dump_stack();
 	BUG();
 }
@@ -1085,7 +1085,7 @@ static void *packet_current_rx_frame(struct packet_sock *po,
 	case TPACKET_V3:
 		return __packet_lookup_frame_in_block(po, skb, status, len);
 	default:
-		WARN(1, "TPACKET version not supported\n");
+		(void)WARN(1, "TPACKET version not supported\n");
 		BUG();
 		return 0;
 	}
@@ -1142,7 +1142,7 @@ static void packet_increment_rx_head(struct packet_sock *po,
 		return packet_increment_head(rb);
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 		return;
 	}
@@ -1165,8 +1165,8 @@ static void packet_sock_destruct(struct sock *sk)
 {
 	skb_queue_purge(&sk->sk_error_queue);
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
 
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		pr_err("Attempt to release alive packet socket: %p\n", sk);
@@ -2419,7 +2419,7 @@ static int packet_release(struct socket *sock)
 
 	packet_flush_mclist(sk);
 
-	memset(&req_u, 0, sizeof(req_u));
+	(void)memset(&req_u, 0, sizeof(req_u));
 
 	if (po->rx_ring.pg_vec)
 		packet_set_ring(sk, &req_u, 1, 0);
@@ -2834,7 +2834,7 @@ static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,
 	if (dev)
 		strncpy(uaddr->sa_data, dev->name, 14);
 	else
-		memset(uaddr->sa_data, 0, 14);
+		(void)memset(uaddr->sa_data, 0, 14);
 	rcu_read_unlock();
 	*uaddr_len = sizeof(*uaddr);
 
@@ -3030,7 +3030,7 @@ packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv
 	{
 		struct packet_mreq_max mreq;
 		int len = optlen;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		if (len < sizeof(struct packet_mreq))
 			return -EINVAL;
 		if (len > sizeof(mreq))
@@ -3238,7 +3238,7 @@ static int packet_getsockopt(struct socket *sock, int level, int optname,
 			st.tp_packets += st.tp_drops;
 			data = &st;
 		}
-		memset(&po->stats, 0, sizeof(st));
+		(void)memset(&po->stats, 0, sizeof(st));
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
 		break;
 	case PACKET_AUXDATA:
@@ -3574,7 +3574,7 @@ static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
 
 	/* Opening a Tx-ring is NOT supported in TPACKET_V3 */
 	if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
-		WARN(1, "Tx-ring is not supported.\n");
+		(void)WARN(1, "Tx-ring is not supported.\n");
 		goto out;
 	}
 
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 93fdf13..4925e29 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -47,7 +47,7 @@ void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo)
 			return;
 		}
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 EXPORT_SYMBOL(tcf_hash_destroy);
 
@@ -158,7 +158,7 @@ int tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,
 	} else if (type == RTM_GETACTION) {
 		return tcf_dump_walker(skb, cb, a, hinfo);
 	} else {
-		WARN(1, "tcf_generic_walker: unknown action %d\n", type);
+		(void)WARN(1, "tcf_generic_walker: unknown action %d\n", type);
 		return -EINVAL;
 	}
 }
@@ -410,7 +410,7 @@ void tcf_action_destroy(struct tc_action *act, int bind)
 			kfree(a);
 		} else {
 			/*FIXME: Remove later - catch insertion bugs*/
-			WARN(1, "tcf_action_destroy: BUG? destroying NULL ops\n");
+			(void)WARN(1, "tcf_action_destroy: BUG? destroying NULL ops\n");
 			act = act->next;
 			kfree(a);
 		}
@@ -1071,11 +1071,11 @@ tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
 	if (a_o == NULL)
 		return 0;
 
-	memset(&a, 0, sizeof(struct tc_action));
+	(void)memset(&a, 0, sizeof(struct tc_action));
 	a.ops = a_o;
 
 	if (a_o->walk == NULL) {
-		WARN(1, "tc_dump_action: %s !capable of dumping table\n",
+		(void)WARN(1, "tc_dump_action: %s !capable of dumping table\n",
 		     a_o->kind);
 		goto nla_put_failure;
 	}
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index a69d44f..ee9c9b5 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -460,7 +460,7 @@ static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)
 		    TC_H_MIN(tcm->tcm_info) != tp->protocol)
 			continue;
 		if (t > s_t)
-			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
+			(void)memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
 		if (cb->args[1] == 0) {
 			if (tcf_fill_node(skb, tp, 0, NETLINK_CB(cb->skb).pid,
 					  cb->nlh->nlmsg_seq, NLM_F_MULTI,
@@ -507,7 +507,7 @@ int tcf_exts_validate(struct tcf_proto *tp, struct nlattr **tb,
 		  struct nlattr *rate_tlv, struct tcf_exts *exts,
 		  const struct tcf_ext_map *map)
 {
-	memset(exts, 0, sizeof(*exts));
+	(void)memset(exts, 0, sizeof(*exts));
 
 #ifdef CONFIG_NET_CLS_ACT
 	{
diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c
index 1d8bd0d..323bcfb0 100644
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@ -259,7 +259,7 @@ static u32 flow_key_get(struct sk_buff *skb, int key, struct flow_keys *flow)
 	case FLOW_KEY_RXHASH:
 		return flow_get_rxhash(skb);
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 }
diff --git a/net/sched/cls_tcindex.c b/net/sched/cls_tcindex.c
index dbe1992..f08e777 100644
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@ -213,12 +213,12 @@ tcindex_set_parms(struct tcf_proto *tp, unsigned long base, u32 handle,
 		return err;
 
 	memcpy(&cp, p, sizeof(cp));
-	memset(&new_filter_result, 0, sizeof(new_filter_result));
+	(void)memset(&new_filter_result, 0, sizeof(new_filter_result));
 
 	if (old_r)
 		memcpy(&cr, r, sizeof(cr));
 	else
-		memset(&cr, 0, sizeof(cr));
+		(void)memset(&cr, 0, sizeof(cr));
 
 	if (tb[TCA_TCINDEX_HASH])
 		cp.hash = nla_get_u32(tb[TCA_TCINDEX_HASH]);
@@ -302,7 +302,7 @@ tcindex_set_parms(struct tcf_proto *tp, unsigned long base, u32 handle,
 
 	tcf_tree_lock(tp);
 	if (old_r && old_r != r)
-		memset(old_r, 0, sizeof(*old_r));
+		(void)memset(old_r, 0, sizeof(*old_r));
 
 	memcpy(p, &cp, sizeof(cp));
 	memcpy(r, &cr, sizeof(cr));
diff --git a/net/sched/cls_u32.c b/net/sched/cls_u32.c
index 939b627..a9bae1f 100644
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@ -370,7 +370,7 @@ static int u32_delete_key(struct tcf_proto *tp, struct tc_u_knode* key)
 			}
 		}
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
@@ -393,7 +393,7 @@ static int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)
 	struct tc_u_common *tp_c = tp->data;
 	struct tc_u_hnode **hn;
 
-	WARN_ON(ht->refcnt);
+	(void)WARN_ON(ht->refcnt);
 
 	u32_clear_hnode(tp, ht);
 
@@ -405,7 +405,7 @@ static int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)
 		}
 	}
 
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -ENOENT;
 }
 
@@ -414,7 +414,7 @@ static void u32_destroy(struct tcf_proto *tp)
 	struct tc_u_common *tp_c = tp->data;
 	struct tc_u_hnode *root_ht = tp->root;
 
-	WARN_ON(root_ht == NULL);
+	(void)WARN_ON(root_ht == NULL);
 
 	if (root_ht && --root_ht->refcnt == 0)
 		u32_destroy_hnode(tp, root_ht);
@@ -432,7 +432,7 @@ static void u32_destroy(struct tcf_proto *tp)
 		while ((ht = tp_c->hlist) != NULL) {
 			tp_c->hlist = ht->next;
 
-			WARN_ON(ht->refcnt != 0);
+			(void)WARN_ON(ht->refcnt != 0);
 
 			kfree(ht);
 		}
diff --git a/net/sched/em_meta.c b/net/sched/em_meta.c
index 1363bf1..2c8c7f5 100644
--- a/net/sched/em_meta.c
+++ b/net/sched/em_meta.c
@@ -827,7 +827,7 @@ static int em_meta_dump(struct sk_buff *skb, struct tcf_ematch *em)
 	struct tcf_meta_hdr hdr;
 	struct meta_type_ops *ops;
 
-	memset(&hdr, 0, sizeof(hdr));
+	(void)memset(&hdr, 0, sizeof(hdr));
 	memcpy(&hdr.left, &meta->lvalue.hdr, sizeof(hdr.left));
 	memcpy(&hdr.right, &meta->rvalue.hdr, sizeof(hdr.right));
 
diff --git a/net/sched/ematch.c b/net/sched/ematch.c
index 88d93eb..6b0293c 100644
--- a/net/sched/ematch.c
+++ b/net/sched/ematch.c
@@ -307,7 +307,7 @@ int tcf_em_tree_validate(struct tcf_proto *tp, struct nlattr *nla,
 	struct tcf_ematch_tree_hdr *tree_hdr;
 	struct tcf_ematch *em;
 
-	memset(tree, 0, sizeof(*tree));
+	(void)memset(tree, 0, sizeof(*tree));
 	if (!nla)
 		return 0;
 
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index 3d8981f..e2ad68d4 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -652,7 +652,7 @@ void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)
 
 		sch = qdisc_lookup(qdisc_dev(sch), TC_H_MAJ(parentid));
 		if (sch == NULL) {
-			WARN_ON(parentid != TC_H_ROOT);
+			(void)WARN_ON(parentid != TC_H_ROOT);
 			return;
 		}
 		cops = sch->ops->cl_ops;
@@ -1576,7 +1576,7 @@ static int tc_dump_tclass_qdisc(struct Qdisc *q, struct sk_buff *skb,
 		return 0;
 	}
 	if (*t_p > s_t)
-		memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
+		(void)memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
 	arg.w.fn = qdisc_class_dump;
 	arg.skb = skb;
 	arg.cb = cb;
diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c
index 2c79020..9a5ee79 100644
--- a/net/sched/sch_dsmark.c
+++ b/net/sched/sch_dsmark.c
@@ -372,10 +372,10 @@ static int dsmark_init(struct Qdisc *sch, struct nlattr *opt)
 	}
 
 	p->mask = mask;
-	memset(p->mask, 0xff, indices);
+	(void)memset(p->mask, 0xff, indices);
 
 	p->value = p->mask + indices;
-	memset(p->value, 0, indices);
+	(void)memset(p->value, 0, indices);
 
 	p->indices = indices;
 	p->default_index = default_index;
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 67fc573..b4b2b09 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -179,7 +179,7 @@ static inline int qdisc_restart(struct Qdisc *q)
 	skb = dequeue_skb(q);
 	if (unlikely(!skb))
 		return 0;
-	WARN_ON_ONCE(skb_dst_is_noref(skb));
+	(void)WARN_ON_ONCE(skb_dst_is_noref(skb));
 	root_lock = qdisc_lock(q);
 	dev = qdisc_dev(q);
 	txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
@@ -252,7 +252,7 @@ static void dev_watchdog(unsigned long arg)
 			}
 
 			if (some_queue_timedout) {
-				WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
+				(void)WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
 				       dev->name, netdev_drivername(dev), i);
 				dev->netdev_ops->ndo_tx_timeout(dev);
 			}
@@ -904,5 +904,5 @@ void dev_shutdown(struct net_device *dev)
 	qdisc_destroy(dev->qdisc);
 	dev->qdisc = &noop_qdisc;
 
-	WARN_ON(timer_pending(&dev->watchdog_timer));
+	(void)WARN_ON(timer_pending(&dev->watchdog_timer));
 }


diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
index 29b942c..7d89564 100644
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@ -330,7 +330,7 @@ static inline void htb_add_class_to_row(struct htb_sched *q,
 static void htb_safe_rb_erase(struct rb_node *rb, struct rb_root *root)
 {
 	if (RB_EMPTY_NODE(rb)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	} else {
 		rb_erase(rb, root);
 		RB_CLEAR_NODE(rb);
@@ -521,7 +521,7 @@ htb_change_class_mode(struct htb_sched *q, struct htb_class *cl, long *diff)
  */
 static inline void htb_activate(struct htb_sched *q, struct htb_class *cl)
 {
-	WARN_ON(cl->level || !cl->un.leaf.q || !cl->un.leaf.q->q.qlen);
+	(void)WARN_ON(cl->level || !cl->un.leaf.q || !cl->un.leaf.q->q.qlen);
 
 	if (!cl->prio_activity) {
 		cl->prio_activity = 1 << cl->prio;
@@ -539,7 +539,7 @@ static inline void htb_activate(struct htb_sched *q, struct htb_class *cl)
  */
 static inline void htb_deactivate(struct htb_sched *q, struct htb_class *cl)
 {
-	WARN_ON(!cl->prio_activity);
+	(void)WARN_ON(!cl->prio_activity);
 
 	htb_deactivate_prios(q, cl);
 	cl->prio_activity = 0;
@@ -763,7 +763,7 @@ static struct htb_class *htb_lookup_leaf(struct rb_root *tree, int prio,
 			if (sp > stk) {
 				sp--;
 				if (!*sp->pptr) {
-					WARN_ON(1);
+					(void)WARN_ON(1);
 					return NULL;
 				}
 				htb_next_rb_node(sp->pptr);
@@ -778,7 +778,7 @@ static struct htb_class *htb_lookup_leaf(struct rb_root *tree, int prio,
 			sp->pid = cl->un.inner.last_ptr_id + prio;
 		}
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return NULL;
 }
 
@@ -949,7 +949,7 @@ static void htb_reset(struct Qdisc *sch)
 	for (i = 0; i < q->clhash.hashsize; i++) {
 		hlist_for_each_entry(cl, n, &q->clhash.hash[i], common.hnode) {
 			if (cl->level)
-				memset(&cl->un.inner, 0, sizeof(cl->un.inner));
+				(void)memset(&cl->un.inner, 0, sizeof(cl->un.inner));
 			else {
 				if (cl->un.leaf.q)
 					qdisc_reset(cl->un.leaf.q);
@@ -963,10 +963,10 @@ static void htb_reset(struct Qdisc *sch)
 	qdisc_watchdog_cancel(&q->watchdog);
 	__skb_queue_purge(&q->direct_queue);
 	sch->q.qlen = 0;
-	memset(q->row, 0, sizeof(q->row));
-	memset(q->row_mask, 0, sizeof(q->row_mask));
-	memset(q->wait_pq, 0, sizeof(q->wait_pq));
-	memset(q->ptr, 0, sizeof(q->ptr));
+	(void)memset(q->row, 0, sizeof(q->row));
+	(void)memset(q->row_mask, 0, sizeof(q->row_mask));
+	(void)memset(q->wait_pq, 0, sizeof(q->wait_pq));
+	(void)memset(q->ptr, 0, sizeof(q->ptr));
 	for (i = 0; i < TC_HTB_NUMPRIO; i++)
 		INIT_LIST_HEAD(q->drops + i);
 }
@@ -1081,7 +1081,7 @@ static int htb_dump_class(struct Qdisc *sch, unsigned long arg,
 	if (nest == NULL)
 		goto nla_put_failure;
 
-	memset(&opt, 0, sizeof(opt));
+	(void)memset(&opt, 0, sizeof(opt));
 
 	opt.rate = cl->rate->rate;
 	opt.buffer = cl->buffer;
@@ -1181,13 +1181,13 @@ static void htb_parent_to_leaf(struct htb_sched *q, struct htb_class *cl,
 {
 	struct htb_class *parent = cl->parent;
 
-	WARN_ON(cl->level || !cl->un.leaf.q || cl->prio_activity);
+	(void)WARN_ON(cl->level || !cl->un.leaf.q || cl->prio_activity);
 
 	if (parent->cmode != HTB_CAN_SEND)
 		htb_safe_rb_erase(&parent->pq_node, q->wait_pq + parent->level);
 
 	parent->level = 0;
-	memset(&parent->un.inner, 0, sizeof(parent->un.inner));
+	(void)memset(&parent->un.inner, 0, sizeof(parent->un.inner));
 	INIT_LIST_HEAD(&parent->un.leaf.drop_list);
 	parent->un.leaf.q = new_q ? new_q : &noop_qdisc;
 	parent->tokens = parent->buffer;
@@ -1199,7 +1199,7 @@ static void htb_parent_to_leaf(struct htb_sched *q, struct htb_class *cl,
 static void htb_destroy_class(struct Qdisc *sch, struct htb_class *cl)
 {
 	if (!cl->level) {
-		WARN_ON(!cl->un.leaf.q);
+		(void)WARN_ON(!cl->un.leaf.q);
 		qdisc_destroy(cl->un.leaf.q);
 	}
 	gen_kill_estimator(&cl->bstats, &cl->rate_est);
@@ -1405,7 +1405,7 @@ static int htb_change_class(struct Qdisc *sch, u32 classid,
 			}
 			parent->level = (parent->parent ? parent->parent->level
 					 : TC_HTB_MAXDEPTH) - 1;
-			memset(&parent->un.inner, 0, sizeof(parent->un.inner));
+			(void)memset(&parent->un.inner, 0, sizeof(parent->un.inner));
 		}
 		/* leaf (we) needs elementary qdisc */
 		cl->un.leaf.q = new_q ? new_q : &noop_qdisc;
diff --git a/net/sched/sch_mq.c b/net/sched/sch_mq.c
index 0a4b2f9..7b1d4c6 100644
--- a/net/sched/sch_mq.c
+++ b/net/sched/sch_mq.c
@@ -97,8 +97,8 @@ static int mq_dump(struct Qdisc *sch, struct sk_buff *skb)
 	unsigned int ntx;
 
 	sch->q.qlen = 0;
-	memset(&sch->bstats, 0, sizeof(sch->bstats));
-	memset(&sch->qstats, 0, sizeof(sch->qstats));
+	(void)memset(&sch->bstats, 0, sizeof(sch->bstats));
+	(void)memset(&sch->qstats, 0, sizeof(sch->qstats));
 
 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
 		qdisc = netdev_get_tx_queue(dev, ntx)->qdisc_sleeping;
diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c
index b8e1563..271d36c 100644
--- a/net/sched/sch_tbf.c
+++ b/net/sched/sch_tbf.c
@@ -356,7 +356,7 @@ static int tbf_dump(struct Qdisc *sch, struct sk_buff *skb)
 	if (q->P_tab)
 		opt.peakrate = q->P_tab->rate;
 	else
-		memset(&opt.peakrate, 0, sizeof(opt.peakrate));
+		(void)memset(&opt.peakrate, 0, sizeof(opt.peakrate));
 	opt.mtu = q->mtu;
 	opt.buffer = q->buffer;
 	NLA_PUT(skb, TCA_TBF_PARMS, sizeof(opt), &opt);
diff --git a/net/socket.c b/net/socket.c
index 28a96af..fddf6eb 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -658,7 +658,7 @@ void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
 	}
 
 
-	memset(ts, 0, sizeof(ts));
+	(void)memset(ts, 0, sizeof(ts));
 	if (skb->tstamp.tv64 &&
 	    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {
 		skb_get_timestampns(skb, ts + 0);
diff --git a/net/sunrpc/addr.c b/net/sunrpc/addr.c
index ee77742..d7e685a 100644
--- a/net/sunrpc/addr.c
+++ b/net/sunrpc/addr.c
@@ -146,7 +146,7 @@ static size_t rpc_pton4(const char *buf, const size_t buflen,
 	if (buflen > INET_ADDRSTRLEN || salen < sizeof(struct sockaddr_in))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in));
 
 	if (in4_pton(buf, buflen, addr, '\0', NULL) == 0)
 		return 0;
@@ -208,7 +208,7 @@ static size_t rpc_pton6(const char *buf, const size_t buflen,
 	    salen < sizeof(struct sockaddr_in6))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in6));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in6));
 
 	if (in6_pton(buf, buflen, addr, IPV6_SCOPE_DELIMITER, &delim) == 0)
 		return 0;
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 727e506..e3d21ad 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -424,7 +424,7 @@ rpcauth_lookupcred(struct rpc_auth *auth, int flags)
 	dprintk("RPC:       looking up %s cred\n",
 		auth->au_ops->au_name);
 
-	memset(&acred, 0, sizeof(acred));
+	(void)memset(&acred, 0, sizeof(acred));
 	acred.uid = cred->fsuid;
 	acred.gid = cred->fsgid;
 	acred.group_info = get_group_info(((struct cred *)cred)->group_info);
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index affa631..400c140 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -1380,7 +1380,7 @@ gss_wrap_req_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,
 		iov = snd_buf->head;
 	p = iov->iov_base + iov->iov_len;
 	pad = 3 - ((snd_buf->len - offset - 1) & 3);
-	memset(p, 0, pad);
+	(void)memset(p, 0, pad);
 	iov->iov_len += pad;
 	snd_buf->len += pad;
 
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 8d0f7d3..0dca63e 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -198,7 +198,7 @@ static int rsi_parse(struct cache_detail *cd,
 	time_t expiry;
 	int status = -EINVAL;
 
-	memset(&rsii, 0, sizeof(rsii));
+	(void)memset(&rsii, 0, sizeof(rsii));
 	/* handle */
 	len = qword_get(&mesg, buf, mlen);
 	if (len < 0)
@@ -400,7 +400,7 @@ update_rsc(struct cache_head *cnew, struct cache_head *ctmp)
 
 	new->mechctx = tmp->mechctx;
 	tmp->mechctx = NULL;
-	memset(&new->seqdata, 0, sizeof(new->seqdata));
+	(void)memset(&new->seqdata, 0, sizeof(new->seqdata));
 	spin_lock_init(&new->seqdata.sd_lock);
 	new->cred = tmp->cred;
 	tmp->cred.cr_group_info = NULL;
@@ -429,7 +429,7 @@ static int rsc_parse(struct cache_detail *cd,
 	int status = -EINVAL;
 	struct gss_api_mech *gm = NULL;
 
-	memset(&rsci, 0, sizeof(rsci));
+	(void)memset(&rsci, 0, sizeof(rsci));
 	/* context handle */
 	len = qword_get(&mesg, buf, mlen);
 	if (len < 0) goto out;
@@ -563,7 +563,7 @@ gss_svc_searchbyctx(struct xdr_netobj *handle)
 	struct rsc rsci;
 	struct rsc *found;
 
-	memset(&rsci, 0, sizeof(rsci));
+	(void)memset(&rsci, 0, sizeof(rsci));
 	if (dup_to_netobj(&rsci.handle, handle->data, handle->len))
 		return NULL;
 	found = rsc_lookup(&rsci);
@@ -584,7 +584,7 @@ gss_check_seq_num(struct rsc *rsci, int seq_num)
 	spin_lock(&sd->sd_lock);
 	if (seq_num > sd->sd_max) {
 		if (seq_num >= sd->sd_max + GSS_SEQ_WIN) {
-			memset(sd->sd_win,0,sizeof(sd->sd_win));
+			(void)memset(sd->sd_win,0,sizeof(sd->sd_win));
 			sd->sd_max = seq_num;
 		} else while (sd->sd_max < seq_num) {
 			sd->sd_max++;
@@ -641,7 +641,7 @@ svc_safe_putnetobj(struct kvec *resv, struct xdr_netobj *o)
 	if (resv->iov_len > PAGE_SIZE)
 		return -1;
 	memcpy(p, o->data, o->len);
-	memset(p + o->len, 0, round_up_to_quad(o->len) - o->len);
+	(void)memset(p + o->len, 0, round_up_to_quad(o->len) - o->len);
 	return 0;
 }
 
@@ -732,7 +732,7 @@ gss_write_verf(struct svc_rqst *rqstp, struct gss_ctx *ctx_id, u32 seq)
 	if (maj_stat != GSS_S_COMPLETE)
 		return -1;
 	*p++ = htonl(mic.len);
-	memset((u8 *)p + mic.len, 0, round_up_to_quad(mic.len) - mic.len);
+	(void)memset((u8 *)p + mic.len, 0, round_up_to_quad(mic.len) - mic.len);
 	p += XDR_QUADLEN(mic.len);
 	if (!xdr_ressize_check(rqstp, p))
 		return -1;
@@ -1014,7 +1014,7 @@ static int svcauth_gss_handle_init(struct svc_rqst *rqstp,
 	*authp = rpc_autherr_badcred;
 	if (gc->gc_proc == RPC_GSS_PROC_INIT && gc->gc_ctx.len != 0)
 		return SVC_DENIED;
-	memset(&rsikey, 0, sizeof(rsikey));
+	(void)memset(&rsikey, 0, sizeof(rsikey));
 	if (dup_netobj(&rsikey.in_handle, &gc->gc_ctx))
 		return SVC_CLOSE;
 	*authp = rpc_autherr_badverf;
@@ -1278,7 +1278,7 @@ svcauth_gss_wrap_resp_integ(struct svc_rqst *rqstp)
 	if (gss_get_mic(gsd->rsci->mechctx, &integ_buf, &mic))
 		goto out_err;
 	svc_putnl(resv, mic.len);
-	memset(mic.data + mic.len, 0,
+	(void)memset(mic.data + mic.len, 0,
 			round_up_to_quad(mic.len) - mic.len);
 	resv->iov_len += XDR_QUADLEN(mic.len) << 2;
 	/* not strictly required: */
@@ -1349,7 +1349,7 @@ svcauth_gss_wrap_resp_priv(struct svc_rqst *rqstp)
 	*len = htonl(resbuf->len - offset);
 	pad = 3 - ((resbuf->len - offset - 1)&3);
 	p = (__be32 *)(resbuf->tail[0].iov_base + resbuf->tail[0].iov_len);
-	memset(p, 0, pad);
+	(void)memset(p, 0, pad);
 	resbuf->tail[0].iov_len += pad;
 	resbuf->len += pad;
 	return 0;
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index f0268ea..3117c06 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -458,7 +458,7 @@ void rpc_shutdown_client(struct rpc_clnt *clnt)
 
 	while (!list_empty(&clnt->cl_tasks)) {
 		rpc_killall_tasks(clnt);
-		wait_event_timeout(destroy_wait,
+		(void)wait_event_timeout(destroy_wait,
 			list_empty(&clnt->cl_tasks), 1*HZ);
 	}
 
@@ -1569,7 +1569,7 @@ call_decode(struct rpc_task *task)
 	req->rq_rcv_buf.len = req->rq_private_buf.len;
 
 	/* Check that the softirq receive buffer is valid */
-	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
+	(void)WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
 				sizeof(req->rq_rcv_buf)) != 0);
 
 	if (req->rq_rcv_buf.len < 12) {
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 3341d89..f69e9dd 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -621,7 +621,7 @@ void rpc_exit_task(struct rpc_task *task)
 	if (task->tk_ops->rpc_call_done != NULL) {
 		task->tk_ops->rpc_call_done(task, task->tk_calldata);
 		if (task->tk_action != NULL) {
-			WARN_ON(RPC_ASSASSINATED(task));
+			(void)WARN_ON(RPC_ASSASSINATED(task));
 			/* Always release the RPC slot and buffer memory */
 			xprt_release(task);
 			rpc_reset_task_statistics(task);
@@ -820,7 +820,7 @@ EXPORT_SYMBOL_GPL(rpc_free);
  */
 static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)
 {
-	memset(task, 0, sizeof(*task));
+	(void)memset(task, 0, sizeof(*task));
 	atomic_set(&task->tk_count, 1);
 	task->tk_flags  = task_setup_data->flags;
 	task->tk_ops = task_setup_data->callback_ops;
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index e4aabc0..9515725 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1147,8 +1147,8 @@ svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)
 	procp->pc_count++;
 
 	/* Initialize storage for argp and resp */
-	memset(rqstp->rq_argp, 0, procp->pc_argsize);
-	memset(rqstp->rq_resp, 0, procp->pc_ressize);
+	(void)memset(rqstp->rq_argp, 0, procp->pc_argsize);
+	(void)memset(rqstp->rq_resp, 0, procp->pc_ressize);
 
 	/* un-reserve some of the out-queue now that we have a
 	 * better idea of reply size
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 74cb0d8..b8b7b86 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -151,7 +151,7 @@ EXPORT_SYMBOL_GPL(svc_xprt_put);
 void svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,
 		   struct svc_xprt *xprt, struct svc_serv *serv)
 {
-	memset(xprt, 0, sizeof(*xprt));
+	(void)memset(xprt, 0, sizeof(*xprt));
 	xprt->xpt_class = xcl;
 	xprt->xpt_ops = xcl->xcl_ops;
 	kref_init(&xprt->xpt_ref);
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 4645709..1e74d56 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1360,7 +1360,7 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 
 		svsk->sk_reclen = 0;
 		svsk->sk_tcplen = 0;
-		memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
+		(void)memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
 
 		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;
 
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 593f4c6..0735555 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -67,7 +67,7 @@ __be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)
 		if (ptr != NULL)
 			memcpy(p, ptr, nbytes);
 		if (padding != 0)
-			memset((char *)p + nbytes, 0, padding);
+			(void)memset((char *)p + nbytes, 0, padding);
 		p += quadlen;
 	}
 	return p;
@@ -649,7 +649,7 @@ EXPORT_SYMBOL_GPL(xdr_init_decode);
 void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,
 			   struct page **pages, unsigned int len)
 {
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	buf->pages =  pages;
 	buf->page_len =  len;
 	buf->buflen =  len;
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aad8fb6..7ca7faa 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -230,7 +230,7 @@ static void __unix_remove_socket(struct sock *sk)
 
 static void __unix_insert_socket(struct hlist_head *list, struct sock *sk)
 {
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	sk_add_node(sk, list);
 }
 
@@ -353,9 +353,9 @@ static void unix_sock_destructor(struct sock *sk)
 
 	skb_queue_purge(&sk->sk_receive_queue);
 
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(!sk_unhashed(sk));
-	WARN_ON(sk->sk_socket);
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(sk->sk_socket);
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		printk(KERN_INFO "Attempt to release alive unix socket: %p\n", sk);
 		return;
@@ -1333,7 +1333,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 static void unix_destruct_scm(struct sk_buff *skb)
 {
 	struct scm_cookie scm;
-	memset(&scm, 0, sizeof(scm));
+	(void)memset(&scm, 0, sizeof(scm));
 	scm.pid  = UNIXCB(skb).pid;
 	scm.cred = UNIXCB(skb).cred;
 	if (UNIXCB(skb).fp)
@@ -1800,7 +1800,7 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 	scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).cred);
 	unix_set_secdata(siocb->scm, skb);
@@ -1904,7 +1904,7 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
 	err = mutex_lock_interruptible(&u->readlock);
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 2fcfe09..a715ba7 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -89,7 +89,7 @@ int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 		wdev = NULL;
 
 	if (wdev) {
-		ASSERT_WDEV_LOCK(wdev);
+		(void)ASSERT_WDEV_LOCK(wdev);
 
 		if (!netif_running(wdev->netdev))
 			return -ENETDOWN;
diff --git a/net/wireless/core.c b/net/wireless/core.c
index ccdfed8..f2458df 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -256,7 +256,7 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 			wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
 			err = dev_change_net_namespace(wdev->netdev, net,
 							"wlan%d");
-			WARN_ON(err);
+			(void)WARN_ON(err);
 			wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
 		}
 
@@ -266,7 +266,7 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 	wiphy_net_set(&rdev->wiphy, net);
 
 	err = device_rename(&rdev->wiphy.dev, dev_name(&rdev->wiphy.dev));
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 	return 0;
 }
@@ -330,14 +330,14 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
 	struct cfg80211_registered_device *rdev;
 	int alloc_size;
 
-	WARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));
-	WARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));
-	WARN_ON(ops->connect && !ops->disconnect);
-	WARN_ON(ops->join_ibss && !ops->leave_ibss);
-	WARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);
-	WARN_ON(ops->add_station && !ops->del_station);
-	WARN_ON(ops->add_mpath && !ops->del_mpath);
-	WARN_ON(ops->join_mesh && !ops->leave_mesh);
+	(void)WARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));
+	(void)WARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));
+	(void)WARN_ON(ops->connect && !ops->disconnect);
+	(void)WARN_ON(ops->join_ibss && !ops->leave_ibss);
+	(void)WARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);
+	(void)WARN_ON(ops->add_station && !ops->del_station);
+	(void)WARN_ON(ops->add_mpath && !ops->del_mpath);
+	(void)WARN_ON(ops->join_mesh && !ops->leave_mesh);
 
 	alloc_size = sizeof(*rdev) + sizeof_priv;
 
@@ -509,7 +509,7 @@ int wiphy_register(struct wiphy *wiphy)
 		memcpy(wiphy->perm_addr, wiphy->addresses[0].addr, ETH_ALEN);
 
 	/* sanity check ifmodes */
-	WARN_ON(!ifmodes);
+	(void)WARN_ON(!ifmodes);
 	ifmodes &= ((1 << NUM_NL80211_IFTYPES) - 1) & ~1;
 	if (WARN_ON(ifmodes != wiphy->interface_modes))
 		wiphy->interface_modes = ifmodes;
@@ -563,7 +563,7 @@ int wiphy_register(struct wiphy *wiphy)
 	}
 
 	if (!have_band) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EINVAL;
 	}
 
@@ -791,7 +791,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block * nb,
 
 	rdev = wiphy_to_dev(wdev->wiphy);
 
-	WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
+	(void)WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
 
 	switch (state) {
 	case NETDEV_POST_INIT:
@@ -1002,7 +1002,7 @@ static void __net_exit cfg80211_pernet_exit(struct net *net)
 	mutex_lock(&cfg80211_mutex);
 	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
 		if (net_eq(wiphy_net(&rdev->wiphy), net))
-			WARN_ON(cfg80211_switch_netns(rdev, &init_net));
+			(void)WARN_ON(cfg80211_switch_netns(rdev, &init_net));
 	}
 	mutex_unlock(&cfg80211_mutex);
 	rtnl_unlock();
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 43ad9c8..df80c3e 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -117,7 +117,7 @@ extern int cfg80211_rdev_list_generation;
 
 static inline void assert_cfg80211_lock(void)
 {
-	lockdep_assert_held(&cfg80211_mutex);
+	(void)lockdep_assert_held(&cfg80211_mutex);
 }
 
 /*
@@ -157,7 +157,7 @@ static inline void cfg80211_hold_bss(struct cfg80211_internal_bss *bss)
 static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 {
 	int r = atomic_dec_return(&bss->hold);
-	WARN_ON(r < 0);
+	(void)WARN_ON(r < 0);
 }
 
 
diff --git a/net/wireless/ethtool.c b/net/wireless/ethtool.c
index 9bde4d1..c8be1ee 100644
--- a/net/wireless/ethtool.c
+++ b/net/wireless/ethtool.c
@@ -44,7 +44,7 @@ static void cfg80211_get_ringparam(struct net_device *dev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 
-	memset(rp, 0, sizeof(*rp));
+	(void)memset(rp, 0, sizeof(*rp));
 
 	if (rdev->ops->get_ringparam)
 		rdev->ops->get_ringparam(wdev->wiphy,
diff --git a/net/wireless/ibss.c b/net/wireless/ibss.c
index 30f20fe..5c314e8 100644
--- a/net/wireless/ibss.c
+++ b/net/wireless/ibss.c
@@ -60,7 +60,7 @@ void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp)
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(!wdev->ssid_len);
+	(void)CFG80211_DEV_WARN_ON(!wdev->ssid_len);
 
 	ev = kzalloc(sizeof(*ev), gfp);
 	if (!ev)
@@ -84,7 +84,7 @@ int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->ssid_len)
 		return -EALREADY;
@@ -150,7 +150,7 @@ static void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	kfree(wdev->connect_keys);
 	wdev->connect_keys = NULL;
@@ -191,7 +191,7 @@ int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->ssid_len)
 		return -ENOLINK;
diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 8c550df..758dc62 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -75,7 +75,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
 	BUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
 		return -EOPNOTSUPP;
@@ -136,7 +136,7 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)
 		return -EOPNOTSUPP;
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index 438dfc1..ab0be5d 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -151,7 +151,7 @@ void __cfg80211_send_deauth(struct net_device *dev,
 	int i;
 	bool found = false, was_current = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->current_bss &&
 	    memcmp(wdev->current_bss->pub.bssid, bssid, ETH_ALEN) == 0) {
@@ -225,7 +225,7 @@ void __cfg80211_send_disassoc(struct net_device *dev,
 	bool from_ap;
 	bool done = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	nl80211_send_disassoc(rdev, dev, buf, len, GFP_KERNEL);
 
@@ -292,7 +292,7 @@ static void __cfg80211_auth_remove(struct wireless_dev *wdev, const u8 *addr)
 	int i;
 	bool done = false;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	for (i = 0; addr && i < MAX_AUTH_BSSES; i++) {
 		if (wdev->authtry_bsses[i] &&
@@ -411,7 +411,7 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 	struct cfg80211_internal_bss *bss;
 	int i, err, slot = -1, nfree = 0;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (auth_type == NL80211_AUTHTYPE_SHARED_KEY)
 		if (!key || !key_len || key_idx < 0 || key_idx > 4)
@@ -680,7 +680,7 @@ static int __cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct cfg80211_disassoc_request req;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state != CFG80211_SME_CONNECTED)
 		return -ENOTCONN;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index afeea32..b8862fa 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -495,7 +495,7 @@ static int nl80211_parse_key(struct genl_info *info, struct key_parse *k)
 {
 	int err;
 
-	memset(k, 0, sizeof(*k));
+	(void)memset(k, 0, sizeof(*k));
 	k->idx = -1;
 	k->type = -1;
 
@@ -548,7 +548,7 @@ nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,
 	result->defmgmt = -1;
 
 	nla_for_each_nested(key, keys, rem) {
-		memset(&parse, 0, sizeof(parse));
+		(void)memset(&parse, 0, sizeof(parse));
 		parse.idx = -1;
 
 		err = nl80211_parse_key_new(key, &parse);
@@ -586,7 +586,7 @@ nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,
 
 static int nl80211_key_allowed(struct wireless_dev *wdev)
 {
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	switch (wdev->iftype) {
 	case NL80211_IFTYPE_AP:
@@ -1629,7 +1629,7 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	u32 _flags, *flags = NULL;
 	bool change = false;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	otype = ntype = dev->ieee80211_ptr->iftype;
 
@@ -1701,7 +1701,7 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 	enum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;
 	u32 flags;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	if (!info->attrs[NL80211_ATTR_IFNAME])
 		return -EINVAL;
@@ -2096,7 +2096,7 @@ static int nl80211_addset_beacon(struct sk_buff *skb, struct genl_info *info)
 	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
 		return -EOPNOTSUPP;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	switch (info->genlhdr->cmd) {
 	case NL80211_CMD_NEW_BEACON:
@@ -2475,7 +2475,7 @@ static int nl80211_dump_station(struct sk_buff *skb,
 	}
 
 	while (1) {
-		memset(&sinfo, 0, sizeof(sinfo));
+		(void)memset(&sinfo, 0, sizeof(sinfo));
 		err = dev->ops->dump_station(&dev->wiphy, netdev, sta_idx,
 					     mac_addr, &sinfo);
 		if (err == -ENOENT)
@@ -2512,7 +2512,7 @@ static int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)
 	u8 *mac_addr = NULL;
 	int err;
 
-	memset(&sinfo, 0, sizeof(sinfo));
+	(void)memset(&sinfo, 0, sizeof(sinfo));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -2580,7 +2580,7 @@ static int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)
 	struct station_parameters params;
 	u8 *mac_addr = NULL;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	params.listen_interval = -1;
 	params.plink_state = -1;
@@ -2720,7 +2720,7 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
 	struct station_parameters params;
 	u8 *mac_addr = NULL;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -2968,7 +2968,7 @@ static int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)
 	u8 *dst = NULL;
 	u8 next_hop[ETH_ALEN];
 
-	memset(&pinfo, 0, sizeof(pinfo));
+	(void)memset(&pinfo, 0, sizeof(pinfo));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -3069,7 +3069,7 @@ static int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)
 	struct net_device *dev = info->user_ptr[1];
 	struct bss_parameters params;
 
-	memset(&params, 0, sizeof(params));
+	(void)memset(&params, 0, sizeof(params));
 	/* default to not changing parameters */
 	params.use_cts_prot = -1;
 	params.use_short_preamble = -1;
@@ -4081,7 +4081,7 @@ static int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,
 	struct nlattr *bss;
 	int i;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).pid, seq, flags,
 			     NL80211_CMD_NEW_SCAN_RESULTS);
@@ -4417,7 +4417,7 @@ static int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,
 				   struct cfg80211_crypto_settings *settings,
 				   int cipher_limit)
 {
-	memset(settings, 0, sizeof(*settings));
+	(void)memset(settings, 0, sizeof(*settings));
 
 	settings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];
 
@@ -4695,7 +4695,7 @@ static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)
 	struct cfg80211_cached_keys *connkeys = NULL;
 	int err;
 
-	memset(&ibss, 0, sizeof(ibss));
+	(void)memset(&ibss, 0, sizeof(ibss));
 
 	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
 		return -EINVAL;
@@ -5039,7 +5039,7 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
 	struct cfg80211_cached_keys *connkeys = NULL;
 	int err;
 
-	memset(&connect, 0, sizeof(connect));
+	(void)memset(&connect, 0, sizeof(connect));
 
 	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
 		return -EINVAL;
@@ -5172,7 +5172,7 @@ static int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)
 	struct net_device *dev = info->user_ptr[1];
 	struct cfg80211_pmksa pmksa;
 
-	memset(&pmksa, 0, sizeof(struct cfg80211_pmksa));
+	(void)memset(&pmksa, 0, sizeof(struct cfg80211_pmksa));
 
 	if (!info->attrs[NL80211_ATTR_MAC])
 		return -EINVAL;
@@ -5195,7 +5195,7 @@ static int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)
 		rdev_ops = rdev->ops->del_pmksa;
 		break;
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		break;
 	}
 
@@ -5412,7 +5412,7 @@ static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
 	if (!rdev->ops->set_bitrate_mask)
 		return -EOPNOTSUPP;
 
-	memset(&mask, 0, sizeof(mask));
+	(void)memset(&mask, 0, sizeof(mask));
 	/* Default to all rates enabled */
 	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
 		sband = rdev->wiphy.bands[i];
@@ -6781,7 +6781,7 @@ static int nl80211_add_scan_req(struct sk_buff *msg,
 	struct nlattr *nest;
 	int i;
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	if (WARN_ON(!req))
 		return 0;
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index f65feaa..4272bcc 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -102,7 +102,7 @@ static DEFINE_MUTEX(reg_mutex);
 
 static inline void assert_reg_lock(void)
 {
-	lockdep_assert_held(&reg_mutex);
+	(void)lockdep_assert_held(&reg_mutex);
 }
 
 /* Used to queue up regulatory hints */
@@ -580,7 +580,7 @@ static struct ieee80211_regdomain *regdom_intersect(
 	/* Uses the stack temporarily for counter arithmetic */
 	intersected_rule = &irule;
 
-	memset(intersected_rule, 0, sizeof(struct ieee80211_reg_rule));
+	(void)memset(intersected_rule, 0, sizeof(struct ieee80211_reg_rule));
 
 	if (!rd1 || !rd2)
 		return NULL;
@@ -600,7 +600,7 @@ static struct ieee80211_regdomain *regdom_intersect(
 			if (!reg_rules_intersect(rule1, rule2,
 					intersected_rule))
 				num_rules++;
-			memset(intersected_rule, 0,
+			(void)memset(intersected_rule, 0,
 					sizeof(struct ieee80211_reg_rule));
 		}
 	}
@@ -1283,7 +1283,7 @@ void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
 	 * no point in calling this if it won't have any effect
 	 * on your device's supportd bands.
 	 */
-	WARN_ON(!bands_set);
+	(void)WARN_ON(!bands_set);
 }
 EXPORT_SYMBOL(wiphy_apply_custom_regulatory);
 
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index 31119e3..6f9db3b 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -28,7 +28,7 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak)
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	request = rdev->scan_req;
 
@@ -87,7 +87,7 @@ void __cfg80211_scan_done(struct work_struct *wk)
 
 void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted)
 {
-	WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
+	(void)WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
 
 	request->aborted = aborted;
 	queue_work(cfg80211_wq, &wiphy_to_dev(request->wiphy)->scan_done_wk);
@@ -135,7 +135,7 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 {
 	struct net_device *dev;
 
-	lockdep_assert_held(&rdev->sched_scan_mtx);
+	(void)lockdep_assert_held(&rdev->sched_scan_mtx);
 
 	if (!rdev->sched_scan_req)
 		return -ENOENT;
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index 7b9ecae..22d52e8 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -82,8 +82,8 @@ static int cfg80211_conn_scan(struct wireless_dev *wdev)
 	int n_channels, err;
 
 	ASSERT_RTNL();
-	ASSERT_RDEV_LOCK(rdev);
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (rdev->scan_req)
 		return -EBUSY;
@@ -160,7 +160,7 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev)
 	const u8 *prev_bssid = NULL;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->conn)
 		return 0;
@@ -255,7 +255,7 @@ static struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)
 	struct cfg80211_bss *bss;
 	u16 capa = WLAN_CAPABILITY_ESS;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->conn->params.privacy)
 		capa |= WLAN_CAPABILITY_PRIVACY;
@@ -284,7 +284,7 @@ static void __cfg80211_sme_scan_done(struct net_device *dev)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	struct cfg80211_bss *bss;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state != CFG80211_SME_CONNECTING)
 		return;
@@ -333,7 +333,7 @@ void cfg80211_sme_rx_auth(struct net_device *dev,
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
 	u16 status_code = le16_to_cpu(mgmt->u.auth.status_code);
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	/* should only RX auth frames when connecting */
 	if (wdev->sme_state != CFG80211_SME_CONNECTING)
@@ -420,7 +420,7 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
@@ -524,7 +524,7 @@ void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
+	(void)CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
 
 	ev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);
 	if (!ev)
@@ -682,7 +682,7 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 	union iwreq_data wrqu;
 #endif
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
@@ -756,7 +756,7 @@ void cfg80211_disconnected(struct net_device *dev, u16 reason,
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
+	(void)CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
 
 	ev = kzalloc(sizeof(*ev) + ie_len, gfp);
 	if (!ev)
@@ -785,7 +785,7 @@ int __cfg80211_connect(struct cfg80211_registered_device *rdev,
 	struct cfg80211_bss *bss = NULL;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state != CFG80211_SME_IDLE)
 		return -EALREADY;
@@ -948,7 +948,7 @@ int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	int err;
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (wdev->sme_state == CFG80211_SME_IDLE)
 		return -EINVAL;
@@ -1018,7 +1018,7 @@ void cfg80211_sme_disassoc(struct net_device *dev, int idx)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
 	u8 bssid[ETH_ALEN];
 
-	ASSERT_WDEV_LOCK(wdev);
+	(void)ASSERT_WDEV_LOCK(wdev);
 
 	if (!wdev->conn)
 		return;
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 9aa9db6..cb9c4ac 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -105,7 +105,7 @@ static void set_mandatory_flags_band(struct ieee80211_supported_band *sband,
 				want--;
 			}
 		}
-		WARN_ON(want);
+		(void)WARN_ON(want);
 		break;
 	case IEEE80211_BAND_2GHZ:
 		want = 7;
@@ -135,10 +135,10 @@ static void set_mandatory_flags_band(struct ieee80211_supported_band *sband,
 				sband->bitrates[i].flags |=
 					IEEE80211_RATE_ERP_G;
 		}
-		WARN_ON(want != 0 && want != 3 && want != 6);
+		(void)WARN_ON(want != 0 && want != 3 && want != 6);
 		break;
 	case IEEE80211_NUM_BANDS:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		break;
 	}
 }
@@ -771,7 +771,7 @@ void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev)
 	struct wireless_dev *wdev;
 
 	ASSERT_RTNL();
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	mutex_lock(&rdev->devlist_mtx);
 
@@ -788,7 +788,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	int err;
 	enum nl80211_iftype otype = dev->ieee80211_ptr->iftype;
 
-	ASSERT_RDEV_LOCK(rdev);
+	(void)ASSERT_RDEV_LOCK(rdev);
 
 	/* don't support changing VLANs, you just re-create them */
 	if (otype == NL80211_IFTYPE_AP_VLAN)
@@ -836,7 +836,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	err = rdev->ops->change_virtual_intf(&rdev->wiphy, dev,
 					     ntype, flags, params);
 
-	WARN_ON(!err && dev->ieee80211_ptr->iftype != ntype);
+	(void)WARN_ON(!err && dev->ieee80211_ptr->iftype != ntype);
 
 	if (!err && params && params->use_4addr != -1)
 		dev->ieee80211_ptr->use_4addr = params->use_4addr;
@@ -952,7 +952,7 @@ int cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
 	if (!(rdev->wiphy.flags & WIPHY_FLAG_ENFORCE_COMBINATIONS))
 		return 0;
 
-	memset(num, 0, sizeof(num));
+	(void)memset(num, 0, sizeof(num));
 
 	num[iftype] = 1;
 
diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c
index 0af7f54..2ea8414 100644
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -540,7 +540,7 @@ void wireless_send_event(struct net_device *	dev,
 	event = nla_data(nla);
 
 	/* Fill event - first clear to avoid data leaking */
-	memset(event, 0, hdr_len);
+	(void)memset(event, 0, hdr_len);
 	event->len = event_len;
 	event->cmd = cmd;
 	memcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);
diff --git a/net/wireless/wext-spy.c b/net/wireless/wext-spy.c
index 5d643a5..81b353e 100644
--- a/net/wireless/wext-spy.c
+++ b/net/wireless/wext-spy.c
@@ -57,7 +57,7 @@ int iw_handler_set_spy(struct net_device *	dev,
 			memcpy(spydata->spy_address[i], address[i].sa_data,
 			       ETH_ALEN);
 		/* Reset stats */
-		memset(spydata->spy_stat, 0,
+		(void)memset(spydata->spy_stat, 0,
 		       sizeof(struct iw_quality) * IW_MAX_SPY);
 	}
 
@@ -124,7 +124,7 @@ int iw_handler_set_thrspy(struct net_device *	dev,
 	       2 * sizeof(struct iw_quality));
 
 	/* Clear flag */
-	memset(spydata->spy_thr_under, '\0', sizeof(spydata->spy_thr_under));
+	(void)memset(spydata->spy_thr_under, '\0', sizeof(spydata->spy_thr_under));
 
 	return 0;
 }
diff --git a/net/xfrm/xfrm_ipcomp.c b/net/xfrm/xfrm_ipcomp.c
index e5246fb..4be4047 100644
--- a/net/xfrm/xfrm_ipcomp.c
+++ b/net/xfrm/xfrm_ipcomp.c
@@ -252,7 +252,7 @@ static void ipcomp_free_tfms(struct crypto_comp * __percpu *tfms)
 			break;
 	}
 
-	WARN_ON(!pos);
+	(void)WARN_ON(!pos);
 
 	if (--pos->users)
 		return;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 7661576..dae38ad 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -1351,7 +1351,7 @@ static inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)
 	xdst = dst_alloc(dst_ops, NULL, 0, 0, 0);
 
 	if (likely(xdst)) {
-		memset(&xdst->u.rt6.rt6i_table, 0,
+		(void)memset(&xdst->u.rt6.rt6i_table, 0,
 			sizeof(*xdst) - sizeof(struct dst_entry));
 		xdst->flo.ops = &xfrm_bundle_fc_ops;
 	} else
@@ -2634,21 +2634,21 @@ static void xfrm_policy_fini(struct net *net)
 	audit_info.secid = 0;
 	xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, &audit_info);
 
-	WARN_ON(!list_empty(&net->xfrm.policy_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.policy_all));
 
 	for (dir = 0; dir < XFRM_POLICY_MAX * 2; dir++) {
 		struct xfrm_policy_hash *htab;
 
-		WARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));
+		(void)WARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));
 
 		htab = &net->xfrm.policy_bydst[dir];
 		sz = (htab->hmask + 1);
-		WARN_ON(!hlist_empty(htab->table));
+		(void)WARN_ON(!hlist_empty(htab->table));
 		xfrm_hash_free(htab->table, sz);
 	}
 
 	sz = (net->xfrm.policy_idx_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.policy_byidx));
+	(void)WARN_ON(!hlist_empty(net->xfrm.policy_byidx));
 	xfrm_hash_free(net->xfrm.policy_byidx, sz);
 }
 
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 5b228f9..b23979b 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -516,7 +516,7 @@ void __xfrm_state_destroy(struct xfrm_state *x)
 {
 	struct net *net = xs_net(x);
 
-	WARN_ON(x->km.state != XFRM_STATE_DEAD);
+	(void)WARN_ON(x->km.state != XFRM_STATE_DEAD);
 
 	spin_lock_bh(&xfrm_state_gc_lock);
 	hlist_add_head(&x->gclist, &net->xfrm.state_gc_list);
@@ -2051,14 +2051,14 @@ void xfrm_state_fini(struct net *net)
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, &audit_info);
 	flush_work(&net->xfrm.state_gc_work);
 
-	WARN_ON(!list_empty(&net->xfrm.state_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.state_all));
 
 	sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.state_byspi));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_byspi));
 	xfrm_hash_free(net->xfrm.state_byspi, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
 	xfrm_hash_free(net->xfrm.state_bysrc, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bydst));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bydst));
 	xfrm_hash_free(net->xfrm.state_bydst, sz);
 }
 
diff --git a/security/commoncap.c b/security/commoncap.c
index 7ce191e..cb0b81c 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -370,7 +370,7 @@ int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data
 	int size;
 	struct vfs_cap_data caps;
 
-	memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));
+	(void)memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));
 
 	if (!inode || !inode->i_op->getxattr)
 		return -ENODATA;
diff --git a/security/keys/key.c b/security/keys/key.c
index 7ada801..8aa05ea 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -307,7 +307,7 @@ struct key *key_alloc(struct key_type *type, const char *desc,
 	if (!(flags & KEY_ALLOC_NOT_IN_QUOTA))
 		key->flags |= 1 << KEY_FLAG_IN_QUOTA;
 
-	memset(&key->type_data, 0, sizeof(key->type_data));
+	(void)memset(&key->type_data, 0, sizeof(key->type_data));
 
 #ifdef KEY_DEBUGGING
 	key->magic = KEY_DEBUG_MAGIC;
diff --git a/security/keys/request_key.c b/security/keys/request_key.c
index 8246532..1bd2d50 100644
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@ -252,7 +252,7 @@ static int construct_key(struct key *key, const void *callout_info,
 
 		/* check that the actor called complete_request_key() prior to
 		 * returning an error */
-		WARN_ON(ret < 0 &&
+		(void)WARN_ON(ret < 0 &&
 			!test_bit(KEY_FLAG_REVOKED, &authkey->flags));
 		key_put(authkey);
 	}
diff --git a/sound/core/control.c b/sound/core/control.c
index 819a5c5..e33df87 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -231,7 +231,7 @@ struct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,
 	
 	if (snd_BUG_ON(!ncontrol || !ncontrol->info))
 		return NULL;
-	memset(&kctl, 0, sizeof(kctl));
+	(void)memset(&kctl, 0, sizeof(kctl));
 	kctl.id.iface = ncontrol->iface;
 	kctl.id.device = ncontrol->device;
 	kctl.id.subdevice = ncontrol->subdevice;
@@ -1139,7 +1139,7 @@ static int snd_ctl_elem_add(struct snd_ctl_file *file,
 				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
 				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
 	info->id.numid = 0;
-	memset(&kctl, 0, sizeof(kctl));
+	(void)memset(&kctl, 0, sizeof(kctl));
 	down_write(&card->controls_rwsem);
 	_kctl = snd_ctl_find_id(card, &info->id);
 	err = 0;
diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 75ea16f..4399ad8 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -183,7 +183,7 @@ static int snd_hwdep_info(struct snd_hwdep *hw,
 {
 	struct snd_hwdep_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.card = hw->card->number;
 	strlcpy(info.id, hw->id, sizeof(info.id));	
 	strlcpy(info.name, hw->name, sizeof(info.name));
@@ -201,7 +201,7 @@ static int snd_hwdep_dsp_status(struct snd_hwdep *hw,
 	
 	if (! hw->ops.dsp_status)
 		return -ENXIO;
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.dsp_loaded = hw->dsp_loaded;
 	if ((err = hw->ops.dsp_status(hw, &info)) < 0)
 		return err;
@@ -218,7 +218,7 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	
 	if (! hw->ops.dsp_load)
 		return -ENXIO;
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	if (copy_from_user(&info, _info, sizeof(info)))
 		return -EFAULT;
 	/* check whether the dsp was already loaded */
diff --git a/sound/core/info_oss.c b/sound/core/info_oss.c
index cf42ab5..a5f4b6e 100644
--- a/sound/core/info_oss.c
+++ b/sound/core/info_oss.c
@@ -117,7 +117,7 @@ int snd_info_minor_register(void)
 {
 	struct snd_info_entry *entry;
 
-	memset(snd_sndstat_strings, 0, sizeof(snd_sndstat_strings));
+	(void)memset(snd_sndstat_strings, 0, sizeof(snd_sndstat_strings));
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "sndstat", snd_oss_root)) != NULL) {
 		entry->c.text.read = snd_sndstat_proc_read;
 		if (snd_info_register(entry) < 0) {
diff --git a/sound/core/init.c b/sound/core/init.c
index 3ac49b1..e698f2e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -375,7 +375,7 @@ int snd_card_disconnect(struct snd_card *card)
 		spin_unlock(&shutdown_lock);
 
 		mfile->file->f_op = &snd_shutdown_f_ops;
-		fops_get(mfile->file->f_op);
+		(void)fops_get(mfile->file->f_op);
 	}
 	spin_unlock(&card->files_lock);	
 
diff --git a/sound/core/jack.c b/sound/core/jack.c
index 26edf63..86e0b9b 100644
--- a/sound/core/jack.c
+++ b/sound/core/jack.c
@@ -161,7 +161,7 @@ EXPORT_SYMBOL(snd_jack_new);
  */
 void snd_jack_set_parent(struct snd_jack *jack, struct device *parent)
 {
-	WARN_ON(jack->registered);
+	(void)WARN_ON(jack->registered);
 
 	jack->input_dev->dev.parent = parent;
 }
@@ -192,7 +192,7 @@ int snd_jack_set_key(struct snd_jack *jack, enum snd_jack_types type,
 {
 	int key = fls(SND_JACK_BTN_0) - fls(type);
 
-	WARN_ON(jack->registered);
+	(void)WARN_ON(jack->registered);
 
 	if (!keytype || key >= ARRAY_SIZE(jack->key))
 		return -EINVAL;
diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 18297f7..d7176d2 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -93,7 +93,7 @@ static int snd_mixer_oss_info(struct snd_mixer_oss_file *fmixer,
 	struct snd_mixer_oss *mixer = fmixer->mixer;
 	struct mixer_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
 	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
 	info.modify_counter = card->mixer_oss_change_count;
@@ -109,7 +109,7 @@ static int snd_mixer_oss_info_obsolete(struct snd_mixer_oss_file *fmixer,
 	struct snd_mixer_oss *mixer = fmixer->mixer;
 	_old_mixer_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
 	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
 	if (copy_to_user(_info, &info, sizeof(info)))
@@ -382,7 +382,7 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
 		return -ENXIO;
 	if (card->mixer_oss == NULL)
 		return -ENXIO;
-	memset(&fmixer, 0, sizeof(fmixer));
+	(void)memset(&fmixer, 0, sizeof(fmixer));
 	fmixer.card = card;
 	fmixer.mixer = card->mixer_oss;
 	return snd_mixer_oss_ioctl1(&fmixer, cmd, arg);
@@ -498,7 +498,7 @@ static struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, c
 	struct snd_card *card = mixer->card;
 	struct snd_ctl_elem_id id;
 	
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	strlcpy(id.name, name, sizeof(id.name));
 	id.index = index;
@@ -947,7 +947,7 @@ static void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)
 	int idx = rslot->number; /* remember this */
 	if (rslot->private_free)
 		rslot->private_free(rslot);
-	memset(rslot, 0, sizeof(*rslot));
+	(void)memset(rslot, 0, sizeof(*rslot));
 	rslot->number = idx;
 }
 
@@ -1030,8 +1030,8 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	if (mixer->slots[ptr->oss_id].get_volume && ! replace_old)
 		return 0;
 
-	memset(&slot, 0, sizeof(slot));
-	memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
+	(void)memset(&slot, 0, sizeof(slot));
+	(void)memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
 	if (snd_mixer_oss_build_test_all(mixer, ptr, &slot))
 		return 0;
 	down_read(&mixer->card->controls_rwsem);
diff --git a/sound/core/oss/mulaw.c b/sound/core/oss/mulaw.c
index 7915564..9fbf6d4 100644
--- a/sound/core/oss/mulaw.c
+++ b/sound/core/oss/mulaw.c
@@ -160,7 +160,7 @@ static inline void cvt_s16_to_native(struct mulaw_priv *data,
 	if (data->cvt_endian)
 		sample = swab16(sample);
 	if (data->native_bytes > data->copy_bytes)
-		memset(dst, 0, data->native_bytes);
+		(void)memset(dst, 0, data->native_bytes);
 	memcpy(dst + data->native_ofs, (char *)&sample + data->copy_ofs,
 	       data->copy_bytes);
 }
diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
index 08fde00..8591064 100644
--- a/sound/core/oss/pcm_oss.c
+++ b/sound/core/oss/pcm_oss.c
@@ -987,7 +987,7 @@ static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)
 		goto failure;
 	}
 
-	memset(sw_params, 0, sizeof(*sw_params));
+	(void)memset(sw_params, 0, sizeof(*sw_params));
 	if (runtime->oss.trigger) {
 		sw_params->start_threshold = 1;
 	} else {
@@ -1668,7 +1668,7 @@ static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)
 				}
 			} else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {
 				void __user *buffers[runtime->channels];
-				memset(buffers, 0, runtime->channels * sizeof(void *));
+				(void)memset(buffers, 0, runtime->channels * sizeof(void *));
 				snd_pcm_lib_writev(substream, buffers, size);
 			}
 		}
@@ -2100,7 +2100,7 @@ static int snd_pcm_oss_get_ptr(struct snd_pcm_oss_file *pcm_oss_file, int stream
 		return err;
 	runtime = substream->runtime;
 	if (runtime->oss.params || runtime->oss.prepare) {
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		if (copy_to_user(_info, &info, sizeof(info)))
 			return -EFAULT;
 		return 0;
@@ -2410,7 +2410,7 @@ static int snd_pcm_oss_open(struct inode *inode, struct file *file)
 		err = -EFAULT;
 		goto __error;
 	}
-	memset(setup, 0, sizeof(setup));
+	(void)memset(setup, 0, sizeof(setup));
 	if (file->f_mode & FMODE_WRITE)
 		snd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 					   task_name, &setup[0]);
@@ -2632,7 +2632,7 @@ static long snd_pcm_oss_ioctl(struct file *file, unsigned int cmd, unsigned long
 		res = snd_pcm_oss_get_odelay(pcm_oss_file);
 		if (res < 0) {
 			/* it's for sure, some broken apps don't check for error codes */
-			put_user(0, p);
+			(void)put_user(0, p);
 			return res;
 		}
 		return put_user(res, p);
@@ -2747,7 +2747,7 @@ static unsigned int snd_pcm_oss_poll(struct file *file, poll_table * wait)
 		snd_pcm_stream_unlock_irq(csubstream);
 		if (ostate != SNDRV_PCM_STATE_RUNNING && runtime->oss.trigger) {
 			struct snd_pcm_oss_file ofile;
-			memset(&ofile, 0, sizeof(ofile));
+			(void)memset(&ofile, 0, sizeof(ofile));
 			ofile.streams[SNDRV_PCM_STREAM_CAPTURE] = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
 			runtime->oss.trigger = 0;
 			snd_pcm_oss_set_trigger(&ofile, PCM_ENABLE_INPUT);
@@ -2875,7 +2875,7 @@ static void snd_pcm_oss_proc_write(struct snd_info_entry *entry,
 
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
 		mutex_lock(&pstr->oss.setup_mutex);
-		memset(&template, 0, sizeof(template));
+		(void)memset(&template, 0, sizeof(template));
 		ptr = snd_info_get_str(task_name, line, sizeof(task_name));
 		if (!strcmp(task_name, "clear") || !strcmp(task_name, "erase")) {
 			snd_pcm_oss_proc_free_setup_list(pstr);
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8928ca87..20ae461 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -447,7 +447,7 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "closed\n");
 		goto unlock;
 	}
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	err = snd_pcm_status(substream, &status);
 	if (err < 0) {
 		snd_iprintf(buffer, "error %d\n", err);
@@ -899,7 +899,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->status, 0, size);
+	(void)memset((void*)runtime->status, 0, size);
 
 	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control));
 	runtime->control = snd_malloc_pages(size, GFP_KERNEL);
@@ -909,7 +909,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->control, 0, size);
+	(void)memset((void*)runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
 	init_waitqueue_head(&runtime->tsleep);
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3420bd3..3068060 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1151,7 +1151,7 @@ int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param
 	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
 	struct snd_mask *maskp = constrs_mask(constrs, var);
 	*maskp->bits &= mask;
-	memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
+	(void)memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
 	if (*maskp->bits == 0)
 		return -EINVAL;
 	return 0;
@@ -1172,7 +1172,7 @@ int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 	struct snd_mask *maskp = constrs_mask(constrs, var);
 	maskp->bits[0] &= (u_int32_t)mask;
 	maskp->bits[1] &= (u_int32_t)(mask >> 32);
-	memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
+	(void)memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
 	if (! maskp->bits[0] && ! maskp->bits[1])
 		return -EINVAL;
 	return 0;
@@ -1447,7 +1447,7 @@ static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
-	memset(params, 0, sizeof(*params));
+	(void)memset(params, 0, sizeof(*params));
 	for (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)
 		_snd_pcm_hw_param_any(params, k);
 	for (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)
diff --git a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
index 9571313..0316561 100644
--- a/sound/core/pcm_memory.c
+++ b/sound/core/pcm_memory.c
@@ -181,7 +181,7 @@ static void snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,
 		}
 		if (substream->dma_buffer.bytes == size)
 			return;
-		memset(&new_dmab, 0, sizeof(new_dmab));
+		(void)memset(&new_dmab, 0, sizeof(new_dmab));
 		new_dmab.dev = substream->dma_buffer.dev;
 		if (size > 0) {
 			if (snd_dma_alloc_pages(substream->dma_buffer.dev.type,
diff --git a/sound/core/pcm_misc.c b/sound/core/pcm_misc.c
index 9c9eff9..79ef4e4 100644
--- a/sound/core/pcm_misc.c
+++ b/sound/core/pcm_misc.c
@@ -397,7 +397,7 @@ int snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int
 	/* signed or 1 byte data */
 	if (pcm_formats[(INT)format].signd == 1 || width <= 8) {
 		unsigned int bytes = samples * width / 8;
-		memset(data, *pat, bytes);
+		(void)memset(data, *pat, bytes);
 		return 0;
 	}
 	/* non-zero samples, fill using a loop */
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 25ed9fe..b2d1aa5 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -99,7 +99,7 @@ int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info)
 	struct snd_pcm *pcm = substream->pcm;
 	struct snd_pcm_str *pstr = substream->pstr;
 
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->card = pcm->card->number;
 	info->device = pcm->device;
 	info->stream = substream->stream;
@@ -631,7 +631,7 @@ static int snd_pcm_status_user(struct snd_pcm_substream *substream,
 	struct snd_pcm_status status;
 	int res;
 	
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	res = snd_pcm_status(substream, &status);
 	if (res < 0)
 		return res;
@@ -656,7 +656,7 @@ static int snd_pcm_channel_info(struct snd_pcm_substream *substream,
 	snd_pcm_stream_unlock_irq(substream);
 	if (channel >= runtime->channels)
 		return -EINVAL;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->channel = channel;
 	return substream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_CHANNEL_INFO, info);
 }
@@ -2453,7 +2453,7 @@ static int snd_pcm_sync_ptr(struct snd_pcm_substream *substream,
 	volatile struct snd_pcm_mmap_control *control;
 	int err;
 
-	memset(&sync_ptr, 0, sizeof(sync_ptr));
+	(void)memset(&sync_ptr, 0, sizeof(sync_ptr));
 	if (get_user(sync_ptr.flags, (unsigned __user *)&(_sync_ptr->flags)))
 		return -EFAULT;
 	if (copy_from_user(&sync_ptr.c.control, &(_sync_ptr->c.control), sizeof(struct snd_pcm_mmap_control)))
@@ -2589,7 +2589,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (copy_from_user(&xferi, _xferi, sizeof(xferi)))
 			return -EFAULT;
 		result = snd_pcm_lib_write(substream, xferi.buf, xferi.frames);
-		__put_user(result, &_xferi->result);
+		(void)__put_user(result, &_xferi->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_WRITEN_FRAMES:
@@ -2614,7 +2614,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 			return PTR_ERR(bufs);
 		result = snd_pcm_lib_writev(substream, bufs, xfern.frames);
 		kfree(bufs);
-		__put_user(result, &_xfern->result);
+		(void)__put_user(result, &_xfern->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_REWIND:
@@ -2627,7 +2627,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_playback_rewind(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_FORWARD:
@@ -2640,7 +2640,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_playback_forward(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	}
@@ -2669,7 +2669,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (copy_from_user(&xferi, _xferi, sizeof(xferi)))
 			return -EFAULT;
 		result = snd_pcm_lib_read(substream, xferi.buf, xferi.frames);
-		__put_user(result, &_xferi->result);
+		(void)__put_user(result, &_xferi->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_READN_FRAMES:
@@ -2694,7 +2694,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 			return PTR_ERR(bufs);
 		result = snd_pcm_lib_readv(substream, bufs, xfern.frames);
 		kfree(bufs);
-		__put_user(result, &_xfern->result);
+		(void)__put_user(result, &_xfern->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_REWIND:
@@ -2707,7 +2707,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_capture_rewind(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_FORWARD:
@@ -2720,7 +2720,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_capture_forward(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	}
@@ -3309,7 +3309,7 @@ static void snd_pcm_hw_convert_from_old_params(struct snd_pcm_hw_params *params,
 {
 	unsigned int i;
 
-	memset(params, 0, sizeof(*params));
+	(void)memset(params, 0, sizeof(*params));
 	params->flags = oparams->flags;
 	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
 		params->masks[i].bits[0] = oparams->masks[i];
@@ -3328,7 +3328,7 @@ static void snd_pcm_hw_convert_to_old_params(struct snd_pcm_hw_params_old *opara
 {
 	unsigned int i;
 
-	memset(oparams, 0, sizeof(*oparams));
+	(void)memset(oparams, 0, sizeof(*oparams));
 	oparams->flags = params->flags;
 	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
 		oparams->masks[i] = params->masks[i].bits[0];
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index ebf6e49..8d5a76d 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -540,7 +540,7 @@ static int snd_rawmidi_info(struct snd_rawmidi_substream *substream,
 	if (substream == NULL)
 		return -ENODEV;
 	rmidi = substream->rmidi;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->card = rmidi->card->number;
 	info->device = rmidi->device;
 	info->subdevice = substream->number;
@@ -669,7 +669,7 @@ static int snd_rawmidi_output_status(struct snd_rawmidi_substream *substream,
 {
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
-	memset(status, 0, sizeof(*status));
+	(void)memset(status, 0, sizeof(*status));
 	status->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;
 	spin_lock_irq(&runtime->lock);
 	status->avail = runtime->avail;
@@ -682,7 +682,7 @@ static int snd_rawmidi_input_status(struct snd_rawmidi_substream *substream,
 {
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
-	memset(status, 0, sizeof(*status));
+	(void)memset(status, 0, sizeof(*status));
 	status->stream = SNDRV_RAWMIDI_STREAM_INPUT;
 	spin_lock_irq(&runtime->lock);
 	status->avail = runtime->avail;
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8e7561d..e57cca3 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -937,7 +937,7 @@ int snd_timer_global_register(struct snd_timer *timer)
 {
 	struct snd_device dev;
 
-	memset(&dev, 0, sizeof(dev));
+	(void)memset(&dev, 0, sizeof(dev));
 	dev.device_data = timer;
 	return snd_timer_dev_register(&dev);
 }
@@ -1192,7 +1192,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	struct timespec tstamp;
 	int prev, append = 0;
 
-	memset(&tstamp, 0, sizeof(tstamp));
+	(void)memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
 	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |
 			   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
@@ -1412,7 +1412,7 @@ static int snd_timer_user_ginfo(struct file *file,
 		return PTR_ERR(ginfo);
 
 	tid = ginfo->tid;
-	memset(ginfo, 0, sizeof(*ginfo));
+	(void)memset(ginfo, 0, sizeof(*ginfo));
 	ginfo->tid = tid;
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
@@ -1480,7 +1480,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	if (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))
 		return -EFAULT;
 	tid = gstatus.tid;
-	memset(&gstatus, 0, sizeof(gstatus));
+	(void)memset(&gstatus, 0, sizeof(gstatus));
 	gstatus.tid = tid;
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
@@ -1703,7 +1703,7 @@ static int snd_timer_user_status(struct file *file,
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	status.tstamp = tu->tstamp;
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
diff --git a/sound/core/vmaster.c b/sound/core/vmaster.c
index 130cfe6..2d27d81 100644
--- a/sound/core/vmaster.c
+++ b/sound/core/vmaster.c
@@ -374,7 +374,7 @@ struct snd_kcontrol *snd_ctl_make_virtual_master(char *name,
 	struct snd_kcontrol *kctl;
 	struct snd_kcontrol_new knew;
 
-	memset(&knew, 0, sizeof(knew));
+	(void)memset(&knew, 0, sizeof(knew));
 	knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	knew.name = name;
 	knew.info = master_info;
diff --git a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
index 9473fca..d78dace 100644
--- a/sound/pci/ac97/ac97_codec.c
+++ b/sound/pci/ac97/ac97_codec.c
@@ -2603,7 +2603,7 @@ static int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,
 			       const char *suffix)
 {
 	struct snd_ctl_elem_id id;
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	set_ctl_name(id.name, name, suffix);
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	return snd_ctl_remove_id(ac97->bus->card, &id);
@@ -2612,7 +2612,7 @@ static int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,
 static struct snd_kcontrol *ctl_find(struct snd_ac97 *ac97, const char *name, const char *suffix)
 {
 	struct snd_ctl_elem_id sid;
-	memset(&sid, 0, sizeof(sid));
+	(void)memset(&sid, 0, sizeof(sid));
 	set_ctl_name(sid.name, name, suffix);
 	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	return snd_ctl_find_id(ac97->bus->card, &sid);
diff --git a/sound/pci/ac97/ac97_patch.c b/sound/pci/ac97/ac97_patch.c
index a872d0a..3608c2fe 100644
--- a/sound/pci/ac97/ac97_patch.c
+++ b/sound/pci/ac97/ac97_patch.c
@@ -55,7 +55,7 @@ static void reset_tlv(struct snd_ac97 *ac97, const char *name,
 {
 	struct snd_ctl_elem_id sid;
 	struct snd_kcontrol *kctl;
-	memset(&sid, 0, sizeof(sid));
+	(void)memset(&sid, 0, sizeof(sid));
 	strcpy(sid.name, name);
 	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	kctl = snd_ctl_find_id(ac97->bus->card, &sid);
@@ -3429,7 +3429,7 @@ static struct snd_kcontrol *snd_ac97_find_mixer_ctl(struct snd_ac97 *ac97,
 						    const char *name)
 {
 	struct snd_ctl_elem_id id;
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	strcpy(id.name, name);
 	return snd_ctl_find_id(ac97->bus->card, &id);
diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index f1488fc..b8f64ae 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -458,9 +458,9 @@ int snd_ac97_pcm_assign(struct snd_ac97_bus *bus,
 	rpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);
 	if (rpcms == NULL)
 		return -ENOMEM;
-	memset(avail_slots, 0, sizeof(avail_slots));
-	memset(rate_table, 0, sizeof(rate_table));
-	memset(spdif_slots, 0, sizeof(spdif_slots));
+	(void)memset(avail_slots, 0, sizeof(avail_slots));
+	(void)memset(rate_table, 0, sizeof(rate_table));
+	(void)memset(spdif_slots, 0, sizeof(spdif_slots));
 	for (i = 0; i < 4; i++) {
 		codec = bus->codec[i];
 		if (!codec)
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b5ecf6d..34305ad 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -99,7 +99,7 @@ static int format_register_str(struct snd_soc_codec *codec,
 
 	/* since tmpbuf is allocated on the stack, warn the callers if they
 	 * try to abuse this function */
-	WARN_ON(len > 63);
+	(void)WARN_ON(len > 63);
 
 	/* +2 for ': ' and + 1 for '\n' */
 	if (wordsize + regsize + 2 + 1 != len)
@@ -107,7 +107,7 @@ static int format_register_str(struct snd_soc_codec *codec,
 
 	ret = snd_soc_read(codec, reg);
 	if (ret < 0) {
-		memset(regbuf, 'X', regsize);
+		(void)memset(regbuf, 'X', regsize);
 		regbuf[regsize] = '\0';
 	} else {
 		snprintf(regbuf, regsize + 1, "%.*x", regsize, ret);
diff --git a/sound/usb/clock.c b/sound/usb/clock.c
index 379baad..b7e4123 100644
--- a/sound/usb/clock.c
+++ b/sound/usb/clock.c
@@ -197,7 +197,7 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
 int snd_usb_clock_find_source(struct snd_usb_audio *chip, int entity_id)
 {
 	DECLARE_BITMAP(visited, 256);
-	memset(visited, 0, sizeof(visited));
+	(void)memset(visited, 0, sizeof(visited));
 	return __uac_clock_find_source(chip, entity_id, visited);
 }
 
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index c83f614..5a17f37 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -868,7 +868,7 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 		return;
 	}
 
-	memset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);
+	(void)memset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);
 	urb->transfer_buffer_length = ep->max_transfer;
 }
 
@@ -2120,7 +2120,7 @@ int snd_usbmidi_create(struct snd_card *card,
 	umidi->error_timer.data = (unsigned long)umidi;
 
 	/* detect the endpoint(s) to use */
-	memset(endpoints, 0, sizeof(endpoints));
+	(void)memset(endpoints, 0, sizeof(endpoints));
 	switch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {
 	case QUIRK_MIDI_STANDARD_INTERFACE:
 		err = snd_usbmidi_get_ms_info(umidi, endpoints);
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index ab23869..e9c9664 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -324,7 +324,7 @@ static int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request, int v
 		size = sizeof(buf);
 	}
 
-	memset(buf, 0, sizeof(buf));
+	(void)memset(buf, 0, sizeof(buf));
 
 	ret = snd_usb_autoresume(chip) ? -EIO : 0;
 	if (ret)
@@ -647,7 +647,7 @@ static int check_input_term(struct mixer_build *state, int id, struct usb_audio_
 	int err;
 	void *p1;
 
-	memset(term, 0, sizeof(*term));
+	(void)memset(term, 0, sizeof(*term));
 	while ((p1 = find_audio_control_unit(state, id)) != NULL) {
 		unsigned char *hdr = p1;
 		term->id = id;
@@ -1961,7 +1961,7 @@ static int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)
 	const struct usbmix_ctl_map *map;
 	void *p;
 
-	memset(&state, 0, sizeof(state));
+	(void)memset(&state, 0, sizeof(state));
 	state.chip = mixer->chip;
 	state.mixer = mixer;
 	state.buffer = mixer->hostif->extra;
