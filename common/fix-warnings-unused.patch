diff --git a/arch/arm/nwfpe/fpa11_cpdt.c b/arch/arm/nwfpe/fpa11_cpdt.c
index d31c49f..e9fcbaa 100644
--- a/arch/arm/nwfpe/fpa11_cpdt.c
+++ b/arch/arm/nwfpe/fpa11_cpdt.c
@@ -32,7 +32,7 @@ static inline void loadSingle(const unsigned int Fn, const unsigned int __user *
 {
 	FPA11 *fpa11 = GET_FPA11();
 	fpa11->fType[Fn] = typeSingle;
-	get_user(fpa11->fpreg[Fn].fSingle, pMem);
+	(void)get_user(fpa11->fpreg[Fn].fSingle, pMem);
 }
 
 static inline void loadDouble(const unsigned int Fn, const unsigned int __user *pMem)
@@ -42,11 +42,11 @@ static inline void loadDouble(const unsigned int Fn, const unsigned int __user *
 	p = (unsigned int *) &fpa11->fpreg[Fn].fDouble;
 	fpa11->fType[Fn] = typeDouble;
 #ifdef __ARMEB__
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
-	get_user(p[1], &pMem[1]);
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[1], &pMem[1]);
 #else
-	get_user(p[0], &pMem[1]);
-	get_user(p[1], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[1]);
+	(void)get_user(p[1], &pMem[0]);	/* sign & exponent */
 #endif
 }
 
@@ -57,13 +57,13 @@ static inline void loadExtended(const unsigned int Fn, const unsigned int __user
 	unsigned int *p;
 	p = (unsigned int *) &fpa11->fpreg[Fn].fExtended;
 	fpa11->fType[Fn] = typeExtended;
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
 #ifdef __ARMEB__
-	get_user(p[1], &pMem[1]);	/* ms bits */
-	get_user(p[2], &pMem[2]);	/* ls bits */
+	(void)get_user(p[1], &pMem[1]);	/* ms bits */
+	(void)get_user(p[2], &pMem[2]);	/* ls bits */
 #else
-	get_user(p[1], &pMem[2]);	/* ls bits */
-	get_user(p[2], &pMem[1]);	/* ms bits */
+	(void)get_user(p[1], &pMem[2]);	/* ls bits */
+	(void)get_user(p[2], &pMem[1]);	/* ms bits */
 #endif
 }
 #endif
@@ -75,15 +75,15 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 	unsigned long x;
 
 	p = (unsigned int *) &(fpa11->fpreg[Fn]);
-	get_user(x, &pMem[0]);
+	(void)get_user(x, &pMem[0]);
 	fpa11->fType[Fn] = (x >> 14) & 0x00000003;
 
 	switch (fpa11->fType[Fn]) {
 	case typeSingle:
 	case typeDouble:
 		{
-			get_user(p[0], &pMem[2]);	/* Single */
-			get_user(p[1], &pMem[1]);	/* double msw */
+			(void)get_user(p[0], &pMem[2]);	/* Single */
+			(void)get_user(p[1], &pMem[1]);	/* double msw */
 			p[2] = 0;			/* empty */
 		}
 		break;
@@ -91,8 +91,8 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			get_user(p[1], &pMem[2]);
-			get_user(p[2], &pMem[1]);	/* msw */
+			(void)get_user(p[1], &pMem[2]);
+			(void)get_user(p[2], &pMem[1]);	/* msw */
 			p[0] = (x & 0x80003fff);
 		}
 		break;
@@ -123,7 +123,7 @@ static inline void storeSingle(struct roundingData *roundData, const unsigned in
 		val.f = fpa11->fpreg[Fn].fSingle;
 	}
 
-	put_user(val.i[0], pMem);
+	(void)put_user(val.i[0], pMem);
 }
 
 static inline void storeDouble(struct roundingData *roundData, const unsigned int Fn, unsigned int __user *pMem)
@@ -150,11 +150,11 @@ static inline void storeDouble(struct roundingData *roundData, const unsigned in
 	}
 
 #ifdef __ARMEB__
-	put_user(val.i[0], &pMem[0]);	/* msw */
-	put_user(val.i[1], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[0], &pMem[0]);	/* msw */
+	(void)put_user(val.i[1], &pMem[1]);	/* lsw */
 #else
-	put_user(val.i[1], &pMem[0]);	/* msw */
-	put_user(val.i[0], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[1], &pMem[0]);	/* msw */
+	(void)put_user(val.i[0], &pMem[1]);	/* lsw */
 #endif
 }
 
@@ -180,13 +180,13 @@ static inline void storeExtended(const unsigned int Fn, unsigned int __user *pMe
 		val.f = fpa11->fpreg[Fn].fExtended;
 	}
 
-	put_user(val.i[0], &pMem[0]);	/* sign & exp */
+	(void)put_user(val.i[0], &pMem[0]);	/* sign & exp */
 #ifdef __ARMEB__
-	put_user(val.i[1], &pMem[1]);	/* msw */
-	put_user(val.i[2], &pMem[2]);
+	(void)put_user(val.i[1], &pMem[1]);	/* msw */
+	(void)put_user(val.i[2], &pMem[2]);
 #else
-	put_user(val.i[1], &pMem[2]);
-	put_user(val.i[2], &pMem[1]);	/* msw */
+	(void)put_user(val.i[1], &pMem[2]);
+	(void)put_user(val.i[2], &pMem[1]);	/* msw */
 #endif
 }
 #endif
@@ -203,18 +203,18 @@ static inline void storeMultiple(const unsigned int Fn, unsigned int __user *pMe
 	case typeSingle:
 	case typeDouble:
 		{
-			put_user(p[0], &pMem[2]);	/* single */
-			put_user(p[1], &pMem[1]);	/* double msw */
-			put_user(nType << 14, &pMem[0]);
+			(void)put_user(p[0], &pMem[2]);	/* single */
+			(void)put_user(p[1], &pMem[1]);	/* double msw */
+			(void)put_user(nType << 14, &pMem[0]);
 		}
 		break;
 
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			put_user(p[2], &pMem[1]);	/* msw */
-			put_user(p[1], &pMem[2]);
-			put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
+			(void)put_user(p[2], &pMem[1]);	/* msw */
+			(void)put_user(p[1], &pMem[2]);
+			(void)put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
 		}
 		break;
 #endif
diff --git a/arch/arm/nwfpe/softfloat-macros b/arch/arm/nwfpe/softfloat-macros
index cf2a617..d7136f3 100644
--- a/arch/arm/nwfpe/softfloat-macros
+++ b/arch/arm/nwfpe/softfloat-macros
@@ -568,7 +568,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
         z = LIT64( 0xFFFFFFFF00000000 );
     }  else {
         z = a0;
-        do_div( z, b0 );
+        (void)do_div( z, b0 );
         z <<= 32;
     }
     mul64To128( b, z, &term0, &term1 );
@@ -582,7 +582,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
     if ( b0<<32 <= rem0 ) {
         z |= 0xFFFFFFFF;
     } else {
-        do_div( rem0, b0 );
+        (void)do_div( rem0, b0 );
         z |= rem0;
     }
     return z;
@@ -627,7 +627,7 @@ static bits32 estimateSqrt32( int16 aExp, bits32 a )
         if ( z <= a ) return (bits32) ( ( (sbits32) a )>>1 );
     }
     A = ( (bits64) a )<<31;
-    do_div( A, z );
+    (void)do_div( A, z );
     return ( (bits32) A ) + ( z>>1 );
 
 }
diff --git a/include/linux/bitmap.h b/include/linux/bitmap.h
index 7ad6345..ad78dba 100644
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -162,7 +162,7 @@ static inline void bitmap_zero(unsigned long *dst, int nbits)
 		*dst = 0UL;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memset(dst, 0, len);
+		(void)memset(dst, 0, len);
 	}
 }
 
@@ -171,7 +171,7 @@ static inline void bitmap_fill(unsigned long *dst, int nbits)
 	size_t nlongs = BITS_TO_LONGS(nbits);
 	if (!small_const_nbits(nbits)) {
 		int len = (nlongs - 1) * sizeof(unsigned long);
-		memset(dst, 0xff,  len);
+		(void)memset(dst, 0xff,  len);
 	}
 	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
 }
@@ -183,7 +183,7 @@ static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
 		*dst = *src;
 	else {
 		int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-		memcpy(dst, src, len);
+		(void)memcpy(dst, src, len);
 	}
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 6c6a1f0..d69f132 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -448,7 +448,7 @@ static inline void queue_flag_set_unlocked(unsigned int flag,
 static inline int queue_flag_test_and_clear(unsigned int flag,
 					    struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (test_bit(flag, &q->queue_flags)) {
 		__clear_bit(flag, &q->queue_flags);
@@ -461,7 +461,7 @@ static inline int queue_flag_test_and_clear(unsigned int flag,
 static inline int queue_flag_test_and_set(unsigned int flag,
 					  struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 
 	if (!test_bit(flag, &q->queue_flags)) {
 		__set_bit(flag, &q->queue_flags);
@@ -473,7 +473,7 @@ static inline int queue_flag_test_and_set(unsigned int flag,
 
 static inline void queue_flag_set(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__set_bit(flag, &q->queue_flags);
 }
 
@@ -490,7 +490,7 @@ static inline int queue_in_flight(struct request_queue *q)
 
 static inline void queue_flag_clear(unsigned int flag, struct request_queue *q)
 {
-	WARN_ON_ONCE(!queue_is_locked(q));
+	(void)WARN_ON_ONCE(!queue_is_locked(q));
 	__clear_bit(flag, &q->queue_flags);
 }
 
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 81e803e..b945988 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -123,7 +123,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 {
 	uint64_t tmp = ((uint64_t)ticks) << shift;
 
-	do_div(tmp, nsec);
+	(void)do_div(tmp, nsec);
 	return (unsigned long) tmp;
 }
 
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index fe23ee7..b83a7e9 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -315,7 +315,7 @@ static inline void part_stat_set_all(struct hd_struct *part, int value)
 	int i;
 
 	for_each_possible_cpu(i)
-		memset(per_cpu_ptr(part->dkstats, i), value,
+		(void)memset(per_cpu_ptr(part->dkstats, i), value,
 				sizeof(struct disk_stats));
 }
 
@@ -343,7 +343,7 @@ static inline void free_part_stats(struct hd_struct *part)
 
 static inline void part_stat_set_all(struct hd_struct *part, int value)
 {
-	memset(&part->dkstats, value, sizeof(struct disk_stats));
+	(void)memset(&part->dkstats, value, sizeof(struct disk_stats));
 }
 
 static inline int init_part_stats(struct hd_struct *part)
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 581e74b..79bfd6e 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -151,7 +151,7 @@ struct vm_area_struct;
 /* Convert GFP flags to their corresponding migrate type */
 static inline int allocflags_to_migratetype(gfp_t gfp_flags)
 {
-	WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
+	(void)WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 
 	if (unlikely(page_group_by_mobility_disabled))
 		return MIGRATE_UNMOVABLE;
diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index 3a93f73..63ed5d1 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -181,7 +181,7 @@ alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
 static inline void clear_highpage(struct page *page)
 {
 	void *kaddr = kmap_atomic(page, KM_USER0);
-	clear_page(kaddr);
+	(void)clear_page(kaddr);
 	kunmap_atomic(kaddr, KM_USER0);
 }
 
@@ -194,10 +194,10 @@ static inline void zero_user_segments(struct page *page,
 	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);
 
 	if (end1 > start1)
-		memset(kaddr + start1, 0, end1 - start1);
+		(void)memset(kaddr + start1, 0, end1 - start1);
 
 	if (end2 > start2)
-		memset(kaddr + start2, 0, end2 - start2);
+		(void)memset(kaddr + start2, 0, end2 - start2);
 
 	kunmap_atomic(kaddr, KM_USER0);
 	flush_dcache_page(page);
diff --git a/include/linux/irqflags.h b/include/linux/irqflags.h
index d176d65..c02806e 100644
--- a/include/linux/irqflags.h
+++ b/include/linux/irqflags.h
@@ -60,22 +60,22 @@
 #define raw_local_irq_enable()		arch_local_irq_enable()
 #define raw_local_irq_save(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_irq_save();		\
 	} while (0)
 #define raw_local_irq_restore(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_local_irq_restore(flags);		\
 	} while (0)
 #define raw_local_save_flags(flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = arch_local_save_flags();	\
 	} while (0)
 #define raw_irqs_disabled_flags(flags)			\
 	({						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		arch_irqs_disabled_flags(flags);	\
 	})
 #define raw_irqs_disabled()		(arch_irqs_disabled())
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0eac07c..c4fced5 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1323,8 +1323,8 @@ static inline
 void netdev_reset_tc(struct net_device *dev)
 {
 	dev->num_tc = 0;
-	memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
-	memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
+	(void)memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq));
+	(void)memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map));
 }
 
 static inline
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 52e4895..31f3eb6 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -250,7 +250,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
 	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
-		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
+		(void)memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 
diff --git a/include/linux/poll.h b/include/linux/poll.h
index cf40010..5273a23 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -110,7 +110,7 @@ int get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 	if (ufdset)
 		return copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;
 
-	memset(fdset, 0, nr);
+	(void)memset(fdset, 0, nr);
 	return 0;
 }
 
@@ -125,7 +125,7 @@ set_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)
 static inline
 void zero_fd_set(unsigned long nr, unsigned long *fdset)
 {
-	memset(fdset, 0, FDS_BYTES(nr));
+	(void)memset(fdset, 0, FDS_BYTES(nr));
 }
 
 #define MAX_INT64_SECONDS (((s64)(~((u64)0)>>1)/HZ)-1)
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index c2f1f6a..d52e4ca 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -363,7 +363,7 @@ extern void user_single_step_siginfo(struct task_struct *tsk,
 static inline void user_single_step_siginfo(struct task_struct *tsk,
 				struct pt_regs *regs, siginfo_t *info)
 {
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->si_signo = SIGTRAP;
 }
 #endif
diff --git a/include/linux/regset.h b/include/linux/regset.h
index 8abee65..3c3e979 100644
--- a/include/linux/regset.h
+++ b/include/linux/regset.h
@@ -283,7 +283,7 @@ static inline int user_regset_copyout_zero(unsigned int *pos,
 		unsigned int copy = (end_pos < 0 ? *count
 				     : min(*count, end_pos - *pos));
 		if (*kbuf) {
-			memset(*kbuf, 0, copy);
+			(void)memset(*kbuf, 0, copy);
 			*kbuf += copy;
 		} else if (__clear_user(*ubuf, copy))
 			return -EFAULT;
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index 8e872ea..4a5eb58 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -732,7 +732,7 @@ __rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 	return rta;
 }
 
diff --git a/include/linux/security.h b/include/linux/security.h
index 83c18e8..2dae9d0 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1898,13 +1898,13 @@ static inline int security_settime(const struct timespec *ts,
 
 static inline int security_vm_enough_memory(long pages)
 {
-	WARN_ON(current->mm == NULL);
+	(void)WARN_ON(current->mm == NULL);
 	return cap_vm_enough_memory(current->mm, pages);
 }
 
 static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	WARN_ON(mm == NULL);
+	(void)WARN_ON(mm == NULL);
 	return cap_vm_enough_memory(mm, pages);
 }
 
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7987ce74..2256c0a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -159,7 +159,7 @@ static inline void sigemptyset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, 0, sizeof(sigset_t));
+		(void)memset(set, 0, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1:	set->sig[0] = 0;
@@ -171,7 +171,7 @@ static inline void sigfillset(sigset_t *set)
 {
 	switch (_NSIG_WORDS) {
 	default:
-		memset(set, -1, sizeof(sigset_t));
+		(void)memset(set, -1, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1:	set->sig[0] = -1;
@@ -201,7 +201,7 @@ static inline void siginitset(sigset_t *set, unsigned long mask)
 	set->sig[0] = mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = 0;
 	case 1: ;
@@ -213,7 +213,7 @@ static inline void siginitsetinv(sigset_t *set, unsigned long mask)
 	set->sig[0] = ~mask;
 	switch (_NSIG_WORDS) {
 	default:
-		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
+		(void)memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
 		break;
 	case 2: set->sig[1] = -1;
 	case 1: ;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 50db9b0..622c720 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -510,7 +510,7 @@ static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
 	/* If refdst was not refcounted, check we still are in a 
 	 * rcu_read_lock section
 	 */
-	WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
+	(void)WARN_ON((skb->_skb_refdst & SKB_DST_NOREF) &&
 		!rcu_read_lock_held() &&
 		!rcu_read_lock_bh_held());
 	return (struct dst_entry *)(skb->_skb_refdst & SKB_DST_PTRMASK);
@@ -1543,7 +1543,7 @@ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 {
 	if (unlikely(skb_is_nonlinear(skb))) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	skb->len = len;
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 7df6c17..b58581b 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -175,7 +175,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 # define raw_spin_lock_nest_lock(lock, nest_lock)			\
 	 do {								\
-		 typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
+		 (void)typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
 		 _raw_spin_lock_nest_lock(lock, &(nest_lock)->dep_map);	\
 	 } while (0)
 #else
@@ -187,20 +187,20 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)			\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		flags = _raw_spin_lock_irqsave(lock);	\
 	} while (0)
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave_nested(lock, subclass);	\
 	} while (0)
 #else
 #define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\
 	do {								\
-		typecheck(unsigned long, flags);			\
+		(void)typecheck(unsigned long, flags);			\
 		flags = _raw_spin_lock_irqsave(lock);			\
 	} while (0)
 #endif
@@ -209,7 +209,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_lock_irqsave(lock, flags)		\
 	do {						\
-		typecheck(unsigned long, flags);	\
+		(void)typecheck(unsigned long, flags);	\
 		_raw_spin_lock_irqsave(lock, flags);	\
 	} while (0)
 
@@ -225,7 +225,7 @@ static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
 
 #define raw_spin_unlock_irqrestore(lock, flags)		\
 	do {							\
-		typecheck(unsigned long, flags);		\
+		(void)typecheck(unsigned long, flags);		\
 		_raw_spin_unlock_irqrestore(lock, flags);	\
 	} while (0)
 #define raw_spin_unlock_bh(lock)	_raw_spin_unlock_bh(lock)
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 65efb92..35ca2a3 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -181,7 +181,7 @@ extern void zone_statistics(struct zone *, struct zone *, gfp_t gfp);
 
 static inline void zap_zone_vm_stats(struct zone *zone)
 {
-	memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
+	(void)memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
 }
 
 extern void inc_zone_state(struct zone *, enum zone_stat_item);
diff --git a/include/net/dst.h b/include/net/dst.h
index 344c8dd..cbae81d 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -173,7 +173,7 @@ dst_metric_raw(const struct dst_entry *dst, const int metric)
 static inline u32
 dst_metric(const struct dst_entry *dst, const int metric)
 {
-	WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
+	(void)WARN_ON_ONCE(metric == RTAX_HOPLIMIT ||
 		     metric == RTAX_ADVMSS ||
 		     metric == RTAX_MTU);
 	return dst_metric_raw(dst, metric);
@@ -303,7 +303,7 @@ static inline void skb_dst_copy(struct sk_buff *nskb, const struct sk_buff *oskb
 static inline void skb_dst_force(struct sk_buff *skb)
 {
 	if (skb_dst_is_noref(skb)) {
-		WARN_ON(!rcu_read_lock_held());
+		(void)WARN_ON(!rcu_read_lock_held());
 		skb->_skb_refdst &= ~SKB_DST_NOREF;
 		dst_clone(skb_dst(skb));
 	}
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index dbf9aab..0bb043e 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -172,7 +172,7 @@ static inline int inet_csk_ack_scheduled(const struct sock *sk)
 
 static inline void inet_csk_delack_init(struct sock *sk)
 {
-	memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
+	(void)memset(&inet_csk(sk)->icsk_ack, 0, sizeof(inet_csk(sk)->icsk_ack));
 }
 
 extern void inet_csk_delete_keepalive_timer(struct sock *sk);
diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index 06b795d..52ac08a 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -102,7 +102,7 @@ extern bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);
  */
 static inline void inet_peer_refcheck(const struct inet_peer *p)
 {
-	WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
+	(void)WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
 }
 
 
diff --git a/include/net/ip.h b/include/net/ip.h
index 775009f..52a58a8 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -384,7 +384,7 @@ static inline int sk_mc_loop(struct sock *sk)
 		return inet6_sk(sk)->mc_loop;
 #endif
 	}
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 1;
 }
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index e4170a2..7081938 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -317,7 +317,7 @@ static inline void ipv6_addr_prefix(struct in6_addr *pfx,
 	int o = plen >> 3,
 	    b = plen & 0x7;
 
-	memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
+	(void)memset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));
 	memcpy(pfx->s6_addr, addr, o);
 	if (b != 0)
 		pfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);
diff --git a/include/net/netlabel.h b/include/net/netlabel.h
index f674409..6b50c2a 100644
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@ -303,7 +303,7 @@ static inline void netlbl_secattr_catmap_free(
  */
 static inline void netlbl_secattr_init(struct netlbl_lsm_secattr *secattr)
 {
-	memset(secattr, 0, sizeof(*secattr));
+	(void)memset(secattr, 0, sizeof(*secattr));
 }
 
 /**
diff --git a/include/net/request_sock.h b/include/net/request_sock.h
index 4c0766e..2c68508 100644
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@ -181,7 +181,7 @@ static inline struct request_sock *reqsk_queue_remove(struct request_sock_queue
 {
 	struct request_sock *req = queue->rskq_accept_head;
 
-	WARN_ON(req == NULL);
+	(void)WARN_ON(req == NULL);
 
 	queue->rskq_accept_head = req->dl_next;
 	if (queue->rskq_accept_head == NULL)
@@ -196,7 +196,7 @@ static inline struct sock *reqsk_queue_get_child(struct request_sock_queue *queu
 	struct request_sock *req = reqsk_queue_remove(queue);
 	struct sock *child = req->sk;
 
-	WARN_ON(child == NULL);
+	(void)WARN_ON(child == NULL);
 
 	sk_acceptq_removed(parent);
 	__reqsk_free(req);
diff --git a/include/net/route.h b/include/net/route.h
index 91855d1..8e809d7 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -156,7 +156,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->flowi4_oif = oif;
 	fl4->daddr = daddr;
 	fl4->saddr = saddr;
diff --git a/include/net/sock.h b/include/net/sock.h
index bb972d2..54d7904 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -474,7 +474,7 @@ static __inline__ int sk_del_node_init(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
diff --git a/init/do_mounts_rd.c b/init/do_mounts_rd.c
index 887629e..a1c76ef 100644
--- a/init/do_mounts_rd.c
+++ b/init/do_mounts_rd.c
@@ -71,7 +71,7 @@ identify_ramdisk_image(int fd, int start_block, decompress_fn *decompressor)
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
 	squashfsb = (struct squashfs_super_block *) buf;
-	memset(buf, 0xe5, size);
+	(void)memset(buf, 0xe5, size);
 
 	/*
 	 * Read block 0 to test for compressed kernel
diff --git a/init/initramfs.c b/init/initramfs.c
index 8216c30..5e6b06b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -507,7 +507,7 @@ static void __init free_initrd(void)
 		 * Initialize initrd memory region since the kexec boot does
 		 * not do.
 		 */
-		memset((void *)initrd_start, 0, initrd_end - initrd_start);
+		(void)memset((void *)initrd_start, 0, initrd_end - initrd_start);
 		if (initrd_start < crashk_start)
 			free_initrd_mem(initrd_start, crashk_start);
 		if (initrd_end > crashk_end)
@@ -530,11 +530,11 @@ static void __init clean_rootfs(void)
 	int num;
 
 	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
-	WARN_ON(fd < 0);
+	(void)WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
 	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
-	WARN_ON(!buf);
+	(void)WARN_ON(!buf);
 	if (!buf) {
 		sys_close(fd);
 		return;
@@ -548,7 +548,7 @@ static void __init clean_rootfs(void)
 			int ret;
 
 			ret = sys_newlstat(dirp->d_name, &st);
-			WARN_ON_ONCE(ret);
+			(void)WARN_ON_ONCE(ret);
 			if (!ret) {
 				if (S_ISDIR(st.st_mode))
 					sys_rmdir(dirp->d_name);
@@ -560,7 +560,7 @@ static void __init clean_rootfs(void)
 			dirp = (void *)dirp + dirp->d_reclen;
 		}
 		dirp = buf;
-		memset(buf, 0, BUF_SIZE);
+		(void)memset(buf, 0, BUF_SIZE);
 		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index e66e9b6..d365326 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -348,7 +348,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	int len;
 
 	if (env->envp_idx >= ARRAY_SIZE(env->envp)) {
-		WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
 		return -ENOMEM;
 	}
 
@@ -359,7 +359,7 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 	va_end(args);
 
 	if (len >= (sizeof(env->buf) - env->buflen)) {
-		WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
+		(void)WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
 		return -ENOMEM;
 	}
 
diff --git a/lib/plist.c b/lib/plist.c
index a0a4da4..5117cd1 100644
--- a/lib/plist.c
+++ b/lib/plist.c
@@ -33,7 +33,7 @@ static struct plist_head test_head;
 static void plist_check_prev_next(struct list_head *t, struct list_head *p,
 				  struct list_head *n)
 {
-	WARN(n->prev != p || p->next != n,
+	(void)WARN(n->prev != p || p->next != n,
 			"top: %p, n: %p, p: %p\n"
 			"prev: %p, n: %p, p: %p\n"
 			"next: %p, n: %p, p: %p\n",
@@ -77,8 +77,8 @@ void plist_add(struct plist_node *node, struct plist_head *head)
 	struct list_head *node_next = &head->node_list;
 
 	plist_check_head(head);
-	WARN_ON(!plist_node_empty(node));
-	WARN_ON(!list_empty(&node->prio_list));
+	(void)WARN_ON(!plist_node_empty(node));
+	(void)WARN_ON(!list_empty(&node->prio_list));
 
 	if (plist_head_empty(head))
 		goto ins_node;
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index 4ceb05d..af9e1f7 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -84,7 +84,7 @@ EXPORT_SYMBOL(sg_last);
  **/
 void sg_init_table(struct scatterlist *sgl, unsigned int nents)
 {
-	memset(sgl, 0, sizeof(*sgl) * nents);
+	(void)memset(sgl, 0, sizeof(*sgl) * nents);
 #ifdef CONFIG_DEBUG_SG
 	{
 		unsigned int i;
@@ -232,7 +232,7 @@ int __sg_alloc_table(struct sg_table *table, unsigned int nents,
 	BUG_ON(nents > max_ents);
 #endif
 
-	memset(table, 0, sizeof(*table));
+	(void)memset(table, 0, sizeof(*table));
 
 	left = nents;
 	prv = NULL;
@@ -333,12 +333,12 @@ EXPORT_SYMBOL(sg_alloc_table);
 void sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
 		    unsigned int nents, unsigned int flags)
 {
-	memset(miter, 0, sizeof(struct sg_mapping_iter));
+	(void)memset(miter, 0, sizeof(struct sg_mapping_iter));
 
 	miter->__sg = sgl;
 	miter->__nents = nents;
 	miter->__offset = 0;
-	WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
+	(void)WARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));
 	miter->__flags = flags;
 }
 EXPORT_SYMBOL(sg_miter_start);
@@ -413,7 +413,7 @@ EXPORT_SYMBOL(sg_miter_next);
  */
 void sg_miter_stop(struct sg_mapping_iter *miter)
 {
-	WARN_ON(miter->consumed > miter->length);
+	(void)WARN_ON(miter->consumed > miter->length);
 
 	/* drop resources from the last iteration */
 	if (miter->addr) {
@@ -423,7 +423,7 @@ void sg_miter_stop(struct sg_mapping_iter *miter)
 			flush_kernel_dcache_page(miter->page);
 
 		if (miter->__flags & SG_MITER_ATOMIC) {
-			WARN_ON(!irqs_disabled());
+			(void)WARN_ON(!irqs_disabled());
 			kunmap_atomic(miter->addr, KM_BIO_SRC_IRQ);
 		} else
 			kunmap(miter->page);
diff --git a/lib/timerqueue.c b/lib/timerqueue.c
index 191176a..e520c72 100644
--- a/lib/timerqueue.c
+++ b/lib/timerqueue.c
@@ -42,7 +42,7 @@ void timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)
 	struct timerqueue_node  *ptr;
 
 	/* Make sure we don't add nodes that are already added */
-	WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));
 
 	while (*p) {
 		parent = *p;
@@ -70,7 +70,7 @@ EXPORT_SYMBOL_GPL(timerqueue_add);
  */
 void timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
 {
-	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
+	(void)WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
 
 	/* update next pointer */
 	if (head->next == node) {
diff --git a/net/core/filter.c b/net/core/filter.c
index 5dea452..041dabf 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -351,7 +351,7 @@ load_b:
 			continue;
 		}
 		default:
-			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
+			(void)WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 				       fentry->code, fentry->jt,
 				       fentry->jf, fentry->k);
 			return 0;
@@ -380,7 +380,7 @@ static int check_load_and_stores(struct sock_filter *filter, int flen)
 	masks = kmalloc(flen * sizeof(*masks), GFP_KERNEL);
 	if (!masks)
 		return -ENOMEM;
-	memset(masks, 0xff, flen * sizeof(*masks));
+	(void)memset(masks, 0xff, flen * sizeof(*masks));
 
 	for (pc = 0; pc < flen; pc++) {
 		memvalid &= masks[pc];
diff --git a/net/core/flow.c b/net/core/flow.c
index e318c7e..c848334 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -430,7 +430,7 @@ static int __init flow_cache_init(struct flow_cache *fc)
 	fc->hotcpu_notifier = (struct notifier_block){
 		.notifier_call = flow_cache_cpu,
 	};
-	register_hotcpu_notifier(&fc->hotcpu_notifier);
+	(void)register_hotcpu_notifier(&fc->hotcpu_notifier);
 
 	setup_timer(&fc->rnd_timer, flow_cache_new_hashrnd,
 		    (unsigned long) fc);
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index a1727cd..2ab3e1b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -338,7 +338,7 @@ static ssize_t netstat_show(const struct device *d,
 	struct net_device *dev = to_net_dev(d);
 	ssize_t ret = -EINVAL;
 
-	WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
+	(void)WARN_ON(offset > sizeof(struct rtnl_link_stats64) ||
 			offset % sizeof(u64) != 0);
 
 	read_lock(&dev_base_lock);
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index a246836..c98e70b 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -105,7 +105,7 @@ int eth_header(struct sk_buff *skb, struct net_device *dev,
 	 */
 
 	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		memset(eth->h_dest, 0, ETH_ALEN);
+		(void)memset(eth->h_dest, 0, ETH_ALEN);
 		return ETH_HLEN;
 	}
 
@@ -342,7 +342,7 @@ void ether_setup(struct net_device *dev)
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 	dev->priv_flags		|= IFF_TX_SKB_SHARING;
 
-	memset(dev->broadcast, 0xFF, ETH_ALEN);
+	(void)memset(dev->broadcast, 0xFF, ETH_ALEN);
 
 }
 EXPORT_SYMBOL(ether_setup);
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 59402be..41a94dd 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -670,7 +670,7 @@ struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
 	if (target_hw != NULL)
 		memcpy(arp_ptr, target_hw, dev->addr_len);
 	else
-		memset(arp_ptr, 0, dev->addr_len);
+		(void)memset(arp_ptr, 0, dev->addr_len);
 	arp_ptr += dev->addr_len;
 	memcpy(arp_ptr, &dest_ip, 4);
 
@@ -958,7 +958,7 @@ static int arp_rcv(struct sk_buff *skb, struct net_device *dev,
 	if (skb == NULL)
 		goto out_of_mem;
 
-	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
+	(void)memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
 	return NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process);
 
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 2e4e244..f7f1f0c 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -201,7 +201,7 @@ tb_not_found:
 success:
 	if (!inet_csk(sk)->icsk_bind_hash)
 		inet_bind_hash(sk, tb, snum);
-	WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
+	(void)WARN_ON(inet_csk(sk)->icsk_bind_hash != tb);
 	ret = 0;
 
 fail_unlock:
@@ -293,7 +293,7 @@ struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)
 	}
 
 	newsk = reqsk_queue_get_child(&icsk->icsk_accept_queue, sk);
-	WARN_ON(newsk->sk_state == TCP_SYN_RECV);
+	(void)WARN_ON(newsk->sk_state == TCP_SYN_RECV);
 out:
 	release_sock(sk);
 	return newsk;
@@ -443,7 +443,7 @@ struct request_sock *inet_csk_search_req(const struct sock *sk,
 		    ireq->rmt_addr == raddr &&
 		    ireq->loc_addr == laddr &&
 		    AF_INET_FAMILY(req->rsk_ops->family)) {
-			WARN_ON(req->sk);
+			(void)WARN_ON(req->sk);
 			*prevp = prev;
 			break;
 		}
@@ -618,7 +618,7 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,
 		newicsk->icsk_probes_out  = 0;
 
 		/* Deinitialize accept_queue to trap illegal accesses. */
-		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
+		(void)memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));
 
 		security_inet_csk_clone(newsk, req);
 	}
@@ -634,14 +634,14 @@ EXPORT_SYMBOL_GPL(inet_csk_clone_lock);
  */
 void inet_csk_destroy_sock(struct sock *sk)
 {
-	WARN_ON(sk->sk_state != TCP_CLOSE);
-	WARN_ON(!sock_flag(sk, SOCK_DEAD));
+	(void)WARN_ON(sk->sk_state != TCP_CLOSE);
+	(void)WARN_ON(!sock_flag(sk, SOCK_DEAD));
 
 	/* It cannot be in hash table! */
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	/* If it has not 0 inet_sk(sk)->inet_num, it must be bound */
-	WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
+	(void)WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash);
 
 	sk->sk_prot->destroy(sk);
 
@@ -722,7 +722,7 @@ void inet_csk_listen_stop(struct sock *sk)
 
 		local_bh_disable();
 		bh_lock_sock(child);
-		WARN_ON(sock_owned_by_user(child));
+		(void)WARN_ON(sock_owned_by_user(child));
 		sock_hold(child);
 
 		sk->sk_prot->disconnect(child, O_NONBLOCK);
@@ -740,7 +740,7 @@ void inet_csk_listen_stop(struct sock *sk)
 		sk_acceptq_removed(sk);
 		__reqsk_free(req);
 	}
-	WARN_ON(sk->sk_ack_backlog);
+	(void)WARN_ON(sk->sk_ack_backlog);
 }
 EXPORT_SYMBOL_GPL(inet_csk_listen_stop);
 
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 984ec65..5ea6a1e 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -339,7 +339,7 @@ unique:
 	inet->inet_num = lport;
 	inet->inet_sport = htons(lport);
 	sk->sk_hash = hash;
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	__sk_nulls_add_node_rcu(sk, &head->chain);
 	if (tw) {
 		twrefcnt = inet_twsk_unhash(tw);
@@ -381,7 +381,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	struct inet_ehash_bucket *head;
 	int twrefcnt = 0;
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 
 	sk->sk_hash = inet_sk_ehashfn(sk);
 	head = inet_ehash_bucket(hashinfo, sk->sk_hash);
@@ -391,7 +391,7 @@ int __inet_hash_nolisten(struct sock *sk, struct inet_timewait_sock *tw)
 	spin_lock(lock);
 	__sk_nulls_add_node_rcu(sk, list);
 	if (tw) {
-		WARN_ON(sk->sk_hash != tw->tw_hash);
+		(void)WARN_ON(sk->sk_hash != tw->tw_hash);
 		twrefcnt = inet_twsk_unhash(tw);
 	}
 	spin_unlock(lock);
@@ -410,7 +410,7 @@ static void __inet_hash(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	ilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
 
 	spin_lock(&ilb->lock);
@@ -493,7 +493,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 				    tb->port == port) {
 					if (tb->fastreuse >= 0)
 						goto next_port;
-					WARN_ON(hlist_empty(&tb->owners));
+					(void)WARN_ON(hlist_empty(&tb->owners));
 					if (!check_established(death_row, sk,
 								port, &tw))
 						goto ok;
diff --git a/net/ipv4/inet_timewait_sock.c b/net/ipv4/inet_timewait_sock.c
index 89168c6..4f79d22 100644
--- a/net/ipv4/inet_timewait_sock.c
+++ b/net/ipv4/inet_timewait_sock.c
@@ -139,7 +139,7 @@ void __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,
 			hashinfo->bhash_size)];
 	spin_lock(&bhead->lock);
 	tw->tw_tb = icsk->icsk_bind_hash;
-	WARN_ON(!icsk->icsk_bind_hash);
+	(void)WARN_ON(!icsk->icsk_bind_hash);
 	inet_twsk_add_bind_node(tw, &tw->tw_tb->owners);
 	spin_unlock(&bhead->lock);
 
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 1f23a57..d97316d 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -571,8 +571,8 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 		qp->q.fragments = head;
 	}
 
-	WARN_ON(head == NULL);
-	WARN_ON(FRAG_CB(head)->offset != 0);
+	(void)WARN_ON(head == NULL);
+	(void)WARN_ON(FRAG_CB(head)->offset != 0);
 
 	/* Allocate a new buffer for the datagram. */
 	ihlen = ip_hdrlen(head);
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 073a9b0..6ea13f7 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -435,7 +435,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	}
 
 	/* Remove any debris in the socket control block */
-	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+	(void)memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index 1e60f76..7665eab 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -64,12 +64,12 @@ void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
 		return;
 	}
 	if (opt->rr) {
-		memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
+		(void)memset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);
 		opt->rr = 0;
 		opt->rr_needaddr = 0;
 	}
 	if (opt->ts) {
-		memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
+		(void)memset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);
 		opt->ts = 0;
 		opt->ts_needaddr = opt->ts_needtime = 0;
 	}
@@ -92,7 +92,7 @@ int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)
 	int	optlen;
 	__be32	daddr;
 
-	memset(dopt, 0, sizeof(struct ip_options));
+	(void)memset(dopt, 0, sizeof(struct ip_options));
 
 	sopt = &(IPCB(skb)->opt);
 
@@ -228,7 +228,7 @@ void ip_options_fragment(struct sk_buff * skb)
 		if (optlen<2 || optlen>l)
 		  return;
 		if (!IPOPT_COPIED(*optptr))
-			memset(optptr, IPOPT_NOOP, optlen);
+			(void)memset(optptr, IPOPT_NOOP, optlen);
 		l -= optlen;
 		optptr += optlen;
 	}
@@ -481,19 +481,19 @@ void ip_options_undo(struct ip_options * opt)
 	if (opt->rr_needaddr) {
 		unsigned  char * optptr = opt->__data+opt->rr-sizeof(struct  iphdr);
 		optptr[2] -= 4;
-		memset(&optptr[optptr[2]-1], 0, 4);
+		(void)memset(&optptr[optptr[2]-1], 0, 4);
 	}
 	if (opt->ts) {
 		unsigned  char * optptr = opt->__data+opt->ts-sizeof(struct  iphdr);
 		if (opt->ts_needtime) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 			if ((optptr[3]&0xF) == IPOPT_TS_PRESPEC)
 				optptr[2] -= 4;
 		}
 		if (opt->ts_needaddr) {
 			optptr[2] -= 4;
-			memset(&optptr[optptr[2]-1], 0, 4);
+			(void)memset(&optptr[optptr[2]-1], 0, 4);
 		}
 	}
 }
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 8aa87c1..6350fc9 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -139,7 +139,7 @@ static void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = iph->daddr;
 	sin.sin_port = ports[1];
-	memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+	(void)memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
 
 	put_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);
 }
@@ -403,7 +403,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +
 						   serr->addr_offset);
 		sin->sin_port = serr->port;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
@@ -415,7 +415,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 		if (inet->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	}
@@ -647,7 +647,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (optlen >= sizeof(struct in_addr) &&
 			    copy_from_user(&mreq.imr_address, optval,
 					   sizeof(struct in_addr)))
@@ -700,7 +700,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			if (copy_from_user(&mreq, optval, sizeof(mreq)))
 				break;
 		} else {
-			memset(&mreq, 0, sizeof(mreq));
+			(void)memset(&mreq, 0, sizeof(mreq));
 			if (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))
 				break;
 		}
@@ -800,7 +800,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		psin = (struct sockaddr_in *)&greq.gr_group;
 		if (psin->sin_family != AF_INET)
 			goto e_inval;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		mreq.imr_multiaddr = psin->sin_addr;
 		mreq.imr_ifindex = greq.gr_interface;
 
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index 3ccda5a..ad004e9 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -717,7 +717,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
-		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
@@ -736,7 +736,7 @@ static int raw_init(struct sock *sk)
 	struct raw_sock *rp = raw_sk(sk);
 
 	if (inet_sk(sk)->inet_num == IPPROTO_ICMP)
-		memset(&rp->filter, 0, sizeof(rp->filter));
+		(void)memset(&rp->filter, 0, sizeof(rp->filter));
 	return 0;
 }
 
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bcacf54..6209d52 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1847,7 +1847,7 @@ static int ip_rt_bug(struct sk_buff *skb)
 		&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,
 		skb->dev ? skb->dev->name : "?");
 	kfree_skb(skb);
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 9bcdec3..14d6111 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1198,7 +1198,7 @@ void tcp_cleanup_rbuf(struct sock *sk, int copied)
 
 	struct sk_buff *skb = skb_peek(&sk->sk_receive_queue);
 
-	WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
+	(void)WARN(skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq),
 	     "cleanup rbuf bug: copied %X seq %X rcvnxt %X\n",
 	     tp->copied_seq, TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt);
 
@@ -1492,7 +1492,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 				goto found_ok_skb;
 			if (tcp_hdr(skb)->fin)
 				goto found_fin_ok;
-			WARN(!(flags & MSG_PEEK),
+			(void)WARN(!(flags & MSG_PEEK),
 			     "recvmsg bug 2: copied %X seq %X rcvnxt %X fl %X\n",
 			     *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);
 		}
@@ -1555,7 +1555,7 @@ int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 			tp->ucopy.len = len;
 
-			WARN_ON(tp->copied_seq != tp->rcv_nxt &&
+			(void)WARN_ON(tp->copied_seq != tp->rcv_nxt &&
 				!(flags & (MSG_PEEK | MSG_TRUNC)));
 
 			/* Ugly... If prequeue is not empty, we have to
@@ -1972,7 +1972,7 @@ adjudge_to_death:
 	 */
 	local_bh_disable();
 	bh_lock_sock(sk);
-	WARN_ON(sock_owned_by_user(sk));
+	(void)WARN_ON(sock_owned_by_user(sk));
 
 	percpu_counter_inc(sk->sk_prot->orphan_count);
 
@@ -2101,10 +2101,10 @@ int tcp_disconnect(struct sock *sk, int flags)
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
 	tcp_init_send_head(sk);
-	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
+	(void)memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
 	__sk_dst_reset(sk);
 
-	WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
+	(void)WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
 
 	sk->sk_error_report(sk);
 	return err;
@@ -2437,7 +2437,7 @@ void tcp_get_info(const struct sock *sk, struct tcp_info *info)
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	u32 now = tcp_time_stamp;
 
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 
 	info->tcpi_state = sk->sk_state;
 	info->tcpi_ca_state = icsk->icsk_ca_state;
@@ -2585,7 +2585,7 @@ static int do_tcp_getsockopt(struct sock *sk, int level,
 		if (len < sizeof(ctd))
 			return -EINVAL;
 
-		memset(&ctd, 0, sizeof(ctd));
+		(void)memset(&ctd, 0, sizeof(ctd));
 		ctd.tcpct_flags = (tp->rx_opt.cookie_in_always ?
 				   TCP_COOKIE_IN_ALWAYS : 0)
 				| (tp->rx_opt.cookie_out_never ?
@@ -3295,8 +3295,8 @@ void __init tcp_init(void)
 
 	tcp_register_congestion_control(&tcp_reno);
 
-	memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
-	memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
+	(void)memset(&tcp_secret_one.secrets[0], 0, sizeof(tcp_secret_one.secrets));
+	(void)memset(&tcp_secret_two.secrets[0], 0, sizeof(tcp_secret_two.secrets));
 	tcp_secret_one.expires = jiffy; /* past due */
 	tcp_secret_two.expires = jiffy; /* past due */
 	tcp_secret_generating = &tcp_secret_one;
diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c
index fc6d475..3e03f5a 100644
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@ -220,7 +220,7 @@ int tcp_set_allowed_congestion_control(char *val)
 	/* pass 3 mark as allowed */
 	while ((name = strsep(&val, " ")) && *name) {
 		ca = tcp_ca_find(name);
-		WARN_ON(!ca);
+		(void)WARN_ON(!ca);
 		if (ca)
 			ca->flags |= TCP_CONG_NON_RESTRICTED;
 	}
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 2877c3e..6be2d34 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1935,10 +1935,10 @@ advance_sp:
 out:
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
-	WARN_ON((int)tcp_packets_in_flight(tp) < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tcp_packets_in_flight(tp) < 0);
 #endif
 	return state.flag;
 }
@@ -2526,7 +2526,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 	int err;
 	unsigned int mss;
 
-	WARN_ON(packets > tp->packets_out);
+	(void)WARN_ON(packets > tp->packets_out);
 	if (tp->lost_skb_hint) {
 		skb = tp->lost_skb_hint;
 		cnt = tp->lost_cnt_hint;
@@ -3048,7 +3048,7 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked,
 	/* E. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
 	if (icsk->icsk_ca_state == TCP_CA_Open) {
-		WARN_ON(tp->retrans_out != 0);
+		(void)WARN_ON(tp->retrans_out != 0);
 		tp->retrans_stamp = 0;
 	} else if (!before(tp->snd_una, tp->high_seq)) {
 		switch (icsk->icsk_ca_state) {
@@ -3413,9 +3413,9 @@ static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,
 	}
 
 #if FASTRETRANS_DEBUG > 0
-	WARN_ON((int)tp->sacked_out < 0);
-	WARN_ON((int)tp->lost_out < 0);
-	WARN_ON((int)tp->retrans_out < 0);
+	(void)WARN_ON((int)tp->sacked_out < 0);
+	(void)WARN_ON((int)tp->lost_out < 0);
+	(void)WARN_ON((int)tp->retrans_out < 0);
 	if (!tp->packets_out && tcp_is_sack(tp)) {
 		icsk = inet_csk(sk);
 		if (tp->lost_out) {
@@ -4361,7 +4361,7 @@ static void tcp_sack_remove(struct tcp_sock *tp)
 			int i;
 
 			/* RCV.NXT must cover all the block! */
-			WARN_ON(before(tp->rcv_nxt, sp->end_seq));
+			(void)WARN_ON(before(tp->rcv_nxt, sp->end_seq));
 
 			/* Zap this SACK, by moving forward any other SACKS. */
 			for (i=this_sack+1; i < num_sacks; i++)
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 1eb4ad5..0d28b10 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -472,7 +472,7 @@ void tcp_v4_err(struct sk_buff *icmp_skb, u32 info)
 		/* ICMPs are not backlogged, hence we cannot get
 		   an established socket here.
 		 */
-		WARN_ON(req->sk);
+		(void)WARN_ON(req->sk);
 
 		if (seq != tcp_rsk(req)->snt_isn) {
 			NET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -612,7 +612,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 		return;
 
 	/* Swap the send and the receive. */
-	memset(&rep, 0, sizeof(rep));
+	(void)memset(&rep, 0, sizeof(rep));
 	rep.th.dest   = th->source;
 	rep.th.source = th->dest;
 	rep.th.doff   = sizeof(struct tcphdr) / 4;
@@ -626,7 +626,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 				       skb->len - (th->doff << 2));
 	}
 
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&arg, 0, sizeof(arg));
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
 
@@ -682,8 +682,8 @@ static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack,
 	struct ip_reply_arg arg;
 	struct net *net = dev_net(skb_dst(skb)->dev);
 
-	memset(&rep.th, 0, sizeof(struct tcphdr));
-	memset(&arg, 0, sizeof(arg));
+	(void)memset(&rep.th, 0, sizeof(struct tcphdr));
+	(void)memset(&arg, 0, sizeof(arg));
 
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
@@ -1121,7 +1121,7 @@ static int tcp_v4_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 
@@ -1171,7 +1171,7 @@ int tcp_v4_md5_hash_skb(char *md5_hash, struct tcp_md5sig_key *key,
 clear_hash:
 	tcp_put_md5sig_pool();
 clear_hash_noput:
-	memset(md5_hash, 0, 16);
+	(void)memset(md5_hash, 0, 16);
 	return 1;
 }
 EXPORT_SYMBOL(tcp_v4_md5_hash_skb);
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 8c8de27..a5d4c47 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -826,7 +826,7 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 	inet = inet_sk(sk);
 	tp = tcp_sk(sk);
 	tcb = TCP_SKB_CB(skb);
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 
 	if (unlikely(tcb->tcp_flags & TCPHDR_SYN))
 		tcp_options_size = tcp_syn_options(sk, skb, &opts, &md5);
@@ -2478,7 +2478,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 		ireq->rcv_wscale = rcv_wscale;
 	}
 
-	memset(&opts, 0, sizeof(opts));
+	(void)memset(&opts, 0, sizeof(opts));
 #ifdef CONFIG_SYN_COOKIES
 	if (unlikely(req->cookie_ts))
 		TCP_SKB_CB(skb)->when = cookie_init_timestamp(req);
@@ -2493,7 +2493,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 	skb_reset_transport_header(skb);
 
 	th = tcp_hdr(skb);
-	memset(th, 0, sizeof(struct tcphdr));
+	(void)memset(th, 0, sizeof(struct tcphdr));
 	th->syn = 1;
 	th->ack = 1;
 	TCP_ECN_make_synack(req, th);
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index a516d1e..c8222a4 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -325,7 +325,7 @@ void tcp_retransmit_timer(struct sock *sk)
 	if (!tp->packets_out)
 		goto out;
 
-	WARN_ON(tcp_write_queue_empty(sk));
+	(void)WARN_ON(tcp_write_queue_empty(sk));
 
 	if (!tp->snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
 	    !((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 5d075b5..2d969bb 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1230,7 +1230,7 @@ try_again:
 		sin->sin_family = AF_INET;
 		sin->sin_port = udp_hdr(skb)->source;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/sunrpc/addr.c b/net/sunrpc/addr.c
index ee77742..d7e685a 100644
--- a/net/sunrpc/addr.c
+++ b/net/sunrpc/addr.c
@@ -146,7 +146,7 @@ static size_t rpc_pton4(const char *buf, const size_t buflen,
 	if (buflen > INET_ADDRSTRLEN || salen < sizeof(struct sockaddr_in))
 		return 0;
 
-	memset(sap, 0, sizeof(struct sockaddr_in));
+	(void)memset(sap, 0, sizeof(struct sockaddr_in));
 
 	if (in4_pton(buf, buflen, addr, '\0', NULL) == 0)
 		return 0;
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 727e506..e3d21ad 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -424,7 +424,7 @@ rpcauth_lookupcred(struct rpc_auth *auth, int flags)
 	dprintk("RPC:       looking up %s cred\n",
 		auth->au_ops->au_name);
 
-	memset(&acred, 0, sizeof(acred));
+	(void)memset(&acred, 0, sizeof(acred));
 	acred.uid = cred->fsuid;
 	acred.gid = cred->fsgid;
 	acred.group_info = get_group_info(((struct cred *)cred)->group_info);
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 3341d89..f69e9dd 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -820,7 +820,7 @@ EXPORT_SYMBOL_GPL(rpc_free);
  */
 static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)
 {
-	memset(task, 0, sizeof(*task));
+	(void)memset(task, 0, sizeof(*task));
 	atomic_set(&task->tk_count, 1);
 	task->tk_flags  = task_setup_data->flags;
 	task->tk_ops = task_setup_data->callback_ops;
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 74cb0d8..b8b7b86 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -151,7 +151,7 @@ EXPORT_SYMBOL_GPL(svc_xprt_put);
 void svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,
 		   struct svc_xprt *xprt, struct svc_serv *serv)
 {
-	memset(xprt, 0, sizeof(*xprt));
+	(void)memset(xprt, 0, sizeof(*xprt));
 	xprt->xpt_class = xcl;
 	xprt->xpt_ops = xcl->xcl_ops;
 	kref_init(&xprt->xpt_ref);
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 4645709..1e74d56 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1360,7 +1360,7 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 
 		svsk->sk_reclen = 0;
 		svsk->sk_tcplen = 0;
-		memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
+		(void)memset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));
 
 		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;
 
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 593f4c6..0735555 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -67,7 +67,7 @@ __be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)
 		if (ptr != NULL)
 			memcpy(p, ptr, nbytes);
 		if (padding != 0)
-			memset((char *)p + nbytes, 0, padding);
+			(void)memset((char *)p + nbytes, 0, padding);
 		p += quadlen;
 	}
 	return p;
@@ -649,7 +649,7 @@ EXPORT_SYMBOL_GPL(xdr_init_decode);
 void xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,
 			   struct page **pages, unsigned int len)
 {
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	buf->pages =  pages;
 	buf->page_len =  len;
 	buf->buflen =  len;
diff --git a/net/sysctl_net.c b/net/sysctl_net.c
index e758139..e3a86d9 100644
--- a/net/sysctl_net.c
+++ b/net/sysctl_net.c
@@ -82,7 +82,7 @@ static int __net_init sysctl_net_init(struct net *net)
 
 static void __net_exit sysctl_net_exit(struct net *net)
 {
-	WARN_ON(!list_empty(&net->sysctls.list));
+	(void)WARN_ON(!list_empty(&net->sysctls.list));
 }
 
 static struct pernet_operations sysctl_pernet_ops = {
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aad8fb6..7ca7faa 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1333,7 +1333,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 static void unix_destruct_scm(struct sk_buff *skb)
 {
 	struct scm_cookie scm;
-	memset(&scm, 0, sizeof(scm));
+	(void)memset(&scm, 0, sizeof(scm));
 	scm.pid  = UNIXCB(skb).pid;
 	scm.cred = UNIXCB(skb).cred;
 	if (UNIXCB(skb).fp)
@@ -1800,7 +1800,7 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 	scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).cred);
 	unix_set_secdata(siocb->scm, skb);
@@ -1904,7 +1904,7 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
-		memset(&tmp_scm, 0, sizeof(tmp_scm));
+		(void)memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
 	err = mutex_lock_interruptible(&u->readlock);
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 5b228f9..b23979b 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -516,7 +516,7 @@ void __xfrm_state_destroy(struct xfrm_state *x)
 {
 	struct net *net = xs_net(x);
 
-	WARN_ON(x->km.state != XFRM_STATE_DEAD);
+	(void)WARN_ON(x->km.state != XFRM_STATE_DEAD);
 
 	spin_lock_bh(&xfrm_state_gc_lock);
 	hlist_add_head(&x->gclist, &net->xfrm.state_gc_list);
@@ -2051,14 +2051,14 @@ void xfrm_state_fini(struct net *net)
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, &audit_info);
 	flush_work(&net->xfrm.state_gc_work);
 
-	WARN_ON(!list_empty(&net->xfrm.state_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.state_all));
 
 	sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.state_byspi));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_byspi));
 	xfrm_hash_free(net->xfrm.state_byspi, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bysrc));
 	xfrm_hash_free(net->xfrm.state_bysrc, sz);
-	WARN_ON(!hlist_empty(net->xfrm.state_bydst));
+	(void)WARN_ON(!hlist_empty(net->xfrm.state_bydst));
 	xfrm_hash_free(net->xfrm.state_bydst, sz);
 }
 
diff --git a/block/blk-core.c b/block/blk-core.c
index e6c05a9..f6381ad 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -129,7 +129,7 @@ EXPORT_SYMBOL(blk_get_backing_dev_info);
 
 void blk_rq_init(struct request_queue *q, struct request *rq)
 {
-	memset(rq, 0, sizeof(*rq));
+	(void)memset(rq, 0, sizeof(*rq));
 
 	INIT_LIST_HEAD(&rq->queuelist);
 	INIT_LIST_HEAD(&rq->timeout_list);
@@ -237,7 +237,7 @@ EXPORT_SYMBOL(blk_delay_queue);
  **/
 void blk_start_queue(struct request_queue *q)
 {
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	queue_flag_clear(QUEUE_FLAG_STOPPED, q);
 	__blk_run_queue(q);
@@ -1130,7 +1130,7 @@ void __blk_put_request(struct request_queue *q, struct request *req)
 	elv_completed_request(q, req);
 
 	/* this is a bio leak */
-	WARN_ON(req->bio != NULL);
+	(void)WARN_ON(req->bio != NULL);
 
 	/*
 	 * Request may not have originated from ll_rw_blk. if not,
@@ -2443,7 +2443,7 @@ EXPORT_SYMBOL(blk_end_request_cur);
  */
 bool blk_end_request_err(struct request *rq, int error)
 {
-	WARN_ON(error >= 0);
+	(void)WARN_ON(error >= 0);
 	return blk_end_request(rq, error, blk_rq_err_bytes(rq));
 }
 EXPORT_SYMBOL_GPL(blk_end_request_err);
@@ -2522,7 +2522,7 @@ EXPORT_SYMBOL(__blk_end_request_cur);
  */
 bool __blk_end_request_err(struct request *rq, int error)
 {
-	WARN_ON(error >= 0);
+	(void)WARN_ON(error >= 0);
 	return __blk_end_request(rq, error, blk_rq_err_bytes(rq));
 }
 EXPORT_SYMBOL_GPL(__blk_end_request_err);
diff --git a/block/blk-exec.c b/block/blk-exec.c
index fb2cbd5..21fcc0e 100644
--- a/block/blk-exec.c
+++ b/block/blk-exec.c
@@ -98,7 +98,7 @@ int blk_execute_rq(struct request_queue *q, struct gendisk *bd_disk,
 	rq->ref_count++;
 
 	if (!rq->sense) {
-		memset(sense, 0, sizeof(sense));
+		(void)memset(sense, 0, sizeof(sense));
 		rq->sense = sense;
 		rq->sense_len = 0;
 	}
diff --git a/block/blk-flush.c b/block/blk-flush.c
index 720ad60..823d9ed 100644
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@ -337,7 +337,7 @@ void blk_insert_flush(struct request *rq)
 	 * @rq should go through flush machinery.  Mark it part of flush
 	 * sequence and submit for further processing.
 	 */
-	memset(&rq->flush, 0, sizeof(rq->flush));
+	(void)memset(&rq->flush, 0, sizeof(rq->flush));
 	INIT_LIST_HEAD(&rq->flush.list);
 	rq->cmd_flags |= REQ_FLUSH_SEQ;
 	rq->flush.saved_end_io = rq->end_io; /* Usually NULL */
diff --git a/block/blk-iopoll.c b/block/blk-iopoll.c
index 58916af..25bf009 100644
--- a/block/blk-iopoll.c
+++ b/block/blk-iopoll.c
@@ -181,7 +181,7 @@ EXPORT_SYMBOL(blk_iopoll_enable);
  **/
 void blk_iopoll_init(struct blk_iopoll *iop, int weight, blk_iopoll_fn *poll_fn)
 {
-	memset(iop, 0, sizeof(*iop));
+	(void)memset(iop, 0, sizeof(*iop));
 	INIT_LIST_HEAD(&iop->list);
 	iop->weight = weight;
 	iop->poll = poll_fn;
@@ -221,7 +221,7 @@ static __init int blk_iopoll_setup(void)
 		INIT_LIST_HEAD(&per_cpu(blk_cpu_iopoll, i));
 
 	open_softirq(BLOCK_IOPOLL_SOFTIRQ, blk_iopoll_softirq);
-	register_hotcpu_notifier(&blk_iopoll_cpu_notifier);
+	(void)register_hotcpu_notifier(&blk_iopoll_cpu_notifier);
 	return 0;
 }
 subsys_initcall(blk_iopoll_setup);
diff --git a/block/blk-merge.c b/block/blk-merge.c
index cfcc37c..08b5415 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -180,7 +180,7 @@ new_segment:
 
 	if (q->dma_drain_size && q->dma_drain_needed(rq)) {
 		if (rq->cmd_flags & REQ_WRITE)
-			memset(q->dma_drain_buffer, 0, q->dma_drain_size);
+			(void)memset(q->dma_drain_buffer, 0, q->dma_drain_size);
 
 		sg->page_link &= ~0x02;
 		sg = sg_next(sg);
@@ -337,7 +337,7 @@ void blk_rq_set_mixed_merge(struct request *rq)
 	 * Distributes the attributs to each bio.
 	 */
 	for (bio = rq->bio; bio; bio = bio->bi_next) {
-		WARN_ON_ONCE((bio->bi_rw & REQ_FAILFAST_MASK) &&
+		(void)WARN_ON_ONCE((bio->bi_rw & REQ_FAILFAST_MASK) &&
 			     (bio->bi_rw & REQ_FAILFAST_MASK) != ff);
 		bio->bi_rw |= ff;
 	}
diff --git a/block/blk-settings.c b/block/blk-settings.c
index d3234fc..a8c11b5 100644
--- a/block/blk-settings.c
+++ b/block/blk-settings.c
@@ -798,7 +798,7 @@ EXPORT_SYMBOL(blk_queue_update_dma_alignment);
  */
 void blk_queue_flush(struct request_queue *q, unsigned int flush)
 {
-	WARN_ON_ONCE(flush & ~(REQ_FLUSH | REQ_FUA));
+	(void)WARN_ON_ONCE(flush & ~(REQ_FLUSH | REQ_FUA));
 
 	if (WARN_ON_ONCE(!(flush & REQ_FLUSH) && (flush & REQ_FUA)))
 		flush &= ~REQ_FUA;
diff --git a/block/blk-softirq.c b/block/blk-softirq.c
index 1366a89..5895d21 100644
--- a/block/blk-softirq.c
+++ b/block/blk-softirq.c
@@ -180,7 +180,7 @@ static __init int blk_softirq_init(void)
 		INIT_LIST_HEAD(&per_cpu(blk_cpu_done, i));
 
 	open_softirq(BLOCK_SOFTIRQ, blk_done_softirq);
-	register_hotcpu_notifier(&blk_cpu_notifier);
+	(void)register_hotcpu_notifier(&blk_cpu_notifier);
 	return 0;
 }
 subsys_initcall(blk_softirq_init);
diff --git a/block/bsg.c b/block/bsg.c
index 4cf703f..a223d73 100644
--- a/block/bsg.c
+++ b/block/bsg.c
@@ -1012,7 +1012,7 @@ int bsg_register_queue(struct request_queue *q, struct device *parent,
 		return 0;
 
 	bcd = &q->bsg_dev;
-	memset(bcd, 0, sizeof(*bcd));
+	(void)memset(bcd, 0, sizeof(*bcd));
 
 	mutex_lock(&bsg_mutex);
 
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index ee55019..217bc33 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -529,7 +529,7 @@ static inline int cfq_prio_slice(struct cfq_data *cfqd, bool sync,
 {
 	const int base_slice = cfqd->cfq_slice[sync];
 
-	WARN_ON(prio >= IOPRIO_BE_NR);
+	(void)WARN_ON(prio >= IOPRIO_BE_NR);
 
 	return base_slice + (base_slice/CFQ_SLICE_SCALE * (4 - prio));
 }
@@ -545,7 +545,7 @@ static inline u64 cfq_scale_slice(unsigned long delta, struct cfq_group *cfqg)
 	u64 d = delta << CFQ_SERVICE_SHIFT;
 
 	d = d * BLKIO_WEIGHT_DEFAULT;
-	do_div(d, cfqg->weight);
+	(void)do_div(d, cfqg->weight);
 	return d;
 }
 
@@ -1594,7 +1594,7 @@ static void cfq_deactivate_request(struct request_queue *q, struct request *rq)
 {
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 
-	WARN_ON(!cfqd->rq_in_driver);
+	(void)WARN_ON(!cfqd->rq_in_driver);
 	cfqd->rq_in_driver--;
 	cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "deactivate rq, drv=%d",
 						cfqd->rq_in_driver);
@@ -2025,8 +2025,8 @@ static void cfq_arm_slice_timer(struct cfq_data *cfqd)
 	if (blk_queue_nonrot(cfqd->queue) && cfqd->hw_tag)
 		return;
 
-	WARN_ON(!RB_EMPTY_ROOT(&cfqq->sort_list));
-	WARN_ON(cfq_cfqq_slice_new(cfqq));
+	(void)WARN_ON(!RB_EMPTY_ROOT(&cfqq->sort_list));
+	(void)WARN_ON(cfq_cfqq_slice_new(cfqq));
 
 	/*
 	 * idle is disabled, either manually or by past process history
@@ -2131,7 +2131,7 @@ cfq_prio_to_maxrq(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
 	const int base_rq = cfqd->cfq_slice_async_rq;
 
-	WARN_ON(cfqq->ioprio >= IOPRIO_BE_NR);
+	(void)WARN_ON(cfqq->ioprio >= IOPRIO_BE_NR);
 
 	return 2 * base_rq * (IOPRIO_BE_NR - cfqq->ioprio);
 }
@@ -2697,7 +2697,7 @@ static void cfq_put_cooperator(struct cfq_queue *cfqq)
 	__cfqq = cfqq->new_cfqq;
 	while (__cfqq) {
 		if (__cfqq == cfqq) {
-			WARN(1, "cfqq->new_cfqq loop detected\n");
+			(void)WARN(1, "cfqq->new_cfqq loop detected\n");
 			break;
 		}
 		next = __cfqq->new_cfqq;
@@ -3299,8 +3299,8 @@ static void cfq_completed_request(struct request_queue *q, struct request *rq)
 
 	cfq_update_hw_tag(cfqd);
 
-	WARN_ON(!cfqd->rq_in_driver);
-	WARN_ON(!cfqq->dispatched);
+	(void)WARN_ON(!cfqd->rq_in_driver);
+	(void)WARN_ON(!cfqq->dispatched);
 	cfqd->rq_in_driver--;
 	cfqq->dispatched--;
 	(RQ_CFQG(rq))->dispatched--;
diff --git a/block/genhd.c b/block/genhd.c
index 23b4f70..30ca52e 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -345,7 +345,7 @@ void unregister_blkdev(unsigned int major, const char *name)
 		if ((*n)->major == major)
 			break;
 	if (!*n || strcmp((*n)->name, name)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	} else {
 		p = *n;
 		*n = p->next;
@@ -583,14 +583,14 @@ void add_disk(struct gendisk *disk)
 	 * be accompanied with EXT_DEVT flag.  Make sure all
 	 * parameters make sense.
 	 */
-	WARN_ON(disk->minors && !(disk->major || disk->first_minor));
-	WARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));
+	(void)WARN_ON(disk->minors && !(disk->major || disk->first_minor));
+	(void)WARN_ON(!disk->minors && !(disk->flags & GENHD_FL_EXT_DEVT));
 
 	disk->flags |= GENHD_FL_UP;
 
 	retval = blk_alloc_devt(&disk->part0, &devt);
 	if (retval) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 	disk_to_dev(disk)->devt = devt;
@@ -1794,6 +1794,6 @@ static void disk_del_events(struct gendisk *disk)
 static void disk_release_events(struct gendisk *disk)
 {
 	/* the block count should be 1 from disk_del_events() */
-	WARN_ON_ONCE(disk->ev && disk->ev->block != 1);
+	(void)WARN_ON_ONCE(disk->ev && disk->ev->block != 1);
 	kfree(disk->ev);
 }
diff --git a/block/ioctl.c b/block/ioctl.c
index ba15b2d..0fb0f1ef 100644
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@ -260,7 +260,7 @@ int blkdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 		 * We need to set the startsect first, the driver may
 		 * want to override it.
 		 */
-		memset(&geo, 0, sizeof(geo));
+		(void)memset(&geo, 0, sizeof(geo));
 		geo.start = get_start_sect(bdev);
 		ret = disk->fops->getgeo(bdev, &geo);
 		if (ret)
diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
index 260fa80..a0d2afe 100644
--- a/block/scsi_ioctl.c
+++ b/block/scsi_ioctl.c
@@ -371,7 +371,7 @@ static int sg_io(struct request_queue *q, struct gendisk *bd_disk,
 		goto out;
 
 	bio = rq->bio;
-	memset(sense, 0, sizeof(sense));
+	(void)memset(sense, 0, sizeof(sense));
 	rq->sense = sense;
 	rq->sense_len = 0;
 	rq->retries = 0;
@@ -508,7 +508,7 @@ int sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,
 		goto out;
 	}
 
-	memset(sense, 0, sizeof(sense));
+	(void)memset(sense, 0, sizeof(sense));
 	rq->sense = sense;
 	rq->sense_len = 0;
 	rq->cmd_type = REQ_TYPE_BLOCK_PC;
@@ -619,7 +619,7 @@ int scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mod
 			if (copy_from_user(&cgc, arg, sizeof(cgc)))
 				break;
 			cgc.timeout = clock_t_to_jiffies(cgc.timeout);
-			memset(&hdr, 0, sizeof(hdr));
+			(void)memset(&hdr, 0, sizeof(hdr));
 			hdr.interface_id = 'S';
 			hdr.cmd_len = sizeof(cgc.cmd);
 			hdr.dxfer_len = cgc.buflen;
diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c
index a0f768c..08a59a6 100644
--- a/crypto/ablkcipher.c
+++ b/crypto/ablkcipher.c
@@ -323,7 +323,7 @@ static int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cipher->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/aead.c b/crypto/aead.c
index 04add3dc..65d66e6 100644
--- a/crypto/aead.c
+++ b/crypto/aead.c
@@ -43,7 +43,7 @@ static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = aead->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/algapi.c b/crypto/algapi.c
index 9d4a9fe..3dc6bbb 100644
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@ -343,7 +343,7 @@ static void crypto_wait_for_test(struct crypto_larval *larval)
 	}
 
 	err = wait_for_completion_interruptible(&larval->completion);
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 out:
 	crypto_larval_kill(&larval->alg);
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index 6ddd99e..8a85d69 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -219,7 +219,7 @@ static int get_prng_bytes(char *buf, size_t nbytes, struct prng_context *ctx,
 remainder:
 	if (ctx->rand_data_valid == DEFAULT_BLK_SZ) {
 		if (_get_more_prng_bytes(ctx, do_cont_test) < 0) {
-			memset(buf, 0, nbytes);
+			(void)memset(buf, 0, nbytes);
 			err = -EINVAL;
 			goto done;
 		}
@@ -246,7 +246,7 @@ empty_rbuf:
 	for (; byte_count >= DEFAULT_BLK_SZ; byte_count -= DEFAULT_BLK_SZ) {
 		if (ctx->rand_data_valid == DEFAULT_BLK_SZ) {
 			if (_get_more_prng_bytes(ctx, do_cont_test) < 0) {
-				memset(buf, 0, nbytes);
+				(void)memset(buf, 0, nbytes);
 				err = -EINVAL;
 				goto done;
 			}
@@ -299,10 +299,10 @@ static int reset_prng_context(struct prng_context *ctx,
 	if (DT)
 		memcpy(ctx->DT, DT, DEFAULT_BLK_SZ);
 	else
-		memset(ctx->DT, 0, DEFAULT_BLK_SZ);
+		(void)memset(ctx->DT, 0, DEFAULT_BLK_SZ);
 
-	memset(ctx->rand_data, 0, DEFAULT_BLK_SZ);
-	memset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);
+	(void)memset(ctx->rand_data, 0, DEFAULT_BLK_SZ);
+	(void)memset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);
 
 	ctx->rand_data_valid = DEFAULT_BLK_SZ;
 
diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c
index 1e61d1a..0151883 100644
--- a/crypto/blkcipher.c
+++ b/crypto/blkcipher.c
@@ -375,7 +375,7 @@ static int setkey_unaligned(struct crypto_tfm *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cipher->setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 }
diff --git a/crypto/cipher.c b/crypto/cipher.c
index 39541e0..530bc13 100644
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -37,7 +37,7 @@ static int setkey_unaligned(struct crypto_tfm *tfm, const u8 *key,
 	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	memcpy(alignbuffer, key, keylen);
 	ret = cia->cia_setkey(tfm, alignbuffer, keylen);
-	memset(alignbuffer, 0, keylen);
+	(void)memset(alignbuffer, 0, keylen);
 	kfree(buffer);
 	return ret;
 
diff --git a/crypto/eseqiv.c b/crypto/eseqiv.c
index 42ce9f5..285f7a1 100644
--- a/crypto/eseqiv.c
+++ b/crypto/eseqiv.c
@@ -129,7 +129,7 @@ static int eseqiv_givencrypt(struct skcipher_givcrypt_request *req)
 
 	len = ivsize;
 	if (ivsize > sizeof(u64)) {
-		memset(req->giv, 0, ivsize - sizeof(u64));
+		(void)memset(req->giv, 0, ivsize - sizeof(u64));
 		len = sizeof(u64);
 	}
 	seq = cpu_to_be64(req->seq);
diff --git a/crypto/md5.c b/crypto/md5.c
index 7febeaa..4b9dd7a 100644
--- a/crypto/md5.c
+++ b/crypto/md5.c
@@ -101,13 +101,13 @@ static int md5_final(struct shash_desc *desc, u8 *out)
 
 	*p++ = 0x80;
 	if (padding < 0) {
-		memset(p, 0x00, padding + sizeof (u64));
+		(void)memset(p, 0x00, padding + sizeof (u64));
 		md5_transform_helper(mctx);
 		p = (char *)mctx->block;
 		padding = 56;
 	}
 
-	memset(p, 0, padding);
+	(void)memset(p, 0, padding);
 	mctx->block[14] = mctx->byte_count << 3;
 	mctx->block[15] = mctx->byte_count >> 29;
 	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
@@ -115,7 +115,7 @@ static int md5_final(struct shash_desc *desc, u8 *out)
 	md5_transform(mctx->hash, mctx->block);
 	cpu_to_le32_array(mctx->hash, sizeof(mctx->hash) / sizeof(u32));
 	memcpy(out, mctx->hash, sizeof(mctx->hash));
-	memset(mctx, 0, sizeof(*mctx));
+	(void)memset(mctx, 0, sizeof(*mctx));
 
 	return 0;
 }
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 40fb122..52599f1 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -541,7 +541,7 @@ void bus_probe_device(struct device *dev)
 
 	if (bus->p->drivers_autoprobe) {
 		ret = device_attach(dev);
-		WARN_ON(ret < 0);
+		(void)WARN_ON(ret < 0);
 	}
 
 	mutex_lock(&bus->p->mutex);
diff --git a/drivers/base/class.c b/drivers/base/class.c
index 03243d4..7988d7f 100644
--- a/drivers/base/class.c
+++ b/drivers/base/class.c
@@ -382,7 +382,7 @@ int class_for_each_device(struct class *class, struct device *start,
 	if (!class)
 		return -EINVAL;
 	if (!class->p) {
-		WARN(1, "%s called for class '%s' before it was initialized",
+		(void)WARN(1, "%s called for class '%s' before it was initialized",
 		     __func__, class->name);
 		return -EINVAL;
 	}
@@ -429,7 +429,7 @@ struct device *class_find_device(struct class *class, struct device *start,
 	if (!class)
 		return NULL;
 	if (!class->p) {
-		WARN(1, "%s called for class '%s' before it was initialized",
+		(void)WARN(1, "%s called for class '%s' before it was initialized",
 		     __func__, class->name);
 		return NULL;
 	}
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a67cc0..a4a1f2c 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -189,7 +189,7 @@ static void device_release(struct kobject *kobj)
 	else if (dev->class && dev->class->dev_release)
 		dev->class->dev_release(dev);
 	else
-		WARN(1, KERN_ERR "Device '%s' does not have a release() "
+		(void)WARN(1, KERN_ERR "Device '%s' does not have a release() "
 			"function, it is broken and must be fixed.\n",
 			dev_name(dev));
 	kfree(p);
@@ -890,7 +890,7 @@ static int device_create_sys_dev_entry(struct device *dev)
 	char devt_str[15];
 
 	if (kobj) {
-		format_dev_t(devt_str, dev->devt);
+		(void)format_dev_t(devt_str, dev->devt);
 		error = sysfs_create_link(kobj, &dev->kobj, devt_str);
 	}
 
@@ -903,7 +903,7 @@ static void device_remove_sys_dev_entry(struct device *dev)
 	char devt_str[15];
 
 	if (kobj) {
-		format_dev_t(devt_str, dev->devt);
+		(void)format_dev_t(devt_str, dev->devt);
 		sysfs_remove_link(kobj, devt_str);
 	}
 }
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 142e3d600..4721024 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -112,7 +112,7 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	atomic_inc(&probe_count);
 	pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
 		 drv->bus->name, __func__, drv->name, dev_name(dev));
-	WARN_ON(!list_empty(&dev->devres_head));
+	(void)WARN_ON(!list_empty(&dev->devres_head));
 
 	dev->driver = drv;
 	if (driver_sysfs_add(dev)) {
diff --git a/drivers/base/dma-coherent.c b/drivers/base/dma-coherent.c
index bb0025c..62d59f1 100644
--- a/drivers/base/dma-coherent.c
+++ b/drivers/base/dma-coherent.c
@@ -135,7 +135,7 @@ int dma_alloc_from_coherent(struct device *dev, ssize_t size,
 	 */
 	*dma_handle = mem->device_base + (pageno << PAGE_SHIFT);
 	*ret = mem->virt_base + (pageno << PAGE_SHIFT);
-	memset(*ret, 0, size);
+	(void)memset(*ret, 0, size);
 
 	return 1;
 
diff --git a/drivers/base/dma-mapping.c b/drivers/base/dma-mapping.c
index 6f3676f..f593dde 100644
--- a/drivers/base/dma-mapping.c
+++ b/drivers/base/dma-mapping.c
@@ -39,7 +39,7 @@ static int dmam_match(struct device *dev, void *res, void *match_data)
 	struct dma_devres *this = res, *match = match_data;
 
 	if (this->vaddr == match->vaddr) {
-		WARN_ON(this->size != match->size ||
+		(void)WARN_ON(this->size != match->size ||
 			this->dma_handle != match->dma_handle);
 		return 1;
 	}
@@ -100,7 +100,7 @@ void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
 	struct dma_devres match_data = { size, vaddr, dma_handle };
 
 	dma_free_coherent(dev, size, vaddr, dma_handle);
-	WARN_ON(devres_destroy(dev, dmam_coherent_release, dmam_match,
+	(void)WARN_ON(devres_destroy(dev, dmam_coherent_release, dmam_match,
 			       &match_data));
 }
 EXPORT_SYMBOL(dmam_free_coherent);
@@ -159,7 +159,7 @@ void dmam_free_noncoherent(struct device *dev, size_t size, void *vaddr,
 	struct dma_devres match_data = { size, vaddr, dma_handle };
 
 	dma_free_noncoherent(dev, size, vaddr, dma_handle);
-	WARN_ON(!devres_destroy(dev, dmam_noncoherent_release, dmam_match,
+	(void)WARN_ON(!devres_destroy(dev, dmam_noncoherent_release, dmam_match,
 				&match_data));
 }
 EXPORT_SYMBOL(dmam_free_noncoherent);
@@ -213,7 +213,7 @@ EXPORT_SYMBOL(dmam_declare_coherent_memory);
  */
 void dmam_release_declared_memory(struct device *dev)
 {
-	WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
+	(void)WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
 }
 EXPORT_SYMBOL(dmam_release_declared_memory);
 
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b631f7c..30a6016 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -259,7 +259,7 @@ EXPORT_SYMBOL_GPL(driver_register);
 void driver_unregister(struct device_driver *drv)
 {
 	if (!drv || !drv->p) {
-		WARN(1, "Unexpected driver unregister!\n");
+		(void)WARN(1, "Unexpected driver unregister!\n");
 		return;
 	}
 	driver_remove_groups(drv, drv->groups);
diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c
index 26ab358..fafa513 100644
--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@ -234,7 +234,7 @@ static ssize_t firmware_loading_store(struct device *dev,
 	switch (loading) {
 	case 1:
 		firmware_free_data(fw_priv->fw);
-		memset(fw_priv->fw, 0, sizeof(struct firmware));
+		(void)memset(fw_priv->fw, 0, sizeof(struct firmware));
 		/* If the pages are not owned by 'struct firmware' */
 		for (i = 0; i < fw_priv->nr_pages; i++)
 			__free_page(fw_priv->pages[i]);
@@ -342,7 +342,7 @@ static int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)
 		}
 		memcpy(new_pages, fw_priv->pages,
 		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
+		(void)memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
 		       (new_array_size - fw_priv->page_array_size));
 		kfree(fw_priv->pages);
 		fw_priv->pages = new_pages;
@@ -637,7 +637,7 @@ static int request_firmware_work_func(void *arg)
 	int ret;
 
 	if (!arg) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index f0c605e..5f5b481 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1151,7 +1151,7 @@ void __init early_platform_cleanup(void)
 	list_for_each_entry_safe(pd, pd2, &early_platform_device_list,
 				 dev.devres_head) {
 		list_del(&pd->dev.devres_head);
-		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
+		(void)memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
 	}
 }
 
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index e2cc3d2..632238e 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -325,7 +325,7 @@ static void dpm_show_time(ktime_t starttime, pm_message_t state, char *info)
 
 	calltime = ktime_get();
 	usecs64 = ktime_to_ns(ktime_sub(calltime, starttime));
-	do_div(usecs64, NSEC_PER_USEC);
+	(void)do_div(usecs64, NSEC_PER_USEC);
 	usecs = usecs64;
 	if (usecs == 0)
 		usecs = 1;
diff --git a/drivers/base/sys.c b/drivers/base/sys.c
index 409f5ce..b67da8d 100644
--- a/drivers/base/sys.c
+++ b/drivers/base/sys.c
@@ -135,7 +135,7 @@ int sysdev_class_register(struct sysdev_class *cls)
 	pr_debug("Registering sysdev class '%s'\n", cls->name);
 
 	INIT_LIST_HEAD(&cls->drivers);
-	memset(&cls->kset.kobj, 0x00, sizeof(struct kobject));
+	(void)memset(&cls->kset.kobj, 0x00, sizeof(struct kobject));
 	cls->kset.kobj.parent = &system_kset->kobj;
 	cls->kset.kobj.ktype = &ktype_sysdev_class;
 	cls->kset.kobj.kset = system_kset;
@@ -211,14 +211,14 @@ int sysdev_driver_register(struct sysdev_class *cls, struct sysdev_driver *drv)
 	int err = 0;
 
 	if (!cls) {
-		WARN(1, KERN_WARNING "sysdev: invalid class passed to %s!\n",
+		(void)WARN(1, KERN_WARNING "sysdev: invalid class passed to %s!\n",
 			__func__);
 		return -EINVAL;
 	}
 
 	/* Check whether this driver has already been added to a class. */
 	if (drv->entry.next && !list_empty(&drv->entry))
-		WARN(1, KERN_WARNING "sysdev: class %s: driver (%p) has already"
+		(void)WARN(1, KERN_WARNING "sysdev: class %s: driver (%p) has already"
 			" been registered to a class, something is wrong, but "
 			"will forge on!\n", cls->name, drv);
 
@@ -236,7 +236,7 @@ int sysdev_driver_register(struct sysdev_class *cls, struct sysdev_driver *drv)
 		}
 	} else {
 		err = -EINVAL;
-		WARN(1, KERN_ERR "%s: invalid device class\n", __func__);
+		(void)WARN(1, KERN_ERR "%s: invalid device class\n", __func__);
 	}
 
 	goto unlock;
@@ -281,7 +281,7 @@ int sysdev_register(struct sys_device *sysdev)
 		 kobject_name(&cls->kset.kobj));
 
 	/* initialize the kobject to 0, in case it had previously been used */
-	memset(&sysdev->kobj, 0x00, sizeof(struct kobject));
+	(void)memset(&sysdev->kobj, 0x00, sizeof(struct kobject));
 
 	/* Make sure the kset is set */
 	sysdev->kobj.kset = &cls->kset;
diff --git a/drivers/base/syscore.c b/drivers/base/syscore.c
index e8d11b6..2a0cf2f 100644
--- a/drivers/base/syscore.c
+++ b/drivers/base/syscore.c
@@ -56,7 +56,7 @@ int syscore_suspend(void)
 	if (ret)
 		return ret;
 
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		"Interrupts enabled before system core suspend.\n");
 
 	list_for_each_entry_reverse(ops, &syscore_ops_list, node)
@@ -66,7 +66,7 @@ int syscore_suspend(void)
 			ret = ops->suspend();
 			if (ret)
 				goto err_out;
-			WARN_ONCE(!irqs_disabled(),
+			(void)WARN_ONCE(!irqs_disabled(),
 				"Interrupts enabled after %pF\n", ops->suspend);
 		}
 
@@ -92,7 +92,7 @@ void syscore_resume(void)
 {
 	struct syscore_ops *ops;
 
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		"Interrupts enabled before system core resume.\n");
 
 	list_for_each_entry(ops, &syscore_ops_list, node)
@@ -100,7 +100,7 @@ void syscore_resume(void)
 			if (initcall_debug)
 				pr_info("PM: Calling %pF\n", ops->resume);
 			ops->resume();
-			WARN_ONCE(!irqs_disabled(),
+			(void)WARN_ONCE(!irqs_disabled(),
 				"Interrupts enabled after %pF\n", ops->resume);
 		}
 }
diff --git a/drivers/block/brd.c b/drivers/block/brd.c
index ec24643..895d98d 100644
--- a/drivers/block/brd.c
+++ b/drivers/block/brd.c
@@ -277,7 +277,7 @@ static void copy_from_brd(void *dst, struct brd_device *brd,
 		memcpy(dst, src + offset, copy);
 		kunmap_atomic(src, KM_USER1);
 	} else
-		memset(dst, 0, copy);
+		(void)memset(dst, 0, copy);
 
 	if (copy < n) {
 		dst += copy;
@@ -289,7 +289,7 @@ static void copy_from_brd(void *dst, struct brd_device *brd,
 			memcpy(dst, src, copy);
 			kunmap_atomic(src, KM_USER1);
 		} else
-			memset(dst, 0, copy);
+			(void)memset(dst, 0, copy);
 	}
 }
 
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 54ca8b2..0d5f989 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -844,8 +844,8 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	 * pool while mixing, and hash one final time.
 	 */
 	sha_transform(hash, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	(void)memset(extract, 0, sizeof(extract));
+	(void)memset(workspace, 0, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
@@ -856,7 +856,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	hash[1] ^= hash[4];
 	hash[2] ^= rol32(hash[2], 16);
 	memcpy(out, hash, EXTRACT_SIZE);
-	memset(hash, 0, sizeof(hash));
+	(void)memset(hash, 0, sizeof(hash));
 }
 
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
@@ -887,7 +887,7 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	(void)memset(tmp, 0, sizeof(tmp));
 
 	return ret;
 }
@@ -924,7 +924,7 @@ static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	(void)memset(tmp, 0, sizeof(tmp));
 
 	return ret;
 }
@@ -1053,7 +1053,7 @@ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 
 			DEBUG_ENT("sleeping?\n");
 
-			wait_event_interruptible(random_read_wait,
+			(void)wait_event_interruptible(random_read_wait,
 				input_pool.entropy_count >=
 						 random_read_wakeup_thresh);
 
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index af08ce7..db67cc6 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -135,7 +135,7 @@ static int open_collection(struct hid_parser *parser, unsigned type)
 		memcpy(collection, parser->device->collection,
 			sizeof(struct hid_collection) *
 			parser->device->collection_size);
-		memset(collection + parser->device->collection_size, 0,
+		(void)memset(collection + parser->device->collection_size, 0,
 			sizeof(struct hid_collection) *
 			parser->device->collection_size);
 		kfree(parser->device->collection);
@@ -788,7 +788,7 @@ static void implement(const struct hid_device *hid, __u8 *report,
 	if (value > m)
 		hid_warn(hid, "%s() called with too large value %d! (%s)\n",
 			 __func__, value, current->comm);
-	WARN_ON(value > m);
+	(void)WARN_ON(value > m);
 	value &= m;
 
 	report += offset >> 3;
@@ -977,7 +977,7 @@ void hid_output_report(struct hid_report *report, __u8 *data)
 	if (report->id > 0)
 		*data++ = report->id;
 
-	memset(data, 0, ((report->size - 1) >> 3) + 1);
+	(void)memset(data, 0, ((report->size - 1) >> 3) + 1);
 	for (n = 0; n < report->maxfield; n++)
 		hid_output_field(report->device, report->field[n], data);
 }
@@ -1054,7 +1054,7 @@ void hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
 	if (csize < rsize) {
 		dbg_hid("report %d is too short, (%d < %d)\n", report->id,
 				csize, rsize);
-		memset(cdata + csize, 0, rsize - csize);
+		(void)memset(cdata + csize, 0, rsize - csize);
 	}
 
 	if ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 1e56061..c7d76b2 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -655,7 +655,7 @@ i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,
 	char *blank, end;
 	int res;
 
-	memset(&info, 0, sizeof(struct i2c_board_info));
+	(void)memset(&info, 0, sizeof(struct i2c_board_info));
 
 	blank = strchr(buf, ' ');
 	if (!blank) {
@@ -1095,7 +1095,7 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 
 	/* Clear the device structure in case this adapter is ever going to be
 	   added again */
-	memset(&adap->dev, 0, sizeof(adap->dev));
+	(void)memset(&adap->dev, 0, sizeof(adap->dev));
 
 	return 0;
 }
@@ -1490,7 +1490,7 @@ static int i2c_detect_address(struct i2c_client *temp_client,
 		return 0;
 
 	/* Finally call the custom detection function */
-	memset(&info, 0, sizeof(struct i2c_board_info));
+	(void)memset(&info, 0, sizeof(struct i2c_board_info));
 	info.addr = addr;
 	err = driver->detect(temp_client, &info);
 	if (err) {
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 1f78c95..9953204 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -404,7 +404,7 @@ void input_alloc_absinfo(struct input_dev *dev)
 		dev->absinfo = kcalloc(ABS_CNT, sizeof(struct input_absinfo),
 					GFP_KERNEL);
 
-	WARN(!dev->absinfo, "%s(): kcalloc() failed?\n", __func__);
+	(void)WARN(!dev->absinfo, "%s(): kcalloc() failed?\n", __func__);
 }
 EXPORT_SYMBOL(input_alloc_absinfo);
 
@@ -1899,7 +1899,7 @@ void input_unregister_device(struct input_dev *dev)
 
 	list_for_each_entry_safe(handle, next, &dev->h_list, d_node)
 		handle->handler->disconnect(handle);
-	WARN_ON(!list_empty(&dev->h_list));
+	(void)WARN_ON(!list_empty(&dev->h_list));
 
 	del_timer_sync(&dev->timer);
 	list_del_init(&dev->node);
@@ -1967,7 +1967,7 @@ void input_unregister_handler(struct input_handler *handler)
 
 	list_for_each_entry_safe(handle, next, &handler->h_list, h_node)
 		handler->disconnect(handle);
-	WARN_ON(!list_empty(&handler->h_list));
+	(void)WARN_ON(!list_empty(&handler->h_list));
 
 	list_del_init(&handler->node);
 
diff --git a/drivers/input/keyboard/atkbd.c b/drivers/input/keyboard/atkbd.c
index e05a2e7..4a793a5 100644
--- a/drivers/input/keyboard/atkbd.c
+++ b/drivers/input/keyboard/atkbd.c
@@ -976,7 +976,7 @@ static void atkbd_set_keycode_table(struct atkbd *atkbd)
 	unsigned int scancode;
 	int i, j;
 
-	memset(atkbd->keycode, 0, sizeof(atkbd->keycode));
+	(void)memset(atkbd->keycode, 0, sizeof(atkbd->keycode));
 	bitmap_zero(atkbd->force_release_mask, ATKBD_KEYMAP_SIZE);
 
 	if (atkbd->translated) {
diff --git a/drivers/input/mousedev.c b/drivers/input/mousedev.c
index 0110b5a..e71937d 100644
--- a/drivers/input/mousedev.c
+++ b/drivers/input/mousedev.c
@@ -285,7 +285,7 @@ static void mousedev_notify_readers(struct mousedev *mousedev,
 			new_head = (client->head + 1) % PACKET_QUEUE_LEN;
 			if (new_head != client->tail) {
 				p = &client->packets[client->head = new_head];
-				memset(p, 0, sizeof(struct mousedev_motion));
+				(void)memset(p, 0, sizeof(struct mousedev_motion));
 			}
 		}
 
diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c
index 07a8363..eb6e035 100644
--- a/drivers/input/serio/libps2.c
+++ b/drivers/input/serio/libps2.c
@@ -43,7 +43,7 @@ int ps2_sendbyte(struct ps2dev *ps2dev, unsigned char byte, int timeout)
 	serio_continue_rx(ps2dev->serio);
 
 	if (serio_write(ps2dev->serio, byte) == 0)
-		wait_event_timeout(ps2dev->wait,
+		(void)wait_event_timeout(ps2dev->wait,
 				   !(ps2dev->flags & PS2_FLAG_ACK),
 				   msecs_to_jiffies(timeout));
 
@@ -81,7 +81,7 @@ EXPORT_SYMBOL(ps2_end_command);
 void ps2_drain(struct ps2dev *ps2dev, int maxbytes, int timeout)
 {
 	if (maxbytes > sizeof(ps2dev->cmdbuf)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		maxbytes = sizeof(ps2dev->cmdbuf);
 	}
 
@@ -92,7 +92,7 @@ void ps2_drain(struct ps2dev *ps2dev, int maxbytes, int timeout)
 	ps2dev->cmdcnt = maxbytes;
 	serio_continue_rx(ps2dev->serio);
 
-	wait_event_timeout(ps2dev->wait,
+	(void)wait_event_timeout(ps2dev->wait,
 			   !(ps2dev->flags & PS2_FLAG_CMD),
 			   msecs_to_jiffies(timeout));
 
@@ -190,12 +190,12 @@ int __ps2_command(struct ps2dev *ps2dev, unsigned char *param, int command)
 	int i;
 
 	if (receive > sizeof(ps2dev->cmdbuf)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -1;
 	}
 
 	if (send && !param) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -1;
 	}
 
@@ -231,7 +231,7 @@ int __ps2_command(struct ps2dev *ps2dev, unsigned char *param, int command)
 	if (ps2dev->cmdcnt && !(ps2dev->flags & PS2_FLAG_CMD1)) {
 
 		timeout = ps2_adjust_timeout(ps2dev, command, timeout);
-		wait_event_timeout(ps2dev->wait,
+		(void)wait_event_timeout(ps2dev->wait,
 				   !(ps2dev->flags & PS2_FLAG_CMD), timeout);
 	}
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index f545a3e..900ef5b 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -207,7 +207,7 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 			 mrq->stop->arg, mrq->stop->flags);
 	}
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	mrq->cmd->error = 0;
 	mrq->cmd->mrq = mrq;
@@ -456,9 +456,9 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 {
 	struct mmc_request mrq = {NULL};
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
-	memset(cmd->resp, 0, sizeof(cmd->resp));
+	(void)memset(cmd->resp, 0, sizeof(cmd->resp));
 	cmd->retries = retries;
 
 	mrq.cmd = cmd;
@@ -831,7 +831,7 @@ EXPORT_SYMBOL(mmc_host_lazy_disable);
  */
 void mmc_release_host(struct mmc_host *host)
 {
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	mmc_host_lazy_disable(host);
 
@@ -876,7 +876,7 @@ void mmc_set_chip_select(struct mmc_host *host, int mode)
  */
 static void __mmc_set_clock(struct mmc_host *host, unsigned int hz)
 {
-	WARN_ON(hz < host->f_min);
+	(void)WARN_ON(hz < host->f_min);
 
 	if (hz > host->f_max)
 		hz = host->f_max;
@@ -1409,7 +1409,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 	BUG_ON(!host);
 	BUG_ON(!ops);
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1432,8 +1432,8 @@ void mmc_detach_bus(struct mmc_host *host)
 
 	BUG_ON(!host);
 
-	WARN_ON(!host->claimed);
-	WARN_ON(!host->bus_ops);
+	(void)WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->bus_ops);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1664,7 +1664,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 	if (mmc_card_sd(card))
 		cmd.opcode = SD_ERASE_WR_BLK_END;
 	else
@@ -1679,7 +1679,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 	}
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
@@ -1696,7 +1696,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		goto out;
 
 	do {
-		memset(&cmd, 0, sizeof(struct mmc_command));
+		(void)memset(&cmd, 0, sizeof(struct mmc_command));
 		cmd.opcode = MMC_SEND_STATUS;
 		cmd.arg = card->rca << 16;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
@@ -2078,7 +2078,7 @@ int mmc_detect_card_removed(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 	/*
 	 * The card will be considered unchanged unless we have been asked to
 	 * detect a change or host requires polling to provide card detection.
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 30055f2..442cb33 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -367,7 +367,7 @@ int mmc_add_host(struct mmc_host *host)
 {
 	int err;
 
-	WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
+	(void)WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
 		!host->ops->enable_sdio_irq);
 
 	err = device_add(&host->class_dev);
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c63ad03..daf54e0 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -65,7 +65,7 @@ void mmc_decode_cid(struct mmc_card *card)
 {
 	u32 *resp = card->raw_cid;
 
-	memset(&card->cid, 0, sizeof(struct mmc_cid));
+	(void)memset(&card->cid, 0, sizeof(struct mmc_cid));
 
 	/*
 	 * SD doesn't currently have a version field so we will
@@ -901,7 +901,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	u32 rocr = 0;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
 	if (err)
@@ -1143,7 +1143,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	u32 ocr;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Make sure we are at 3.3V signalling voltage */
 	err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, false);
diff --git a/drivers/mmc/core/sd_ops.c b/drivers/mmc/core/sd_ops.c
index 274ef00..27e4807 100644
--- a/drivers/mmc/core/sd_ops.c
+++ b/drivers/mmc/core/sd_ops.c
@@ -92,9 +92,9 @@ int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
 			continue;
 		}
 
-		memset(&mrq, 0, sizeof(struct mmc_request));
+		(void)memset(&mrq, 0, sizeof(struct mmc_request));
 
-		memset(cmd->resp, 0, sizeof(cmd->resp));
+		(void)memset(cmd->resp, 0, sizeof(cmd->resp));
 		cmd->retries = 0;
 
 		mrq.cmd = cmd;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index bd7bacc..4953bc3 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -105,7 +105,7 @@ static int sdio_read_cccr(struct mmc_card *card)
 	unsigned char data;
 	unsigned char speed;
 
-	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
+	(void)memset(&card->cccr, 0, sizeof(struct sdio_cccr));
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);
 	if (ret)
@@ -578,7 +578,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/*
 	 * Inform the card of the voltage
@@ -1043,7 +1043,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	struct mmc_card *card;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	err = mmc_send_io_op_cond(host, 0, &ocr);
 	if (err)
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 68f81b9..3f26671 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -166,7 +166,7 @@ static int sdio_card_irq_get(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	if (!host->sdio_irqs++) {
 		atomic_set(&host->sdio_irq_thread_abort, 0);
@@ -187,7 +187,7 @@ static int sdio_card_irq_put(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
 
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 	BUG_ON(host->sdio_irqs < 1);
 
 	if (!--host->sdio_irqs) {
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 0d955ff..06b696f 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -588,7 +588,7 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	data->bytes_xfered = 0;
 
 	clks = (unsigned long long)data->timeout_ns * host->cclk;
-	do_div(clks, 1000000000UL);
+	(void)do_div(clks, 1000000000UL);
 
 	timeout = data->timeout_clks + (unsigned int)clks;
 
@@ -985,7 +985,7 @@ static void mmci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	struct mmci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	WARN_ON(host->mrq != NULL);
+	(void)WARN_ON(host->mrq != NULL);
 
 	if (mrq->data && !is_power_of_2(mrq->data->blksz)) {
 		dev_err(mmc_dev(mmc), "unsupported block size (%d bytes)\n",
diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index e1e122f..be1dfb7 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -176,7 +176,7 @@ static void fixup_convert_atmel_pri(struct mtd_info *mtd)
 	extp->ProtRegAddr = cpu_to_le16(extp->ProtRegAddr);
 
 	memcpy(&atmel_pri, extp, sizeof(atmel_pri));
-	memset((char *)extp + 5, 0, sizeof(*extp) - 5);
+	(void)memset((char *)extp + 5, 0, sizeof(*extp) - 5);
 
 	printk(KERN_ERR "atmel Features: %02x\n", atmel_pri.Features);
 
diff --git a/drivers/mtd/chips/cfi_probe.c b/drivers/mtd/chips/cfi_probe.c
index d255352..496ff43 100644
--- a/drivers/mtd/chips/cfi_probe.c
+++ b/drivers/mtd/chips/cfi_probe.c
@@ -173,7 +173,7 @@ static int __xipram cfi_chip_setup(struct map_info *map,
 		return 0;
 	}
 
-	memset(cfi->cfiq,0,sizeof(struct cfi_ident));
+	(void)memset(cfi->cfiq,0,sizeof(struct cfi_ident));
 
 	cfi->cfi_mode = CFI_MODE_CFI;
 
diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 3b9a284..3d6028b 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -64,7 +64,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	int i, j, mapsize;
 	int max_chips;
 
-	memset(&cfi, 0, sizeof(cfi));
+	(void)memset(&cfi, 0, sizeof(cfi));
 
 	/* Call the probetype-specific code with all permutations of
 	   interleave and device type, etc. */
@@ -146,7 +146,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	}
 
 	memcpy(retcfi, &cfi, sizeof(cfi));
-	memset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);
+	(void)memset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);
 
 	for (i = 0, j = 0; (j < cfi.numchips) && (i < max_chips); i++) {
 		if(test_bit(i, chip_map)) {
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index 424ca5f..9f7d72a 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -454,7 +454,7 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
 	if (new->disk_attributes) {
 		ret = sysfs_create_group(&disk_to_dev(gd)->kobj,
 					new->disk_attributes);
-		WARN_ON(ret);
+		(void)WARN_ON(ret);
 	}
 	return 0;
 error4:
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 50c6a1e..224c317 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -511,7 +511,7 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 	if (!from || !to)
 		return -EINVAL;
 
-	memset(to, 0, sizeof(*to));
+	(void)memset(to, 0, sizeof(*to));
 
 	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES);
 	for (i = 0; i < to->eccbytes; i++)
@@ -663,7 +663,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 
 	case MEMGETINFO:
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		info.type	= mtd->type;
 		info.flags	= mtd->flags;
 		info.size	= mtd->size;
diff --git a/drivers/mtd/mtdconcat.c b/drivers/mtd/mtdconcat.c
index 1ed5103..d18b05f 100644
--- a/drivers/mtd/mtdconcat.c
+++ b/drivers/mtd/mtdconcat.c
@@ -944,7 +944,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 					erase_region_p->erasesize =
 					    curr_erasesize;
 					tmp64 = position - begin;
-					do_div(tmp64, curr_erasesize);
+					(void)do_div(tmp64, curr_erasesize);
 					erase_region_p->numblocks = tmp64;
 					begin = position;
 
@@ -963,7 +963,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 						erase_region_p->erasesize =
 						    curr_erasesize;
 						tmp64 = position - begin;
-						do_div(tmp64, curr_erasesize);
+						(void)do_div(tmp64, curr_erasesize);
 						erase_region_p->numblocks = tmp64;
 						begin = position;
 
@@ -982,7 +982,7 @@ struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to c
 		erase_region_p->offset = begin;
 		erase_region_p->erasesize = curr_erasesize;
 		tmp64 = position - begin;
-		do_div(tmp64, curr_erasesize);
+		(void)do_div(tmp64, curr_erasesize);
 		erase_region_p->numblocks = tmp64;
 	}
 
diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index d2256d0..f078723 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -183,7 +183,7 @@ static void reset_buffer_flags(struct tty_struct *tty)
 	mutex_unlock(&tty->echo_lock);
 
 	tty->canon_head = tty->canon_data = tty->erasing = 0;
-	memset(&tty->read_flags, 0, sizeof tty->read_flags);
+	(void)memset(&tty->read_flags, 0, sizeof tty->read_flags);
 	n_tty_set_room(tty);
 }
 
@@ -1463,7 +1463,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 	if (old)
 		canon_change = (old->c_lflag ^ tty->termios->c_lflag) & ICANON;
 	if (canon_change) {
-		memset(&tty->read_flags, 0, sizeof tty->read_flags);
+		(void)memset(&tty->read_flags, 0, sizeof tty->read_flags);
 		tty->canon_head = tty->read_tail;
 		tty->canon_data = 0;
 		tty->erasing = 0;
@@ -1483,7 +1483,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
 	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
 	    I_PARMRK(tty)) {
-		memset(tty->process_char_map, 0, 256/8);
+		(void)memset(tty->process_char_map, 0, 256/8);
 
 		if (I_IGNCR(tty) || I_ICRNL(tty))
 			set_bit('\r', tty->process_char_map);
diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index d8653ab..a6b7cd5 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -39,7 +39,7 @@ static void pty_close(struct tty_struct *tty, struct file *filp)
 {
 	BUG_ON(!tty);
 	if (tty->driver->subtype == PTY_TYPE_MASTER)
-		WARN_ON(tty->count > 1);
+		(void)WARN_ON(tty->count > 1);
 	else {
 		if (tty->count > 2)
 			return;
diff --git a/drivers/tty/serial/8250.c b/drivers/tty/serial/8250.c
index 9f50c4e..4dab9be 100644
--- a/drivers/tty/serial/8250.c
+++ b/drivers/tty/serial/8250.c
@@ -2194,7 +2194,7 @@ static void serial8250_shutdown(struct uart_port *port)
 	spin_lock_irqsave(&up->port.lock, flags);
 	if (up->port.flags & UPF_FOURPORT) {
 		/* reset interrupts on the AST Fourport board */
-		inb((up->port.iobase & 0xfe0) | 0x1f);
+		(void)inb((up->port.iobase & 0xfe0) | 0x1f);
 		up->port.mctrl |= TIOCM_OUT1;
 	} else
 		up->port.mctrl &= ~TIOCM_OUT2;
@@ -3026,7 +3026,7 @@ static int __devinit serial8250_probe(struct platform_device *dev)
 	struct uart_port port;
 	int ret, i, irqflag = 0;
 
-	memset(&port, 0, sizeof(struct uart_port));
+	(void)memset(&port, 0, sizeof(struct uart_port));
 
 	if (share_irqs)
 		irqflag = IRQF_SHARED;
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index c7bf31a..bd971e1 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -397,7 +397,7 @@ uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,
 		}
 	}
 	/* Should never happen */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
@@ -506,7 +506,7 @@ static int uart_write(struct tty_struct *tty,
 	 * closed.  No cookie for you.
 	 */
 	if (!state) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return -EL3HLT;
 	}
 
@@ -570,7 +570,7 @@ static void uart_flush_buffer(struct tty_struct *tty)
 	 * closed.  No cookie for you.
 	 */
 	if (!state) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -641,7 +641,7 @@ static int uart_get_info(struct uart_state *state,
 	struct tty_port *port = &state->port;
 	struct serial_struct tmp;
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 
 	/* Ensure the state we copy is consistent and no hardware changes
 	   occur as we go */
@@ -1777,7 +1777,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 	spin_lock_init(&port->lock);
 	lockdep_set_class(&port->lock, &port_lock_key);
 
-	memset(&termios, 0, sizeof(struct ktermios));
+	(void)memset(&termios, 0, sizeof(struct ktermios));
 
 	termios.c_cflag = CREAD | HUPCL | CLOCAL;
 
@@ -1954,7 +1954,7 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		/*
 		 * First try to use the console cflag setting.
 		 */
-		memset(&termios, 0, sizeof(struct ktermios));
+		(void)memset(&termios, 0, sizeof(struct ktermios));
 		termios.c_cflag = uport->cons->cflag;
 
 		/*
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 6c9b7cd..4bb9837 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -89,7 +89,7 @@ static void tty_buffer_free(struct tty_struct *tty, struct tty_buffer *b)
 {
 	/* Dumb strategy for now - should keep some stats */
 	tty->buf.memory_used -= b->size;
-	WARN_ON(tty->buf.memory_used < 0);
+	(void)WARN_ON(tty->buf.memory_used < 0);
 
 	if (b->size >= 512)
 		kfree(b);
@@ -255,7 +255,7 @@ int tty_insert_flip_string_fixed_flag(struct tty_struct *tty,
 		if (unlikely(space == 0))
 			break;
 		memcpy(tb->char_buf_ptr + tb->used, chars, space);
-		memset(tb->flag_buf_ptr + tb->used, flag, space);
+		(void)memset(tb->flag_buf_ptr + tb->used, flag, space);
 		tb->used += space;
 		copied += space;
 		chars += space;
@@ -348,7 +348,7 @@ int tty_prepare_flip_string(struct tty_struct *tty, unsigned char **chars,
 	if (likely(space)) {
 		struct tty_buffer *tb = tty->buf.tail;
 		*chars = tb->char_buf_ptr + tb->used;
-		memset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);
+		(void)memset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);
 		tb->used += space;
 	}
 	return space;
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index e41b9bb..9691b31 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1354,7 +1354,7 @@ static int tty_reopen(struct tty_struct *tty)
 	tty->driver = driver; /* N.B. why do this every time?? */
 
 	mutex_lock(&tty->ldisc_mutex);
-	WARN_ON(!test_bit(TTY_LDISC, &tty->flags));
+	(void)WARN_ON(!test_bit(TTY_LDISC, &tty->flags));
 	mutex_unlock(&tty->ldisc_mutex);
 
 	return 0;
@@ -1549,7 +1549,7 @@ EXPORT_SYMBOL(tty_kref_put);
 static void release_tty(struct tty_struct *tty, int idx)
 {
 	/* This should always be true but check for the moment */
-	WARN_ON(tty->index != idx);
+	(void)WARN_ON(tty->index != idx);
 
 	if (tty->link)
 		tty_kref_put(tty->link);
@@ -2598,7 +2598,7 @@ static int tty_tiocgicount(struct tty_struct *tty, void __user *arg)
 {
 	int retval = -EINVAL;
 	struct serial_icounter_struct icount;
-	memset(&icount, 0, sizeof(icount));
+	(void)memset(&icount, 0, sizeof(icount));
 	if (tty->ops->get_icount)
 		retval = tty->ops->get_icount(tty, &icount);
 	if (retval != 0)
@@ -2934,7 +2934,7 @@ static struct device *tty_get_device(struct tty_struct *tty)
 void initialize_tty_struct(struct tty_struct *tty,
 		struct tty_driver *driver, int idx)
 {
-	memset(tty, 0, sizeof(struct tty_struct));
+	(void)memset(tty, 0, sizeof(struct tty_struct));
 	kref_init(&tty->kref);
 	tty->magic = TTY_MAGIC;
 	tty_ldisc_init(tty);
@@ -3400,7 +3400,7 @@ int __init tty_init(void)
 	if (IS_ERR(consdev))
 		consdev = NULL;
 	else
-		WARN_ON(device_create_file(consdev, &dev_attr_active) < 0);
+		(void)WARN_ON(device_create_file(consdev, &dev_attr_active) < 0);
 
 #ifdef CONFIG_VT
 	vty_init(&console_fops);
diff --git a/drivers/tty/tty_ldisc.c b/drivers/tty/tty_ldisc.c
index 24b95db..98ccbf7 100644
--- a/drivers/tty/tty_ldisc.c
+++ b/drivers/tty/tty_ldisc.c
@@ -429,7 +429,7 @@ static void tty_set_termios_ldisc(struct tty_struct *tty, int num)
 
 static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)
 {
-	WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));
+	(void)WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));
 	if (ld->ops->open) {
 		int ret;
                 /* BTM here locks versus a hangup event */
@@ -452,7 +452,7 @@ static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)
 
 static void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)
 {
-	WARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));
+	(void)WARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));
 	clear_bit(TTY_LDISC_OPEN, &tty->flags);
 	if (ld->ops->close)
 		ld->ops->close(tty);
@@ -475,7 +475,7 @@ static void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)
 
 	/* There is an outstanding reference here so this is safe */
 	old = tty_ldisc_get(old->ops->num);
-	WARN_ON(IS_ERR(old));
+	(void)WARN_ON(IS_ERR(old));
 	tty_ldisc_assign(tty, old);
 	tty_set_termios_ldisc(tty, old->ops->num);
 	if (tty_ldisc_open(tty, old) < 0) {
@@ -854,7 +854,7 @@ retry:
 		   N_TTY open cannot fail */
 		if (reset || err) {
 			BUG_ON(tty_ldisc_reinit(tty, N_TTY));
-			WARN_ON(tty_ldisc_open(tty, tty->ldisc));
+			(void)WARN_ON(tty_ldisc_open(tty, tty->ldisc));
 		}
 		tty_ldisc_enable(tty);
 	}
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index ef9dd62..1df91d9 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -20,7 +20,7 @@
 
 void tty_port_init(struct tty_port *port)
 {
-	memset(port, 0, sizeof(*port));
+	(void)memset(port, 0, sizeof(*port));
 	init_waitqueue_head(&port->open_wait);
 	init_waitqueue_head(&port->close_wait);
 	init_waitqueue_head(&port->delta_msr_wait);
@@ -231,7 +231,7 @@ int tty_port_block_til_ready(struct tty_port *port,
 
 	/* block if port is in the process of being closed */
 	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		wait_event_interruptible_tty(port->close_wait,
+		(void)wait_event_interruptible_tty(port->close_wait,
 				!(port->flags & ASYNC_CLOSING));
 		if (port->flags & ASYNC_HUP_NOTIFY)
 			return -EAGAIN;
diff --git a/drivers/tty/vt/consolemap.c b/drivers/tty/vt/consolemap.c
index a0f3d6c..a6f0e27 100644
--- a/drivers/tty/vt/consolemap.c
+++ b/drivers/tty/vt/consolemap.c
@@ -197,7 +197,7 @@ static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int
 			kmalloc(MAX_GLYPH, GFP_KERNEL);
 		if (!q) return;
 	}
-	memset(q, 0, MAX_GLYPH);
+	(void)memset(q, 0, MAX_GLYPH);
 
 	for (j = 0; j < E_TABSZ; j++) {
 		glyph = conv_uni_to_pc(conp, t[j]);
@@ -223,7 +223,7 @@ static void set_inverse_trans_unicode(struct vc_data *conp,
 		if (!q)
 			return;
 	}
-	memset(q, 0, MAX_GLYPH * sizeof(u16));
+	(void)memset(q, 0, MAX_GLYPH * sizeof(u16));
 
 	for (i = 0; i < 32; i++) {
 		p1 = p->uni_pgdir[i];
@@ -314,7 +314,7 @@ int con_set_trans_old(unsigned char __user * arg)
 
 	for (i=0; i<E_TABSZ ; i++) {
 		unsigned char uc;
-		__get_user(uc, arg+i);
+		(void)__get_user(uc, arg+i);
 		p[i] = UNI_DIRECT_BASE | uc;
 	}
 
@@ -333,7 +333,7 @@ int con_get_trans_old(unsigned char __user * arg)
 	for (i=0; i<E_TABSZ ; i++)
 	  {
 	    ch = conv_uni_to_pc(vc_cons[fg_console].d, p[i]);
-	    __put_user((ch & ~0xff) ? 0 : ch, arg+i);
+	    (void)__put_user((ch & ~0xff) ? 0 : ch, arg+i);
 	  }
 	return 0;
 }
@@ -348,7 +348,7 @@ int con_set_trans_new(ushort __user * arg)
 
 	for (i=0; i<E_TABSZ ; i++) {
 		unsigned short us;
-		__get_user(us, arg+i);
+		(void)__get_user(us, arg+i);
 		p[i] = us;
 	}
 
@@ -365,7 +365,7 @@ int con_get_trans_new(ushort __user * arg)
 		return -EFAULT;
 
 	for (i=0; i<E_TABSZ ; i++)
-	  __put_user(p[i], arg+i);
+	  (void)__put_user(p[i], arg+i);
 	
 	return 0;
 }
@@ -477,7 +477,7 @@ con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)
 	if (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {
 		p2 = p1[n] = kmalloc(64*sizeof(u16), GFP_KERNEL);
 		if (!p2) return -ENOMEM;
-		memset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */
+		(void)memset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */
 	}
 
 	p2[unicode & 0x3f] = fontpos;
@@ -550,8 +550,8 @@ int con_set_unimap(struct vc_data *vc, ushort ct, struct unipair __user *list)
 	
 	while (ct--) {
 		unsigned short unicode, fontpos;
-		__get_user(unicode, &list->unicode);
-		__get_user(fontpos, &list->fontpos);
+		(void)__get_user(unicode, &list->unicode);
+		(void)__get_user(fontpos, &list->fontpos);
 		if ((err1 = con_insert_unipair(p, unicode,fontpos)) != 0)
 			err = err1;
 		list++;
@@ -649,16 +649,16 @@ int con_get_unimap(struct vc_data *vc, ushort ct, ushort __user *uct, struct uni
 			if ((p2 = *(p1++)))
 				for (k = 0; k < 64; k++) {
 					if (*p2 < MAX_GLYPH && ect++ < ct) {
-						__put_user((u_short)((i<<11)+(j<<6)+k),
+						(void)__put_user((u_short)((i<<11)+(j<<6)+k),
 							   &list->unicode);
-						__put_user((u_short) *p2, 
+						(void)__put_user((u_short) *p2, 
 							   &list->fontpos);
 						list++;
 					}
 					p2++;
 				}
 	}
-	__put_user(ect, uct);
+	(void)__put_user(ect, uct);
 	return ((ect <= ct) ? 0 : -ENOMEM);
 }
 
diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c
index a605549..5a8f6e9 100644
--- a/drivers/tty/vt/keyboard.c
+++ b/drivers/tty/vt/keyboard.c
@@ -389,7 +389,7 @@ void compute_shiftstate(void)
 	unsigned int i, j, k, sym, val;
 
 	shift_state = 0;
-	memset(shift_down, 0, sizeof(shift_down));
+	(void)memset(shift_down, 0, sizeof(shift_down));
 
 	for (i = 0; i < ARRAY_SIZE(key_down); i++) {
 
diff --git a/drivers/tty/vt/selection.c b/drivers/tty/vt/selection.c
index 7a0a12a..297e815 100644
--- a/drivers/tty/vt/selection.c
+++ b/drivers/tty/vt/selection.c
@@ -146,11 +146,11 @@ int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *t
 
 	  if (!access_ok(VERIFY_READ, sel, sizeof(*sel)))
 		return -EFAULT;
-	  __get_user(xs, &sel->xs);
-	  __get_user(ys, &sel->ys);
-	  __get_user(xe, &sel->xe);
-	  __get_user(ye, &sel->ye);
-	  __get_user(sel_mode, &sel->sel_mode);
+	  (void)__get_user(xs, &sel->xs);
+	  (void)__get_user(ys, &sel->ys);
+	  (void)__get_user(xe, &sel->xe);
+	  (void)__get_user(ye, &sel->ye);
+	  (void)__get_user(sel_mode, &sel->sel_mode);
 	  xs--; ys--; xe--; ye--;
 	  xs = limit(xs, vc->vc_cols - 1);
 	  ys = limit(ys, vc->vc_rows - 1);
diff --git a/drivers/tty/vt/vc_screen.c b/drivers/tty/vt/vc_screen.c
index 7a367ff..938d584 100644
--- a/drivers/tty/vt/vc_screen.c
+++ b/drivers/tty/vt/vc_screen.c
@@ -139,7 +139,7 @@ vcs_vc(struct inode *inode, int *viewed)
 {
 	unsigned int currcons = iminor(inode) & 127;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (currcons == 0) {
 		currcons = fg_console;
@@ -164,7 +164,7 @@ vcs_size(struct inode *inode)
 	int minor = iminor(inode);
 	struct vc_data *vc;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	vc = vcs_vc(inode, NULL);
 	if (!vc)
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index e716839..db83bd7 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -390,7 +390,7 @@ static void do_update_region(struct vc_data *vc, unsigned long start, int count)
 
 void update_region(struct vc_data *vc, unsigned long start, int count)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (DO_UPDATE(vc)) {
 		hide_cursor(vc);
@@ -461,7 +461,7 @@ void invert_screen(struct vc_data *vc, int offset, int count, int viewed)
 {
 	unsigned short *p;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	count /= 2;
 	p = screenpos(vc, offset, viewed);
@@ -508,7 +508,7 @@ void complement_pos(struct vc_data *vc, int offset)
 	static unsigned short old;
 	static unsigned short oldx, oldy;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (old_offset != -1 && old_offset >= 0 &&
 	    old_offset < vc->vc_screenbuf_size) {
@@ -634,7 +634,7 @@ static void set_cursor(struct vc_data *vc)
 
 static void set_origin(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!CON_IS_VISIBLE(vc) ||
 	    !vc->vc_sw->con_set_origin ||
@@ -647,7 +647,7 @@ static void set_origin(struct vc_data *vc)
 
 static inline void save_screen(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc->vc_sw->con_save_screen)
 		vc->vc_sw->con_save_screen(vc);
@@ -672,7 +672,7 @@ void redraw_screen(struct vc_data *vc, int is_switch)
 {
 	int redraw = 0;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!vc) {
 		/* strange ... */
@@ -769,7 +769,7 @@ static void visual_init(struct vc_data *vc, int num, int init)
 
 int vc_allocate(unsigned int currcons)	/* return 0 on success */
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (currcons >= MAX_NR_CONSOLES)
 		return -ENXIO;
@@ -861,7 +861,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 	unsigned int user;
 	unsigned short *newscreen;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (!vc)
 		return -ENXIO;
@@ -951,7 +951,7 @@ static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,
 		/* Rewrite the requested winsize data with the actual
 		   resulting sizes */
 		struct winsize ws;
-		memset(&ws, 0, sizeof(ws));
+		(void)memset(&ws, 0, sizeof(ws));
 		ws.ws_row = vc->vc_rows;
 		ws.ws_col = vc->vc_cols;
 		ws.ws_ypixel = vc->vc_scan_lines;
@@ -1006,7 +1006,7 @@ static int vt_resize(struct tty_struct *tty, struct winsize *ws)
 
 void vc_deallocate(unsigned int currcons)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc_cons_allocated(currcons)) {
 		struct vc_data *vc = vc_cons[currcons].d;
@@ -2984,7 +2984,7 @@ int __init vty_init(const struct file_operations *console_fops)
 	if (IS_ERR(tty0dev))
 		tty0dev = NULL;
 	else
-		WARN_ON(device_create_file(tty0dev, &dev_attr_active) < 0);
+		(void)WARN_ON(device_create_file(tty0dev, &dev_attr_active) < 0);
 
 	vcs_init();
 
@@ -3725,7 +3725,7 @@ void do_blank_screen(int entering_gfx)
 	struct vc_data *vc = vc_cons[fg_console].d;
 	int i;
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (console_blanked) {
 		if (blank_state == blank_vesa_wait) {
@@ -3792,7 +3792,7 @@ void do_unblank_screen(int leaving_gfx)
 	if (!oops_in_progress)
 		might_sleep();
 
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	ignore_poke = 0;
 	if (!console_blanked)
@@ -3853,7 +3853,7 @@ static void blank_screen_t(unsigned long dummy)
 
 void poke_blanked_console(void)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	/* Add this so we quickly catch whoever might call us in a non
 	 * safe context. Nowadays, unblank_screen() isn't to be called in
@@ -3885,7 +3885,7 @@ void poke_blanked_console(void)
 
 static void set_palette(struct vc_data *vc)
 {
-	WARN_CONSOLE_UNLOCKED();
+	(void)WARN_CONSOLE_UNLOCKED();
 
 	if (vc->vc_mode != KD_GRAPHICS)
 		vc->vc_sw->con_set_palette(vc, color_table);
@@ -3895,17 +3895,17 @@ static int set_get_cmap(unsigned char __user *arg, int set)
 {
     int i, j, k;
 
-    WARN_CONSOLE_UNLOCKED();
+    (void)WARN_CONSOLE_UNLOCKED();
 
     for (i = 0; i < 16; i++)
 	if (set) {
-	    get_user(default_red[i], arg++);
-	    get_user(default_grn[i], arg++);
-	    get_user(default_blu[i], arg++);
+	    (void)get_user(default_red[i], arg++);
+	    (void)get_user(default_grn[i], arg++);
+	    (void)get_user(default_blu[i], arg++);
 	} else {
-	    put_user(default_red[i], arg++);
-	    put_user(default_grn[i], arg++);
-	    put_user(default_blu[i], arg++);
+	    (void)put_user(default_red[i], arg++);
+	    (void)put_user(default_grn[i], arg++);
+	    (void)put_user(default_blu[i], arg++);
 	}
     if (set) {
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
diff --git a/drivers/tty/vt/vt_ioctl.c b/drivers/tty/vt/vt_ioctl.c
index 5e096f4..f9f7d1c 100644
--- a/drivers/tty/vt/vt_ioctl.c
+++ b/drivers/tty/vt/vt_ioctl.c
@@ -130,7 +130,7 @@ static void vt_event_wait(struct vt_event_wait *vw)
 	list_add(&vw->list, &vt_events);
 	spin_unlock_irqrestore(&vt_event_lock, flags);
 	/* Wait for it to pass */
-	wait_event_interruptible_tty(vt_event_waitqueue, vw->done);
+	(void)wait_event_interruptible_tty(vt_event_waitqueue, vw->done);
 	/* Dequeue it */
 	spin_lock_irqsave(&vt_event_lock, flags);
 	list_del(&vw->list);
@@ -1166,12 +1166,12 @@ int vt_ioctl(struct tty_struct *tty,
 			break;
 		}
 		/* FIXME: Should check the copies properly */
-		__get_user(ll, &vtconsize->v_rows);
-		__get_user(cc, &vtconsize->v_cols);
-		__get_user(vlin, &vtconsize->v_vlin);
-		__get_user(clin, &vtconsize->v_clin);
-		__get_user(vcol, &vtconsize->v_vcol);
-		__get_user(ccol, &vtconsize->v_ccol);
+		(void)__get_user(ll, &vtconsize->v_rows);
+		(void)__get_user(cc, &vtconsize->v_cols);
+		(void)__get_user(vlin, &vtconsize->v_vlin);
+		(void)__get_user(clin, &vtconsize->v_clin);
+		(void)__get_user(vcol, &vtconsize->v_vcol);
+		(void)__get_user(ccol, &vtconsize->v_ccol);
 		vlin = vlin ? vlin : vc->vc_scan_lines;
 		if (clin) {
 			if (ll) {
diff --git a/drivers/video/amba-clcd.c b/drivers/video/amba-clcd.c
index 0a2cce7..9863e32 100644
--- a/drivers/video/amba-clcd.c
+++ b/drivers/video/amba-clcd.c
@@ -137,7 +137,7 @@ clcdfb_set_bitfields(struct clcd_fb *fb, struct fb_var_screeninfo *var)
 	if (!(fb->panel->cntl & CNTL_LCDTFT))
 		caps &= ~CLCD_CAP_888;
 
-	memset(&var->transp, 0, sizeof(var->transp));
+	(void)memset(&var->transp, 0, sizeof(var->transp));
 
 	var->red.msb_right = 0;
 	var->green.msb_right = 0;
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index 8745637..09664d9 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -2182,7 +2182,7 @@ static int fbcon_switch(struct vc_data *vc)
 			o->currcon = vc->vc_num;
 		}
 	}
-	memset(&var, 0, sizeof(struct fb_var_screeninfo));
+	(void)memset(&var, 0, sizeof(struct fb_var_screeninfo));
 	display_to_var(&var, p);
 	var.activate = FB_ACTIVATE_NOW;
 
@@ -2382,7 +2382,7 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 		j = vc->vc_font.height;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 32 - j);
+			(void)memset(data + j, 0, 32 - j);
 			data += 32;
 			fontdata += j;
 		}
@@ -2390,7 +2390,7 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 		j = vc->vc_font.height * 2;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 64 - j);
+			(void)memset(data + j, 0, 64 - j);
 			data += 64;
 			fontdata += j;
 		}
@@ -2402,14 +2402,14 @@ static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
 				*data++ = fontdata[2];
 				fontdata += sizeof(u32);
 			}
-			memset(data, 0, 3 * (32 - j));
+			(void)memset(data, 0, 3 * (32 - j));
 			data += 3 * (32 - j);
 		}
 	} else {
 		j = vc->vc_font.height * 4;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
-			memset(data + j, 0, 128 - j);
+			(void)memset(data + j, 0, 128 - j);
 			data += 128;
 			fontdata += j;
 		}
diff --git a/drivers/video/fbcmap.c b/drivers/video/fbcmap.c
index 5c3960d..df84bcd 100644
--- a/drivers/video/fbcmap.c
+++ b/drivers/video/fbcmap.c
@@ -268,7 +268,7 @@ int fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *info)
 	if (size < 0 || size < cmap->len)
 		return -E2BIG;
 
-	memset(&umap, 0, sizeof(struct fb_cmap));
+	(void)memset(&umap, 0, sizeof(struct fb_cmap));
 	rc = fb_alloc_cmap_gfp(&umap, cmap->len, cmap->transp != NULL,
 				GFP_KERNEL);
 	if (rc)
diff --git a/drivers/video/fbcvt.c b/drivers/video/fbcvt.c
index 7cb715d..614d1a4 100644
--- a/drivers/video/fbcvt.c
+++ b/drivers/video/fbcvt.c
@@ -306,7 +306,7 @@ int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
 {
 	struct fb_cvt_data cvt;
 
-	memset(&cvt, 0, sizeof(cvt));
+	(void)memset(&cvt, 0, sizeof(cvt));
 
 	if (margins)
 	    cvt.flags |= FB_CVT_FLAG_MARGINS;
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index ac9141b..e67a5a6 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -917,8 +917,8 @@ static int fb_check_caps(struct fb_info *info, struct fb_var_screeninfo *var,
 	struct fb_blit_caps caps, fbcaps;
 	int err = 0;
 
-	memset(&caps, 0, sizeof(caps));
-	memset(&fbcaps, 0, sizeof(fbcaps));
+	(void)memset(&caps, 0, sizeof(caps));
+	(void)memset(&fbcaps, 0, sizeof(fbcaps));
 	caps.flags = (activate & FB_ACTIVATE_ALL) ? 1 : 0;
 	event.info = info;
 	event.data = &caps;
diff --git a/drivers/video/fbsysfs.c b/drivers/video/fbsysfs.c
index 67afa9c..f66f84c 100644
--- a/drivers/video/fbsysfs.c
+++ b/drivers/video/fbsysfs.c
@@ -134,7 +134,7 @@ static ssize_t store_mode(struct device *device, struct device_attribute *attr,
 	size_t i;
 	int err;
 
-	memset(&var, 0, sizeof(var));
+	(void)memset(&var, 0, sizeof(var));
 
 	list_for_each(pos, &fb_info->modelist) {
 		modelist = list_entry(pos, struct fb_modelist, list);
diff --git a/fs/aio.c b/fs/aio.c
index 969beb0..eec0a67 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1171,7 +1171,7 @@ static int read_events(struct kioctx *ctx,
 	/* needed to zero any padding within an entry (there shouldn't be 
 	 * any, but C is fun!
 	 */
-	memset(&ent, 0, sizeof(ent));
+	(void)memset(&ent, 0, sizeof(ent));
 retry:
 	ret = 0;
 	while (likely(i < nr)) {
@@ -1832,7 +1832,7 @@ SYSCALL_DEFINE3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb,
 	if (NULL != cancel) {
 		struct io_event tmp;
 		pr_debug("calling cancel\n");
-		memset(&tmp, 0, sizeof(tmp));
+		(void)memset(&tmp, 0, sizeof(tmp));
 		tmp.obj = (u64)(unsigned long)kiocb->ki_obj.user;
 		tmp.data = kiocb->ki_user_data;
 		ret = cancel(kiocb, &tmp);
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index bcb884e..2361046 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -247,7 +247,7 @@ create_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,
 	}
 #undef NEW_AUX_ENT
 	/* AT_NULL is zero; clear the rest too */
-	memset(&elf_info[ei_index], 0,
+	(void)memset(&elf_info[ei_index], 0,
 	       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);
 
 	/* And advance past the AT_NULL entry.  */
@@ -983,7 +983,7 @@ static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
 
-	start_thread(regs, elf_entry, bprm->p);
+	(void)start_thread(regs, elf_entry, bprm->p);
 	retval = 0;
 out:
 	kfree(loc);
@@ -1230,7 +1230,7 @@ static int writenote(struct memelfnote *men, struct file *file,
 static void fill_elf_header(struct elfhdr *elf, int segs,
 			    u16 machine, u32 flags, u8 osabi)
 {
-	memset(elf, 0, sizeof(*elf));
+	(void)memset(elf, 0, sizeof(*elf));
 
 	memcpy(elf->e_ident, ELFMAG, SELFMAG);
 	elf->e_ident[EI_CLASS] = ELF_CLASS;
@@ -1314,7 +1314,7 @@ static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,
 	unsigned int i, len;
 	
 	/* first copy the parameters from user space */
-	memset(psinfo, 0, sizeof(struct elf_prpsinfo));
+	(void)memset(psinfo, 0, sizeof(struct elf_prpsinfo));
 
 	len = mm->arg_end - mm->arg_start;
 	if (len >= ELF_PRARGSZ)
@@ -1484,7 +1484,7 @@ static int fill_note_info(struct elfhdr *elf, int phdrs,
 	 */
 	if (unlikely(info->thread_notes == 0) ||
 	    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return 0;
 	}
 
@@ -1582,7 +1582,7 @@ static void free_note_info(struct elf_note_info *info)
 		unsigned int i;
 		struct elf_thread_core_info *t = threads;
 		threads = t->next;
-		WARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);
+		(void)WARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);
 		for (i = 1; i < info->thread_notes; ++i)
 			kfree(t->notes[i].data);
 		kfree(t);
@@ -1853,7 +1853,7 @@ static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,
 	elf->e_shnum = 1;
 	elf->e_shstrndx = SHN_UNDEF;
 
-	memset(shdr4extnum, 0, sizeof(*shdr4extnum));
+	(void)memset(shdr4extnum, 0, sizeof(*shdr4extnum));
 
 	shdr4extnum->sh_type = SHT_NULL;
 	shdr4extnum->sh_size = elf->e_shnum;
diff --git a/fs/bio.c b/fs/bio.c
index b1fe82c..31a889a 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -137,7 +137,7 @@ static void bio_put_slab(struct bio_set *bs)
 	if (WARN(!bslab, KERN_ERR "bio: unable to find slab!\n"))
 		goto out;
 
-	WARN_ON(!bslab->slab_ref);
+	(void)WARN_ON(!bslab->slab_ref);
 
 	if (--bslab->slab_ref)
 		goto out;
@@ -253,7 +253,7 @@ EXPORT_SYMBOL(bio_free);
 
 void bio_init(struct bio *bio)
 {
-	memset(bio, 0, sizeof(*bio));
+	(void)memset(bio, 0, sizeof(*bio));
 	bio->bi_flags = 1 << BIO_UPTODATE;
 	atomic_set(&bio->bi_cnt, 1);
 }
@@ -395,7 +395,7 @@ void zero_fill_bio(struct bio *bio)
 
 	bio_for_each_segment(bv, bio, i) {
 		char *data = bvec_kmap_irq(bv, &flags);
-		memset(data, 0, bv->bv_len);
+		(void)memset(data, 0, bv->bv_len);
 		flush_dcache_page(bv->bv_page);
 		bvec_kunmap_irq(data, &flags);
 	}
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 0e575d1..7ba8418 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -461,7 +461,7 @@ static void init_once(void *foo)
 	struct bdev_inode *ei = (struct bdev_inode *) foo;
 	struct block_device *bdev = &ei->bdev;
 
-	memset(bdev, 0, sizeof(*bdev));
+	(void)memset(bdev, 0, sizeof(*bdev));
 	mutex_init(&bdev->bd_mutex);
 	INIT_LIST_HEAD(&bdev->bd_inodes);
 	INIT_LIST_HEAD(&bdev->bd_list);
@@ -890,7 +890,7 @@ int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)
 
 	mutex_lock(&bdev->bd_mutex);
 
-	WARN_ON_ONCE(!bdev->bd_holder);
+	(void)WARN_ON_ONCE(!bdev->bd_holder);
 
 	/* FIXME: remove the following once add_disk() handles errors */
 	if (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))
@@ -1274,7 +1274,7 @@ int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)
 	struct block_device *whole = NULL;
 	int res;
 
-	WARN_ON_ONCE((mode & FMODE_EXCL) && !holder);
+	(void)WARN_ON_ONCE((mode & FMODE_EXCL) && !holder);
 
 	if ((mode & FMODE_EXCL) && holder) {
 		whole = bd_start_claiming(bdev, holder);
@@ -1453,7 +1453,7 @@ static int __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)
 		bdev->bd_part_count--;
 
 	if (!--bdev->bd_openers) {
-		WARN_ON_ONCE(bdev->bd_holders);
+		(void)WARN_ON_ONCE(bdev->bd_holders);
 		sync_blockdev(bdev);
 		kill_bdev(bdev);
 		/* ->release can cause the old bdi to disappear,
@@ -1500,8 +1500,8 @@ int blkdev_put(struct block_device *bdev, fmode_t mode)
 		 */
 		spin_lock(&bdev_lock);
 
-		WARN_ON_ONCE(--bdev->bd_holders < 0);
-		WARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);
+		(void)WARN_ON_ONCE(--bdev->bd_holders < 0);
+		(void)WARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);
 
 		/* bd_contains might point to self, check in a separate step */
 		if ((bdev_free = !bdev->bd_holders))
diff --git a/fs/buffer.c b/fs/buffer.c
index 1a30db7..bfd2487 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -465,7 +465,7 @@ EXPORT_SYMBOL(mark_buffer_async_write);
 static void __remove_assoc_queue(struct buffer_head *bh)
 {
 	list_del_init(&bh->b_assoc_buffers);
-	WARN_ON(!bh->b_assoc_map);
+	(void)WARN_ON(!bh->b_assoc_map);
 	if (buffer_write_io_error(bh))
 		set_bit(AS_EIO, &bh->b_assoc_map->flags);
 	bh->b_assoc_map = NULL;
@@ -615,7 +615,7 @@ static void __set_page_dirty(struct page *page,
 {
 	spin_lock_irq(&mapping->tree_lock);
 	if (page->mapping) {	/* Race with truncate? */
-		WARN_ON_ONCE(warn && !PageUptodate(page));
+		(void)WARN_ON_ONCE(warn && !PageUptodate(page));
 		account_page_dirtied(page, mapping);
 		radix_tree_tag_set(&mapping->page_tree,
 				page_index(page), PAGECACHE_TAG_DIRTY);
@@ -1100,7 +1100,7 @@ __getblk_slow(struct block_device *bdev, sector_t block, int size)
  */
 void mark_buffer_dirty(struct buffer_head *bh)
 {
-	WARN_ON_ONCE(!buffer_uptodate(bh));
+	(void)WARN_ON_ONCE(!buffer_uptodate(bh));
 
 	/*
 	 * Very *carefully* optimize the it-is-already-dirty case.
@@ -1138,7 +1138,7 @@ void __brelse(struct buffer_head * buf)
 		put_bh(buf);
 		return;
 	}
-	WARN(1, KERN_ERR "VFS: brelse: Trying to free free buffer\n");
+	(void)WARN(1, KERN_ERR "VFS: brelse: Trying to free free buffer\n");
 }
 EXPORT_SYMBOL(__brelse);
 
@@ -1387,7 +1387,7 @@ static void invalidate_bh_lru(void *arg)
 	
 void invalidate_bh_lrus(void)
 {
-	on_each_cpu(invalidate_bh_lru, NULL, 1);
+	(void)on_each_cpu(invalidate_bh_lru, NULL, 1);
 }
 EXPORT_SYMBOL_GPL(invalidate_bh_lrus);
 
@@ -1623,7 +1623,7 @@ static int __block_write_full_page(struct inode *inode, struct page *page,
 			set_buffer_uptodate(bh);
 		} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&
 			   buffer_dirty(bh)) {
-			WARN_ON(bh->b_size != blocksize);
+			(void)WARN_ON(bh->b_size != blocksize);
 			err = get_block(inode, block, bh, 1);
 			if (err)
 				goto recover;
@@ -1815,7 +1815,7 @@ int __block_write_begin(struct page *page, loff_t pos, unsigned len,
 		if (buffer_new(bh))
 			clear_buffer_new(bh);
 		if (!buffer_mapped(bh)) {
-			WARN_ON(bh->b_size != blocksize);
+			(void)WARN_ON(bh->b_size != blocksize);
 			err = get_block(inode, block, bh, 1);
 			if (err)
 				break;
@@ -2081,7 +2081,7 @@ int block_read_full_page(struct page *page, get_block_t *get_block)
 
 			fully_mapped = 0;
 			if (iblock < lblock) {
-				WARN_ON(bh->b_size != blocksize);
+				(void)WARN_ON(bh->b_size != blocksize);
 				err = get_block(inode, iblock, bh, 0);
 				if (err)
 					SetPageError(page);
@@ -2744,7 +2744,7 @@ int block_truncate_page(struct address_space *mapping,
 
 	err = 0;
 	if (!buffer_mapped(bh)) {
-		WARN_ON(bh->b_size != blocksize);
+		(void)WARN_ON(bh->b_size != blocksize);
 		err = get_block(inode, iblock, bh, 0);
 		if (err)
 			goto unlock;
@@ -2982,7 +2982,7 @@ int __sync_dirty_buffer(struct buffer_head *bh, int rw)
 {
 	int ret = 0;
 
-	WARN_ON(atomic_read(&bh->b_count) < 1);
+	(void)WARN_ON(atomic_read(&bh->b_count) < 1);
 	lock_buffer(bh);
 	if (test_clear_buffer_dirty(bh)) {
 		get_bh(bh);
diff --git a/fs/char_dev.c b/fs/char_dev.c
index 3f152b9..c046775 100644
--- a/fs/char_dev.c
+++ b/fs/char_dev.c
@@ -541,7 +541,7 @@ struct cdev *cdev_alloc(void)
  */
 void cdev_init(struct cdev *cdev, const struct file_operations *fops)
 {
-	memset(cdev, 0, sizeof *cdev);
+	(void)memset(cdev, 0, sizeof *cdev);
 	INIT_LIST_HEAD(&cdev->list);
 	kobject_init(&cdev->kobj, &ktype_cdev_default);
 	cdev->ops = fops;
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index a2ee8f9..4c50286 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -213,7 +213,7 @@ static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned i
 			kunmap(page);
 			page_cache_release(page);
 		} else
-			memset(data, 0, PAGE_CACHE_SIZE);
+			(void)memset(data, 0, PAGE_CACHE_SIZE);
 		data += PAGE_CACHE_SIZE;
 	}
 	return read_buffers[buffer] + offset;
@@ -520,7 +520,7 @@ static int cramfs_readpage(struct file *file, struct page * page)
 		}
 	}
 
-	memset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);
+	(void)memset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);
 	flush_dcache_page(page);
 	kunmap(page);
 	SetPageUptodate(page);
diff --git a/fs/dcache.c b/fs/dcache.c
index 16a53cc..0ef8232 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -141,7 +141,7 @@ static void __d_free(struct rcu_head *head)
 {
 	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
 
-	WARN_ON(!list_empty(&dentry->d_alias));
+	(void)WARN_ON(!list_empty(&dentry->d_alias));
 	if (dname_external(dentry))
 		kfree(dentry->d_name.name);
 	kmem_cache_free(dentry_cache, dentry); 
@@ -1285,7 +1285,7 @@ EXPORT_SYMBOL(d_alloc_name);
 
 void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)
 {
-	WARN_ON_ONCE(dentry->d_op);
+	(void)WARN_ON_ONCE(dentry->d_op);
 	WARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH	|
 				DCACHE_OP_COMPARE	|
 				DCACHE_OP_REVALIDATE	|
@@ -2507,7 +2507,7 @@ global_root:
 	 */
 	if (IS_ROOT(dentry) &&
 	    (dentry->d_name.len != 1 || dentry->d_name.name[0] != '/')) {
-		WARN(1, "Root dentry has weird name <%.*s>\n",
+		(void)WARN(1, "Root dentry has weird name <%.*s>\n",
 		     (int) dentry->d_name.len, dentry->d_name.name);
 	}
 	if (!slash)
diff --git a/fs/direct-io.c b/fs/direct-io.c
index 4a588db..8ace3d8 100644
--- a/fs/direct-io.c
+++ b/fs/direct-io.c
@@ -1152,7 +1152,7 @@ do_blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	 * performance regression in a database benchmark.  So, we take
 	 * care to only zero out what's needed.
 	 */
-	memset(dio, 0, offsetof(struct dio, pages));
+	(void)memset(dio, 0, offsetof(struct dio, pages));
 
 	dio->flags = flags;
 	if (dio->flags & DIO_LOCKING) {
diff --git a/fs/exec.c b/fs/exec.c
index aeb135c..d6edac6 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1064,7 +1064,7 @@ void set_task_comm(struct task_struct *tsk, char *buf)
 	 * Readers without a lock may see incomplete new
 	 * names but are safe from non-terminating string reads.
 	 */
-	memset(tsk->comm, 0, TASK_COMM_LEN);
+	(void)memset(tsk->comm, 0, TASK_COMM_LEN);
 	wmb();
 	strlcpy(tsk->comm, buf, sizeof(tsk->comm));
 	task_unlock(tsk);
@@ -1310,7 +1310,7 @@ int prepare_binprm(struct linux_binprm *bprm)
 		return retval;
 	bprm->cred_prepared = 1;
 
-	memset(bprm->buf, 0, BINPRM_BUF_SIZE);
+	(void)memset(bprm->buf, 0, BINPRM_BUF_SIZE);
 	return kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);
 }
 
@@ -1896,7 +1896,7 @@ static inline int zap_threads(struct task_struct *tsk, struct mm_struct *mm,
 		do {
 			if (p->mm) {
 				if (unlikely(p->mm == mm)) {
-					lock_task_sighand(p, &flags);
+					(void)lock_task_sighand(p, &flags);
 					nr += zap_process(p, exit_code);
 					unlock_task_sighand(p, &flags);
 				}
diff --git a/fs/ext2/dir.c b/fs/ext2/dir.c
index d37df35..7f09677 100644
--- a/fs/ext2/dir.c
+++ b/fs/ext2/dir.c
@@ -646,7 +646,7 @@ int ext2_make_empty(struct inode *inode, struct inode *parent)
 		goto fail;
 	}
 	kaddr = kmap_atomic(page, KM_USER0);
-	memset(kaddr, 0, chunk_size);
+	(void)memset(kaddr, 0, chunk_size);
 	de = (struct ext2_dir_entry_2 *)kaddr;
 	de->name_len = 1;
 	de->rec_len = ext2_rec_len_to_disk(EXT2_DIR_REC_LEN(1));
diff --git a/fs/ext2/ialloc.c b/fs/ext2/ialloc.c
index 8b15cf8..25d13bc 100644
--- a/fs/ext2/ialloc.c
+++ b/fs/ext2/ialloc.c
@@ -555,7 +555,7 @@ got:
 	inode->i_ino = ino;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	(void)memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_flags =
 		ext2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);
 	ei->i_faddr = 0;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 740cad8..ada0c51 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -494,7 +494,7 @@ static int ext2_alloc_branch(struct inode *inode,
 		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
 		branch[n].bh = bh;
 		lock_buffer(bh);
-		memset(bh->b_data, 0, blocksize);
+		(void)memset(bh->b_data, 0, blocksize);
 		branch[n].p = (__le32 *) bh->b_data + offsets[n];
 		branch[n].key = cpu_to_le32(new_blocks[n]);
 		*branch[n].p = branch[n].key;
@@ -1426,7 +1426,7 @@ static int __ext2_write_inode(struct inode *inode, int do_sync)
 	/* For fields not not tracking in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ei->i_state & EXT2_STATE_NEW)
-		memset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);
+		(void)memset(raw_inode, 0, EXT2_SB(sb)->s_inode_size);
 
 	ext2_get_inode_flags(ei);
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index aca191b..e651e47 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -1047,7 +1047,7 @@ static int fat_zeroed_cluster(struct inode *dir, sector_t blknr, int nr_used,
 			err = -ENOMEM;
 			goto error;
 		}
-		memset(bhs[n]->b_data, 0, sb->s_blocksize);
+		(void)memset(bhs[n]->b_data, 0, sb->s_blocksize);
 		set_buffer_uptodate(bhs[n]);
 		mark_buffer_dirty_inode(bhs[n], dir);
 
@@ -1127,7 +1127,7 @@ int fat_alloc_new_dir(struct inode *dir, struct timespec *ts)
 	de[1].start = cpu_to_le16(MSDOS_I(dir)->i_logstart);
 	de[1].starthi = cpu_to_le16(MSDOS_I(dir)->i_logstart >> 16);
 	de[0].size = de[1].size = 0;
-	memset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));
+	(void)memset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));
 	set_buffer_uptodate(bhs[0]);
 	mark_buffer_dirty_inode(bhs[0], dir);
 
@@ -1199,7 +1199,7 @@ static int fat_add_new_entries(struct inode *dir, void *slots, int nr_slots,
 		}
 	} while (++i < *nr_cluster);
 
-	memset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);
+	(void)memset(bhs[n]->b_data + copy, 0, sb->s_blocksize - copy);
 	offset = copy - sizeof(struct msdos_dir_entry);
 	get_bh(bhs[n]);
 	*bh = bhs[n];
diff --git a/fs/fat/fatent.c b/fs/fat/fatent.c
index 2e81ac0..a204755 100644
--- a/fs/fat/fatent.c
+++ b/fs/fat/fatent.c
@@ -26,7 +26,7 @@ static void fat12_ent_blocknr(struct super_block *sb, int entry,
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	int bytes = entry + (entry >> 1);
-	WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
+	(void)WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
 	*offset = bytes & (sb->s_blocksize - 1);
 	*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);
 }
@@ -36,7 +36,7 @@ static void fat_ent_blocknr(struct super_block *sb, int entry,
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	int bytes = (entry << sbi->fatent_shift);
-	WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
+	(void)WARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);
 	*offset = bytes & (sb->s_blocksize - 1);
 	*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);
 }
@@ -45,11 +45,11 @@ static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
 	struct buffer_head **bhs = fatent->bhs;
 	if (fatent->nr_bhs == 1) {
-		WARN_ON(offset >= (bhs[0]->b_size - 1));
+		(void)WARN_ON(offset >= (bhs[0]->b_size - 1));
 		fatent->u.ent12_p[0] = bhs[0]->b_data + offset;
 		fatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);
 	} else {
-		WARN_ON(offset != (bhs[0]->b_size - 1));
+		(void)WARN_ON(offset != (bhs[0]->b_size - 1));
 		fatent->u.ent12_p[0] = bhs[0]->b_data + offset;
 		fatent->u.ent12_p[1] = bhs[1]->b_data;
 	}
@@ -57,13 +57,13 @@ static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)
 
 static void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
-	WARN_ON(offset & (2 - 1));
+	(void)WARN_ON(offset & (2 - 1));
 	fatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);
 }
 
 static void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)
 {
-	WARN_ON(offset & (4 - 1));
+	(void)WARN_ON(offset & (4 - 1));
 	fatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);
 }
 
@@ -72,7 +72,7 @@ static int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 {
 	struct buffer_head **bhs = fatent->bhs;
 
-	WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
+	(void)WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
 	fatent->fat_inode = MSDOS_SB(sb)->fat_inode;
 
 	bhs[0] = sb_bread(sb, blocknr);
@@ -104,7 +104,7 @@ static int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 {
 	struct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;
 
-	WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
+	(void)WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
 	fatent->fat_inode = MSDOS_SB(sb)->fat_inode;
 	fatent->bhs[0] = sb_bread(sb, blocknr);
 	if (!fatent->bhs[0]) {
@@ -138,7 +138,7 @@ static int fat12_ent_get(struct fat_entry *fatent)
 static int fat16_ent_get(struct fat_entry *fatent)
 {
 	int next = le16_to_cpu(*fatent->u.ent16_p);
-	WARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));
+	(void)WARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));
 	if (next >= BAD_FAT16)
 		next = FAT_ENT_EOF;
 	return next;
@@ -147,7 +147,7 @@ static int fat16_ent_get(struct fat_entry *fatent)
 static int fat32_ent_get(struct fat_entry *fatent)
 {
 	int next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;
-	WARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));
+	(void)WARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));
 	if (next >= BAD_FAT32)
 		next = FAT_ENT_EOF;
 	return next;
@@ -189,7 +189,7 @@ static void fat32_ent_put(struct fat_entry *fatent, int new)
 	if (new == FAT_ENT_EOF)
 		new = EOF_FAT32;
 
-	WARN_ON(new & 0xf0000000);
+	(void)WARN_ON(new & 0xf0000000);
 	new |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;
 	*fatent->u.ent32_p = cpu_to_le32(new);
 	mark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);
@@ -203,16 +203,16 @@ static int fat12_ent_next(struct fat_entry *fatent)
 
 	fatent->entry++;
 	if (fatent->nr_bhs == 1) {
-		WARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 2)));
-		WARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
+		(void)WARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 2)));
+		(void)WARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
 		if (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {
 			ent12_p[0] = nextp - 1;
 			ent12_p[1] = nextp;
 			return 1;
 		}
 	} else {
-		WARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
-		WARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);
+		(void)WARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1)));
+		(void)WARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);
 		ent12_p[0] = nextp - 1;
 		ent12_p[1] = nextp;
 		brelse(bhs[0]);
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index a81eb23..36a9068 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -432,7 +432,7 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,
 	 * any bad symbols (lowercase transformed to uppercase).
 	 */
 
-	memset(name_res, ' ', MSDOS_NAME);
+	(void)memset(name_res, ' ', MSDOS_NAME);
 	memcpy(name_res, base, baselen);
 	memcpy(name_res + 8, ext, extlen);
 	*lcase = 0;
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 22764c7..b27355d 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -326,7 +326,7 @@ static int f_getown_ex(struct file *filp, unsigned long arg)
 		break;
 
 	default:
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		ret = -EINVAL;
 		break;
 	}
diff --git a/fs/file.c b/fs/file.c
index 4c6992d..b53e865 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -129,14 +129,14 @@ static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)
 	cpy = ofdt->max_fds * sizeof(struct file *);
 	set = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);
 	memcpy(nfdt->fd, ofdt->fd, cpy);
-	memset((char *)(nfdt->fd) + cpy, 0, set);
+	(void)memset((char *)(nfdt->fd) + cpy, 0, set);
 
 	cpy = ofdt->max_fds / BITS_PER_BYTE;
 	set = (nfdt->max_fds - ofdt->max_fds) / BITS_PER_BYTE;
 	memcpy(nfdt->open_fds, ofdt->open_fds, cpy);
-	memset((char *)(nfdt->open_fds) + cpy, 0, set);
+	(void)memset((char *)(nfdt->open_fds) + cpy, 0, set);
 	memcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);
-	memset((char *)(nfdt->close_on_exec) + cpy, 0, set);
+	(void)memset((char *)(nfdt->close_on_exec) + cpy, 0, set);
 }
 
 static struct fdtable * alloc_fdtable(unsigned int nr)
@@ -376,14 +376,14 @@ struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)
 	size = (new_fdt->max_fds - open_files) * sizeof(struct file *);
 
 	/* This is long word aligned thus could use a optimized version */
-	memset(new_fds, 0, size);
+	(void)memset(new_fds, 0, size);
 
 	if (new_fdt->max_fds > open_files) {
 		int left = (new_fdt->max_fds-open_files)/8;
 		int start = open_files / (8 * sizeof(unsigned long));
 
-		memset(&new_fdt->open_fds->fds_bits[start], 0, left);
-		memset(&new_fdt->close_on_exec->fds_bits[start], 0, left);
+		(void)memset(&new_fdt->open_fds->fds_bits[start], 0, left);
+		(void)memset(&new_fdt->close_on_exec->fds_bits[start], 0, left);
 	}
 
 	rcu_assign_pointer(newf->fdt, new_fdt);
diff --git a/fs/file_table.c b/fs/file_table.c
index 20002e3..7dd23bc 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -188,7 +188,7 @@ struct file *alloc_file(struct path *path, fmode_t mode,
 	 */
 	if ((mode & FMODE_WRITE) && !special_file(path->dentry->d_inode->i_mode)) {
 		file_take_write(file);
-		WARN_ON(mnt_clone_write(path->mnt));
+		(void)WARN_ON(mnt_clone_write(path->mnt));
 	}
 	if ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
 		i_readcount_inc(path->dentry->d_inode);
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index f855916..92635f3 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -370,9 +370,9 @@ writeback_single_inode(struct inode *inode, struct bdi_writeback *wb,
 	assert_spin_locked(&inode->i_lock);
 
 	if (!atomic_read(&inode->i_count))
-		WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
+		(void)WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
 	else
-		WARN_ON(inode->i_state & I_WILL_FREE);
+		(void)WARN_ON(inode->i_state & I_WILL_FREE);
 
 	if (inode->i_state & I_SYNC) {
 		/*
@@ -1118,7 +1118,7 @@ void __mark_inode_dirty(struct inode *inode, int flags)
 			bdi = inode_to_bdi(inode);
 
 			if (bdi_cap_writeback_dirty(bdi)) {
-				WARN(!test_bit(BDI_registered, &bdi->state),
+				(void)WARN(!test_bit(BDI_registered, &bdi->state),
 				     "bdi-%s not registered\n", bdi->name);
 
 				/*
@@ -1173,7 +1173,7 @@ static void wait_sb_inodes(struct super_block *sb)
 	 * We need to be protected against the filesystem going from
 	 * r/o to r/w or vice versa.
 	 */
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	spin_lock(&inode_sb_list_lock);
 
@@ -1242,7 +1242,7 @@ void writeback_inodes_sb_nr(struct super_block *sb,
 		.reason			= reason,
 	};
 
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 	bdi_queue_work(sb->s_bdi, &work);
 	wait_for_completion(&done);
 }
@@ -1325,7 +1325,7 @@ void sync_inodes_sb(struct super_block *sb)
 		.reason		= WB_REASON_SYNC,
 	};
 
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	bdi_queue_work(sb->s_bdi, &work);
 	wait_for_completion(&done);
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 066836e..7c38139 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -104,7 +104,7 @@ int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,
 	if (flags & SET_NOT_ALIGNED_FLAGS)
 		flags |= FIEMAP_EXTENT_NOT_ALIGNED;
 
-	memset(&extent, 0, sizeof(extent));
+	(void)memset(&extent, 0, sizeof(extent));
 	extent.fe_logical = logical;
 	extent.fe_physical = phys;
 	extent.fe_length = len;
@@ -288,7 +288,7 @@ int __generic_block_fiemap(struct inode *inode,
 		 * we set b_size to the total size we want so it will map as
 		 * many contiguous blocks as possible at once
 		 */
-		memset(&map_bh, 0, sizeof(struct buffer_head));
+		(void)memset(&map_bh, 0, sizeof(struct buffer_head));
 		map_bh.b_size = len;
 
 		ret = get_block(inode, start_blk, &map_bh, 0);
diff --git a/fs/jffs2/compr.c b/fs/jffs2/compr.c
index 5b6c9d1..d06dfbf 100644
--- a/fs/jffs2/compr.c
+++ b/fs/jffs2/compr.c
@@ -266,7 +266,7 @@ int jffs2_decompress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 		none_stat_decompr_blocks++;
 		break;
 	case JFFS2_COMPR_ZERO:
-		memset(data_out, 0, datalen);
+		(void)memset(data_out, 0, datalen);
 		break;
 	default:
 		spin_lock(&jffs2_compressor_list_lock);
diff --git a/fs/jffs2/compr_rtime.c b/fs/jffs2/compr_rtime.c
index 16a5047..cc3cc46 100644
--- a/fs/jffs2/compr_rtime.c
+++ b/fs/jffs2/compr_rtime.c
@@ -37,7 +37,7 @@ static int jffs2_rtime_compress(unsigned char *data_in,
 	int outpos = 0;
 	int pos=0;
 
-	memset(positions,0,sizeof(positions));
+	(void)memset(positions,0,sizeof(positions));
 
 	while (pos < (*sourcelen) && outpos <= (*dstlen)-2) {
 		int backpos, runlen=0;
@@ -78,7 +78,7 @@ static int jffs2_rtime_decompress(unsigned char *data_in,
 	int outpos = 0;
 	int pos=0;
 
-	memset(positions,0,sizeof(positions));
+	(void)memset(positions,0,sizeof(positions));
 
 	while (outpos<destlen) {
 		unsigned char value;
diff --git a/fs/jffs2/erase.c b/fs/jffs2/erase.c
index a01cdad..91ba7a2 100644
--- a/fs/jffs2/erase.c
+++ b/fs/jffs2/erase.c
@@ -62,7 +62,7 @@ static void jffs2_erase_block(struct jffs2_sb_info *c,
 		return;
 	}
 
-	memset(instr, 0, sizeof(*instr));
+	(void)memset(instr, 0, sizeof(*instr));
 
 	instr->mtd = c->mtd;
 	instr->addr = jeb->offset;
diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 61e6723..94a072b 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -162,7 +162,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 			goto out_page;
 
 		mutex_lock(&f->sem);
-		memset(&ri, 0, sizeof(ri));
+		(void)memset(&ri, 0, sizeof(ri));
 
 		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 		ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 2e01238..28fca94 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -427,7 +427,7 @@ struct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode, struct jffs2_r
 	jffs2_init_inode_info(f);
 	mutex_lock(&f->sem);
 
-	memset(ri, 0, sizeof(*ri));
+	(void)memset(ri, 0, sizeof(*ri));
 	/* Set OS-specific defaults for new inodes */
 	ri->uid = cpu_to_je16(current_fsuid());
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 31dce61..ef2115d 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -759,7 +759,7 @@ static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_
 	else
 		ilen = JFFS2_F_I_SIZE(f);
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 	ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 	ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
 	ri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);
@@ -967,7 +967,7 @@ static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eras
 	D1(printk(KERN_DEBUG "Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\n",
 		  f->inocache->ino, start, end));
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 
 	if(fn->frags > 1) {
 		size_t readlen;
@@ -1115,7 +1115,7 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 	unsigned long pg;
 	unsigned char *pg_ptr;
 
-	memset(&ri, 0, sizeof(ri));
+	(void)memset(&ri, 0, sizeof(ri));
 
 	D1(printk(KERN_DEBUG "Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\n",
 		  f->inocache->ino, start, end));
diff --git a/fs/jffs2/read.c b/fs/jffs2/read.c
index 3f39be1..a1d88cd 100644
--- a/fs/jffs2/read.c
+++ b/fs/jffs2/read.c
@@ -74,7 +74,7 @@ int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 
 
 	if (ri->compr == JFFS2_COMPR_ZERO) {
-		memset(buf, 0, len);
+		(void)memset(buf, 0, len);
 		goto out_ri;
 	}
 
@@ -177,14 +177,14 @@ int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 				holesize = min(holesize, frag->ofs - offset);
 			}
 			D1(printk(KERN_DEBUG "Filling non-frag hole from %d-%d\n", offset, offset+holesize));
-			memset(buf, 0, holesize);
+			(void)memset(buf, 0, holesize);
 			buf += holesize;
 			offset += holesize;
 			continue;
 		} else if (unlikely(!frag->node)) {
 			uint32_t holeend = min(end, frag->ofs + frag->size);
 			D1(printk(KERN_DEBUG "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n", offset, holeend, frag->ofs, frag->ofs + frag->size));
-			memset(buf, 0, holeend - offset);
+			(void)memset(buf, 0, holeend - offset);
 			buf += holeend - offset;
 			offset = holeend;
 			frag = frag_next(frag);
@@ -202,7 +202,7 @@ int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			D2(printk(KERN_DEBUG "node read done\n"));
 			if (ret) {
 				D1(printk(KERN_DEBUG"jffs2_read_inode_range error %d\n",ret));
-				memset(buf, 0, readlen);
+				(void)memset(buf, 0, readlen);
 				return ret;
 			}
 			buf += readlen;
diff --git a/fs/jffs2/readinode.c b/fs/jffs2/readinode.c
index 3093ac4..2e244dc 100644
--- a/fs/jffs2/readinode.c
+++ b/fs/jffs2/readinode.c
@@ -1149,7 +1149,7 @@ static int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,
 	dbg_readinode("ino #%u pino/nlink is %d\n", f->inocache->ino,
 		      f->inocache->pino_nlink);
 
-	memset(&rii, 0, sizeof(rii));
+	(void)memset(&rii, 0, sizeof(rii));
 
 	/* Grab all nodes relevant to this ino */
 	ret = jffs2_get_inode_nodes(c, f, &rii);
@@ -1381,7 +1381,7 @@ int jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			return -ENOMEM;
 		}
 		dbg_readinode("creating inocache for root inode\n");
-		memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
+		(void)memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
 		f->inocache->ino = f->inocache->pino_nlink = 1;
 		f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
 		f->inocache->state = INO_STATE_READING;
diff --git a/fs/jffs2/scan.c b/fs/jffs2/scan.c
index f994648..ab29f45 100644
--- a/fs/jffs2/scan.c
+++ b/fs/jffs2/scan.c
@@ -938,7 +938,7 @@ struct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uin
 		printk(KERN_NOTICE "jffs2_scan_make_inode_cache(): allocation of inode cache failed\n");
 		return NULL;
 	}
-	memset(ic, 0, sizeof(*ic));
+	(void)memset(ic, 0, sizeof(*ic));
 
 	ic->ino = ino;
 	ic->nodes = (void *)ic;
diff --git a/fs/jffs2/wbuf.c b/fs/jffs2/wbuf.c
index 30e8f47..b932596 100644
--- a/fs/jffs2/wbuf.c
+++ b/fs/jffs2/wbuf.c
@@ -601,7 +601,7 @@ static int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)
 
 		/* Pad with JFFS2_DIRTY_BITMASK initially.  this helps out ECC'd NOR
 		   with 8 byte page size */
-		memset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);
+		(void)memset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);
 
 		if ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {
 			struct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);
@@ -677,7 +677,7 @@ static int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)
 	jffs2_clear_wbuf_ino_list(c);
 	spin_unlock(&c->erase_completion_lock);
 
-	memset(c->wbuf,0xff,c->wbuf_pagesize);
+	(void)memset(c->wbuf,0xff,c->wbuf_pagesize);
 	/* adjust write buffer offset, else we get a non contiguous write bug */
 	c->wbuf_ofs += c->wbuf_pagesize;
 	c->wbuf_len = 0;
@@ -798,7 +798,7 @@ int jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,
 	if (c->wbuf_ofs == 0xFFFFFFFF) {
 		c->wbuf_ofs = PAGE_DIV(to);
 		c->wbuf_len = PAGE_MOD(to);
-		memset(c->wbuf,0xff,c->wbuf_pagesize);
+		(void)memset(c->wbuf,0xff,c->wbuf_pagesize);
 	}
 
 	/*
diff --git a/fs/jffs2/write.c b/fs/jffs2/write.c
index 30d175b..3b81141 100644
--- a/fs/jffs2/write.c
+++ b/fs/jffs2/write.c
@@ -28,7 +28,7 @@ int jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 		return -ENOMEM;
 	}
 
-	memset(ic, 0, sizeof(*ic));
+	(void)memset(ic, 0, sizeof(*ic));
 
 	f->inocache = ic;
 	f->inocache->pino_nlink = 1; /* Will be overwritten shortly for directories */
@@ -222,7 +222,7 @@ struct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jff
 		printk(KERN_CRIT "Directory inode #%u, name at *0x%p \"%s\"->ino #%u, name_crc 0x%08x\n",
 		       je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),
 		       je32_to_cpu(rd->name_crc));
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return ERR_PTR(-EIO);
 	}
 
diff --git a/fs/libfs.c b/fs/libfs.c
index 5b2dbb3..4a42414 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -362,7 +362,7 @@ int simple_setattr(struct dentry *dentry, struct iattr *iattr)
 	struct inode *inode = dentry->d_inode;
 	int error;
 
-	WARN_ON_ONCE(inode->i_op->truncate);
+	(void)WARN_ON_ONCE(inode->i_op->truncate);
 
 	error = inode_change_ok(inode, iattr);
 	if (error)
diff --git a/fs/lockd/clnt4xdr.c b/fs/lockd/clnt4xdr.c
index f848b52..361470b 100644
--- a/fs/lockd/clnt4xdr.c
+++ b/fs/lockd/clnt4xdr.c
@@ -183,7 +183,7 @@ static int decode_cookie(struct xdr_stream *xdr,
 	return 0;
 out_hpux:
 	cookie->len = 4;
-	memset(cookie->data, 0, 4);
+	(void)memset(cookie->data, 0, 4);
 	return 0;
 out_size:
 	dprintk("NFS: returned cookie was too long: %u\n", length);
@@ -290,7 +290,7 @@ static int decode_nlm4_holder(struct xdr_stream *xdr, struct nlm_res *result)
 	__be32 *p;
 	s32 end;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(fl);
 
 	p = xdr_inline_decode(xdr, 4 + 4);
diff --git a/fs/lockd/clntproc.c b/fs/lockd/clntproc.c
index 8392cb8..2f03ae8 100644
--- a/fs/lockd/clntproc.c
+++ b/fs/lockd/clntproc.c
@@ -622,7 +622,7 @@ nlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl)
 	int		status;
 
 	req = &reqst;
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 	locks_init_lock(&req->a_args.lock.fl);
 	locks_init_lock(&req->a_res.lock.fl);
 	req->a_host  = host;
diff --git a/fs/lockd/clntxdr.c b/fs/lockd/clntxdr.c
index 180ac34..39bacd5 100644
--- a/fs/lockd/clntxdr.c
+++ b/fs/lockd/clntxdr.c
@@ -180,7 +180,7 @@ static int decode_cookie(struct xdr_stream *xdr,
 	return 0;
 out_hpux:
 	cookie->len = 4;
-	memset(cookie->data, 0, 4);
+	(void)memset(cookie->data, 0, 4);
 	return 0;
 out_size:
 	dprintk("NFS: returned cookie was too long: %u\n", length);
@@ -284,7 +284,7 @@ static int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)
 	__be32 *p;
 	s32 end;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(fl);
 
 	p = xdr_inline_decode(xdr, 4 + 4);
diff --git a/fs/lockd/mon.c b/fs/lockd/mon.c
index 65ba36b..6fe8ba4 100644
--- a/fs/lockd/mon.c
+++ b/fs/lockd/mon.c
@@ -107,7 +107,7 @@ static int nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res)
 		goto out;
 	}
 
-	memset(res, 0, sizeof(*res));
+	(void)memset(res, 0, sizeof(*res));
 
 	msg.rpc_proc = &clnt->cl_procinfo[proc];
 	status = rpc_call_sync(clnt, &msg, 0);
diff --git a/fs/lockd/xdr.c b/fs/lockd/xdr.c
index 964666c..da4fb04 100644
--- a/fs/lockd/xdr.c
+++ b/fs/lockd/xdr.c
@@ -88,7 +88,7 @@ nlm_decode_fh(__be32 *p, struct nfs_fh *f)
 		return NULL;
 	}
 	f->size = NFS2_FHSIZE;
-	memset(f->data, 0, sizeof(f->data));
+	(void)memset(f->data, 0, sizeof(f->data));
 	memcpy(f->data, p, NFS2_FHSIZE);
 	return p + XDR_QUADLEN(NFS2_FHSIZE);
 }
@@ -263,7 +263,7 @@ nlmsvc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(&lock->fl);
 	lock->svid = ~(u32) 0;
 	lock->fl.fl_pid = (pid_t)lock->svid;
diff --git a/fs/lockd/xdr4.c b/fs/lockd/xdr4.c
index dfa4789..d552084 100644
--- a/fs/lockd/xdr4.c
+++ b/fs/lockd/xdr4.c
@@ -82,7 +82,7 @@ nlm4_encode_cookie(__be32 *p, struct nlm_cookie *c)
 static __be32 *
 nlm4_decode_fh(__be32 *p, struct nfs_fh *f)
 {
-	memset(f->data, 0, sizeof(f->data));
+	(void)memset(f->data, 0, sizeof(f->data));
 	f->size = ntohl(*p++);
 	if (f->size > NFS_MAXFHSIZE) {
 		dprintk("lockd: bad fhandle size %d (should be <=%d)\n",
@@ -254,7 +254,7 @@ nlm4svc_decode_shareargs(struct svc_rqst *rqstp, __be32 *p, nlm_args *argp)
 {
 	struct nlm_lock	*lock = &argp->lock;
 
-	memset(lock, 0, sizeof(*lock));
+	(void)memset(lock, 0, sizeof(*lock));
 	locks_init_lock(&lock->fl);
 	lock->svid = ~(u32) 0;
 	lock->fl.fl_pid = (pid_t)lock->svid;
diff --git a/fs/minix/bitmap.c b/fs/minix/bitmap.c
index 4bc50da..2c1f588 100644
--- a/fs/minix/bitmap.c
+++ b/fs/minix/bitmap.c
@@ -255,7 +255,7 @@ struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)
 	inode->i_ino = j;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 	inode->i_blocks = 0;
-	memset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));
+	(void)memset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
 
diff --git a/fs/minix/dir.c b/fs/minix/dir.c
index 085a926..c529091 100644
--- a/fs/minix/dir.c
+++ b/fs/minix/dir.c
@@ -276,10 +276,10 @@ got_it:
 		goto out_unlock;
 	memcpy (namx, name, namelen);
 	if (sbi->s_version == MINIX_V3) {
-		memset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);
+		(void)memset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);
 		de3->inode = inode->i_ino;
 	} else {
-		memset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);
+		(void)memset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);
 		de->inode = inode->i_ino;
 	}
 	err = dir_commit_chunk(page, pos, sbi->s_dirsize);
@@ -336,7 +336,7 @@ int minix_make_empty(struct inode *inode, struct inode *dir)
 	}
 
 	kaddr = kmap_atomic(page, KM_USER0);
-	memset(kaddr, 0, PAGE_CACHE_SIZE);
+	(void)memset(kaddr, 0, PAGE_CACHE_SIZE);
 
 	if (sbi->s_version == MINIX_V3) {
 		minix3_dirent *de3 = (minix3_dirent *)kaddr;
diff --git a/fs/minix/itree_common.c b/fs/minix/itree_common.c
index a731cab..806686b 100644
--- a/fs/minix/itree_common.c
+++ b/fs/minix/itree_common.c
@@ -85,7 +85,7 @@ static int alloc_branch(struct inode *inode,
 		branch[n].key = cpu_to_block(nr);
 		bh = sb_getblk(inode->i_sb, parent);
 		lock_buffer(bh);
-		memset(bh->b_data, 0, bh->b_size);
+		(void)memset(bh->b_data, 0, bh->b_size);
 		branch[n].bh = bh;
 		branch[n].p = (block_t*) bh->b_data + offsets[n];
 		*branch[n].p = branch[n].key;
diff --git a/fs/namei.c b/fs/namei.c
index 208c6aa..c5c1982 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1776,7 +1776,7 @@ struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)
 	unsigned long hash;
 	unsigned int c;
 
-	WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
+	(void)WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
 
 	this.name = name;
 	this.len = len;
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index fd9a872..8636cb6 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -639,7 +639,7 @@ int nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page,
 		status = PTR_ERR(array);
 		goto out;
 	}
-	memset(array, 0, sizeof(struct nfs_cache_array));
+	(void)memset(array, 0, sizeof(struct nfs_cache_array));
 	array->eof_index = -1;
 
 	status = nfs_readdir_large_page(pages, array_size);
@@ -869,7 +869,7 @@ static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	 * to either find the entry with the appropriate number or
 	 * revalidate the cookie.
 	 */
-	memset(desc, 0, sizeof(*desc));
+	(void)memset(desc, 0, sizeof(*desc));
 
 	desc->file = filp;
 	desc->dir_cookie = &dir_ctx->dir_cookie;
@@ -1249,7 +1249,7 @@ static void nfs_d_release(struct dentry *dentry)
 	/* free cached devname value, if it survived that far */
 	if (unlikely(dentry->d_fsdata)) {
 		if (dentry->d_flags & DCACHE_NFSFS_RENAMED)
-			WARN_ON(1);
+			(void)WARN_ON(1);
 		else
 			kfree(dentry->d_fsdata);
 	}
@@ -1873,7 +1873,7 @@ static int nfs_symlink(struct inode *dir, struct dentry *dentry, const char *sym
 	kaddr = kmap_atomic(page, KM_USER0);
 	memcpy(kaddr, symname, pathlen);
 	if (pathlen < PAGE_SIZE)
-		memset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);
+		(void)memset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);
 	kunmap_atomic(kaddr, KM_USER0);
 
 	error = NFS_PROTO(dir)->symlink(dir, dentry, page, pathlen, &attr);
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 1940f1a..9031fa0 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -494,7 +494,7 @@ static void nfs_direct_write_reschedule(struct nfs_direct_req *dreq)
 		 */
 		nfs_fattr_init(&data->fattr);
 		data->res.count = data->args.count;
-		memset(&data->verf, 0, sizeof(data->verf));
+		(void)memset(&data->verf, 0, sizeof(data->verf));
 
 		/*
 		 * Reuse data->task; data->args should not have changed
diff --git a/fs/nfs/dns_resolve.c b/fs/nfs/dns_resolve.c
index a6e711a..18b3a90 100644
--- a/fs/nfs/dns_resolve.c
+++ b/fs/nfs/dns_resolve.c
@@ -234,7 +234,7 @@ static int nfs_dns_parse(struct cache_detail *cd, char *buf, int buflen)
 
 	key.hostname = buf1;
 	key.namelen = len;
-	memset(&key.h, 0, sizeof(key.h));
+	(void)memset(&key.h, 0, sizeof(key.h));
 
 	ttl = get_expiry(&buf);
 	if (ttl == 0)
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index f649fba..95ecd05 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -151,7 +151,7 @@ static void nfs_zap_caches_locked(struct inode *inode)
 	nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
 	nfsi->attrtimeo_timestamp = jiffies;
 
-	memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
+	(void)memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
 	if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
 	else
@@ -859,7 +859,7 @@ static int nfs_invalidate_mapping(struct inode *inode, struct address_space *map
 	spin_lock(&inode->i_lock);
 	nfsi->cache_validity &= ~NFS_INO_INVALID_DATA;
 	if (S_ISDIR(inode->i_mode))
-		memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
+		(void)memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
 	spin_unlock(&inode->i_lock);
 	nfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);
 	nfs_fscache_reset_inode_cookie(inode);
diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
index 8102391..a5aaf78 100644
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@ -91,7 +91,7 @@ rename_retry:
 	if (!base) {
 		spin_unlock(&dentry->d_lock);
 		rcu_read_unlock();
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return end;
 	}
 	namelen = strlen(base);
diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c
index 183c6b1..879be75 100644
--- a/fs/nfs/nfs3xdr.c
+++ b/fs/nfs/nfs3xdr.c
@@ -477,7 +477,7 @@ out_overflow:
 
 static void zero_nfs_fh3(struct nfs_fh *fh)
 {
-	memset(fh, 0, sizeof(*fh));
+	(void)memset(fh, 0, sizeof(*fh));
 }
 
 /*
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 3dfa4f1..e0c99fc 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -1784,7 +1784,7 @@ static int nfs_validate_mount_data(void *options,
 		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 			goto out_no_sec;
 	case 5:
-		memset(data->context, 0, sizeof(data->context));
+		(void)memset(data->context, 0, sizeof(data->context));
 	case 6:
 		if (data->flags & NFS_MOUNT_VER3) {
 			if (data->root.size > NFS3_FHSIZE || data->root.size == 0)
@@ -1799,7 +1799,7 @@ static int nfs_validate_mount_data(void *options,
 
 		memcpy(mntfh->data, data->root.data, mntfh->size);
 		if (mntfh->size < sizeof(mntfh->data))
-			memset(mntfh->data + mntfh->size, 0,
+			(void)memset(mntfh->data + mntfh->size, 0,
 			       sizeof(mntfh->data) - mntfh->size);
 
 		/*
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 834f0fe..cf5e76d 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -55,7 +55,7 @@ struct nfs_write_data *nfs_commitdata_alloc(void)
 	struct nfs_write_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOFS);
 
 	if (p) {
-		memset(p, 0, sizeof(*p));
+		(void)memset(p, 0, sizeof(*p));
 		INIT_LIST_HEAD(&p->pages);
 	}
 	return p;
@@ -75,7 +75,7 @@ struct nfs_write_data *nfs_writedata_alloc(unsigned int pagecount)
 	struct nfs_write_data *p = mempool_alloc(nfs_wdata_mempool, GFP_NOFS);
 
 	if (p) {
-		memset(p, 0, sizeof(*p));
+		(void)memset(p, 0, sizeof(*p));
 		INIT_LIST_HEAD(&p->pages);
 		p->npages = pagecount;
 		if (pagecount <= ARRAY_SIZE(p->page_array))
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 68454e7..566ed62 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -548,7 +548,7 @@ fh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,
 
 	if (fhp->fh_handle.fh_version == 0xca) {
 		/* old style filehandle please */
-		memset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);
+		(void)memset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);
 		fhp->fh_handle.fh_size = NFS_FHSIZE;
 		fhp->fh_handle.ofh_dcookie = 0xfeebbaca;
 		fhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);
diff --git a/fs/nfsd/nfsfh.h b/fs/nfsd/nfsfh.h
index e5e6707..c35ccbf 100644
--- a/fs/nfsd/nfsfh.h
+++ b/fs/nfsd/nfsfh.h
@@ -110,7 +110,7 @@ void	fh_put(struct svc_fh *);
 static __inline__ struct svc_fh *
 fh_copy(struct svc_fh *dst, struct svc_fh *src)
 {
-	WARN_ON(src->fh_dentry || src->fh_locked);
+	(void)WARN_ON(src->fh_dentry || src->fh_locked);
 			
 	*dst = *src;
 	return dst;
@@ -126,7 +126,7 @@ fh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)
 static __inline__ struct svc_fh *
 fh_init(struct svc_fh *fhp, int maxsize)
 {
-	memset(fhp, 0, sizeof(*fhp));
+	(void)memset(fhp, 0, sizeof(*fhp));
 	fhp->fh_maxsize = maxsize;
 	return fhp;
 }
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index eda7d7e..adb1729 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -311,7 +311,7 @@ int nfsd_create_serv(void)
 {
 	int err = 0;
 
-	WARN_ON(!mutex_is_locked(&nfsd_mutex));
+	(void)WARN_ON(!mutex_is_locked(&nfsd_mutex));
 	if (nfsd_serv) {
 		svc_get(nfsd_serv);
 		return 0;
@@ -370,7 +370,7 @@ int nfsd_set_nrthreads(int n, int *nthreads)
 	int tot = 0;
 	int err = 0;
 
-	WARN_ON(!mutex_is_locked(&nfsd_mutex));
+	(void)WARN_ON(!mutex_is_locked(&nfsd_mutex));
 
 	if (nfsd_serv == NULL || n <= 0)
 		return 0;
diff --git a/fs/notify/inotify/inotify_fsnotify.c b/fs/notify/inotify/inotify_fsnotify.c
index e3cbd74..fc0068e 100644
--- a/fs/notify/inotify/inotify_fsnotify.c
+++ b/fs/notify/inotify/inotify_fsnotify.c
@@ -177,7 +177,7 @@ static int idr_callback(int id, void *p, void *data)
 	fsn_mark = p;
 	i_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);
 
-	WARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "
+	(void)WARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "
 		"idr.  Probably leaking memory\n", id, p, data);
 
 	/*
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 8445fbc..3e94f2b 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -454,7 +454,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	 * if it wasn't....
 	 */
 	if (wd == -1) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
 			" i_mark->inode=%p\n", __func__, i_mark, i_mark->wd,
 			i_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);
 		goto out;
@@ -463,7 +463,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	/* Lets look in the idr to see if we find it */
 	found_i_mark = inotify_idr_find_locked(group, wd);
 	if (unlikely(!found_i_mark)) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p"
 			" i_mark->inode=%p\n", __func__, i_mark, i_mark->wd,
 			i_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);
 		goto out;
@@ -475,7 +475,7 @@ static void inotify_remove_from_idr(struct fsnotify_group *group,
 	 * fucked up somewhere.
 	 */
 	if (unlikely(found_i_mark != i_mark)) {
-		WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p "
+		(void)WARN_ONCE(1, "%s: i_mark=%p i_mark->wd=%d i_mark->group=%p "
 			"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d "
 			"found_i_mark->group=%p found_i_mark->inode=%p\n",
 			__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index f104d56..72a14eb 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -328,7 +328,7 @@ void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *ol
 void fsnotify_init_mark(struct fsnotify_mark *mark,
 			void (*free_mark)(struct fsnotify_mark *mark))
 {
-	memset(mark, 0, sizeof(*mark));
+	(void)memset(mark, 0, sizeof(*mark));
 	spin_lock_init(&mark->lock);
 	atomic_set(&mark->refcnt, 1);
 	mark->free_mark = free_mark;
@@ -352,7 +352,7 @@ static int fsnotify_mark_destroy(void *ignored)
 			fsnotify_put_mark(mark);
 		}
 
-		wait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));
+		(void)wait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));
 	}
 
 	return 0;
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 9cde9edf..5d6910e 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -937,7 +937,7 @@ static ssize_t oom_adjust_write(struct file *file, const char __user *buf,
 	unsigned long flags;
 	int err;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count)) {
@@ -1038,7 +1038,7 @@ static ssize_t oom_score_adj_write(struct file *file, const char __user *buf,
 	int oom_score_adj;
 	int err;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count)) {
@@ -1384,7 +1384,7 @@ static ssize_t comm_write(struct file *file, const char __user *buf,
 	struct task_struct *p;
 	char buffer[TASK_COMM_LEN];
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
@@ -2739,7 +2739,7 @@ static ssize_t proc_coredump_filter_write(struct file *file,
 	unsigned long mask;
 
 	ret = -EFAULT;
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 2edf34f..7bde9be 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -320,7 +320,7 @@ static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,
 				break;
 		}
 		if (!de) {
-			WARN(1, "name '%s'\n", name);
+			(void)WARN(1, "name '%s'\n", name);
 			return -ENOENT;
 		}
 		cp += len + 1;
@@ -582,7 +582,7 @@ static int proc_register(struct proc_dir_entry * dir, struct proc_dir_entry * dp
 
 	for (tmp = dir->subdir; tmp; tmp = tmp->next)
 		if (strcmp(tmp->name, dp->name) == 0) {
-			WARN(1, KERN_WARNING "proc_dir_entry '%s/%s' already registered\n",
+			(void)WARN(1, KERN_WARNING "proc_dir_entry '%s/%s' already registered\n",
 				dir->name, dp->name);
 			break;
 		}
@@ -805,7 +805,7 @@ void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
 	}
 	spin_unlock(&proc_subdir_lock);
 	if (!de) {
-		WARN(1, "name '%s'\n", name);
+		(void)WARN(1, "name '%s'\n", name);
 		return;
 	}
 
@@ -844,7 +844,7 @@ void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
 	if (S_ISDIR(de->mode))
 		parent->nlink--;
 	de->nlink = 0;
-	WARN(de->subdir, KERN_WARNING "%s: removing non-empty directory "
+	(void)WARN(de->subdir, KERN_WARNING "%s: removing non-empty directory "
 			"'%s/%s', leaking at least '%s'\n", __func__,
 			de->parent->name, de->name, de->subdir->name);
 	pde_put(de);
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index a6b6217..d85ee28 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -101,7 +101,7 @@ static struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,
 		return ERR_CAST(head);
 
 	if (table && !table->child) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out;
 	}
 
@@ -296,7 +296,7 @@ static int proc_sys_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		return PTR_ERR(head);
 
 	if (table && !table->child) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		goto out;
 	}
 
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 7dcd2a2..97611cf 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -434,7 +434,7 @@ static int show_smap(struct seq_file *m, void *v)
 		.private = &mss,
 	};
 
-	memset(&mss, 0, sizeof mss);
+	(void)memset(&mss, 0, sizeof mss);
 	mss.vma = vma;
 	/* mmap_sem is held in m_start */
 	if (vma->vm_mm && !is_vm_hugetlb_page(vma))
@@ -544,7 +544,7 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,
 	int type;
 	int rv;
 
-	memset(buffer, 0, sizeof(buffer));
+	(void)memset(buffer, 0, sizeof(buffer));
 	if (count > sizeof(buffer) - 1)
 		count = sizeof(buffer) - 1;
 	if (copy_from_user(buffer, buf, count))
diff --git a/fs/romfs/super.c b/fs/romfs/super.c
index bb36ab7..f4f8195 100644
--- a/fs/romfs/super.c
+++ b/fs/romfs/super.c
@@ -128,7 +128,7 @@ static int romfs_readpage(struct file *file, struct page *page)
 	}
 
 	if (fillsize < PAGE_SIZE)
-		memset(buf + fillsize, 0, PAGE_SIZE - fillsize);
+		(void)memset(buf + fillsize, 0, PAGE_SIZE - fillsize);
 	if (ret == 0)
 		SetPageUptodate(page);
 
diff --git a/fs/select.c b/fs/select.c
index d33418f..da03888 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -307,7 +307,7 @@ static int poll_select_copy_remaining(struct timespec *end_time, void __user *p,
 
 	if (timeval) {
 		if (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))
-			memset(&rtv, 0, sizeof(rtv));
+			(void)memset(&rtv, 0, sizeof(rtv));
 		rtv.tv_sec = rts.tv_sec;
 		rtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;
 
diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4023d6b..73974ac 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -37,7 +37,7 @@ int seq_open(struct file *file, const struct seq_operations *op)
 			return -ENOMEM;
 		file->private_data = p;
 	}
-	memset(p, 0, sizeof(*p));
+	(void)memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
 
diff --git a/fs/splice.c b/fs/splice.c
index 1ec0493..b978e50 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -47,7 +47,7 @@ static int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,
 
 	mapping = page_mapping(page);
 	if (mapping) {
-		WARN_ON(!PageUptodate(page));
+		(void)WARN_ON(!PageUptodate(page));
 
 		/*
 		 * At least for ext2 with nobh option, we need to wait on
diff --git a/fs/stat.c b/fs/stat.c
index 8806b89..550fb13 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -202,7 +202,7 @@ static int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)
 		return -EOVERFLOW;
 #endif
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 #if BITS_PER_LONG == 32
 	tmp.st_dev = old_encode_dev(stat->dev);
 #else
@@ -331,7 +331,7 @@ static long cp_new_stat64(struct kstat *stat, struct stat64 __user *statbuf)
 {
 	struct stat64 tmp;
 
-	memset(&tmp, 0, sizeof(struct stat64));
+	(void)memset(&tmp, 0, sizeof(struct stat64));
 #ifdef CONFIG_MIPS
 	/* mips has weird padding, so we don't get 64 bits there */
 	if (!new_valid_dev(stat->dev) || !new_valid_dev(stat->rdev))
diff --git a/fs/statfs.c b/fs/statfs.c
index 2aa6a22..ec22033 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -53,7 +53,7 @@ static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)
 	if (!dentry->d_sb->s_op->statfs)
 		return -ENOSYS;
 
-	memset(buf, 0, sizeof(*buf));
+	(void)memset(buf, 0, sizeof(*buf));
 	retval = security_sb_statfs(dentry);
 	if (retval)
 		return retval;
@@ -131,7 +131,7 @@ static int do_statfs_native(struct kstatfs *st, struct statfs __user *p)
 		buf.f_namelen = st->f_namelen;
 		buf.f_frsize = st->f_frsize;
 		buf.f_flags = st->f_flags;
-		memset(buf.f_spare, 0, sizeof(buf.f_spare));
+		(void)memset(buf.f_spare, 0, sizeof(buf.f_spare));
 	}
 	if (copy_to_user(p, &buf, sizeof(buf)))
 		return -EFAULT;
@@ -155,7 +155,7 @@ static int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)
 		buf.f_namelen = st->f_namelen;
 		buf.f_frsize = st->f_frsize;
 		buf.f_flags = st->f_flags;
-		memset(buf.f_spare, 0, sizeof(buf.f_spare));
+		(void)memset(buf.f_spare, 0, sizeof(buf.f_spare));
 	}
 	if (copy_to_user(p, &buf, sizeof(buf)))
 		return -EFAULT;
@@ -226,7 +226,7 @@ SYSCALL_DEFINE2(ustat, unsigned, dev, struct ustat __user *, ubuf)
 	if (err)
 		return err;
 
-	memset(&tmp,0,sizeof(struct ustat));
+	(void)memset(&tmp,0,sizeof(struct ustat));
 	tmp.f_tfree = sbuf.f_bfree;
 	tmp.f_tinode = sbuf.f_ffree;
 
diff --git a/fs/sync.c b/fs/sync.c
index f3501ef..ac5a649 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -62,7 +62,7 @@ int sync_filesystem(struct super_block *sb)
 	 * We need to be protected against the filesystem going from
 	 * r/o to r/w or vice versa.
 	 */
-	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+	(void)WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
 	/*
 	 * No point in syncing out anything if the filesystem is read-only.
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index dd1701c..b550730 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -134,7 +134,7 @@ void sysfs_remove_group(struct kobject * kobj,
 	if (grp->name) {
 		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
 		if (!sd) {
-			WARN(!sd, KERN_WARNING "sysfs group %p not found for "
+			(void)WARN(!sd, KERN_WARNING "sysfs group %p not found for "
 				"kobject '%s'\n", grp, kobject_name(kobj));
 			return;
 		}
diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c
index a7ac78f..c2ff2aa 100644
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@ -75,7 +75,7 @@ static int sysfs_do_create_link(struct kobject *kobj, struct kobject *target,
 			error = __sysfs_add_one(&acxt, sd);
 	} else {
 		error = -EINVAL;
-		WARN(1, KERN_WARNING
+		(void)WARN(1, KERN_WARNING
 			"sysfs: symlink across ns_types %s/%s -> %s/%s\n",
 			parent_sd->s_name,
 			sd->s_name,
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index 7484a36..40c463d 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -192,7 +192,7 @@ int sysfs_rename(struct sysfs_dirent *sd,
 static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
 {
 	if (sd) {
-		WARN_ON(!atomic_read(&sd->s_count));
+		(void)WARN_ON(!atomic_read(&sd->s_count));
 		atomic_inc(&sd->s_count);
 	}
 	return sd;
diff --git a/include/linux/acct.h b/include/linux/acct.h
index d537aa0..7677788 100644
--- a/include/linux/acct.h
+++ b/include/linux/acct.h
@@ -193,7 +193,7 @@ static inline u32 jiffies_to_AHZ(unsigned long x)
 static inline u64 nsec_to_AHZ(u64 x)
 {
 #if (NSEC_PER_SEC % AHZ) == 0
-	do_div(x, (NSEC_PER_SEC / AHZ));
+	(void)do_div(x, (NSEC_PER_SEC / AHZ));
 #elif (AHZ % 512) == 0
 	x *= AHZ/512;
 	do_div(x, (NSEC_PER_SEC / 512));
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index 38ac48b..625e61c 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -64,7 +64,7 @@ static inline void gpio_free(unsigned gpio)
 	might_sleep();
 
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline void gpio_free_array(const struct gpio *array, size_t num)
@@ -72,7 +72,7 @@ static inline void gpio_free_array(const struct gpio *array, size_t num)
 	might_sleep();
 
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_direction_input(unsigned gpio)
@@ -93,40 +93,40 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline void gpio_set_value(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested or set as output */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_cansleep(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline int gpio_get_value_cansleep(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return 0;
 }
 
 static inline void gpio_set_value_cansleep(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested or set as output */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_export(unsigned gpio, bool direction_may_change)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
@@ -134,34 +134,34 @@ static inline int gpio_export_link(struct device *dev, const char *name,
 				unsigned gpio)
 {
 	/* GPIO can never have been exported */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline int gpio_sysfs_set_active_low(unsigned gpio, int value)
 {
 	/* GPIO can never have been requested */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline void gpio_unexport(unsigned gpio)
 {
 	/* GPIO can never have been exported */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 }
 
 static inline int gpio_to_irq(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as input */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
 static inline int irq_to_gpio(unsigned irq)
 {
 	/* irq can never have been returned from gpio_to_irq() */
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return -EINVAL;
 }
 
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 1a81fde..9e8a8bd 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -456,7 +456,7 @@ static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->erasesize_shift)
 		return sz >> mtd->erasesize_shift;
-	do_div(sz, mtd->erasesize);
+	(void)do_div(sz, mtd->erasesize);
 	return sz;
 }
 
@@ -471,7 +471,7 @@ static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->writesize_shift)
 		return sz >> mtd->writesize_shift;
-	do_div(sz, mtd->writesize);
+	(void)do_div(sz, mtd->writesize);
 	return sz;
 }
 
diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index f494f1e..a352c2b 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -68,12 +68,12 @@ static inline size_t snd_mask_sizeof(void)
 
 static inline void snd_mask_none(struct snd_mask *mask)
 {
-	memset(mask, 0, sizeof(*mask));
+	(void)memset(mask, 0, sizeof(*mask));
 }
 
 static inline void snd_mask_any(struct snd_mask *mask)
 {
-	memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
+	(void)memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
 static inline int snd_mask_empty(const struct snd_mask *mask)
diff --git a/ipc/ipcns_notifier.c b/ipc/ipcns_notifier.c
index b9b31a4..668f79d 100644
--- a/ipc/ipcns_notifier.c
+++ b/ipc/ipcns_notifier.c
@@ -57,7 +57,7 @@ int register_ipcns_notifier(struct ipc_namespace *ns)
 {
 	int rc;
 
-	memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
+	(void)memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
 	ns->ipcns_nb.notifier_call = ipcns_callback;
 	ns->ipcns_nb.priority = IPCNS_CALLBACK_PRI;
 	rc = blocking_notifier_chain_register(&ipcns_chain, &ns->ipcns_nb);
@@ -70,7 +70,7 @@ int cond_register_ipcns_notifier(struct ipc_namespace *ns)
 {
 	int rc;
 
-	memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
+	(void)memset(&ns->ipcns_nb, 0, sizeof(ns->ipcns_nb));
 	ns->ipcns_nb.notifier_call = ipcns_callback;
 	ns->ipcns_nb.priority = IPCNS_CALLBACK_PRI;
 	rc = blocking_notifier_chain_cond_register(&ipcns_chain,
diff --git a/ipc/msg.c b/ipc/msg.c
index 7385de2..1025ef2 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -337,7 +337,7 @@ copy_msqid_to_user(void __user *buf, struct msqid64_ds *in, int version)
 	{
 		struct msqid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 
 		ipc64_perm_to_ipc_perm(&in->msg_perm, &out.msg_perm);
 
@@ -496,7 +496,7 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&msginfo, 0, sizeof(msginfo));
+		(void)memset(&msginfo, 0, sizeof(msginfo));
 		msginfo.msgmni = ns->msg_ctlmni;
 		msginfo.msgmax = ns->msg_ctlmax;
 		msginfo.msgmnb = ns->msg_ctlmnb;
@@ -546,7 +546,7 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 		if (err)
 			goto out_unlock;
 
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 
 		kernel_to_ipc64_perm(&msq->q_perm, &tbuf.msg_perm);
 		tbuf.msg_stime  = msq->q_stime;
diff --git a/ipc/sem.c b/ipc/sem.c
index 5215a81..1fd4151 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -302,7 +302,7 @@ static int newary(struct ipc_namespace *ns, struct ipc_params *params)
 	if (!sma) {
 		return -ENOMEM;
 	}
-	memset (sma, 0, size);
+	(void)memset (sma, 0, size);
 
 	sma->sem_perm.mode = (semflg & S_IRWXUGO);
 	sma->sem_perm.key = key;
@@ -783,7 +783,7 @@ static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in,
 	    {
 		struct semid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 
 		ipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);
 
@@ -815,7 +815,7 @@ static int semctl_nolock(struct ipc_namespace *ns, int semid,
 		if (err)
 			return err;
 		
-		memset(&seminfo,0,sizeof(seminfo));
+		(void)memset(&seminfo,0,sizeof(seminfo));
 		seminfo.semmni = ns->sc_semmni;
 		seminfo.semmns = ns->sc_semmns;
 		seminfo.semmsl = ns->sc_semmsl;
@@ -864,7 +864,7 @@ static int semctl_nolock(struct ipc_namespace *ns, int semid,
 		if (err)
 			goto out_unlock;
 
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 
 		kernel_to_ipc64_perm(&sma->sem_perm, &tbuf.sem_perm);
 		tbuf.sem_otime  = sma->sem_otime;
diff --git a/ipc/shm.c b/ipc/shm.c
index b76be5b..0703af5 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -587,7 +587,7 @@ static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_
 	    {
 		struct shmid_ds out;
 
-		memset(&out, 0, sizeof(out));
+		(void)memset(&out, 0, sizeof(out));
 		ipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);
 		out.shm_segsz	= in->shm_segsz;
 		out.shm_atime	= in->shm_atime;
@@ -782,7 +782,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&shminfo, 0, sizeof(shminfo));
+		(void)memset(&shminfo, 0, sizeof(shminfo));
 		shminfo.shmmni = shminfo.shmseg = ns->shm_ctlmni;
 		shminfo.shmmax = ns->shm_ctlmax;
 		shminfo.shmall = ns->shm_ctlall;
@@ -807,7 +807,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		if (err)
 			return err;
 
-		memset(&shm_info, 0, sizeof(shm_info));
+		(void)memset(&shm_info, 0, sizeof(shm_info));
 		down_read(&shm_ids(ns).rw_mutex);
 		shm_info.used_ids = shm_ids(ns).in_use;
 		shm_get_stat (ns, &shm_info.shm_rss, &shm_info.shm_swp);
@@ -851,7 +851,7 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		err = security_shm_shmctl(shp, cmd);
 		if (err)
 			goto out_unlock;
-		memset(&tbuf, 0, sizeof(tbuf));
+		(void)memset(&tbuf, 0, sizeof(tbuf));
 		kernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);
 		tbuf.shm_segsz	= shp->shm_segsz;
 		tbuf.shm_atime	= shp->shm_atim;
diff --git a/kernel/fork.c b/kernel/fork.c
index 051f090..528c464 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -188,9 +188,9 @@ static inline void put_signal_struct(struct signal_struct *sig)
 
 void __put_task_struct(struct task_struct *tsk)
 {
-	WARN_ON(!tsk->exit_state);
-	WARN_ON(atomic_read(&tsk->usage));
-	WARN_ON(tsk == current);
+	(void)WARN_ON(!tsk->exit_state);
+	(void)WARN_ON(atomic_read(&tsk->usage));
+	(void)WARN_ON(tsk == current);
 
 	exit_creds(tsk);
 	delayacct_tsk_free(tsk);
@@ -493,7 +493,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)
 		(current->mm->flags & MMF_INIT_MASK) : default_dump_filter;
 	mm->core_state = NULL;
 	mm->nr_ptes = 0;
-	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
+	(void)memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
 	spin_lock_init(&mm->page_table_lock);
 	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	mm->cached_hole_size = ~0UL;
@@ -521,7 +521,7 @@ struct mm_struct *mm_alloc(void)
 	if (!mm)
 		return NULL;
 
-	memset(mm, 0, sizeof(*mm));
+	(void)memset(mm, 0, sizeof(*mm));
 	mm_init_cpumask(mm);
 	return mm_init(mm, current);
 }
@@ -702,7 +702,7 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 			 * We don't check the error code - if userspace has
 			 * not set up a proper pointer then tough luck.
 			 */
-			put_user(0, tsk->clear_child_tid);
+			(void)put_user(0, tsk->clear_child_tid);
 			sys_futex(tsk->clear_child_tid, FUTEX_WAKE,
 					1, NULL, NULL, 0);
 		}
@@ -1427,7 +1427,7 @@ fork_out:
 
 noinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)
 {
-	memset(regs, 0, sizeof(struct pt_regs));
+	(void)memset(regs, 0, sizeof(struct pt_regs));
 	return regs;
 }
 
@@ -1520,7 +1520,7 @@ long do_fork(unsigned long clone_flags,
 		nr = task_pid_vnr(p);
 
 		if (clone_flags & CLONE_PARENT_SETTID)
-			put_user(nr, parent_tidptr);
+			(void)put_user(nr, parent_tidptr);
 
 		if (clone_flags & CLONE_VFORK) {
 			p->vfork_done = &vfork;
diff --git a/kernel/futex.c b/kernel/futex.c
index 1614be2..c9811af 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -199,7 +199,7 @@ static void drop_futex_key_refs(union futex_key *key)
 {
 	if (!key->both.ptr) {
 		/* If we're here then we tried to put a key we failed to get */
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return;
 	}
 
@@ -476,7 +476,7 @@ static struct futex_pi_state * alloc_pi_state(void)
 {
 	struct futex_pi_state *pi_state = current->pi_state_cache;
 
-	WARN_ON(!pi_state);
+	(void)WARN_ON(!pi_state);
 	current->pi_state_cache = NULL;
 
 	return pi_state;
@@ -571,8 +571,8 @@ void exit_pi_state_list(struct task_struct *curr)
 			continue;
 		}
 
-		WARN_ON(pi_state->owner != curr);
-		WARN_ON(list_empty(&pi_state->list));
+		(void)WARN_ON(pi_state->owner != curr);
+		(void)WARN_ON(list_empty(&pi_state->list));
 		list_del_init(&pi_state->list);
 		pi_state->owner = NULL;
 		raw_spin_unlock_irq(&curr->pi_lock);
@@ -611,7 +611,7 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 			if (unlikely(!pi_state))
 				return -EINVAL;
 
-			WARN_ON(!atomic_read(&pi_state->refcount));
+			(void)WARN_ON(!atomic_read(&pi_state->refcount));
 
 			/*
 			 * When pi_state->owner is NULL then the owner died
@@ -680,7 +680,7 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	/* Store the key for possible exit cleanups: */
 	pi_state->key = *key;
 
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &p->pi_state_list);
 	pi_state->owner = p;
 	raw_spin_unlock_irq(&p->pi_lock);
@@ -910,12 +910,12 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 	}
 
 	raw_spin_lock_irq(&pi_state->owner->pi_lock);
-	WARN_ON(list_empty(&pi_state->list));
+	(void)WARN_ON(list_empty(&pi_state->list));
 	list_del_init(&pi_state->list);
 	raw_spin_unlock_irq(&pi_state->owner->pi_lock);
 
 	raw_spin_lock_irq(&new_owner->pi_lock);
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &new_owner->pi_state_list);
 	pi_state->owner = new_owner;
 	raw_spin_unlock_irq(&new_owner->pi_lock);
@@ -1151,7 +1151,7 @@ void requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,
 
 	__unqueue_futex(q);
 
-	WARN_ON(!q->rt_waiter);
+	(void)WARN_ON(!q->rt_waiter);
 	q->rt_waiter = NULL;
 
 	q->lock_ptr = &hb->lock;
@@ -1340,7 +1340,7 @@ retry_private:
 		 * reference to it.
 		 */
 		if (ret == 1) {
-			WARN_ON(pi_state);
+			(void)WARN_ON(pi_state);
 			drop_count++;
 			task_count++;
 			ret = get_futex_value_locked(&curval2, uaddr2);
@@ -1632,7 +1632,7 @@ retry:
 	 */
 	if (pi_state->owner != NULL) {
 		raw_spin_lock_irq(&pi_state->owner->pi_lock);
-		WARN_ON(list_empty(&pi_state->list));
+		(void)WARN_ON(list_empty(&pi_state->list));
 		list_del_init(&pi_state->list);
 		raw_spin_unlock_irq(&pi_state->owner->pi_lock);
 	}
@@ -1640,7 +1640,7 @@ retry:
 	pi_state->owner = newowner;
 
 	raw_spin_lock_irq(&newowner->pi_lock);
-	WARN_ON(!list_empty(&pi_state->list));
+	(void)WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &newowner->pi_state_list);
 	raw_spin_unlock_irq(&newowner->pi_lock);
 	return 0;
@@ -2018,7 +2018,7 @@ retry_private:
 	 */
 	queue_me(&q, hb);
 
-	WARN_ON(!q.pi_state);
+	(void)WARN_ON(!q.pi_state);
 	/*
 	 * Block on the PI mutex:
 	 */
@@ -2201,7 +2201,7 @@ int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,
 	 * support a PI aware source futex for requeue.
 	 */
 	if (!match_futex(&q->key, key2)) {
-		WARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));
+		(void)WARN_ON(q->lock_ptr && (&hb->lock != q->lock_ptr));
 		/*
 		 * We were woken prior to requeue by a timeout or a signal.
 		 * Unqueue the futex_q and determine which it was.
@@ -2342,7 +2342,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		 * signal.  futex_unlock_pi() will not destroy the lock_ptr nor
 		 * the pi_state.
 		 */
-		WARN_ON(!&q.pi_state);
+		(void)WARN_ON(!&q.pi_state);
 		pi_mutex = &q.pi_state->pi_mutex;
 		ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);
 		debug_rt_mutex_free_waiter(&rt_waiter);
diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index ae34bf5..86324c7 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -321,7 +321,7 @@ u64 ktime_divns(const ktime_t kt, s64 div)
 		div >>= 1;
 	}
 	dclc >>= sft;
-	do_div(dclc, (unsigned long) div);
+	(void)do_div(dclc, (unsigned long) div);
 
 	return dclc;
 }
@@ -761,7 +761,7 @@ void clock_was_set(void)
  */
 void hrtimers_resume(void)
 {
-	WARN_ONCE(!irqs_disabled(),
+	(void)WARN_ONCE(!irqs_disabled(),
 		  KERN_INFO "hrtimers_resume() called with IRQs enabled!");
 
 	retrigger_next_event(NULL);
@@ -1142,7 +1142,7 @@ static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
 	struct hrtimer_cpu_base *cpu_base;
 	int base;
 
-	memset(timer, 0, sizeof(struct hrtimer));
+	(void)memset(timer, 0, sizeof(struct hrtimer));
 
 	cpu_base = &__raw_get_cpu_var(hrtimer_bases);
 
@@ -1201,7 +1201,7 @@ static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)
 	enum hrtimer_restart (*fn)(struct hrtimer *);
 	int restart;
 
-	WARN_ON(!irqs_disabled());
+	(void)WARN_ON(!irqs_disabled());
 
 	debug_deactivate(timer);
 	__remove_hrtimer(timer, base, HRTIMER_STATE_CALLBACK, 0);
@@ -1229,7 +1229,7 @@ static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)
 		enqueue_hrtimer(timer, base);
 	}
 
-	WARN_ON_ONCE(!(timer->state & HRTIMER_STATE_CALLBACK));
+	(void)WARN_ON_ONCE(!(timer->state & HRTIMER_STATE_CALLBACK));
 
 	timer->state &= ~HRTIMER_STATE_CALLBACK;
 }
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index 1f9e265..dea8c12 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -30,12 +30,12 @@ void irq_domain_add(struct irq_domain *domain)
 	irq_domain_for_each_irq(domain, hwirq, irq) {
 		d = irq_get_irq_data(irq);
 		if (!d) {
-			WARN(1, "error: assigning domain to non existant irq_desc");
+			(void)WARN(1, "error: assigning domain to non existant irq_desc");
 			return;
 		}
 		if (d->domain) {
 			/* things are broken; just report, don't clean up */
-			WARN(1, "error: irq_desc already assigned to a domain");
+			(void)WARN(1, "error: irq_desc already assigned to a domain");
 			return;
 		}
 		d->domain = domain;
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index a9a9dbe..aeae73a 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -418,7 +418,7 @@ void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume)
 	switch (desc->depth) {
 	case 0:
  err_out:
-		WARN(1, KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);
+		(void)WARN(1, KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);
 		break;
 	case 1: {
 		if (desc->istate & IRQS_SUSPENDED)
@@ -510,7 +510,7 @@ int irq_set_irq_wake(unsigned int irq, unsigned int on)
 		}
 	} else {
 		if (desc->wake_depth == 0) {
-			WARN(1, "Unbalanced IRQ %d wake disable\n", irq);
+			(void)WARN(1, "Unbalanced IRQ %d wake disable\n", irq);
 		} else if (--desc->wake_depth == 0) {
 			ret = set_irq_wake_real(irq, on);
 			if (ret)
@@ -617,7 +617,7 @@ static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)
  */
 static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)
 {
-	WARN(1, "Primary handler called for nested irq %d\n", irq);
+	(void)WARN(1, "Primary handler called for nested irq %d\n", irq);
 	return IRQ_NONE;
 }
 
@@ -1144,7 +1144,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 	struct irqaction *action, **action_ptr;
 	unsigned long flags;
 
-	WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
+	(void)WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
 
 	if (!desc)
 		return NULL;
@@ -1160,7 +1160,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 		action = *action_ptr;
 
 		if (!action) {
-			WARN(1, "Trying to free already-free IRQ %d\n", irq);
+			(void)WARN(1, "Trying to free already-free IRQ %d\n", irq);
 			raw_spin_unlock_irqrestore(&desc->lock, flags);
 
 			return NULL;
@@ -1438,7 +1438,7 @@ void enable_percpu_irq(unsigned int irq, unsigned int type)
 		ret = __irq_set_trigger(desc, irq, type);
 
 		if (ret) {
-			WARN(1, "failed to set type for IRQ%d\n", irq);
+			(void)WARN(1, "failed to set type for IRQ%d\n", irq);
 			goto out;
 		}
 	}
@@ -1470,7 +1470,7 @@ static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_
 	struct irqaction *action;
 	unsigned long flags;
 
-	WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
+	(void)WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);
 
 	if (!desc)
 		return NULL;
@@ -1479,12 +1479,12 @@ static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_
 
 	action = desc->action;
 	if (!action || action->percpu_dev_id != dev_id) {
-		WARN(1, "Trying to free already-free IRQ %d\n", irq);
+		(void)WARN(1, "Trying to free already-free IRQ %d\n", irq);
 		goto bad;
 	}
 
 	if (!cpumask_empty(desc->percpu_enabled)) {
-		WARN(1, "percpu IRQ %d still enabled on CPU%d!\n",
+		(void)WARN(1, "percpu IRQ %d still enabled on CPU%d!\n",
 		     irq, cpumask_first(desc->percpu_enabled));
 		goto bad;
 	}
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index 4bd4faa..c2d34d3 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -296,7 +296,7 @@ void register_handler_proc(unsigned int irq, struct irqaction *action)
 					!name_unique(irq, action))
 		return;
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	snprintf(name, MAX_NAMELEN, "%s", action->name);
 
 	/* create /proc/irq/1234/handler/ */
@@ -314,7 +314,7 @@ void register_irq_proc(unsigned int irq, struct irq_desc *desc)
 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip) || desc->dir)
 		return;
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	sprintf(name, "%d", irq);
 
 	/* create /proc/irq/1234 */
@@ -357,7 +357,7 @@ void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)
 #endif
 	remove_proc_entry("spurious", desc->dir);
 
-	memset(name, 0, MAX_NAMELEN);
+	(void)memset(name, 0, MAX_NAMELEN);
 	sprintf(name, "%u", irq);
 	remove_proc_entry(name, root_irq_dir);
 }
diff --git a/kernel/itimer.c b/kernel/itimer.c
index 22000c3..f531700 100644
--- a/kernel/itimer.c
+++ b/kernel/itimer.c
@@ -285,7 +285,7 @@ SYSCALL_DEFINE3(setitimer, int, which, struct itimerval __user *, value,
 		if(copy_from_user(&set_buffer, value, sizeof(set_buffer)))
 			return -EFAULT;
 	} else
-		memset((char *) &set_buffer, 0, sizeof(set_buffer));
+		(void)memset((char *) &set_buffer, 0, sizeof(set_buffer));
 
 	error = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);
 	if (error || !ovalue)
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 3d3de63..7270281 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -223,7 +223,7 @@ void kthread_bind(struct task_struct *p, unsigned int cpu)
 {
 	/* Must have done schedule() in kthread() before we set_task_cpu */
 	if (!wait_task_inactive(p, TASK_UNINTERRUPTIBLE)) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return;
 	}
 
@@ -340,7 +340,7 @@ int kthread_worker_fn(void *worker_ptr)
 	struct kthread_worker *worker = worker_ptr;
 	struct kthread_work *work;
 
-	WARN_ON(worker->task);
+	(void)WARN_ON(worker->task);
 	worker->task = current;
 repeat:
 	set_current_state(TASK_INTERRUPTIBLE);	/* mb paired w/ kthread_stop */
diff --git a/kernel/module.c b/kernel/module.c
index 2c93276..de18616 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1537,7 +1537,7 @@ static int mod_sysfs_init(struct module *mod)
 
 	mod->mkobj.mod = mod;
 
-	memset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));
+	(void)memset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));
 	mod->mkobj.kobj.kset = module_kset;
 	err = kobject_init_and_add(&mod->mkobj.kobj, &module_ktype, NULL,
 				   "%s", mod->name);
@@ -2641,7 +2641,7 @@ static int move_module(struct module *mod, struct load_info *info)
 	if (!ptr)
 		return -ENOMEM;
 
-	memset(ptr, 0, mod->core_size);
+	(void)memset(ptr, 0, mod->core_size);
 	mod->module_core = ptr;
 
 	ptr = module_alloc_update_bounds(mod->init_size);
@@ -2656,7 +2656,7 @@ static int move_module(struct module *mod, struct load_info *info)
 		module_free(mod, mod->module_core);
 		return -ENOMEM;
 	}
-	memset(ptr, 0, mod->init_size);
+	(void)memset(ptr, 0, mod->init_size);
 	mod->module_init = ptr;
 
 	/* Transfer each section which specifies SHF_ALLOC */
diff --git a/kernel/params.c b/kernel/params.c
index 32ee043..3c3c618 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -638,9 +638,9 @@ static __modinit int add_sysfs_param(struct module_kobject *mk,
 	}
 
 	/* Sysfs wants everything zeroed. */
-	memset(new, 0, sizeof(*new));
-	memset(&new->attrs[num], 0, sizeof(new->attrs[num]));
-	memset(&attrs[num], 0, sizeof(attrs[num]));
+	(void)memset(new, 0, sizeof(*new));
+	(void)memset(&new->attrs[num], 0, sizeof(new->attrs[num]));
+	(void)memset(&attrs[num], 0, sizeof(attrs[num]));
 	new->grp.name = "parameters";
 	new->grp.attrs = attrs;
 
diff --git a/kernel/posix-cpu-timers.c b/kernel/posix-cpu-timers.c
index 125cb67..e31eff9 100644
--- a/kernel/posix-cpu-timers.c
+++ b/kernel/posix-cpu-timers.c
@@ -1400,7 +1400,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 	/*
 	 * Set up a temporary timer and then wait for it to go off.
 	 */
-	memset(&timer, 0, sizeof timer);
+	(void)memset(&timer, 0, sizeof timer);
 	spin_lock_init(&timer.it_lock);
 	timer.it_clock = which_clock;
 	timer.it_overrun = -1;
@@ -1409,7 +1409,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 	if (!error) {
 		static struct itimerspec zero_it;
 
-		memset(it, 0, sizeof *it);
+		(void)memset(it, 0, sizeof *it);
 		it->it_value = *rqtp;
 
 		spin_lock_irq(&timer.it_lock);
@@ -1597,7 +1597,7 @@ static __init int init_posix_cpu_timers(void)
 
 	cputime_to_timespec(cputime_one_jiffy, &ts);
 	onecputick = ts.tv_nsec;
-	WARN_ON(ts.tv_sec != 0);
+	(void)WARN_ON(ts.tv_sec != 0);
 
 	return 0;
 }
diff --git a/kernel/posix-timers.c b/kernel/posix-timers.c
index 69185ae..46300e8 100644
--- a/kernel/posix-timers.c
+++ b/kernel/posix-timers.c
@@ -487,7 +487,7 @@ static struct k_itimer * alloc_posix_timer(void)
 		kmem_cache_free(posix_timers_cache, tmr);
 		return NULL;
 	}
-	memset(&tmr->sigq->info, 0, sizeof(siginfo_t));
+	(void)memset(&tmr->sigq->info, 0, sizeof(siginfo_t));
 	return tmr;
 }
 
@@ -676,7 +676,7 @@ common_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 	ktime_t now, remaining, iv;
 	struct hrtimer *timer = &timr->it.real.timer;
 
-	memset(cur_setting, 0, sizeof(struct itimerspec));
+	(void)memset(cur_setting, 0, sizeof(struct itimerspec));
 
 	iv = timr->it.real.interval;
 
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 77274c9..f6fa746 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -87,7 +87,7 @@ static int try_to_freeze_tasks(bool user_only)
 
 	do_gettimeofday(&end);
 	elapsed_csecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);
-	do_div(elapsed_csecs64, NSEC_PER_SEC / 100);
+	(void)do_div(elapsed_csecs64, NSEC_PER_SEC / 100);
 	elapsed_csecs = elapsed_csecs64;
 
 	if (todo) {
diff --git a/kernel/resource.c b/kernel/resource.c
index 7640b3a..2aa88ff 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -1018,7 +1018,7 @@ void __devm_release_region(struct device *dev, struct resource *parent,
 	struct region_devres match_data = { parent, start, n };
 
 	__release_region(parent, start, n);
-	WARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,
+	(void)WARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,
 			       &match_data));
 }
 EXPORT_SYMBOL(__devm_release_region);
diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index a242e69..f8fe7e1 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -523,7 +523,7 @@ static void remove_waiter(struct rt_mutex *lock,
 		raw_spin_unlock_irqrestore(&owner->pi_lock, flags);
 	}
 
-	WARN_ON(!plist_node_empty(&waiter->pi_list_entry));
+	(void)WARN_ON(!plist_node_empty(&waiter->pi_list_entry));
 
 	if (!chain_walk)
 		return;
@@ -869,7 +869,7 @@ EXPORT_SYMBOL_GPL(rt_mutex_unlock);
  */
 void rt_mutex_destroy(struct rt_mutex *lock)
 {
-	WARN_ON(rt_mutex_is_locked(lock));
+	(void)WARN_ON(rt_mutex_is_locked(lock));
 #ifdef CONFIG_DEBUG_RT_MUTEXES
 	lock->magic = NULL;
 #endif
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 4eb3a0f..658c89b 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -134,8 +134,8 @@ EXPORT_SYMBOL(local_bh_disable);
 
 static void __local_bh_enable(unsigned int cnt)
 {
-	WARN_ON_ONCE(in_irq());
-	WARN_ON_ONCE(!irqs_disabled());
+	(void)WARN_ON_ONCE(in_irq());
+	(void)WARN_ON_ONCE(!irqs_disabled());
 
 	if (softirq_count() == cnt)
 		trace_softirqs_on((unsigned long)__builtin_return_address(0));
@@ -156,7 +156,7 @@ EXPORT_SYMBOL(_local_bh_enable);
 
 static inline void _local_bh_enable_ip(unsigned long ip)
 {
-	WARN_ON_ONCE(in_irq() || irqs_disabled());
+	(void)WARN_ON_ONCE(in_irq() || irqs_disabled());
 #ifdef CONFIG_TRACE_IRQFLAGS
 	local_irq_disable();
 #endif
@@ -731,7 +731,7 @@ void __init softirq_init(void)
 			INIT_LIST_HEAD(&per_cpu(softirq_work_list[i], cpu));
 	}
 
-	register_hotcpu_notifier(&remote_softirq_cpu_notifier);
+	(void)register_hotcpu_notifier(&remote_softirq_cpu_notifier);
 
 	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
 	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
diff --git a/kernel/srcu.c b/kernel/srcu.c
index 0febf61..77e25b7 100644
--- a/kernel/srcu.c
+++ b/kernel/srcu.c
@@ -113,7 +113,7 @@ void cleanup_srcu_struct(struct srcu_struct *sp)
 	int sum;
 
 	sum = srcu_readers_active(sp);
-	WARN_ON(sum);  /* Leakage unless caller handles error. */
+	(void)WARN_ON(sum);  /* Leakage unless caller handles error. */
 	if (sum != 0)
 		return;
 	free_percpu(sp->per_cpu_ref);
diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c
index 8a46f5d..c92849a 100644
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@ -524,7 +524,7 @@ static int alarm_timer_create(struct k_itimer *new_timer)
 static void alarm_timer_get(struct k_itimer *timr,
 				struct itimerspec *cur_setting)
 {
-	memset(cur_setting, 0, sizeof(struct itimerspec));
+	(void)memset(cur_setting, 0, sizeof(struct itimerspec));
 
 	cur_setting->it_interval =
 			ktime_to_timespec(timr->it.alarm.interval);
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index 9cd928f..5107f0e 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -43,10 +43,10 @@ u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)
 
 	if (unlikely(!evt->mult)) {
 		evt->mult = 1;
-		WARN_ON(1);
+		(void)WARN_ON(1);
 	}
 
-	do_div(clc, evt->mult);
+	(void)do_div(clc, evt->mult);
 	if (clc < 1000)
 		clc = 1000;
 	if (clc > KTIME_MAX)
@@ -77,7 +77,7 @@ void clockevents_set_mode(struct clock_event_device *dev,
 		if (mode == CLOCK_EVT_MODE_ONESHOT) {
 			if (unlikely(!dev->mult)) {
 				dev->mult = 1;
-				WARN_ON(1);
+				(void)WARN_ON(1);
 			}
 		}
 	}
@@ -206,7 +206,7 @@ int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,
 	int rc;
 
 	if (unlikely(expires.tv64 < 0)) {
-		WARN_ON_ONCE(1);
+		(void)WARN_ON_ONCE(1);
 		return -ETIME;
 	}
 
@@ -283,7 +283,7 @@ void clockevents_register_device(struct clock_event_device *dev)
 
 	BUG_ON(dev->mode != CLOCK_EVT_MODE_UNUSED);
 	if (!dev->cpumask) {
-		WARN_ON(num_possible_cpus() > 1);
+		(void)WARN_ON(num_possible_cpus() > 1);
 		dev->cpumask = cpumask_of(smp_processor_id());
 	}
 
@@ -311,7 +311,7 @@ static void clockevents_config(struct clock_event_device *dev,
 	 * 32bit ticks so we still get reasonable conversion values.
 	 */
 	sec = dev->max_delta_ticks;
-	do_div(sec, freq);
+	(void)do_div(sec, freq);
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && dev->max_delta_ticks > UINT_MAX)
diff --git a/kernel/timer.c b/kernel/timer.c
index a297ffc..d4e01c0 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -1118,7 +1118,7 @@ static void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),
 	lock_map_release(&lockdep_map);
 
 	if (preempt_count != preempt_count()) {
-		WARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",
+		(void)WARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",
 			  fn, preempt_count, preempt_count());
 		/*
 		 * Restore the preempt count. That gives us a decent
@@ -1573,7 +1573,7 @@ int do_sysinfo(struct sysinfo *info)
 	unsigned int mem_unit, bitcount;
 	struct timespec tp;
 
-	memset(info, 0, sizeof(struct sysinfo));
+	(void)memset(info, 0, sizeof(struct sysinfo));
 
 	ktime_get_ts(&tp);
 	monotonic_to_bootbased(&tp);
@@ -1663,7 +1663,7 @@ static int __cpuinit init_timers_cpu(int cpu)
 
 			/* Make sure that tvec_base is 2 byte aligned */
 			if (tbase_get_deferrable(base)) {
-				WARN_ON(1);
+				(void)WARN_ON(1);
 				kfree(base);
 				return -ENOMEM;
 			}
diff --git a/kernel/up.c b/kernel/up.c
index c54c75e..44f6edc 100644
--- a/kernel/up.c
+++ b/kernel/up.c
@@ -10,7 +10,7 @@
 int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 				int wait)
 {
-	WARN_ON(cpu != 0);
+	(void)WARN_ON(cpu != 0);
 
 	local_irq_disable();
 	(func)(info);
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index bec7b5b..c35220b 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -738,7 +738,7 @@ static inline void worker_set_flags(struct worker *worker, unsigned int flags,
 {
 	struct global_cwq *gcwq = worker->gcwq;
 
-	WARN_ON_ONCE(worker->task != current);
+	(void)WARN_ON_ONCE(worker->task != current);
 
 	/*
 	 * If transitioning into NOT_RUNNING, adjust nr_running and
@@ -775,7 +775,7 @@ static inline void worker_clr_flags(struct worker *worker, unsigned int flags)
 	struct global_cwq *gcwq = worker->gcwq;
 	unsigned int oflags = worker->flags;
 
-	WARN_ON_ONCE(worker->task != current);
+	(void)WARN_ON_ONCE(worker->task != current);
 
 	worker->flags &= ~flags;
 
@@ -1214,7 +1214,7 @@ static void worker_enter_idle(struct worker *worker)
 		wake_up_all(&gcwq->trustee_wait);
 
 	/* sanity check nr_running */
-	WARN_ON_ONCE(gcwq->nr_workers == gcwq->nr_idle &&
+	(void)WARN_ON_ONCE(gcwq->nr_workers == gcwq->nr_idle &&
 		     atomic_read(get_gcwq_nr_running(gcwq->cpu)));
 }
 
@@ -3438,7 +3438,7 @@ static int __cpuinit trustee_thread(void *__gcwq)
 	 * Tell the remaining busy ones to rebind once it finishes the
 	 * currently scheduled works by scheduling the rebind_work.
 	 */
-	WARN_ON(!list_empty(&gcwq->idle_list));
+	(void)WARN_ON(!list_empty(&gcwq->idle_list));
 
 	for_each_busy_worker(worker, i, pos, gcwq) {
 		struct work_struct *rebind_work = &worker->rebind_work;
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 0d4a127..07e8e20 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -134,7 +134,7 @@ void __bitmap_shift_right(unsigned long *dst,
 			dst[k] &= mask;
 	}
 	if (off)
-		memset(&dst[lim - off], 0, off*sizeof(unsigned long));
+		(void)memset(&dst[lim - off], 0, off*sizeof(unsigned long));
 }
 EXPORT_SYMBOL(__bitmap_shift_right);
 
@@ -175,7 +175,7 @@ void __bitmap_shift_left(unsigned long *dst,
 			dst[k + off] &= (1UL << left) - 1;
 	}
 	if (off)
-		memset(dst, 0, off*sizeof(unsigned long));
+		(void)memset(dst, 0, off*sizeof(unsigned long));
 }
 EXPORT_SYMBOL(__bitmap_shift_left);
 
diff --git a/lib/decompress_bunzip2.c b/lib/decompress_bunzip2.c
index 31c5f76..c0c85ca 100644
--- a/lib/decompress_bunzip2.c
+++ b/lib/decompress_bunzip2.c
@@ -641,7 +641,7 @@ static int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, int len,
 	bd = *bdp = malloc(i);
 	if (!bd)
 		return RETVAL_OUT_OF_MEMORY;
-	memset(bd, 0, sizeof(struct bunzip_data));
+	(void)memset(bd, 0, sizeof(struct bunzip_data));
 	/* Setup input buffer */
 	bd->inbuf = inbuf;
 	bd->inbufCount = len;
diff --git a/lib/flex_array.c b/lib/flex_array.c
index 9b8b894..714c49b 100644
--- a/lib/flex_array.c
+++ b/lib/flex_array.c
@@ -110,7 +110,7 @@ struct flex_array *flex_array_alloc(int element_size, unsigned int total,
 	ret->elems_per_part = elems_per_part;
 	ret->reciprocal_elems = reciprocal_elems;
 	if (elements_fit_in_base(ret) && !(flags & __GFP_ZERO))
-		memset(&ret->parts[0], FLEX_ARRAY_FREE,
+		(void)memset(&ret->parts[0], FLEX_ARRAY_FREE,
 						FLEX_ARRAY_BASE_BYTES_LEFT);
 	return ret;
 }
@@ -166,7 +166,7 @@ __fa_get_part(struct flex_array *fa, int part_nr, gfp_t flags)
 		if (!part)
 			return NULL;
 		if (!(flags & __GFP_ZERO))
-			memset(part, FLEX_ARRAY_FREE,
+			(void)memset(part, FLEX_ARRAY_FREE,
 				sizeof(struct flex_array_part));
 		fa->parts[part_nr] = part;
 	}
@@ -241,7 +241,7 @@ int flex_array_clear(struct flex_array *fa, unsigned int element_nr)
 			return -EINVAL;
 	}
 	dst = &part->elements[index_inside_part(fa, element_nr, part_nr)];
-	memset(dst, FLEX_ARRAY_FREE, fa->element_size);
+	(void)memset(dst, FLEX_ARRAY_FREE, fa->element_size);
 	return 0;
 }
 EXPORT_SYMBOL(flex_array_clear);
diff --git a/lib/idr.c b/lib/idr.c
index ed055b2..45c1f1f 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -694,7 +694,7 @@ void __init idr_init_cache(void)
  */
 void idr_init(struct idr *idp)
 {
-	memset(idp, 0, sizeof(struct idr));
+	(void)memset(idp, 0, sizeof(struct idr));
 	spin_lock_init(&idp->lock);
 }
 EXPORT_SYMBOL(idr_init);
@@ -809,7 +809,7 @@ int ida_get_new_above(struct ida *ida, int starting_id, int *p_id)
 		if (!bitmap)
 			return -EAGAIN;
 
-		memset(bitmap, 0, sizeof(struct ida_bitmap));
+		(void)memset(bitmap, 0, sizeof(struct ida_bitmap));
 		rcu_assign_pointer(pa[0]->ary[idr_id & IDR_MASK],
 				(void *)bitmap);
 		pa[0]->count++;
@@ -1004,7 +1004,7 @@ EXPORT_SYMBOL(ida_simple_remove);
  */
 void ida_init(struct ida *ida)
 {
-	memset(ida, 0, sizeof(struct ida));
+	(void)memset(ida, 0, sizeof(struct ida));
 	idr_init(&ida->idr);
 
 }
diff --git a/lib/klist.c b/lib/klist.c
index 573d606..811d8e9 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -60,13 +60,13 @@ static void knode_set_klist(struct klist_node *knode, struct klist *klist)
 {
 	knode->n_klist = klist;
 	/* no knode deserves to start its life dead */
-	WARN_ON(knode_dead(knode));
+	(void)WARN_ON(knode_dead(knode));
 }
 
 static void knode_kill(struct klist_node *knode)
 {
 	/* and no knode should die twice ever either, see we're very humane */
-	WARN_ON(knode_dead(knode));
+	(void)WARN_ON(knode_dead(knode));
 	*(unsigned long *)&knode->n_klist |= KNODE_DEAD;
 }
 
@@ -186,7 +186,7 @@ static void klist_release(struct kref *kref)
 	struct klist_waiter *waiter, *tmp;
 	struct klist_node *n = container_of(kref, struct klist_node, n_ref);
 
-	WARN_ON(!knode_dead(n));
+	(void)WARN_ON(!knode_dead(n));
 	list_del(&n->n_node);
 	spin_lock(&klist_remove_lock);
 	list_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {
diff --git a/lib/kobject.c b/lib/kobject.c
index c33d7a1..26c910a 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -164,7 +164,7 @@ static int kobject_add_internal(struct kobject *kobj)
 		return -ENOENT;
 
 	if (!kobj->name || !kobj->name[0]) {
-		WARN(1, "kobject: (%p): attempted to be registered with empty "
+		(void)WARN(1, "kobject: (%p): attempted to be registered with empty "
 			 "name!\n", kobj);
 		return -EINVAL;
 	}
@@ -590,7 +590,7 @@ void kobject_put(struct kobject *kobj)
 {
 	if (kobj) {
 		if (!kobj->state_initialized)
-			WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
+			(void)WARN(1, KERN_WARNING "kobject: '%s' (%p): is not "
 			       "initialized, yet kobject_put() is being "
 			       "called.\n", kobject_name(kobj), kobj);
 		kref_put(&kobj->kref, kobject_release);
diff --git a/lib/list_sort.c b/lib/list_sort.c
index d7325c6..283b83d 100644
--- a/lib/list_sort.c
+++ b/lib/list_sort.c
@@ -107,7 +107,7 @@ void list_sort(void *priv, struct list_head *head,
 	if (list_empty(head))
 		return;
 
-	memset(part, 0, sizeof(part));
+	(void)memset(part, 0, sizeof(part));
 
 	head->prev->next = NULL;
 	list = head->next;
diff --git a/lib/nlattr.c b/lib/nlattr.c
index a8408b6..70940e5 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -180,7 +180,7 @@ int nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,
 	const struct nlattr *nla;
 	int rem, err;
 
-	memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));
+	(void)memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));
 
 	nla_for_each_attr(nla, head, len, rem) {
 		u16 type = nla_type(nla);
@@ -248,7 +248,7 @@ size_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize)
 	if (dstsize > 0) {
 		size_t len = (srclen >= dstsize) ? dstsize - 1 : srclen;
 
-		memset(dst, 0, dstsize);
+		(void)memset(dst, 0, dstsize);
 		memcpy(dst, src, len);
 	}
 
@@ -329,7 +329,7 @@ struct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 	nla->nla_type = attrtype;
 	nla->nla_len = nla_attr_size(attrlen);
 
-	memset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));
+	(void)memset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));
 
 	return nla;
 }
@@ -350,7 +350,7 @@ void *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)
 	void *start;
 
 	start = skb_put(skb, NLA_ALIGN(attrlen));
-	memset(start, 0, NLA_ALIGN(attrlen));
+	(void)memset(start, 0, NLA_ALIGN(attrlen));
 
 	return start;
 }
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index dc63d08..f127026 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -1459,7 +1459,7 @@ EXPORT_SYMBOL(radix_tree_tagged);
 static void
 radix_tree_node_ctor(void *node)
 {
-	memset(node, 0, sizeof(struct radix_tree_node));
+	(void)memset(node, 0, sizeof(struct radix_tree_node));
 }
 
 static __init unsigned long __maxindex(unsigned int height)
diff --git a/lib/reciprocal_div.c b/lib/reciprocal_div.c
index 75510e9..fdaf046 100644
--- a/lib/reciprocal_div.c
+++ b/lib/reciprocal_div.c
@@ -5,7 +5,7 @@
 u32 reciprocal_value(u32 k)
 {
 	u64 val = (1LL << 32) + (k - 1);
-	do_div(val, k);
+	(void)do_div(val, k);
 	return (u32)val;
 }
 EXPORT_SYMBOL(reciprocal_value);
diff --git a/lib/string_helpers.c b/lib/string_helpers.c
index ab431d4..472c8db 100644
--- a/lib/string_helpers.c
+++ b/lib/string_helpers.c
@@ -53,7 +53,7 @@ int string_get_size(u64 size, const enum string_size_units units,
 
 		if (j) {
 			remainder *= 1000;
-			do_div(remainder, divisor[units]);
+			(void)do_div(remainder, divisor[units]);
 			snprintf(tmp, sizeof(tmp), ".%03lld",
 				 (unsigned long long)remainder);
 			tmp[j+1] = '\0';
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 8e75003..ef01271 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -623,7 +623,7 @@ char *ip6_compressed_string(char *p, const char *addr)
 
 	useIPv4 = ipv6_addr_v4mapped(&in6) || ipv6_addr_is_isatap(&in6);
 
-	memset(zerolength, 0, sizeof(zerolength));
+	(void)memset(zerolength, 0, sizeof(zerolength));
 
 	if (useIPv4)
 		range = 6;
diff --git a/lib/xz/xz_dec_lzma2.c b/lib/xz/xz_dec_lzma2.c
index a6cdc96..afabda4 100644
--- a/lib/xz/xz_dec_lzma2.c
+++ b/lib/xz/xz_dec_lzma2.c
@@ -859,7 +859,7 @@ static bool lzma2_lzma(struct xz_dec_lzma2 *s, struct xz_buf *b)
 		memcpy(s->temp.buf + s->temp.size, b->in + b->in_pos, tmp);
 
 		if (s->temp.size + tmp == s->lzma2.compressed) {
-			memzero(s->temp.buf + s->temp.size + tmp,
+			(void)memzero(s->temp.buf + s->temp.size + tmp,
 					sizeof(s->temp.buf)
 						- s->temp.size - tmp);
 			s->rc.in_limit = s->temp.size + tmp;
diff --git a/lib/xz/xz_dec_stream.c b/lib/xz/xz_dec_stream.c
index ac809b1..65319ee 100644
--- a/lib/xz/xz_dec_stream.c
+++ b/lib/xz/xz_dec_stream.c
@@ -803,8 +803,8 @@ XZ_EXTERN void xz_dec_reset(struct xz_dec *s)
 	s->allow_buf_error = false;
 	s->pos = 0;
 	s->crc32 = 0;
-	memzero(&s->block, sizeof(s->block));
-	memzero(&s->index, sizeof(s->index));
+	(void)memzero(&s->block, sizeof(s->block));
+	(void)memzero(&s->index, sizeof(s->index));
 	s->temp.pos = 0;
 	s->temp.size = STREAM_HEADER_SIZE;
 }
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 7ba8fea..2367f0c 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -418,7 +418,7 @@ static int bdi_forker_thread(void *ptr)
 			     bdi_cap_flush_forker(bdi))
 				continue;
 
-			WARN(!test_bit(BDI_registered, &bdi->state),
+			(void)WARN(!test_bit(BDI_registered, &bdi->state),
 			     "bdi %p/%s is not registered!\n", bdi, bdi->name);
 
 			have_dirty_io = !list_empty(&bdi->work_list) ||
@@ -640,7 +640,7 @@ EXPORT_SYMBOL(bdi_unregister);
 
 static void bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)
 {
-	memset(wb, 0, sizeof(*wb));
+	(void)memset(wb, 0, sizeof(*wb));
 
 	wb->bdi = bdi;
 	wb->last_old_flush = jiffies;
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 668e94d..419e346 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -108,7 +108,7 @@ static unsigned long __init init_bootmem_core(bootmem_data_t *bdata,
 	 * register free RAM areas explicitly.
 	 */
 	mapsize = bootmap_bytes(end - start);
-	memset(bdata->node_bootmem_map, 0xff, mapsize);
+	(void)memset(bdata->node_bootmem_map, 0xff, mapsize);
 
 	bdebug("nid=%td start=%lx map=%lx end=%lx mapsize=%lx\n",
 		bdata - bootmem_node_data, start, mapstart, end, mapsize);
@@ -556,7 +556,7 @@ find_block:
 
 		region = phys_to_virt(PFN_PHYS(bdata->node_min_pfn) +
 				start_off);
-		memset(region, 0, size);
+		(void)memset(region, 0, size);
 		/*
 		 * The min_count is set to 0 so that bootmem allocated blocks
 		 * are never reported as leaks.
diff --git a/mm/memory.c b/mm/memory.c
index fa2f04e..46950a7 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -572,7 +572,7 @@ void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,
 		unlink_file_vma(vma);
 
 		if (is_vm_hugetlb_page(vma)) {
-			hugetlb_free_pgd_range(tlb, addr, vma->vm_end,
+			(void)hugetlb_free_pgd_range(tlb, addr, vma->vm_end,
 				floor, next? next->vm_start: ceiling);
 		} else {
 			/*
@@ -653,7 +653,7 @@ int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)
 
 static inline void init_rss_vec(int *rss)
 {
-	memset(rss, 0, sizeof(int) * NR_MM_COUNTERS);
+	(void)memset(rss, 0, sizeof(int) * NR_MM_COUNTERS);
 }
 
 static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)
@@ -2457,7 +2457,7 @@ static inline void cow_user_page(struct page *dst, struct page *src, unsigned lo
 		 * zeroes.
 		 */
 		if (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))
-			clear_page(kaddr);
+			(void)clear_page(kaddr);
 		kunmap_atomic(kaddr, KM_USER0);
 		flush_dcache_page(dst);
 	} else
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 363ba70..8acc410 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -526,7 +526,7 @@ unsigned long bdi_dirty_limit(struct backing_dev_info *bdi, unsigned long dirty)
 
 	bdi_dirty = (dirty * (100 - bdi_min_ratio)) / 100;
 	bdi_dirty *= numerator;
-	do_div(bdi_dirty, denominator);
+	(void)do_div(bdi_dirty, denominator);
 
 	bdi_dirty += (dirty * bdi->min_ratio) / 100;
 	if (bdi_dirty > (dirty * bdi->max_ratio) / 100)
@@ -1640,7 +1640,7 @@ void tag_pages_for_writeback(struct address_space *mapping,
 				&start, end, WRITEBACK_TAG_BATCH,
 				PAGECACHE_TAG_DIRTY, PAGECACHE_TAG_TOWRITE);
 		spin_unlock_irq(&mapping->tree_lock);
-		WARN_ON_ONCE(tagged > WRITEBACK_TAG_BATCH);
+		(void)WARN_ON_ONCE(tagged > WRITEBACK_TAG_BATCH);
 		cond_resched();
 		/* We check 'start' to handle wrapping when end == ~0UL */
 	} while (tagged >= WRITEBACK_TAG_BATCH && start);
@@ -1983,7 +1983,7 @@ int __set_page_dirty_nobuffers(struct page *page)
 		mapping2 = page_mapping(page);
 		if (mapping2) { /* Race with truncate? */
 			BUG_ON(mapping2 != mapping);
-			WARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));
+			(void)WARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));
 			account_page_dirtied(page, mapping);
 			radix_tree_tag_set(&mapping->page_tree,
 				page_index(page), PAGECACHE_TAG_DIRTY);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index d2186ec..0e1f655 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -122,7 +122,7 @@ static gfp_t saved_gfp_mask;
 
 void pm_restore_gfp_mask(void)
 {
-	WARN_ON(!mutex_is_locked(&pm_mutex));
+	(void)WARN_ON(!mutex_is_locked(&pm_mutex));
 	if (saved_gfp_mask) {
 		gfp_allowed_mask = saved_gfp_mask;
 		saved_gfp_mask = 0;
@@ -131,8 +131,8 @@ void pm_restore_gfp_mask(void)
 
 void pm_restrict_gfp_mask(void)
 {
-	WARN_ON(!mutex_is_locked(&pm_mutex));
-	WARN_ON(saved_gfp_mask);
+	(void)WARN_ON(!mutex_is_locked(&pm_mutex));
+	(void)WARN_ON(saved_gfp_mask);
 	saved_gfp_mask = gfp_allowed_mask;
 	gfp_allowed_mask &= ~GFP_IOFS;
 }
@@ -1165,7 +1165,7 @@ void drain_local_pages(void *arg)
  */
 void drain_all_pages(void)
 {
-	on_each_cpu(drain_local_pages, NULL, 1);
+	(void)on_each_cpu(drain_local_pages, NULL, 1);
 }
 
 #ifdef CONFIG_HIBERNATION
@@ -1391,7 +1391,7 @@ again:
 			 * allocate greater than order-1 page units with
 			 * __GFP_NOFAIL.
 			 */
-			WARN_ON_ONCE(order > 1);
+			(void)WARN_ON_ONCE(order > 1);
 		}
 		spin_lock_irqsave(&zone->lock, flags);
 		page = __rmqueue(zone, order, migratetype);
@@ -2201,7 +2201,7 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
 	 * too large.
 	 */
 	if (order >= MAX_ORDER) {
-		WARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));
+		(void)WARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));
 		return NULL;
 	}
 
@@ -3690,7 +3690,7 @@ static void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)
 	struct per_cpu_pages *pcp;
 	int migratetype;
 
-	memset(p, 0, sizeof(*p));
+	(void)memset(p, 0, sizeof(*p));
 
 	pcp = &p->pcp;
 	pcp->count = 0;
@@ -4957,7 +4957,7 @@ void setup_per_zone_wmarks(void)
 
 		spin_lock_irqsave(&zone->lock, flags);
 		tmp = (u64)pages_min * zone->present_pages;
-		do_div(tmp, lowmem_pages);
+		(void)do_div(tmp, lowmem_pages);
 		if (is_highmem(zone)) {
 			/*
 			 * __GFP_HIGH and PF_MEMALLOC allocations usually don't
@@ -5221,7 +5221,7 @@ void *__init alloc_large_system_hash(const char *tablename,
 		/* Make sure we've got at least a 0-order allocation.. */
 		if (unlikely(flags & HASH_SMALL)) {
 			/* Makes no sense without HASH_EARLY */
-			WARN_ON(!(flags & HASH_EARLY));
+			(void)WARN_ON(!(flags & HASH_EARLY));
 			if (!(numentries >> *_hash_shift)) {
 				numentries = 1UL << *_hash_shift;
 				BUG_ON(!numentries);
@@ -5234,7 +5234,7 @@ void *__init alloc_large_system_hash(const char *tablename,
 	/* limit allocation size to 1/16 total memory by default */
 	if (max == 0) {
 		max = ((unsigned long long)nr_all_pages << PAGE_SHIFT) >> 4;
-		do_div(max, bucketsize);
+		(void)do_div(max, bucketsize);
 	}
 
 	if (numentries > max)
diff --git a/mm/percpu-km.c b/mm/percpu-km.c
index 89633fe..7c20af3 100644
--- a/mm/percpu-km.c
+++ b/mm/percpu-km.c
@@ -38,7 +38,7 @@ static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)
 	unsigned int cpu;
 
 	for_each_possible_cpu(cpu)
-		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
+		(void)memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 
 	return 0;
 }
diff --git a/mm/percpu.c b/mm/percpu.c
index f47af91..02837bb 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -714,7 +714,7 @@ static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved)
 	void __percpu *ptr;
 
 	if (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE)) {
-		WARN(true, "illegal size (%zu) or align (%zu) for "
+		(void)WARN(true, "illegal size (%zu) or align (%zu) for "
 		     "percpu allocation\n", size, align);
 		return NULL;
 	}
@@ -882,7 +882,7 @@ static void pcpu_reclaim(struct work_struct *work)
 	spin_lock_irq(&pcpu_lock);
 
 	list_for_each_entry_safe(chunk, next, head, list) {
-		WARN_ON(chunk->immutable);
+		(void)WARN_ON(chunk->immutable);
 
 		/* spare the first one */
 		if (chunk == list_first_entry(head, struct pcpu_chunk, list))
diff --git a/mm/shmem.c b/mm/shmem.c
index 269d049..e33796c 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -1135,7 +1135,7 @@ static struct inode *shmem_get_inode(struct super_block *sb, const struct inode
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 		inode->i_generation = get_seconds();
 		info = SHMEM_I(inode);
-		memset(info, 0, (char *)inode - (char *)info);
+		(void)memset(info, 0, (char *)inode - (char *)info);
 		spin_lock_init(&info->lock);
 		info->flags = flags & VM_NORESERVE;
 		INIT_LIST_HEAD(&info->swaplist);
diff --git a/mm/util.c b/mm/util.c
index 136ac4f..0ddf823 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -183,7 +183,7 @@ void kzfree(const void *p)
 	if (unlikely(ZERO_OR_NULL_PTR(mem)))
 		return;
 	ks = ksize(mem);
-	memset(mem, 0, ks);
+	(void)memset(mem, 0, ks);
 	kfree(mem);
 }
 EXPORT_SYMBOL(kzfree);
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 86ce9a5..cbdf337 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -40,7 +40,7 @@ static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)
 	pte = pte_offset_kernel(pmd, addr);
 	do {
 		pte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);
-		WARN_ON(!pte_none(ptent) && !pte_present(ptent));
+		(void)WARN_ON(!pte_none(ptent) && !pte_present(ptent));
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
 
@@ -1460,13 +1460,13 @@ static void __vunmap(const void *addr, int deallocate_pages)
 		return;
 
 	if ((PAGE_SIZE-1) & (unsigned long)addr) {
-		WARN(1, KERN_ERR "Trying to vfree() bad address (%p)\n", addr);
+		(void)WARN(1, KERN_ERR "Trying to vfree() bad address (%p)\n", addr);
 		return;
 	}
 
 	area = remove_vm_area(addr);
 	if (unlikely(!area)) {
-		WARN(1, KERN_ERR "Trying to vfree() nonexistent vm area (%p)\n",
+		(void)WARN(1, KERN_ERR "Trying to vfree() nonexistent vm area (%p)\n",
 				addr);
 		return;
 	}
@@ -1910,7 +1910,7 @@ static int aligned_vread(char *buf, char *addr, unsigned long count)
 			memcpy(buf, map + offset, length);
 			kunmap_atomic(map, KM_USER0);
 		} else
-			memset(buf, 0, length);
+			(void)memset(buf, 0, length);
 
 		addr += length;
 		buf += length;
@@ -2015,7 +2015,7 @@ long vread(char *buf, char *addr, unsigned long count)
 		if (!(tmp->flags & VM_IOREMAP))
 			aligned_vread(buf, addr, n);
 		else /* IOREMAP area is treated as memory hole */
-			memset(buf, 0, n);
+			(void)memset(buf, 0, n);
 		buf += n;
 		addr += n;
 		count -= n;
@@ -2027,7 +2027,7 @@ finished:
 		return 0;
 	/* zero-fill memory holes */
 	if (buf != buf_start + buflen)
-		memset(buf, 0, buflen - (buf - buf_start));
+		(void)memset(buf, 0, buflen - (buf - buf_start));
 
 	return buflen;
 }
@@ -2544,7 +2544,7 @@ static void show_numa_info(struct seq_file *m, struct vm_struct *v)
 		if (!counters)
 			return;
 
-		memset(counters, 0, nr_node_ids * sizeof(unsigned int));
+		(void)memset(counters, 0, nr_node_ids * sizeof(unsigned int));
 
 		for (nr = 0; nr < v->nr_pages; nr++)
 			counters[page_to_nid(v->pages[nr])]++;
diff --git a/mm/vmstat.c b/mm/vmstat.c
index f600557..0634033 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -29,7 +29,7 @@ static void sum_vm_events(unsigned long *ret)
 	int cpu;
 	int i;
 
-	memset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));
+	(void)memset(ret, 0, NR_VM_EVENT_ITEMS * sizeof(unsigned long));
 
 	for_each_online_cpu(cpu) {
 		struct vm_event_state *this = &per_cpu(vm_event_states, cpu);
diff --git a/net/core/datagram.c b/net/core/datagram.c
index 68bbf9f..a94eac3 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -326,7 +326,7 @@ int skb_copy_datagram_iovec(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -352,7 +352,7 @@ int skb_copy_datagram_iovec(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -412,7 +412,7 @@ int skb_copy_datagram_const_iovec(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -439,7 +439,7 @@ int skb_copy_datagram_const_iovec(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -502,7 +502,7 @@ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -531,7 +531,7 @@ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -587,7 +587,7 @@ static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,
 		int end;
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -619,7 +619,7 @@ static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index 29c07fe..d19c7a5 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -242,7 +242,7 @@ int dev_addr_init(struct net_device *dev)
 	/* rtnl_mutex must be held here */
 
 	__hw_addr_init(&dev->dev_addrs);
-	memset(addr, 0, sizeof(addr));
+	(void)memset(addr, 0, sizeof(addr));
 	err = __hw_addr_add(&dev->dev_addrs, addr, sizeof(addr),
 			    NETDEV_HW_ADDR_T_LAN);
 	if (!err) {
diff --git a/net/core/dst.c b/net/core/dst.c
index 43d94ce..0369479 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -271,7 +271,7 @@ void dst_release(struct dst_entry *dst)
 		int newrefcnt;
 
 		newrefcnt = atomic_dec_return(&dst->__refcnt);
-		WARN_ON(newrefcnt < 0);
+		(void)WARN_ON(newrefcnt < 0);
 		if (unlikely(dst->flags & DST_NOCACHE) && !newrefcnt) {
 			dst = dst_destroy(dst);
 			if (dst)
@@ -327,7 +327,7 @@ EXPORT_SYMBOL(__dst_destroy_metrics_generic);
  */
 void skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst)
 {
-	WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
+	(void)WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
 	/* If dst not in cache, we must take a reference, because
 	 * dst_release() will destroy dst as soon as its refcount becomes zero
 	 */
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 921aa2b..6e3c125 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -338,7 +338,7 @@ static noinline_for_stack int ethtool_get_drvinfo(struct net_device *dev,
 	struct ethtool_drvinfo info;
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GDRVINFO;
 	if (ops && ops->get_drvinfo) {
 		ops->get_drvinfo(dev, &info);
@@ -397,7 +397,7 @@ static noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,
 	/* calculate size of return buffer */
 	n_bits = hweight64(sset_mask);
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GSSET_INFO;
 
 	info_buf = kzalloc(n_bits * sizeof(u32), GFP_USER);
@@ -960,7 +960,7 @@ static int ethtool_self_test(struct net_device *dev, char __user *useraddr)
 	test_len = ops->get_sset_count(dev, ETH_SS_TEST);
 	if (test_len < 0)
 		return test_len;
-	WARN_ON(test_len == 0);
+	(void)WARN_ON(test_len == 0);
 
 	if (copy_from_user(&test, useraddr, sizeof(test)))
 		return -EFAULT;
@@ -1091,7 +1091,7 @@ static int ethtool_get_stats(struct net_device *dev, void __user *useraddr)
 	n_stats = ops->get_sset_count(dev, ETH_SS_STATS);
 	if (n_stats < 0)
 		return n_stats;
-	WARN_ON(n_stats == 0);
+	(void)WARN_ON(n_stats == 0);
 
 	if (copy_from_user(&stats, useraddr, sizeof(stats)))
 		return -EFAULT;
@@ -1245,7 +1245,7 @@ static int ethtool_get_dump_data(struct net_device *dev,
 	if (copy_from_user(&dump, useraddr, sizeof(dump)))
 		return -EFAULT;
 
-	memset(&tmp, 0, sizeof(tmp));
+	(void)memset(&tmp, 0, sizeof(tmp));
 	tmp.cmd = ETHTOOL_GET_DUMP_FLAG;
 	ret = ops->get_dump_flag(dev, &tmp);
 	if (ret)
diff --git a/net/core/gen_stats.c b/net/core/gen_stats.c
index 0452eb2..876abf8 100644
--- a/net/core/gen_stats.c
+++ b/net/core/gen_stats.c
@@ -58,7 +58,7 @@ gnet_stats_start_copy_compat(struct sk_buff *skb, int type, int tc_stats_type,
 	int xstats_type, spinlock_t *lock, struct gnet_dump *d)
 	__acquires(lock)
 {
-	memset(d, 0, sizeof(*d));
+	(void)memset(d, 0, sizeof(*d));
 
 	spin_lock_bh(lock);
 	d->lock = lock;
@@ -118,7 +118,7 @@ gnet_stats_copy_basic(struct gnet_dump *d, struct gnet_stats_basic_packed *b)
 	if (d->tail) {
 		struct gnet_stats_basic sb;
 
-		memset(&sb, 0, sizeof(sb));
+		(void)memset(&sb, 0, sizeof(sb));
 		sb.bytes = b->bytes;
 		sb.packets = b->packets;
 		return gnet_stats_copy(d, TCA_STATS_BASIC, &sb, sizeof(sb));
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index e287346..9680099 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -1846,7 +1846,7 @@ static int neightbl_fill_info(struct sk_buff *skb, struct neigh_table *tbl,
 		int cpu;
 		struct ndt_stats ndst;
 
-		memset(&ndst, 0, sizeof(ndst));
+		(void)memset(&ndst, 0, sizeof(ndst));
 
 		for_each_possible_cpu(cpu) {
 			struct neigh_statistics	*st;
@@ -2227,7 +2227,7 @@ static int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
 		if (t < s_t || (family && tbl->family != family))
 			continue;
 		if (t > s_t)
-			memset(&cb->args[1], 0, sizeof(cb->args) -
+			(void)memset(&cb->args[1], 0, sizeof(cb->args) -
 						sizeof(cb->args[0]));
 		if (neigh_dump_table(tbl, skb, cb) < 0)
 			break;
@@ -2648,7 +2648,7 @@ static void __neigh_notify(struct neighbour *n, int type, int flags)
 	err = neigh_fill_info(skb, n, 0, 0, type, flags);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in neigh_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index a1727cd..4119f6c 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -1228,7 +1228,7 @@ static void netdev_queue_release(struct kobject *kobj)
 	xps_queue_release(queue);
 #endif
 
-	memset(kobj, 0, sizeof(*kobj));
+	(void)memset(kobj, 0, sizeof(*kobj));
 	dev_put(queue->dev);
 }
 
diff --git a/net/core/request_sock.c b/net/core/request_sock.c
index 9b570a6..d1fe37f 100644
--- a/net/core/request_sock.c
+++ b/net/core/request_sock.c
@@ -123,7 +123,7 @@ void reqsk_queue_destroy(struct request_sock_queue *queue)
 		}
 	}
 
-	WARN_ON(lopt->qlen != 0);
+	(void)WARN_ON(lopt->qlen != 0);
 	if (lopt_size > PAGE_SIZE)
 		vfree(lopt);
 	else
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index f16444b..3df0b34 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -550,7 +550,7 @@ void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
 	memcpy(RTA_DATA(rta), data, attrlen);
-	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	(void)memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 }
 EXPORT_SYMBOL(__rta_fill);
 
@@ -1721,7 +1721,7 @@ replay:
 		if (err < 0)
 			return err;
 	} else
-		memset(linkinfo, 0, sizeof(linkinfo));
+		(void)memset(linkinfo, 0, sizeof(linkinfo));
 
 	if (linkinfo[IFLA_INFO_KIND]) {
 		nla_strlcpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));
@@ -1866,7 +1866,7 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 			       nlh->nlmsg_seq, 0, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(nskb);
 	} else
 		err = rtnl_unicast(nskb, net, NETLINK_CB(skb).pid);
@@ -1894,7 +1894,7 @@ static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)
 		    rtnl_msg_handlers[idx][type].dumpit == NULL)
 			continue;
 		if (idx > s_idx)
-			memset(&cb->args[0], 0, sizeof(cb->args));
+			(void)memset(&cb->args[0], 0, sizeof(cb->args));
 		if (rtnl_msg_handlers[idx][type].dumpit(skb, cb))
 			break;
 	}
@@ -1919,7 +1919,7 @@ void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
@@ -1984,7 +1984,7 @@ static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		return err;
 	}
 
-	memset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));
+	(void)memset(rta_buf, 0, (rtattr_max * sizeof(struct rtattr *)));
 
 	min_len = rtm_min[sz_idx];
 	if (nlh->nlmsg_len < min_len)
diff --git a/net/core/sock.c b/net/core/sock.c
index 5c5af998..10d68c6 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -482,7 +482,7 @@ static int sock_bindtodevice(struct sock *sk, char __user *optval, int optlen)
 	 */
 	if (optlen > IFNAMSIZ - 1)
 		optlen = IFNAMSIZ - 1;
-	memset(devname, 0, sizeof(devname));
+	(void)memset(devname, 0, sizeof(devname));
 
 	ret = -EFAULT;
 	if (copy_from_user(devname, optval, optlen))
@@ -836,7 +836,7 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 	if (len < 0)
 		return -EINVAL;
 
-	memset(&v, 0, sizeof(v));
+	(void)memset(&v, 0, sizeof(v));
 
 	switch (optname) {
 	case SO_DEBUG:
@@ -1074,8 +1074,8 @@ static void sock_copy(struct sock *nsk, const struct sock *osk)
 static inline void sk_prot_clear_nulls(struct sock *sk, int size)
 {
 	if (offsetof(struct sock, sk_node.next) != 0)
-		memset(sk, 0, offsetof(struct sock, sk_node.next));
-	memset(&sk->sk_node.pprev, 0,
+		(void)memset(sk, 0, offsetof(struct sock, sk_node.next));
+	(void)memset(&sk->sk_node.pprev, 0,
 	       size - offsetof(struct sock, sk_node.pprev));
 }
 
@@ -1089,10 +1089,10 @@ void sk_prot_clear_portaddr_nulls(struct sock *sk, int size)
 		swap(nulls1, nulls2);
 
 	if (nulls1 != 0)
-		memset((char *)sk, 0, nulls1);
-	memset((char *)sk + nulls1 + sizeof(void *), 0,
+		(void)memset((char *)sk, 0, nulls1);
+	(void)memset((char *)sk + nulls1 + sizeof(void *), 0,
 	       nulls2 - nulls1 - sizeof(void *));
-	memset((char *)sk + nulls2 + sizeof(void *), 0,
+	(void)memset((char *)sk + nulls2 + sizeof(void *), 0,
 	       size - nulls2 - sizeof(void *));
 }
 EXPORT_SYMBOL(sk_prot_clear_portaddr_nulls);
@@ -1696,7 +1696,7 @@ static void __release_sock(struct sock *sk)
 		do {
 			struct sk_buff *next = skb->next;
 
-			WARN_ON_ONCE(skb_dst_is_noref(skb));
+			(void)WARN_ON_ONCE(skb_dst_is_noref(skb));
 			skb->next = NULL;
 			sk_backlog_rcv(sk, skb);
 
diff --git a/net/core/stream.c b/net/core/stream.c
index f5df85d..5f334aa 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -141,7 +141,7 @@ int sk_stream_wait_memory(struct sock *sk, long *timeo_p)
 
 		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 		sk->sk_write_pending++;
-		sk_wait_event(sk, &current_timeo, sk->sk_err ||
+		(void)sk_wait_event(sk, &current_timeo, sk->sk_err ||
 						  (sk->sk_shutdown & SEND_SHUTDOWN) ||
 						  (sk_stream_memory_free(sk) &&
 						  !vm_wait));
@@ -192,13 +192,13 @@ void sk_stream_kill_queues(struct sock *sk)
 	__skb_queue_purge(&sk->sk_error_queue);
 
 	/* Next, the write queue. */
-	WARN_ON(!skb_queue_empty(&sk->sk_write_queue));
+	(void)WARN_ON(!skb_queue_empty(&sk->sk_write_queue));
 
 	/* Account for returned memory. */
 	sk_mem_reclaim(sk);
 
-	WARN_ON(sk->sk_wmem_queued);
-	WARN_ON(sk->sk_forward_alloc);
+	(void)WARN_ON(sk->sk_wmem_queued);
+	(void)WARN_ON(sk->sk_forward_alloc);
 
 	/* It is _impossible_ for the backlog to contain anything
 	 * when we get here.  All user references to this socket
diff --git a/net/core/utils.c b/net/core/utils.c
index 386e263f..679d581 100644
--- a/net/core/utils.c
+++ b/net/core/utils.c
@@ -177,7 +177,7 @@ int in6_pton(const char *src, int srclen,
 	int state = IN6PTON_COLON_1_2 | IN6PTON_XDIGIT | IN6PTON_NULL;
 	int w = 0;
 
-	memset(dbuf, 0, sizeof(dbuf));
+	(void)memset(dbuf, 0, sizeof(dbuf));
 
 	s = src;
 	d = dbuf;
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index f7b5670..d548fff 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -149,10 +149,10 @@ void inet_sock_destruct(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(sk->sk_wmem_queued);
-	WARN_ON(sk->sk_forward_alloc);
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(sk->sk_wmem_queued);
+	(void)WARN_ON(sk->sk_forward_alloc);
 
 	kfree(rcu_dereference_protected(inet->inet_opt, 1));
 	dst_release(rcu_dereference_check(sk->sk_dst_cache, 1));
@@ -237,7 +237,7 @@ void build_ehash_secret(void)
 		get_random_bytes(&rnd, sizeof(rnd));
 	} while (rnd == 0);
 
-	cmpxchg(&inet_ehash_secret, 0, rnd);
+	(void)cmpxchg(&inet_ehash_secret, 0, rnd);
 }
 EXPORT_SYMBOL(build_ehash_secret);
 
@@ -339,7 +339,7 @@ lookup_protocol:
 	answer_flags = answer->flags;
 	rcu_read_unlock();
 
-	WARN_ON(answer_prot->slab == NULL);
+	(void)WARN_ON(answer_prot->slab == NULL);
 
 	err = -ENOBUFS;
 	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);
@@ -684,7 +684,7 @@ int inet_accept(struct socket *sock, struct socket *newsock, int flags)
 	lock_sock(sk2);
 
 	sock_rps_record_flow(sk2);
-	WARN_ON(!((1 << sk2->sk_state) &
+	(void)WARN_ON(!((1 << sk2->sk_state) &
 		  (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE)));
 
 	sock_graft(sk2, newsock);
@@ -723,7 +723,7 @@ int inet_getname(struct socket *sock, struct sockaddr *uaddr,
 		sin->sin_port = inet->inet_sport;
 		sin->sin_addr.s_addr = addr;
 	}
-	memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	*uaddr_len = sizeof(*sin);
 	return 0;
 }
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index e41c40f..e41c699 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -215,8 +215,8 @@ void in_dev_finish_destroy(struct in_device *idev)
 {
 	struct net_device *dev = idev->dev;
 
-	WARN_ON(idev->ifa_list);
-	WARN_ON(idev->mc_list);
+	(void)WARN_ON(idev->ifa_list);
+	(void)WARN_ON(idev->mc_list);
 #ifdef NET_REFCNT_DEBUG
 	printk(KERN_DEBUG "in_dev_finish_destroy: %p=%s\n",
 	       idev, dev ? dev->name : "NIL");
@@ -492,7 +492,7 @@ static int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)
 	}
 	ipv4_devconf_setall(in_dev);
 	if (ifa->ifa_dev != in_dev) {
-		WARN_ON(ifa->ifa_dev);
+		(void)WARN_ON(ifa->ifa_dev);
 		in_dev_hold(in_dev);
 		ifa->ifa_dev = in_dev;
 	}
@@ -722,7 +722,7 @@ int devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 		   One day we will be forced to put shlock here (I mean SMP)
 		 */
 		tryaddrmatch = (sin_orig.sin_family == AF_INET);
-		memset(sin, 0, sizeof(*sin));
+		(void)memset(sin, 0, sizeof(*sin));
 		sin->sin_family = AF_INET;
 		break;
 
@@ -940,7 +940,7 @@ static int inet_gifconf(struct net_device *dev, char __user *buf, int len)
 		}
 		if (len < (int) sizeof(ifr))
 			break;
-		memset(&ifr, 0, sizeof(struct ifreq));
+		(void)memset(&ifr, 0, sizeof(struct ifreq));
 		if (ifa->ifa_label)
 			strcpy(ifr.ifr_name, ifa->ifa_label);
 		else
@@ -1356,7 +1356,7 @@ static void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,
 	err = inet_fill_ifaddr(skb, ifa, pid, seq, event, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in inet_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 92fc5f6..32a5c27 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -302,7 +302,7 @@ static int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,
 	__be32 addr;
 	int plen;
 
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 	cfg->fc_nlinfo.nl_net = net;
 
 	if (rt->rt_dst.sa_family != AF_INET)
@@ -495,7 +495,7 @@ static int rtm_to_fib_config(struct net *net, struct sk_buff *skb,
 	if (err < 0)
 		goto errout;
 
-	memset(cfg, 0, sizeof(*cfg));
+	(void)memset(cfg, 0, sizeof(*cfg));
 
 	rtm = nlmsg_data(nlh);
 	cfg->fc_dst_len = rtm->rtm_dst_len;
@@ -623,7 +623,7 @@ static int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 			if (e < s_e)
 				goto next;
 			if (dumped)
-				memset(&cb->args[2], 0, sizeof(cb->args) -
+				(void)memset(&cb->args[2], 0, sizeof(cb->args) -
 						 2 * sizeof(cb->args[0]));
 			if (fib_table_dump(tb, skb, cb) < 0)
 				goto out;
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index 80106d8..a9ce800 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -331,7 +331,7 @@ void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
 			    fa->fa_tos, fa->fa_info, nlm_flags);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in fib_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
+		(void)WARN_ON(err == -EMSGSIZE);
 		kfree_skb(skb);
 		goto errout;
 	}
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 2b555a5..a8ef6ae 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -342,7 +342,7 @@ static inline int tkey_mismatch(t_key a, int offset, t_key b)
 
 static inline void check_tnode(const struct tnode *tn)
 {
-	WARN_ON(tn && tn->pos+tn->bits > 32);
+	(void)WARN_ON(tn && tn->pos+tn->bits > 32);
 }
 
 static const int halve_threshold = 25;
@@ -1957,7 +1957,7 @@ int fib_table_dump(struct fib_table *tb, struct sk_buff *skb,
 
 		++count;
 		l = trie_nextleaf(l);
-		memset(&cb->args[4], 0,
+		(void)memset(&cb->args[4], 0,
 		       sizeof(cb->args) - 4*sizeof(cb->args[0]));
 	}
 	cb->args[3] = count;
@@ -1994,7 +1994,7 @@ struct fib_table *fib_trie_table(u32 id)
 	tb->tb_num_default = 0;
 
 	t = (struct trie *) tb->tb_data;
-	memset(t, 0, sizeof(*t));
+	(void)memset(t, 0, sizeof(*t));
 
 	return tb;
 }
@@ -2084,7 +2084,7 @@ static void trie_collect_stats(struct trie *t, struct trie_stat *s)
 	struct rt_trie_node *n;
 	struct fib_trie_iter iter;
 
-	memset(s, 0, sizeof(*s));
+	(void)memset(s, 0, sizeof(*s));
 
 	rcu_read_lock();
 	for (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index ab188ae..69fa4c9 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -354,7 +354,7 @@ static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 		if (ipc.opt->opt.srr)
 			daddr = icmp_param->replyopts.opt.opt.faddr;
 	}
-	memset(&fl4, 0, sizeof(fl4));
+	(void)memset(&fl4, 0, sizeof(fl4));
 	fl4.daddr = daddr;
 	fl4.saddr = rt->rt_spec_dst;
 	fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);
@@ -383,7 +383,7 @@ static struct rtable *icmp_route_lookup(struct net *net,
 	struct flowi4 fl4_dec;
 	int err;
 
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->daddr = (param->replyopts.opt.opt.srr ?
 		      param->replyopts.opt.opt.faddr : iph->saddr);
 	fl4->saddr = saddr;
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index 450e5d2..ae4fcd1 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -2223,7 +2223,7 @@ int ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,
 		struct sockaddr_storage ss;
 
 		psin = (struct sockaddr_in *)&ss;
-		memset(&ss, 0, sizeof(ss));
+		(void)memset(&ss, 0, sizeof(ss));
 		psin->sin_family = AF_INET;
 		psin->sin_addr.s_addr = psl->sl_addr[i];
 		if (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))
diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c
index 5ff2a51..1fd0522 100644
--- a/net/ipv4/inet_fragment.c
+++ b/net/ipv4/inet_fragment.c
@@ -134,8 +134,8 @@ void inet_frag_destroy(struct inet_frag_queue *q, struct inet_frags *f,
 	struct sk_buff *fp;
 	struct netns_frags *nf;
 
-	WARN_ON(!(q->last_in & INET_FRAG_COMPLETE));
-	WARN_ON(del_timer(&q->timer) != 0);
+	(void)WARN_ON(!(q->last_in & INET_FRAG_COMPLETE));
+	(void)WARN_ON(del_timer(&q->timer) != 0);
 
 	/* Release all fragment data. */
 	fp = q->fragments;
diff --git a/net/ipv4/inet_lro.c b/net/ipv4/inet_lro.c
index cc280a3..ae1d813 100644
--- a/net/ipv4/inet_lro.c
+++ b/net/ipv4/inet_lro.c
@@ -180,7 +180,7 @@ static void lro_init_desc(struct net_lro_desc *lro_desc, struct sk_buff *skb,
 
 static inline void lro_clear_desc(struct net_lro_desc *lro_desc)
 {
-	memset(lro_desc, 0, sizeof(struct net_lro_desc));
+	(void)memset(lro_desc, 0, sizeof(struct net_lro_desc));
 }
 
 static void lro_add_common(struct net_lro_desc *lro_desc, struct iphdr *iph,
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index 6e412a6..c73e99a 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -355,7 +355,7 @@ static int __init ic_setup_if(void)
 	struct sockaddr_in *sin = (void *) &ir.ifr_ifru.ifru_addr;
 	int err;
 
-	memset(&ir, 0, sizeof(ir));
+	(void)memset(&ir, 0, sizeof(ir));
 	strcpy(ir.ifr_ifrn.ifrn_name, ic_dev->name);
 	set_sockaddr(sin, ic_myaddr, 0);
 	if ((err = ic_devinet_ioctl(SIOCSIFADDR, &ir)) < 0) {
@@ -394,7 +394,7 @@ static int __init ic_setup_routes(void)
 		struct rtentry rm;
 		int err;
 
-		memset(&rm, 0, sizeof(rm));
+		(void)memset(&rm, 0, sizeof(rm));
 		if ((ic_gateway ^ ic_myaddr) & ic_netmask) {
 			printk(KERN_ERR "IP-Config: Gateway not on directly connected network.\n");
 			return -1;
@@ -777,7 +777,7 @@ static void __init ic_bootp_send_if(struct ic_device *d, unsigned long jiffies_d
 		return;
 	skb_reserve(skb, hlen);
 	b = (struct bootp_pkt *) skb_put(skb, sizeof(struct bootp_pkt));
-	memset(b, 0, sizeof(struct bootp_pkt));
+	(void)memset(b, 0, sizeof(struct bootp_pkt));
 
 	/* Construct IP header */
 	skb_reset_network_header(skb);
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index aea5a19..3cac97d 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -661,7 +661,7 @@ static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_family = AF_INET;
 		sin->sin_port = 0 /* skb->h.uh->source */;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		(void)memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (isk->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bcacf54..140869b 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1873,7 +1873,7 @@ void ip_rt_get_source(u8 *addr, struct sk_buff *skb, struct rtable *rt)
 
 		iph = ip_hdr(skb);
 
-		memset(&fl4, 0, sizeof(fl4));
+		(void)memset(&fl4, 0, sizeof(fl4));
 		fl4.daddr = iph->daddr;
 		fl4.saddr = iph->saddr;
 		fl4.flowi4_tos = RT_TOS(iph->tos);
@@ -3476,7 +3476,7 @@ int __init ip_rt_init(void)
 					&rt_hash_log,
 					&rt_hash_mask,
 					rhash_entries ? 0 : 512 * 1024);
-	memset(rt_hash_table, 0, (rt_hash_mask + 1) * sizeof(struct rt_hash_bucket));
+	(void)memset(rt_hash_table, 0, (rt_hash_mask + 1) * sizeof(struct rt_hash_bucket));
 	rt_hash_lock_init();
 
 	ipv4_dst_ops.gc_thresh = (rt_hash_mask + 1);
diff --git a/net/ipv4/tcp_cubic.c b/net/ipv4/tcp_cubic.c
index f376b05..68cf6e4 100644
--- a/net/ipv4/tcp_cubic.c
+++ b/net/ipv4/tcp_cubic.c
@@ -469,7 +469,7 @@ static int __init cubictcp_register(void)
 	cube_factor = 1ull << (10+3*BICTCP_HZ); /* 2^40 */
 
 	/* divide by bic_scale and by constant Srtt (100ms) */
-	do_div(cube_factor, bic_scale * 10);
+	(void)do_div(cube_factor, bic_scale * 10);
 
 	/* hystart needs ms clock resolution */
 	if (hystart && HZ < 1000)
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 2877c3e..0fd2422 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1925,7 +1925,7 @@ advance_sp:
 
 	tcp_mark_lost_retrans(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	if ((state.reord < tp->fackets_out) &&
 	    ((icsk->icsk_ca_state != TCP_CA_Loss) || tp->undo_marker) &&
@@ -1978,7 +1978,7 @@ static void tcp_add_reno_sack(struct sock *sk)
 	struct tcp_sock *tp = tcp_sk(sk);
 	tp->sacked_out++;
 	tcp_check_reno_reordering(sk, 0);
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Account for ACK, ACKing some data in Reno Recovery phase. */
@@ -1995,7 +1995,7 @@ static void tcp_remove_reno_sacks(struct sock *sk, int acked)
 			tp->sacked_out -= acked - 1;
 	}
 	tcp_check_reno_reordering(sk, acked);
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 static inline void tcp_reset_reno_sack(struct tcp_sock *tp)
@@ -2108,7 +2108,7 @@ void tcp_enter_frto(struct sock *sk)
 		TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
 		tp->retrans_out -= tcp_skb_pcount(skb);
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Too bad if TCP was application limited */
 	tp->snd_cwnd = min(tp->snd_cwnd, tcp_packets_in_flight(tp) + 1);
@@ -2178,7 +2178,7 @@ static void tcp_enter_frto_loss(struct sock *sk, int allowed_segments, int flag)
 			tp->retransmit_high = TCP_SKB_CB(skb)->end_seq;
 		}
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	tp->snd_cwnd = tcp_packets_in_flight(tp) + allowed_segments;
 	tp->snd_cwnd_cnt = 0;
@@ -2263,7 +2263,7 @@ void tcp_enter_loss(struct sock *sk, int how)
 			tp->retransmit_high = TCP_SKB_CB(skb)->end_seq;
 		}
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	tp->reordering = min_t(unsigned int, tp->reordering,
 			       sysctl_tcp_reordering);
@@ -2512,7 +2512,7 @@ static void tcp_timeout_skbs(struct sock *sk)
 
 	tp->scoreboard_skb_hint = skb;
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Mark head of queue up as lost. With RFC3517 SACK, the packets is
@@ -2571,7 +2571,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)
 		if (mark_head)
 			break;
 	}
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Account newly detected lost packet(s) */
@@ -2871,7 +2871,7 @@ static void tcp_try_to_open(struct sock *sk, int flag)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	if (!tp->frto_counter && !tcp_any_retrans_done(sk))
 		tp->retrans_stamp = 0;
@@ -2948,7 +2948,7 @@ void tcp_simple_retransmit(struct sock *sk)
 	if (tcp_is_reno(tp))
 		tcp_limit_reno_sacked(tp);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Don't muck with the congestion window here.
 	 * Reason is that we do not increase amount of _data_
@@ -3043,7 +3043,7 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked,
 	}
 
 	/* D. Check consistency of the current state. */
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* E. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
@@ -3585,7 +3585,7 @@ static int tcp_process_frto(struct sock *sk, int flag)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 
 	/* Duplicate the behavior from Loss state (fastretrans_alert) */
 	if (flag & FLAG_DATA_ACKED)
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 8c8de27..b099c4a 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -988,7 +988,7 @@ static void tcp_adjust_pcount(struct sock *sk, const struct sk_buff *skb, int de
 	    (tcp_is_fack(tp) || (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)))
 		tp->lost_cnt_hint -= decr;
 
-	tcp_verify_left_out(tp);
+	(void)tcp_verify_left_out(tp);
 }
 
 /* Function to create two new TCP segments.  Shrinks the given segment
diff --git a/net/ipv4/xfrm4_mode_beet.c b/net/ipv4/xfrm4_mode_beet.c
index 6341818..8aa4207 100644
--- a/net/ipv4/xfrm4_mode_beet.c
+++ b/net/ipv4/xfrm4_mode_beet.c
@@ -69,7 +69,7 @@ static int xfrm4_beet_output(struct xfrm_state *x, struct sk_buff *skb)
 		ph->hdrlen = optlen / 8;
 		ph->nexthdr = top_iph->protocol;
 		if (ph->padlen)
-			memset(ph + 1, IPOPT_NOP, ph->padlen);
+			(void)memset(ph + 1, IPOPT_NOP, ph->padlen);
 
 		top_iph->protocol = IPPROTO_BEETPH;
 		top_iph->ihl = sizeof(struct iphdr) / 4;
diff --git a/net/ipv4/xfrm4_output.c b/net/ipv4/xfrm4_output.c
index 327a617..0aa2a46 100644
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@ -65,7 +65,7 @@ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err)
 		return err;
 
-	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
+	(void)memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 	IPCB(skb)->flags |= IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED;
 
 	skb->protocol = htons(ETH_P_IP);
diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index a0b4c5d..daeb189 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -25,7 +25,7 @@ static struct dst_entry *__xfrm4_dst_lookup(struct net *net, struct flowi4 *fl4,
 {
 	struct rtable *rt;
 
-	memset(fl4, 0, sizeof(*fl4));
+	(void)memset(fl4, 0, sizeof(*fl4));
 	fl4->daddr = daddr->a4;
 	fl4->flowi4_tos = tos;
 	if (saddr)
@@ -114,7 +114,7 @@ _decode_session4(struct sk_buff *skb, struct flowi *fl, int reverse)
 	u8 *xprth = skb_network_header(skb) + iph->ihl * 4;
 	struct flowi4 *fl4 = &fl->u.ip4;
 
-	memset(fl4, 0, sizeof(struct flowi4));
+	(void)memset(fl4, 0, sizeof(struct flowi4));
 	fl4->flowi4_mark = skb->mark;
 
 	if (!ip_is_fragment(iph)) {
diff --git a/net/ipv4/xfrm4_state.c b/net/ipv4/xfrm4_state.c
index 9258e75..f96bfed 100644
--- a/net/ipv4/xfrm4_state.c
+++ b/net/ipv4/xfrm4_state.c
@@ -64,7 +64,7 @@ int xfrm4_extract_header(struct sk_buff *skb)
 	XFRM_MODE_SKB_CB(skb)->tos = iph->tos;
 	XFRM_MODE_SKB_CB(skb)->ttl = iph->ttl;
 	XFRM_MODE_SKB_CB(skb)->optlen = iph->ihl * 4 - sizeof(*iph);
-	memset(XFRM_MODE_SKB_CB(skb)->flow_lbl, 0,
+	(void)memset(XFRM_MODE_SKB_CB(skb)->flow_lbl, 0,
 	       sizeof(XFRM_MODE_SKB_CB(skb)->flow_lbl));
 
 	return 0;
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 629b061..1514cd9 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -166,9 +166,9 @@ static void netlink_sock_destruct(struct sock *sk)
 		return;
 	}
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(nlk_sk(sk)->groups);
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(nlk_sk(sk)->groups);
 }
 
 /* This lock without WQ_FLAG_EXCLUSIVE is good on UP and it is _very_ bad on
@@ -618,7 +618,7 @@ static int netlink_realloc_groups(struct sock *sk)
 		err = -ENOMEM;
 		goto out_unlock;
 	}
-	memset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,
+	(void)memset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,
 	       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));
 
 	nlk->groups = new_groups;
@@ -1447,7 +1447,7 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
 		netlink_cmsg_recv_pktinfo(msg, skb);
 
 	if (NULL == siocb->scm) {
-		memset(&scm, 0, sizeof(scm));
+		(void)memset(&scm, 0, sizeof(scm));
 		siocb->scm = &scm;
 	}
 	siocb->scm->creds = *NETLINK_CREDS(skb);
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index c29d256..1da4edc 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -555,7 +555,7 @@ static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	info.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;
 	info.attrs = family->attrbuf;
 	genl_info_net_set(&info, net);
-	memset(&info.user_ptr, 0, sizeof(info.user_ptr));
+	(void)memset(&info.user_ptr, 0, sizeof(info.user_ptr));
 
 	if (family->pre_doit) {
 		err = family->pre_doit(ops, skb, &info);
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 67fc573..b4b2b09 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -179,7 +179,7 @@ static inline int qdisc_restart(struct Qdisc *q)
 	skb = dequeue_skb(q);
 	if (unlikely(!skb))
 		return 0;
-	WARN_ON_ONCE(skb_dst_is_noref(skb));
+	(void)WARN_ON_ONCE(skb_dst_is_noref(skb));
 	root_lock = qdisc_lock(q);
 	dev = qdisc_dev(q);
 	txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
@@ -252,7 +252,7 @@ static void dev_watchdog(unsigned long arg)
 			}
 
 			if (some_queue_timedout) {
-				WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
+				(void)WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
 				       dev->name, netdev_drivername(dev), i);
 				dev->netdev_ops->ndo_tx_timeout(dev);
 			}
@@ -904,5 +904,5 @@ void dev_shutdown(struct net_device *dev)
 	qdisc_destroy(dev->qdisc);
 	dev->qdisc = &noop_qdisc;
 
-	WARN_ON(timer_pending(&dev->watchdog_timer));
+	(void)WARN_ON(timer_pending(&dev->watchdog_timer));
 }
diff --git a/net/sched/sch_mq.c b/net/sched/sch_mq.c
index 0a4b2f9..7b1d4c6 100644
--- a/net/sched/sch_mq.c
+++ b/net/sched/sch_mq.c
@@ -97,8 +97,8 @@ static int mq_dump(struct Qdisc *sch, struct sk_buff *skb)
 	unsigned int ntx;
 
 	sch->q.qlen = 0;
-	memset(&sch->bstats, 0, sizeof(sch->bstats));
-	memset(&sch->qstats, 0, sizeof(sch->qstats));
+	(void)memset(&sch->bstats, 0, sizeof(sch->bstats));
+	(void)memset(&sch->qstats, 0, sizeof(sch->qstats));
 
 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
 		qdisc = netdev_get_tx_queue(dev, ntx)->qdisc_sleeping;
diff --git a/net/socket.c b/net/socket.c
index 28a96af..fddf6eb 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -658,7 +658,7 @@ void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
 	}
 
 
-	memset(ts, 0, sizeof(ts));
+	(void)memset(ts, 0, sizeof(ts));
 	if (skb->tstamp.tv64 &&
 	    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {
 		skb_get_timestampns(skb, ts + 0);
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index f0268ea..3117c06 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -458,7 +458,7 @@ void rpc_shutdown_client(struct rpc_clnt *clnt)
 
 	while (!list_empty(&clnt->cl_tasks)) {
 		rpc_killall_tasks(clnt);
-		wait_event_timeout(destroy_wait,
+		(void)wait_event_timeout(destroy_wait,
 			list_empty(&clnt->cl_tasks), 1*HZ);
 	}
 
@@ -1569,7 +1569,7 @@ call_decode(struct rpc_task *task)
 	req->rq_rcv_buf.len = req->rq_private_buf.len;
 
 	/* Check that the softirq receive buffer is valid */
-	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
+	(void)WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
 				sizeof(req->rq_rcv_buf)) != 0);
 
 	if (req->rq_rcv_buf.len < 12) {
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 3341d89..b7d8a7d 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -621,7 +621,7 @@ void rpc_exit_task(struct rpc_task *task)
 	if (task->tk_ops->rpc_call_done != NULL) {
 		task->tk_ops->rpc_call_done(task, task->tk_calldata);
 		if (task->tk_action != NULL) {
-			WARN_ON(RPC_ASSASSINATED(task));
+			(void)WARN_ON(RPC_ASSASSINATED(task));
 			/* Always release the RPC slot and buffer memory */
 			xprt_release(task);
 			rpc_reset_task_statistics(task);
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index e4aabc0..9515725 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1147,8 +1147,8 @@ svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)
 	procp->pc_count++;
 
 	/* Initialize storage for argp and resp */
-	memset(rqstp->rq_argp, 0, procp->pc_argsize);
-	memset(rqstp->rq_resp, 0, procp->pc_ressize);
+	(void)memset(rqstp->rq_argp, 0, procp->pc_argsize);
+	(void)memset(rqstp->rq_resp, 0, procp->pc_ressize);
 
 	/* un-reserve some of the out-queue now that we have a
 	 * better idea of reply size
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 55472c4..ae7ba6b 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -2005,7 +2005,7 @@ static void xs_abort_connection(struct sock_xprt *transport)
 	 * Disconnect the transport socket by doing a connect operation
 	 * with AF_UNSPEC.  This should return immediately...
 	 */
-	memset(&any, 0, sizeof(any));
+	(void)memset(&any, 0, sizeof(any));
 	any.sa_family = AF_UNSPEC;
 	result = kernel_connect(transport->sock, &any, sizeof(any), 0);
 	if (!result)
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aad8fb6..7a97f4d 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -230,7 +230,7 @@ static void __unix_remove_socket(struct sock *sk)
 
 static void __unix_insert_socket(struct hlist_head *list, struct sock *sk)
 {
-	WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(!sk_unhashed(sk));
 	sk_add_node(sk, list);
 }
 
@@ -353,9 +353,9 @@ static void unix_sock_destructor(struct sock *sk)
 
 	skb_queue_purge(&sk->sk_receive_queue);
 
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-	WARN_ON(!sk_unhashed(sk));
-	WARN_ON(sk->sk_socket);
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(!sk_unhashed(sk));
+	(void)WARN_ON(sk->sk_socket);
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		printk(KERN_INFO "Attempt to release alive unix socket: %p\n", sk);
 		return;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 7661576..dae38ad 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -2634,21 +2634,21 @@ static void xfrm_policy_fini(struct net *net)
 	audit_info.secid = 0;
 	xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, &audit_info);
 
-	WARN_ON(!list_empty(&net->xfrm.policy_all));
+	(void)WARN_ON(!list_empty(&net->xfrm.policy_all));
 
 	for (dir = 0; dir < XFRM_POLICY_MAX * 2; dir++) {
 		struct xfrm_policy_hash *htab;
 
-		WARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));
+		(void)WARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));
 
 		htab = &net->xfrm.policy_bydst[dir];
 		sz = (htab->hmask + 1);
-		WARN_ON(!hlist_empty(htab->table));
+		(void)WARN_ON(!hlist_empty(htab->table));
 		xfrm_hash_free(htab->table, sz);
 	}
 
 	sz = (net->xfrm.policy_idx_hmask + 1) * sizeof(struct hlist_head);
-	WARN_ON(!hlist_empty(net->xfrm.policy_byidx));
+	(void)WARN_ON(!hlist_empty(net->xfrm.policy_byidx));
 	xfrm_hash_free(net->xfrm.policy_byidx, sz);
 }
 
diff --git a/security/commoncap.c b/security/commoncap.c
index 7ce191e..cb0b81c 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -370,7 +370,7 @@ int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data
 	int size;
 	struct vfs_cap_data caps;
 
-	memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));
+	(void)memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));
 
 	if (!inode || !inode->i_op->getxattr)
 		return -ENODATA;
diff --git a/sound/core/info_oss.c b/sound/core/info_oss.c
index cf42ab5..a5f4b6e 100644
--- a/sound/core/info_oss.c
+++ b/sound/core/info_oss.c
@@ -117,7 +117,7 @@ int snd_info_minor_register(void)
 {
 	struct snd_info_entry *entry;
 
-	memset(snd_sndstat_strings, 0, sizeof(snd_sndstat_strings));
+	(void)memset(snd_sndstat_strings, 0, sizeof(snd_sndstat_strings));
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "sndstat", snd_oss_root)) != NULL) {
 		entry->c.text.read = snd_sndstat_proc_read;
 		if (snd_info_register(entry) < 0) {
diff --git a/sound/core/init.c b/sound/core/init.c
index 3ac49b1..e698f2e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -375,7 +375,7 @@ int snd_card_disconnect(struct snd_card *card)
 		spin_unlock(&shutdown_lock);
 
 		mfile->file->f_op = &snd_shutdown_f_ops;
-		fops_get(mfile->file->f_op);
+		(void)fops_get(mfile->file->f_op);
 	}
 	spin_unlock(&card->files_lock);	
 
diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 18297f7..d7176d2 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -93,7 +93,7 @@ static int snd_mixer_oss_info(struct snd_mixer_oss_file *fmixer,
 	struct snd_mixer_oss *mixer = fmixer->mixer;
 	struct mixer_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
 	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
 	info.modify_counter = card->mixer_oss_change_count;
@@ -109,7 +109,7 @@ static int snd_mixer_oss_info_obsolete(struct snd_mixer_oss_file *fmixer,
 	struct snd_mixer_oss *mixer = fmixer->mixer;
 	_old_mixer_info info;
 	
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
 	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
 	if (copy_to_user(_info, &info, sizeof(info)))
@@ -382,7 +382,7 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
 		return -ENXIO;
 	if (card->mixer_oss == NULL)
 		return -ENXIO;
-	memset(&fmixer, 0, sizeof(fmixer));
+	(void)memset(&fmixer, 0, sizeof(fmixer));
 	fmixer.card = card;
 	fmixer.mixer = card->mixer_oss;
 	return snd_mixer_oss_ioctl1(&fmixer, cmd, arg);
@@ -498,7 +498,7 @@ static struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, c
 	struct snd_card *card = mixer->card;
 	struct snd_ctl_elem_id id;
 	
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	strlcpy(id.name, name, sizeof(id.name));
 	id.index = index;
@@ -947,7 +947,7 @@ static void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)
 	int idx = rslot->number; /* remember this */
 	if (rslot->private_free)
 		rslot->private_free(rslot);
-	memset(rslot, 0, sizeof(*rslot));
+	(void)memset(rslot, 0, sizeof(*rslot));
 	rslot->number = idx;
 }
 
@@ -1030,8 +1030,8 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	if (mixer->slots[ptr->oss_id].get_volume && ! replace_old)
 		return 0;
 
-	memset(&slot, 0, sizeof(slot));
-	memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
+	(void)memset(&slot, 0, sizeof(slot));
+	(void)memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
 	if (snd_mixer_oss_build_test_all(mixer, ptr, &slot))
 		return 0;
 	down_read(&mixer->card->controls_rwsem);
diff --git a/sound/core/oss/mulaw.c b/sound/core/oss/mulaw.c
index 7915564..9fbf6d4 100644
--- a/sound/core/oss/mulaw.c
+++ b/sound/core/oss/mulaw.c
@@ -160,7 +160,7 @@ static inline void cvt_s16_to_native(struct mulaw_priv *data,
 	if (data->cvt_endian)
 		sample = swab16(sample);
 	if (data->native_bytes > data->copy_bytes)
-		memset(dst, 0, data->native_bytes);
+		(void)memset(dst, 0, data->native_bytes);
 	memcpy(dst + data->native_ofs, (char *)&sample + data->copy_ofs,
 	       data->copy_bytes);
 }
diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
index 08fde00..8591064 100644
--- a/sound/core/oss/pcm_oss.c
+++ b/sound/core/oss/pcm_oss.c
@@ -987,7 +987,7 @@ static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)
 		goto failure;
 	}
 
-	memset(sw_params, 0, sizeof(*sw_params));
+	(void)memset(sw_params, 0, sizeof(*sw_params));
 	if (runtime->oss.trigger) {
 		sw_params->start_threshold = 1;
 	} else {
@@ -1668,7 +1668,7 @@ static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)
 				}
 			} else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {
 				void __user *buffers[runtime->channels];
-				memset(buffers, 0, runtime->channels * sizeof(void *));
+				(void)memset(buffers, 0, runtime->channels * sizeof(void *));
 				snd_pcm_lib_writev(substream, buffers, size);
 			}
 		}
@@ -2100,7 +2100,7 @@ static int snd_pcm_oss_get_ptr(struct snd_pcm_oss_file *pcm_oss_file, int stream
 		return err;
 	runtime = substream->runtime;
 	if (runtime->oss.params || runtime->oss.prepare) {
-		memset(&info, 0, sizeof(info));
+		(void)memset(&info, 0, sizeof(info));
 		if (copy_to_user(_info, &info, sizeof(info)))
 			return -EFAULT;
 		return 0;
@@ -2410,7 +2410,7 @@ static int snd_pcm_oss_open(struct inode *inode, struct file *file)
 		err = -EFAULT;
 		goto __error;
 	}
-	memset(setup, 0, sizeof(setup));
+	(void)memset(setup, 0, sizeof(setup));
 	if (file->f_mode & FMODE_WRITE)
 		snd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 					   task_name, &setup[0]);
@@ -2632,7 +2632,7 @@ static long snd_pcm_oss_ioctl(struct file *file, unsigned int cmd, unsigned long
 		res = snd_pcm_oss_get_odelay(pcm_oss_file);
 		if (res < 0) {
 			/* it's for sure, some broken apps don't check for error codes */
-			put_user(0, p);
+			(void)put_user(0, p);
 			return res;
 		}
 		return put_user(res, p);
@@ -2747,7 +2747,7 @@ static unsigned int snd_pcm_oss_poll(struct file *file, poll_table * wait)
 		snd_pcm_stream_unlock_irq(csubstream);
 		if (ostate != SNDRV_PCM_STATE_RUNNING && runtime->oss.trigger) {
 			struct snd_pcm_oss_file ofile;
-			memset(&ofile, 0, sizeof(ofile));
+			(void)memset(&ofile, 0, sizeof(ofile));
 			ofile.streams[SNDRV_PCM_STREAM_CAPTURE] = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
 			runtime->oss.trigger = 0;
 			snd_pcm_oss_set_trigger(&ofile, PCM_ENABLE_INPUT);
@@ -2875,7 +2875,7 @@ static void snd_pcm_oss_proc_write(struct snd_info_entry *entry,
 
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
 		mutex_lock(&pstr->oss.setup_mutex);
-		memset(&template, 0, sizeof(template));
+		(void)memset(&template, 0, sizeof(template));
 		ptr = snd_info_get_str(task_name, line, sizeof(task_name));
 		if (!strcmp(task_name, "clear") || !strcmp(task_name, "erase")) {
 			snd_pcm_oss_proc_free_setup_list(pstr);
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8928ca87..20ae461 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -447,7 +447,7 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "closed\n");
 		goto unlock;
 	}
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	err = snd_pcm_status(substream, &status);
 	if (err < 0) {
 		snd_iprintf(buffer, "error %d\n", err);
@@ -899,7 +899,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->status, 0, size);
+	(void)memset((void*)runtime->status, 0, size);
 
 	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control));
 	runtime->control = snd_malloc_pages(size, GFP_KERNEL);
@@ -909,7 +909,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->control, 0, size);
+	(void)memset((void*)runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
 	init_waitqueue_head(&runtime->tsleep);
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3420bd3..3068060 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1151,7 +1151,7 @@ int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param
 	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
 	struct snd_mask *maskp = constrs_mask(constrs, var);
 	*maskp->bits &= mask;
-	memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
+	(void)memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
 	if (*maskp->bits == 0)
 		return -EINVAL;
 	return 0;
@@ -1172,7 +1172,7 @@ int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 	struct snd_mask *maskp = constrs_mask(constrs, var);
 	maskp->bits[0] &= (u_int32_t)mask;
 	maskp->bits[1] &= (u_int32_t)(mask >> 32);
-	memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
+	(void)memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
 	if (! maskp->bits[0] && ! maskp->bits[1])
 		return -EINVAL;
 	return 0;
@@ -1447,7 +1447,7 @@ static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
-	memset(params, 0, sizeof(*params));
+	(void)memset(params, 0, sizeof(*params));
 	for (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)
 		_snd_pcm_hw_param_any(params, k);
 	for (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)
diff --git a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
index 9571313..0316561 100644
--- a/sound/core/pcm_memory.c
+++ b/sound/core/pcm_memory.c
@@ -181,7 +181,7 @@ static void snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,
 		}
 		if (substream->dma_buffer.bytes == size)
 			return;
-		memset(&new_dmab, 0, sizeof(new_dmab));
+		(void)memset(&new_dmab, 0, sizeof(new_dmab));
 		new_dmab.dev = substream->dma_buffer.dev;
 		if (size > 0) {
 			if (snd_dma_alloc_pages(substream->dma_buffer.dev.type,
diff --git a/sound/core/pcm_misc.c b/sound/core/pcm_misc.c
index 9c9eff9..79ef4e4 100644
--- a/sound/core/pcm_misc.c
+++ b/sound/core/pcm_misc.c
@@ -397,7 +397,7 @@ int snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int
 	/* signed or 1 byte data */
 	if (pcm_formats[(INT)format].signd == 1 || width <= 8) {
 		unsigned int bytes = samples * width / 8;
-		memset(data, *pat, bytes);
+		(void)memset(data, *pat, bytes);
 		return 0;
 	}
 	/* non-zero samples, fill using a loop */
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 25ed9fe..b2d1aa5 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -99,7 +99,7 @@ int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info)
 	struct snd_pcm *pcm = substream->pcm;
 	struct snd_pcm_str *pstr = substream->pstr;
 
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->card = pcm->card->number;
 	info->device = pcm->device;
 	info->stream = substream->stream;
@@ -631,7 +631,7 @@ static int snd_pcm_status_user(struct snd_pcm_substream *substream,
 	struct snd_pcm_status status;
 	int res;
 	
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	res = snd_pcm_status(substream, &status);
 	if (res < 0)
 		return res;
@@ -656,7 +656,7 @@ static int snd_pcm_channel_info(struct snd_pcm_substream *substream,
 	snd_pcm_stream_unlock_irq(substream);
 	if (channel >= runtime->channels)
 		return -EINVAL;
-	memset(info, 0, sizeof(*info));
+	(void)memset(info, 0, sizeof(*info));
 	info->channel = channel;
 	return substream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_CHANNEL_INFO, info);
 }
@@ -2453,7 +2453,7 @@ static int snd_pcm_sync_ptr(struct snd_pcm_substream *substream,
 	volatile struct snd_pcm_mmap_control *control;
 	int err;
 
-	memset(&sync_ptr, 0, sizeof(sync_ptr));
+	(void)memset(&sync_ptr, 0, sizeof(sync_ptr));
 	if (get_user(sync_ptr.flags, (unsigned __user *)&(_sync_ptr->flags)))
 		return -EFAULT;
 	if (copy_from_user(&sync_ptr.c.control, &(_sync_ptr->c.control), sizeof(struct snd_pcm_mmap_control)))
@@ -2589,7 +2589,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (copy_from_user(&xferi, _xferi, sizeof(xferi)))
 			return -EFAULT;
 		result = snd_pcm_lib_write(substream, xferi.buf, xferi.frames);
-		__put_user(result, &_xferi->result);
+		(void)__put_user(result, &_xferi->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_WRITEN_FRAMES:
@@ -2614,7 +2614,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 			return PTR_ERR(bufs);
 		result = snd_pcm_lib_writev(substream, bufs, xfern.frames);
 		kfree(bufs);
-		__put_user(result, &_xfern->result);
+		(void)__put_user(result, &_xfern->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_REWIND:
@@ -2627,7 +2627,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_playback_rewind(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_FORWARD:
@@ -2640,7 +2640,7 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_playback_forward(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	}
@@ -2669,7 +2669,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (copy_from_user(&xferi, _xferi, sizeof(xferi)))
 			return -EFAULT;
 		result = snd_pcm_lib_read(substream, xferi.buf, xferi.frames);
-		__put_user(result, &_xferi->result);
+		(void)__put_user(result, &_xferi->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_READN_FRAMES:
@@ -2694,7 +2694,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 			return PTR_ERR(bufs);
 		result = snd_pcm_lib_readv(substream, bufs, xfern.frames);
 		kfree(bufs);
-		__put_user(result, &_xfern->result);
+		(void)__put_user(result, &_xfern->result);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_REWIND:
@@ -2707,7 +2707,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_capture_rewind(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	case SNDRV_PCM_IOCTL_FORWARD:
@@ -2720,7 +2720,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		if (put_user(0, _frames))
 			return -EFAULT;
 		result = snd_pcm_capture_forward(substream, frames);
-		__put_user(result, _frames);
+		(void)__put_user(result, _frames);
 		return result < 0 ? result : 0;
 	}
 	}
@@ -3309,7 +3309,7 @@ static void snd_pcm_hw_convert_from_old_params(struct snd_pcm_hw_params *params,
 {
 	unsigned int i;
 
-	memset(params, 0, sizeof(*params));
+	(void)memset(params, 0, sizeof(*params));
 	params->flags = oparams->flags;
 	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
 		params->masks[i].bits[0] = oparams->masks[i];
@@ -3328,7 +3328,7 @@ static void snd_pcm_hw_convert_to_old_params(struct snd_pcm_hw_params_old *opara
 {
 	unsigned int i;
 
-	memset(oparams, 0, sizeof(*oparams));
+	(void)memset(oparams, 0, sizeof(*oparams));
 	oparams->flags = params->flags;
 	for (i = 0; i < ARRAY_SIZE(oparams->masks); i++)
 		oparams->masks[i] = params->masks[i].bits[0];
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8e7561d..e57cca3 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -937,7 +937,7 @@ int snd_timer_global_register(struct snd_timer *timer)
 {
 	struct snd_device dev;
 
-	memset(&dev, 0, sizeof(dev));
+	(void)memset(&dev, 0, sizeof(dev));
 	dev.device_data = timer;
 	return snd_timer_dev_register(&dev);
 }
@@ -1192,7 +1192,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	struct timespec tstamp;
 	int prev, append = 0;
 
-	memset(&tstamp, 0, sizeof(tstamp));
+	(void)memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
 	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |
 			   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
@@ -1412,7 +1412,7 @@ static int snd_timer_user_ginfo(struct file *file,
 		return PTR_ERR(ginfo);
 
 	tid = ginfo->tid;
-	memset(ginfo, 0, sizeof(*ginfo));
+	(void)memset(ginfo, 0, sizeof(*ginfo));
 	ginfo->tid = tid;
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
@@ -1480,7 +1480,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	if (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))
 		return -EFAULT;
 	tid = gstatus.tid;
-	memset(&gstatus, 0, sizeof(gstatus));
+	(void)memset(&gstatus, 0, sizeof(gstatus));
 	gstatus.tid = tid;
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
@@ -1703,7 +1703,7 @@ static int snd_timer_user_status(struct file *file,
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
-	memset(&status, 0, sizeof(status));
+	(void)memset(&status, 0, sizeof(status));
 	status.tstamp = tu->tstamp;
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
diff --git a/sound/core/vmaster.c b/sound/core/vmaster.c
index 130cfe6..2d27d81 100644
--- a/sound/core/vmaster.c
+++ b/sound/core/vmaster.c
@@ -374,7 +374,7 @@ struct snd_kcontrol *snd_ctl_make_virtual_master(char *name,
 	struct snd_kcontrol *kctl;
 	struct snd_kcontrol_new knew;
 
-	memset(&knew, 0, sizeof(knew));
+	(void)memset(&knew, 0, sizeof(knew));
 	knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	knew.name = name;
 	knew.info = master_info;
diff --git a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
index 9473fca..d78dace 100644
--- a/sound/pci/ac97/ac97_codec.c
+++ b/sound/pci/ac97/ac97_codec.c
@@ -2603,7 +2603,7 @@ static int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,
 			       const char *suffix)
 {
 	struct snd_ctl_elem_id id;
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	set_ctl_name(id.name, name, suffix);
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	return snd_ctl_remove_id(ac97->bus->card, &id);
@@ -2612,7 +2612,7 @@ static int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,
 static struct snd_kcontrol *ctl_find(struct snd_ac97 *ac97, const char *name, const char *suffix)
 {
 	struct snd_ctl_elem_id sid;
-	memset(&sid, 0, sizeof(sid));
+	(void)memset(&sid, 0, sizeof(sid));
 	set_ctl_name(sid.name, name, suffix);
 	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	return snd_ctl_find_id(ac97->bus->card, &sid);
diff --git a/sound/pci/ac97/ac97_patch.c b/sound/pci/ac97/ac97_patch.c
index a872d0a..3608c2fe 100644
--- a/sound/pci/ac97/ac97_patch.c
+++ b/sound/pci/ac97/ac97_patch.c
@@ -55,7 +55,7 @@ static void reset_tlv(struct snd_ac97 *ac97, const char *name,
 {
 	struct snd_ctl_elem_id sid;
 	struct snd_kcontrol *kctl;
-	memset(&sid, 0, sizeof(sid));
+	(void)memset(&sid, 0, sizeof(sid));
 	strcpy(sid.name, name);
 	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	kctl = snd_ctl_find_id(ac97->bus->card, &sid);
@@ -3429,7 +3429,7 @@ static struct snd_kcontrol *snd_ac97_find_mixer_ctl(struct snd_ac97 *ac97,
 						    const char *name)
 {
 	struct snd_ctl_elem_id id;
-	memset(&id, 0, sizeof(id));
+	(void)memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	strcpy(id.name, name);
 	return snd_ctl_find_id(ac97->bus->card, &id);
diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index f1488fc..b8f64ae 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -458,9 +458,9 @@ int snd_ac97_pcm_assign(struct snd_ac97_bus *bus,
 	rpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);
 	if (rpcms == NULL)
 		return -ENOMEM;
-	memset(avail_slots, 0, sizeof(avail_slots));
-	memset(rate_table, 0, sizeof(rate_table));
-	memset(spdif_slots, 0, sizeof(spdif_slots));
+	(void)memset(avail_slots, 0, sizeof(avail_slots));
+	(void)memset(rate_table, 0, sizeof(rate_table));
+	(void)memset(spdif_slots, 0, sizeof(spdif_slots));
 	for (i = 0; i < 4; i++) {
 		codec = bus->codec[i];
 		if (!codec)
