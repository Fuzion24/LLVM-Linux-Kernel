diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index e13117c..35df364 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -126,7 +126,7 @@ static inline void *dma_zalloc_coherent(struct device *dev, size_t size,
 {
 	void *ret = dma_alloc_coherent(dev, size, dma_handle, flag);
 	if (ret)
-		memset(ret, 0, size);
+		(void)memset(ret, 0, size);
 	return ret;
 }

diff --git a/include/linux/kref.h b/include/linux/kref.h
index 9c07dce..516b7a3 100644
--- a/include/linux/kref.h
+++ b/include/linux/kref.h
@@ -38,7 +38,7 @@ static inline void kref_init(struct kref *kref)
  */
 static inline void kref_get(struct kref *kref)
 {
-	WARN_ON(!atomic_read(&kref->refcount));
+	(void)WARN_ON(!atomic_read(&kref->refcount));
 	atomic_inc(&kref->refcount);
 }
 
@@ -63,7 +63,7 @@ static inline void kref_get(struct kref *kref)
 static inline int kref_sub(struct kref *kref, unsigned int count,
 	     void (*release)(struct kref *kref))
 {
-	WARN_ON(release == NULL);
+	(void)WARN_ON(release == NULL);
 
 	if (atomic_sub_and_test((int) count, &kref->refcount)) {
 		release(kref);
diff --git a/include/net/scm.h b/include/net/scm.h
index d456f4c..3fd7dfc 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -73,7 +73,7 @@ static __inline__ void scm_destroy(struct scm_cookie *scm)
 static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 			       struct scm_cookie *scm)
 {
-	memset(scm, 0, sizeof(*scm));
+	(void)memset(scm, 0, sizeof(*scm));
 	unix_get_peersec_dgram(sock, scm);
 	if (msg->msg_controllen <= 0)
 		return 0;
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index ff302bd..78492e1 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -121,7 +121,7 @@ static int ip_dev_loopback_xmit(struct sk_buff *newskb)
 	__skb_pull(newskb, skb_network_offset(newskb));
 	newskb->pkt_type = PACKET_LOOPBACK;
 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
-	WARN_ON(!skb_dst(newskb));
+	(void)WARN_ON(!skb_dst(newskb));
 	skb_dst_force(newskb);
 	netif_rx_ni(newskb);
 	return 0;
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bcacf54..b8bd44f 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -849,7 +849,7 @@ static void rt_check_expire(void)
 	expires_ljiffies = jiffies;
 	mult = ((u64)delta) << rt_hash_log;
 	if (ip_rt_gc_timeout > 1)
-		do_div(mult, ip_rt_gc_timeout);
+		(void)do_div(mult, ip_rt_gc_timeout);
 	goal = (unsigned int)mult;
 	if (goal > rt_hash_mask)
 		goal = rt_hash_mask + 1;
diff --git a/include/net/sock.h b/include/net/sock.h
index bb972d2..54d7904 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -496,7 +496,7 @@ static __inline__ int sk_nulls_del_node_init_rcu(struct sock *sk)
 
 	if (rc) {
 		/* paranoid for a while -acme */
-		WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
+		(void)WARN_ON(atomic_read(&sk->sk_refcnt) == 1);
 		__sock_put(sk);
 	}
 	return rc;
--- a/block/blk-exec.c
+++ b/block/blk-exec.c
@@ -50,7 +50,7 @@ void blk_execute_rq_nowait(struct request_queue *q, struct gendisk *bd_disk,
 {
 	int where = at_head ? ELEVATOR_INSERT_FRONT : ELEVATOR_INSERT_BACK;
 
-	WARN_ON(irqs_disabled());
+	(void)WARN_ON(irqs_disabled());
 	spin_lock_irq(q->queue_lock);
 
 	if (unlikely(blk_queue_dead(q))) {
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index ee55019..217bc33 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -1614,7 +1614,7 @@ static void cfq_remove_request(struct request *rq)
 	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
 					rq_data_dir(rq), rq_is_sync(rq));
 	if (rq->cmd_flags & REQ_PRIO) {
-		WARN_ON(!cfqq->prio_pending);
+		(void)WARN_ON(!cfqq->prio_pending);
 		cfqq->prio_pending--;
 	}
 }
diff --git a/block/genhd.c b/block/genhd.c
index 23b4f70..30ca52e 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -614,11 +614,11 @@ void add_disk(struct gendisk *disk)
 	 * Take an extra ref on queue which will be put on disk_release()
 	 * so that it sticks around as long as @disk is there.
 	 */
-	WARN_ON_ONCE(!blk_get_queue(disk->queue));
+	(void)WARN_ON_ONCE(!blk_get_queue(disk->queue));
 
 	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
 				   "bdi");
-	WARN_ON(retval);
+	(void)WARN_ON(retval);
 
 	disk_add_events(disk);
 }
diff --git a/block/partitions/check.c b/block/partitions/check.c
index bc90867..7136055 100644
--- a/block/partitions/check.c
+++ b/block/partitions/check.c
@@ -131,7 +131,7 @@ check_partition(struct gendisk *hd, struct block_device *bdev)
 	state->limit = disk_max_parts(hd);
 	i = res = err = 0;
 	while (!res && check_part[i]) {
-		memset(&state->parts, 0, sizeof(state->parts));
+		(void)memset(&state->parts, 0, sizeof(state->parts));
 		res = check_part[i++](state);
 		if (res < 0) {
 			/* We have hit an I/O error which we don't report now.
diff --git a/drivers/base/power/qos.c b/drivers/base/power/qos.c
index c5d3588..a0ce7d9 100644
--- a/drivers/base/power/qos.c
+++ b/drivers/base/power/qos.c
@@ -180,7 +180,7 @@ void dev_pm_qos_constraints_destroy(struct device *dev)
 		 * callbacks if needed
 		 */
 		apply_constraint(req, PM_QOS_REMOVE_REQ, PM_QOS_DEFAULT_VALUE);
-		memset(req, 0, sizeof(*req));
+		(void)memset(req, 0, sizeof(*req));
 	}
 
 	spin_lock_irq(&dev->power.lock);
@@ -325,7 +325,7 @@ int dev_pm_qos_remove_request(struct dev_pm_qos_request *req)
 	if (req->dev->power.constraints) {
 		ret = apply_constraint(req, PM_QOS_REMOVE_REQ,
 				       PM_QOS_DEFAULT_VALUE);
-		memset(req, 0, sizeof(*req));
+		(void)memset(req, 0, sizeof(*req));
 	} else {
 		/* Return if the device has been removed */
 		ret = -ENODEV;
diff --git a/drivers/net/ethernet/smsc/smc91x.c b/drivers/net/ethernet/smsc/smc91x.c
index 64ad3ed..16aa4ef 100644
--- a/drivers/net/ethernet/smsc/smc91x.c
+++ b/drivers/net/ethernet/smsc/smc91x.c
@@ -1420,7 +1420,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		static const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};
 
 		/* start with a table of all zeros: reject all */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 
 		netdev_for_each_mc_addr(ha, dev) {
 			int position;
@@ -1446,7 +1446,7 @@ static void smc_set_multicast_list(struct net_device *dev)
 		 * since I'm disabling all multicast entirely, I need to
 		 * clear the multicast list
 		 */
-		memset(multicast_table, 0, sizeof(multicast_table));
+		(void)memset(multicast_table, 0, sizeof(multicast_table));
 		update_multicast = 1;
 	}
 
@@ -2105,7 +2105,7 @@ static int smc_enable_device(struct platform_device *pdev)
 	local_irq_save(flags);
 	ecor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;
 	writeb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));
-	readb(addr + (ECOR << SMC_IO_SHIFT));
+	(void)readb(addr + (ECOR << SMC_IO_SHIFT));
 
 	/*
 	 * Wait 100us for the chip to reset.
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 995e3bd..e31bc0a 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -249,7 +249,7 @@ void pm_qos_add_request(struct pm_qos_request *req,
 		return;
 
 	if (pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
+		(void)WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
 		return;
 	}
 	req->pm_qos_class = pm_qos_class;
@@ -275,7 +275,7 @@ void pm_qos_update_request(struct pm_qos_request *req,
 		return;
 
 	if (!pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_update_request() called for unknown object\n");
 		return;
 	}
 
@@ -301,14 +301,14 @@ void pm_qos_remove_request(struct pm_qos_request *req)
 		/* silent return to keep pcm code cleaner */
 
 	if (!pm_qos_request_active(req)) {
-		WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
+		(void)WARN(1, KERN_ERR "pm_qos_remove_request() called for unknown object\n");
 		return;
 	}
 
 	pm_qos_update_target(pm_qos_array[req->pm_qos_class]->constraints,
 			     &req->node, PM_QOS_REMOVE_REQ,
 			     PM_QOS_DEFAULT_VALUE);
-	memset(req, 0, sizeof(*req));
+	(void)memset(req, 0, sizeof(*req));
 }
 EXPORT_SYMBOL_GPL(pm_qos_remove_request);
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index df00cb0..7a5d563 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2010,7 +2010,7 @@ asmlinkage void schedule_tail(struct task_struct *prev)
 	preempt_enable();
 #endif
 	if (current->set_child_tid)
-		put_user(task_pid_vnr(current), current->set_child_tid);
+		(void)put_user(task_pid_vnr(current), current->set_child_tid);
 }
 
 /*
@@ -2940,7 +2940,7 @@ void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = (__force u64) rtime;
 
 		temp *= (__force u64) utime;
-		do_div(temp, (__force u32) total);
+		(void)do_div(temp, (__force u32) total);
 		utime = (__force cputime_t) temp;
 	} else
 		utime = rtime;
@@ -2973,7 +2973,7 @@ void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 		u64 temp = (__force u64) rtime;
 
 		temp *= (__force u64) cputime.utime;
-		do_div(temp, (__force u32) total);
+		(void)do_div(temp, (__force u32) total);
 		utime = (__force cputime_t) temp;
 	} else
 		utime = rtime;
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 2a075e1..41c5f34 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -39,10 +39,10 @@ static long long nsec_high(unsigned long long nsec)
 {
 	if ((long long)nsec < 0) {
 		nsec = -nsec;
-		do_div(nsec, 1000000);
+		(void)do_div(nsec, 1000000);
 		return -nsec;
 	}
-	do_div(nsec, 1000000);
+	(void)do_div(nsec, 1000000);
 
 	return nsec;
 }
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 3640ebb..6056850 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -1023,7 +1023,7 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
 	int prio = rt_se_prio(rt_se);
 
-	WARN_ON(!rt_prio(prio));
+	(void)WARN_ON(!rt_prio(prio));
 	rt_rq->rt_nr_running++;
 
 	inc_rt_prio(rt_rq, prio);
@@ -1034,8 +1034,8 @@ void inc_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 static inline
 void dec_rt_tasks(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
 {
-	WARN_ON(!rt_prio(rt_se_prio(rt_se)));
-	WARN_ON(!rt_rq->rt_nr_running);
+	(void)WARN_ON(!rt_prio(rt_se_prio(rt_se)));
+	(void)WARN_ON(!rt_rq->rt_nr_running);
 	rt_rq->rt_nr_running--;
 
 	dec_rt_prio(rt_rq, rt_se_prio(rt_se));
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 0985b9b..e2ca94c 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -25,7 +25,7 @@ bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
 	u8 ip_proto;
 	__be16 proto = skb->protocol;
 
-	memset(flow, 0, sizeof(*flow));
+	(void)memset(flow, 0, sizeof(*flow));
 
 again:
 	switch (proto) {
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 921aa2b..6e3c125 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -299,7 +299,7 @@ int __ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	if (!dev->ethtool_ops || !dev->ethtool_ops->get_settings)
 		return -EOPNOTSUPP;
 
-	memset(cmd, 0, sizeof(struct ethtool_cmd));
+	(void)memset(cmd, 0, sizeof(struct ethtool_cmd));
 	cmd->cmd = ETHTOOL_GSET;
 	return dev->ethtool_ops->get_settings(dev, cmd);
 }
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index da0c97f..d03cc8d 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -206,7 +206,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	 * actually initialise below. Hence, don't put any more fields after
 	 * the tail pointer in struct sk_buff!
 	 */
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	/* Account for allocated memory : skb + skb->head */
 	skb->truesize = SKB_TRUESIZE(size);
 	atomic_set(&skb->users, 1);
@@ -220,7 +220,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -272,7 +272,7 @@ struct sk_buff *build_skb(void *data)
 
 	size = ksize(data) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->truesize = SKB_TRUESIZE(size);
 	atomic_set(&skb->users, 1);
 	skb->head = data;
@@ -285,7 +285,7 @@ struct sk_buff *build_skb(void *data)
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
@@ -449,7 +449,7 @@ static void skb_release_head_state(struct sk_buff *skb)
 	secpath_put(skb->sp);
 #endif
 	if (skb->destructor) {
-		WARN_ON(in_irq());
+		(void)WARN_ON(in_irq());
 		skb->destructor(skb);
 	}
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
@@ -549,10 +549,10 @@ void skb_recycle(struct sk_buff *skb)
 	skb_release_head_state(skb);
 
 	shinfo = skb_shinfo(skb);
-	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
+	(void)memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 
-	memset(skb, 0, offsetof(struct sk_buff, tail));
+	(void)memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->data = skb->head + NET_SKB_PAD;
 	skb_reset_tail_pointer(skb);
 }
@@ -1121,7 +1121,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 
 	/* If the skbuff is non linear tailroom is always zero.. */
 	if (!skb_cloned(skb) && skb_tailroom(skb) >= pad) {
-		memset(skb->data+skb->len, 0, pad);
+		(void)memset(skb->data+skb->len, 0, pad);
 		return 0;
 	}
 
@@ -1139,7 +1139,7 @@ int skb_pad(struct sk_buff *skb, int pad)
 	if (unlikely(err))
 		goto free_skb;
 
-	memset(skb->data + skb->len, 0, pad);
+	(void)memset(skb->data + skb->len, 0, pad);
 	return 0;
 
 free_skb:
@@ -1486,7 +1486,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1512,7 +1512,7 @@ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1795,7 +1795,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(frag);
 		if ((copy = end - offset) > 0) {
@@ -1820,7 +1820,7 @@ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1868,7 +1868,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1894,7 +1894,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -1943,7 +1943,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -1973,7 +1973,7 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 		__wsum csum2;
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -2989,7 +2989,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);
 		if ((copy = end - offset) > 0) {
@@ -3010,7 +3010,7 @@ __skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)
 	skb_walk_frags(skb, frag_iter) {
 		int end;
 
-		WARN_ON(start > offset + len);
+		(void)WARN_ON(start > offset + len);
 
 		end = start + frag_iter->len;
 		if ((copy = end - offset) > 0) {
@@ -3207,7 +3207,7 @@ void skb_tstamp_tx(struct sk_buff *orig_skb,
 	}
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	(void)memset(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 
@@ -3228,7 +3228,7 @@ void skb_complete_wifi_ack(struct sk_buff *skb, bool acked)
 	skb->wifi_acked = acked;
 
 	serr = SKB_EXT_ERR(skb);
-	memset(serr, 0, sizeof(*serr));
+	(void)memset(serr, 0, sizeof(*serr));
 	serr->ee.ee_errno = ENOMSG;
 	serr->ee.ee_origin = SO_EE_ORIGIN_TXSTATUS;
 
diff --git a/net/core/dev.c b/net/core/dev.c
index 115dee1..26282bb 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -498,7 +498,7 @@ static int netdev_boot_setup_add(char *name, struct ifmap *map)
 	s = dev_boot_setup;
 	for (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++) {
 		if (s[i].name[0] == '\0' || s[i].name[0] == ' ') {
-			memset(s[i].name, 0, sizeof(s[i].name));
+			(void)memset(s[i].name, 0, sizeof(s[i].name));
 			strlcpy(s[i].name, name, IFNAMSIZ);
 			memcpy(&s[i].map, map, sizeof(s[i].map));
 			break;
@@ -581,7 +581,7 @@ int __init netdev_boot_setup(char *str)
 		return 0;
 
 	/* Save settings */
-	memset(&map, 0, sizeof(map));
+	(void)memset(&map, 0, sizeof(map));
 	if (ints[0] > 0)
 		map.irq = ints[1];
 	if (ints[0] > 1)
@@ -1330,7 +1330,7 @@ void dev_disable_lro(struct net_device *dev)
 	netdev_update_features(dev);
 
 	if (unlikely(dev->features & NETIF_F_LRO))
-		netdev_WARN(dev, "failed to disable LRO!\n");
+		(void)netdev_WARN(dev, "failed to disable LRO!\n");
 }
 EXPORT_SYMBOL(dev_disable_lro);
 
@@ -1461,7 +1461,7 @@ void net_enable_timestamp(void)
 		return;
 	}
 #endif
-	WARN_ON(in_interrupt());
+	(void)WARN_ON(in_interrupt());
 	jump_label_inc(&netstamp_needed);
 }
 EXPORT_SYMBOL(net_enable_timestamp);
@@ -1896,7 +1896,7 @@ static void skb_warn_bad_offload(const struct sk_buff *skb)
 	if (dev && dev->dev.parent)
 		driver = dev_driver_string(dev->dev.parent);
 
-	WARN(1, "%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d "
+	(void)WARN(1, "%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d "
 	     "gso_type=%d ip_summed=%d\n",
 	     driver, dev ? &dev->features : &null_features,
 	     skb->sk ? &skb->sk->sk_route_caps : &null_features,
@@ -3001,7 +3001,7 @@ static void net_tx_action(struct softirq_action *h)
 			struct sk_buff *skb = clist;
 			clist = clist->next;
 
-			WARN_ON(atomic_read(&skb->users));
+			(void)WARN_ON(atomic_read(&skb->users));
 			trace_kfree_skb(skb, net_tx_action);
 			__kfree_skb(skb);
 		}
@@ -3380,7 +3380,7 @@ static int napi_gro_complete(struct sk_buff *skb)
 	rcu_read_unlock();
 
 	if (err) {
-		WARN_ON(&ptype->list == head);
+		(void)WARN_ON(&ptype->list == head);
 		kfree_skb(skb);
 		return NET_RX_SUCCESS;
 	}
@@ -3871,7 +3871,7 @@ static void net_rx_action(struct softirq_action *h)
 			trace_napi_poll(n);
 		}
 
-		WARN_ON_ONCE(work > weight);
+		(void)WARN_ON_ONCE(work > weight);
 
 		budget -= work;
 
@@ -4859,7 +4859,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 
 	case SIOCGIFHWADDR:
 		if (!dev->addr_len)
-			memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
+			(void)memset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);
 		else
 			memcpy(ifr->ifr_hwaddr.sa_data, dev->dev_addr,
 			       min(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));
@@ -4891,7 +4891,7 @@ static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cm
 		/* dev_ioctl() should ensure this case
 		 * is never reached
 		 */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		err = -ENOTTY;
 		break;
 
@@ -5235,7 +5235,7 @@ static void rollback_registered_many(struct list_head *head)
 			pr_debug("unregister_netdevice: device %s/%p never "
 				 "was registered\n", dev->name, dev);
 
-			WARN_ON(1);
+			(void)WARN_ON(1);
 			list_del(&dev->unreg_list);
 			continue;
 		}
@@ -5279,7 +5279,7 @@ static void rollback_registered_many(struct list_head *head)
 			dev->netdev_ops->ndo_uninit(dev);
 
 		/* Notifier chain MUST detach us from master device. */
-		WARN_ON(dev->master);
+		(void)WARN_ON(dev->master);
 
 		/* Remove entries from kobject tree */
 		netdev_unregister_kobject(dev);
@@ -5317,14 +5317,14 @@ static netdev_features_t netdev_fix_features(struct net_device *dev,
 	/* Fix illegal SG+CSUM combinations. */
 	if ((features & NETIF_F_SG) &&
 	    !(features & NETIF_F_ALL_CSUM)) {
-		netdev_dbg(dev,
+		(void)netdev_dbg(dev,
 			"Dropping NETIF_F_SG since no checksum feature.\n");
 		features &= ~NETIF_F_SG;
 	}
 
 	/* TSO requires that SG is present as well. */
 	if ((features & NETIF_F_ALL_TSO) && !(features & NETIF_F_SG)) {
-		netdev_dbg(dev, "Dropping TSO features since no SG feature.\n");
+		(void)netdev_dbg(dev, "Dropping TSO features since no SG feature.\n");
 		features &= ~NETIF_F_ALL_TSO;
 	}
 
@@ -5334,7 +5334,7 @@ static netdev_features_t netdev_fix_features(struct net_device *dev,
 
 	/* Software GSO depends on SG. */
 	if ((features & NETIF_F_GSO) && !(features & NETIF_F_SG)) {
-		netdev_dbg(dev, "Dropping NETIF_F_GSO since no SG feature.\n");
+		(void)netdev_dbg(dev, "Dropping NETIF_F_GSO since no SG feature.\n");
 		features &= ~NETIF_F_GSO;
 	}
 
@@ -5344,13 +5344,13 @@ static netdev_features_t netdev_fix_features(struct net_device *dev,
 		if (!((features & NETIF_F_GEN_CSUM) ||
 		    (features & (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))
 			    == (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))) {
-			netdev_dbg(dev,
+			(void)netdev_dbg(dev,
 				"Dropping NETIF_F_UFO since no checksum offload features.\n");
 			features &= ~NETIF_F_UFO;
 		}
 
 		if (!(features & NETIF_F_SG)) {
-			netdev_dbg(dev,
+			(void)netdev_dbg(dev,
 				"Dropping NETIF_F_UFO since no NETIF_F_SG feature.\n");
 			features &= ~NETIF_F_UFO;
 		}
@@ -5377,7 +5377,7 @@ int __netdev_update_features(struct net_device *dev)
 	if (dev->features == features)
 		return 0;
 
-	netdev_dbg(dev, "Features changed: %pNF -> %pNF\n",
+	(void)netdev_dbg(dev, "Features changed: %pNF -> %pNF\n",
 		&dev->features, &features);
 
 	if (dev->netdev_ops->ndo_set_features)
@@ -5650,7 +5650,7 @@ int init_dummy_netdev(struct net_device *dev)
 	 * NAPI code and this dummy netdev is supposed to be
 	 * only ever used for NAPI polls
 	 */
-	memset(dev, 0, sizeof(struct net_device));
+	(void)memset(dev, 0, sizeof(struct net_device));
 
 	/* make sure we BUG if trying to hit standard
 	 * register/unregister code path
@@ -5821,15 +5821,15 @@ void netdev_run_todo(void)
 
 		dev->reg_state = NETREG_UNREGISTERED;
 
-		on_each_cpu(flush_backlog, dev, 1);
+		(void)on_each_cpu(flush_backlog, dev, 1);
 
 		netdev_wait_allrefs(dev);
 
 		/* paranoia */
 		BUG_ON(netdev_refcnt_read(dev));
-		WARN_ON(rcu_access_pointer(dev->ip_ptr));
-		WARN_ON(rcu_access_pointer(dev->ip6_ptr));
-		WARN_ON(dev->dn_ptr);
+		(void)WARN_ON(rcu_access_pointer(dev->ip_ptr));
+		(void)WARN_ON(rcu_access_pointer(dev->ip6_ptr));
+		(void)WARN_ON(dev->dn_ptr);
 
 		if (dev->destructor)
 			dev->destructor(dev);
@@ -5876,7 +5876,7 @@ struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,
 	const struct net_device_ops *ops = dev->netdev_ops;
 
 	if (ops->ndo_get_stats64) {
-		memset(storage, 0, sizeof(*storage));
+		(void)memset(storage, 0, sizeof(*storage));
 		ops->ndo_get_stats64(dev, storage);
 	} else if (ops->ndo_get_stats) {
 		netdev_stats_to_stats64(storage, ops->ndo_get_stats(dev));
@@ -6228,7 +6228,7 @@ int dev_change_net_namespace(struct net_device *dev, struct net *net, const char
 
 	/* Fixup kobjects */
 	err = device_rename(&dev->dev, dev->name);
-	WARN_ON(err);
+	(void)WARN_ON(err);
 
 	/* Add the device back in the hashes */
 	list_netdevice(dev);
@@ -6561,7 +6561,7 @@ static int __init net_dev_init(void)
 	for_each_possible_cpu(i) {
 		struct softnet_data *sd = &per_cpu(softnet_data, i);
 
-		memset(sd, 0, sizeof(*sd));
+		(void)memset(sd, 0, sizeof(*sd));
 		skb_queue_head_init(&sd->input_pkt_queue);
 		skb_queue_head_init(&sd->process_queue);
 		sd->completion_queue = NULL;
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index e287346..9680099 100644
--- net/core/neighbour.c
+++ net/core/neighbour.c
@@ -2872,7 +2872,7 @@
 	if (dev) {
 		dev_name_source = dev->name;
 		/* Terminate the table early */
-		memset(&t->neigh_vars[NEIGH_VAR_GC_INTERVAL], 0,
+		(void)memset(&t->neigh_vars[NEIGH_VAR_GC_INTERVAL], 0,
 		       sizeof(t->neigh_vars[NEIGH_VAR_GC_INTERVAL]));
 	} else {
 		dev_name_source = neigh_path[NEIGH_CTL_PATH_DEV].procname;
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 2dbb32b..45163b8 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -420,7 +420,7 @@ static void __packet_set_status(struct packet_sock *po, void *frame, int status)
 		break;
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 	}
 
@@ -447,7 +447,7 @@ static int __packet_get_status(struct packet_sock *po, void *frame)
 		return h.h2->tp_status;
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 		return 0;
 	}
@@ -588,7 +588,7 @@ static void init_prb_bdqc(struct packet_sock *po,
 	struct tpacket_kbdq_core *p1 = &rb->prb_bdqc;
 	struct tpacket_block_desc *pbd;
 
-	memset(p1, 0x0, sizeof(*p1));
+	(void)memset(p1, 0x0, sizeof(*p1));
 
 	p1->knxt_seq_num = 1;
 	p1->pkbdq = pg_vec;
@@ -840,7 +840,7 @@ static void prb_open_block(struct tpacket_kbdq_core *pkc1,
 		return;
 	}
 
-	WARN(1, "ERROR block:%p is NOT FREE status:%d kactive_blk_num:%d\n",
+	(void)WARN(1, "ERROR block:%p is NOT FREE status:%d kactive_blk_num:%d\n",
 		pbd1, BLOCK_STATUS(pbd1), pkc1->kactive_blk_num);
 	dump_stack();
 	BUG();
@@ -935,7 +935,7 @@ static void prb_retire_current_block(struct tpacket_kbdq_core *pkc,
 		return;
 	}
 
-	WARN(1, "ERROR-pbd[%d]:%p\n", pkc->kactive_blk_num, pbd);
+	(void)WARN(1, "ERROR-pbd[%d]:%p\n", pkc->kactive_blk_num, pbd);
 	dump_stack();
 	BUG();
 }
@@ -1085,7 +1085,7 @@ static void *packet_current_rx_frame(struct packet_sock *po,
 	case TPACKET_V3:
 		return __packet_lookup_frame_in_block(po, skb, status, len);
 	default:
-		WARN(1, "TPACKET version not supported\n");
+		(void)WARN(1, "TPACKET version not supported\n");
 		BUG();
 		return 0;
 	}
@@ -1142,7 +1142,7 @@ static void packet_increment_rx_head(struct packet_sock *po,
 		return packet_increment_head(rb);
 	case TPACKET_V3:
 	default:
-		WARN(1, "TPACKET version not supported.\n");
+		(void)WARN(1, "TPACKET version not supported.\n");
 		BUG();
 		return;
 	}
@@ -1165,8 +1165,8 @@ static void packet_sock_destruct(struct sock *sk)
 {
 	skb_queue_purge(&sk->sk_error_queue);
 
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+	(void)WARN_ON(atomic_read(&sk->sk_wmem_alloc));
 
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		pr_err("Attempt to release alive packet socket: %p\n", sk);
@@ -2419,7 +2419,7 @@ static int packet_release(struct socket *sock)
 
 	packet_flush_mclist(sk);
 
-	memset(&req_u, 0, sizeof(req_u));
+	(void)memset(&req_u, 0, sizeof(req_u));
 
 	if (po->rx_ring.pg_vec)
 		packet_set_ring(sk, &req_u, 1, 0);
@@ -2834,7 +2834,7 @@ static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,
 	if (dev)
 		strncpy(uaddr->sa_data, dev->name, 14);
 	else
-		memset(uaddr->sa_data, 0, 14);
+		(void)memset(uaddr->sa_data, 0, 14);
 	rcu_read_unlock();
 	*uaddr_len = sizeof(*uaddr);
 
@@ -3030,7 +3030,7 @@ packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv
 	{
 		struct packet_mreq_max mreq;
 		int len = optlen;
-		memset(&mreq, 0, sizeof(mreq));
+		(void)memset(&mreq, 0, sizeof(mreq));
 		if (len < sizeof(struct packet_mreq))
 			return -EINVAL;
 		if (len > sizeof(mreq))
@@ -3238,7 +3238,7 @@ static int packet_getsockopt(struct socket *sock, int level, int optname,
 			st.tp_packets += st.tp_drops;
 			data = &st;
 		}
-		memset(&po->stats, 0, sizeof(st));
+		(void)memset(&po->stats, 0, sizeof(st));
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
 		break;
 	case PACKET_AUXDATA:
@@ -3574,7 +3574,7 @@ static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
 
 	/* Opening a Tx-ring is NOT supported in TPACKET_V3 */
 	if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
-		WARN(1, "Tx-ring is not supported.\n");
+		(void)WARN(1, "Tx-ring is not supported.\n");
 		goto out;
 	}
 
diff --git a/net/ipv4/inetpeer.c b/net/ipv4/inetpeer.c
index bf4a9c4..b56eb06 100644
--- a/net/ipv4/inetpeer.c
+++ b/net/ipv4/inetpeer.c
@@ -448,7 +448,7 @@ relookup:
 		p->pmtu_expires = 0;
 		p->pmtu_orig = 0;
 		p->redirect_genid = 0;
-		memset(&p->redirect_learned, 0, sizeof(p->redirect_learned));
+		(void)memset(&p->redirect_learned, 0, sizeof(p->redirect_learned));
 
 
 		/* Link the node. */
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 1f23a57..cb702b9 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -708,7 +708,7 @@ struct sk_buff *ip_check_defrag(struct sk_buff *skb, u32 user)
 		if (skb) {
 			if (pskb_trim_rcsum(skb, len))
 				return skb;
-			memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+			(void)memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 			if (ip_defrag(skb, user))
 				return NULL;
 			skb->rxhash = 0;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 7661576..dae38ad 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -1351,7 +1351,7 @@ static inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)
 	xdst = dst_alloc(dst_ops, NULL, 0, 0, 0);
 
 	if (likely(xdst)) {
-		memset(&xdst->u.rt6.rt6i_table, 0,
+		(void)memset(&xdst->u.rt6.rt6i_table, 0,
 			sizeof(*xdst) - sizeof(struct dst_entry));
 		xdst->flo.ops = &xfrm_bundle_fc_ops;
 	} else
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 62f4fb3..a722ea6 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -510,7 +510,7 @@ int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 	ns = ops->namespace(kobj, attr);
 out:
 	if (err) {
-		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
+		(void)WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 		     "kobject: %s\n", kobject_name(kobj));
 	}
 	*pns = ns;
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 7fdf6a7..038f4e6 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -373,7 +373,7 @@ struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)
 void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 		       struct sysfs_dirent *parent_sd)
 {
-	memset(acxt, 0, sizeof(*acxt));
+	(void)memset(acxt, 0, sizeof(*acxt));
 	acxt->parent_sd = parent_sd;
 
 	mutex_lock(&sysfs_mutex);
@@ -404,7 +404,7 @@ int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
 	struct sysfs_inode_attrs *ps_iattr;
 
 	if (!!sysfs_ns_type(acxt->parent_sd) != !!sd->s_ns) {
-		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+		(void)WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 			sysfs_ns_type(acxt->parent_sd)? "required": "invalid",
 			acxt->parent_sd->s_name, sd->s_name);
 		return -EINVAL;
@@ -474,7 +474,7 @@ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
 	ret = __sysfs_add_one(acxt, sd);
 	if (ret == -EEXIST) {
 		char *path = kzalloc(PATH_MAX, GFP_KERNEL);
-		WARN(1, KERN_WARNING
+		(void)WARN(1, KERN_WARNING
 		     "sysfs: cannot create duplicate filename '%s'\n",
 		     (path == NULL) ? sd->s_name :
 		     strcat(strcat(sysfs_pathname(acxt->parent_sd, path), "/"),
@@ -569,7 +569,7 @@ struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 	struct sysfs_dirent *found = NULL;
 
 	if (!!sysfs_ns_type(parent_sd) != !!ns) {
-		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+		(void)WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 			sysfs_ns_type(parent_sd)? "required": "invalid",
 			parent_sd->s_name, name);
 		return NULL;
diff --git a/fs/locks.c b/fs/locks.c
index 637694b..9a0f6b5 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -223,7 +223,7 @@ EXPORT_SYMBOL(locks_free_lock);
 
 void locks_init_lock(struct file_lock *fl)
 {
-	memset(fl, 0, sizeof(struct file_lock));
+	(void)memset(fl, 0, sizeof(struct file_lock));
 	locks_init_lock_heads(fl);
 }
 
diff --git a/fs/jffs2/super.c b/fs/jffs2/super.c
index f2d96b5..d6b7628 100644
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@ -91,7 +91,7 @@ static const char *jffs2_compr_name(unsigned int compr)
 #endif
 	default:
 		/* should never happen; programmer error */
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		return "";
 	}
 }
diff --git a/fs/super.c b/fs/super.c
index 6015c02..5683f4d 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -201,7 +201,7 @@ static inline void destroy_super(struct super_block *s)
 	free_percpu(s->s_files);
 #endif
 	security_sb_free(s);
-	WARN_ON(!list_empty(&s->s_mounts));
+	(void)WARN_ON(!list_empty(&s->s_mounts));
 	kfree(s->s_subtype);
 	kfree(s->s_options);
 	kfree(s);
@@ -738,7 +738,7 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 			if (!force)
 				goto cancel_readonly;
 			/* If forced remount, go ahead despite any errors */
-			WARN(1, "forced remount of a %s fs returned %i\n",
+			(void)WARN(1, "forced remount of a %s fs returned %i\n",
 			     sb->s_type->name, retval);
 		}
 	}
@@ -1027,7 +1027,7 @@ void kill_block_super(struct super_block *sb)
 	bdev->bd_super = NULL;
 	generic_shutdown_super(sb);
 	sync_blockdev(bdev);
-	WARN_ON_ONCE(!(mode & FMODE_EXCL));
+	(void)WARN_ON_ONCE(!(mode & FMODE_EXCL));
 	blkdev_put(bdev, mode | FMODE_EXCL);
 }
 
@@ -1111,8 +1111,8 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	}
 	sb = root->d_sb;
 	BUG_ON(!sb);
-	WARN_ON(!sb->s_bdi);
-	WARN_ON(sb->s_bdi == &default_backing_dev_info);
+	(void)WARN_ON(!sb->s_bdi);
+	(void)WARN_ON(sb->s_bdi == &default_backing_dev_info);
 	sb->s_flags |= MS_BORN;
 
 	error = security_sb_kern_mount(sb, flags, secdata);
@@ -1125,7 +1125,7 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	 * this warning for a little while to try and catch filesystems that
 	 * violate this rule.
 	 */
-	WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
+	(void)WARN((sb->s_maxbytes < 0), "%s set sb->s_maxbytes to "
 		"negative value (%lld)\n", type->name, sb->s_maxbytes);
 
 	up_write(&sb->s_umount);
diff --git a/fs/inode.c b/fs/inode.c
index fb10d86..ea1e773 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -244,7 +244,7 @@ void __destroy_inode(struct inode *inode)
 	security_inode_free(inode);
 	fsnotify_inode_delete(inode);
 	if (!inode->i_nlink) {
-		WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
+		(void)WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
 		atomic_long_dec(&inode->i_sb->s_remove_count);
 	}
 
@@ -287,7 +287,7 @@ static void destroy_inode(struct inode *inode)
  */
 void drop_nlink(struct inode *inode)
 {
-	WARN_ON(inode->i_nlink == 0);
+	(void)WARN_ON(inode->i_nlink == 0);
 	inode->__i_nlink--;
 	if (!inode->i_nlink)
 		atomic_long_inc(&inode->i_sb->s_remove_count);
@@ -352,7 +352,7 @@ EXPORT_SYMBOL(inc_nlink);
 
 void address_space_init_once(struct address_space *mapping)
 {
-	memset(mapping, 0, sizeof(*mapping));
+	(void)memset(mapping, 0, sizeof(*mapping));
 	INIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);
 	spin_lock_init(&mapping->tree_lock);
 	mutex_init(&mapping->i_mmap_mutex);
@@ -370,7 +370,7 @@ EXPORT_SYMBOL(address_space_init_once);
  */
 void inode_init_once(struct inode *inode)
 {
-	memset(inode, 0, sizeof(*inode));
+	(void)memset(inode, 0, sizeof(*inode));
 	INIT_HLIST_NODE(&inode->i_hash);
 	INIT_LIST_HEAD(&inode->i_devices);
 	INIT_LIST_HEAD(&inode->i_wb_list);
@@ -403,7 +403,7 @@ void __iget(struct inode *inode)
  */
 void ihold(struct inode *inode)
 {
-	WARN_ON(atomic_inc_return(&inode->i_count) < 2);
+	(void)WARN_ON(atomic_inc_return(&inode->i_count) < 2);
 }
 EXPORT_SYMBOL(ihold);
 
@@ -760,7 +760,7 @@ void prune_icache_sb(struct super_block *sb, int nr_to_scan)
 				continue;
 			}
 		}
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state |= I_FREEING;
 		spin_unlock(&inode->i_lock);
 
@@ -964,7 +964,7 @@ void unlock_new_inode(struct inode *inode)
 {
 	lockdep_annotate_inode_mutex_key(inode);
 	spin_lock(&inode->i_lock);
-	WARN_ON(!(inode->i_state & I_NEW));
+	(void)WARN_ON(!(inode->i_state & I_NEW));
 	inode->i_state &= ~I_NEW;
 	wake_up_bit(&inode->i_state, __I_NEW);
 	spin_unlock(&inode->i_lock);
@@ -1395,7 +1395,7 @@ static void iput_final(struct inode *inode)
 	const struct super_operations *op = inode->i_sb->s_op;
 	int drop;
 
-	WARN_ON(inode->i_state & I_NEW);
+	(void)WARN_ON(inode->i_state & I_NEW);
 
 	if (op->drop_inode)
 		drop = op->drop_inode(inode);
@@ -1415,7 +1415,7 @@ static void iput_final(struct inode *inode)
 		spin_unlock(&inode->i_lock);
 		write_inode_now(inode, 1);
 		spin_lock(&inode->i_lock);
-		WARN_ON(inode->i_state & I_NEW);
+		(void)WARN_ON(inode->i_state & I_NEW);
 		inode->i_state &= ~I_WILL_FREE;
 	}
 
diff --git a/fs/nfs/nfs3proc.c b/fs/nfs/nfs3proc.c
index 9194395..4f328eb 100644
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -33,7 +33,7 @@ nfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EJUKEBOX && res != -EKEYEXPIRED)
 			break;
-		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		(void)freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index f649fba..95ecd05 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -316,16 +316,16 @@ nfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)
 		else
 			init_special_inode(inode, inode->i_mode, fattr->rdev);
 
-		memset(&inode->i_atime, 0, sizeof(inode->i_atime));
-		memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
-		memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
+		(void)memset(&inode->i_atime, 0, sizeof(inode->i_atime));
+		(void)memset(&inode->i_mtime, 0, sizeof(inode->i_mtime));
+		(void)memset(&inode->i_ctime, 0, sizeof(inode->i_ctime));
 		inode->i_version = 0;
 		inode->i_size = 0;
 		clear_nlink(inode);
 		inode->i_uid = -2;
 		inode->i_gid = -2;
 		inode->i_blocks = 0;
-		memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
+		(void)memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));
 
 		nfsi->read_cache_jiffies = fattr->time_start;
 		nfsi->attr_gencount = fattr->gencount;
diff --git a/mm/vmscan.c b/mm/vmscan.c
index c52b235..ed37cdb 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -293,7 +293,7 @@ unsigned long shrink_slab(struct shrink_control *shrink,
 		total_scan = nr;
 		delta = (4 * nr_pages_scanned) / shrinker->seeks;
 		delta *= max_pass;
-		do_div(delta, lru_pages + 1);
+		(void)do_div(delta, lru_pages + 1);
 		total_scan += delta;
 		if (total_scan < 0) {
 			printk(KERN_ERR "shrink_slab: %pF negative objects to "
diff --git a/mm/memblock.c b/mm/memblock.c
index 2f55f19..1e1f25c 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -174,7 +174,7 @@ static void __init_memblock memblock_remove_region(struct memblock_type *type, u
 
 	/* Special case for empty arrays */
 	if (type->cnt == 0) {
-		WARN_ON(type->total_size != 0);
+		(void)WARN_ON(type->total_size != 0);
 		type->cnt = 1;
 		type->regions[0].base = 0;
 		type->regions[0].size = 0;
@@ -229,7 +229,7 @@ static int __init_memblock memblock_double_array(struct memblock_type *type)
 	 * array itself that is full.
 	 */
 	memcpy(new_array, type->regions, old_size);
-	memset(new_array + type->max, 0, old_size);
+	(void)memset(new_array + type->max, 0, old_size);
 	old_array = type->regions;
 	type->regions = new_array;
 	type->max <<= 1;
@@ -332,7 +332,7 @@ static int __init_memblock memblock_add_region(struct memblock_type *type,
 
 	/* special case for empty array */
 	if (type->regions[0].size == 0) {
-		WARN_ON(type->cnt != 1 || type->total_size);
+		(void)WARN_ON(type->cnt != 1 || type->total_size);
 		type->regions[0].base = base;
 		type->regions[0].size = size;
 		memblock_set_region_node(&type->regions[0], nid);
diff --git a/mm/truncate.c b/mm/truncate.c
index 632b15e..a65fdce 100644
--- a/mm/truncate.c
+++ b/mm/truncate.c
@@ -235,7 +235,7 @@ void truncate_inode_pages_range(struct address_space *mapping,
 
 			if (!trylock_page(page))
 				continue;
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			if (PageWriteback(page)) {
 				unlock_page(page);
 				continue;
@@ -283,7 +283,7 @@ void truncate_inode_pages_range(struct address_space *mapping,
 				break;
 
 			lock_page(page);
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			wait_on_page_writeback(page);
 			truncate_inode_page(mapping, page);
 			unlock_page(page);
@@ -358,7 +358,7 @@ unsigned long invalidate_mapping_pages(struct address_space *mapping,
 
 			if (!trylock_page(page))
 				continue;
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			ret = invalidate_inode_page(page);
 			unlock_page(page);
 			/*
@@ -459,7 +459,7 @@ int invalidate_inode_pages2_range(struct address_space *mapping,
 				break;
 
 			lock_page(page);
-			WARN_ON(page->index != index);
+			(void)WARN_ON(page->index != index);
 			if (page->mapping != mapping) {
 				unlock_page(page);
 				continue;
diff --git a/mm/filemap.c b/mm/filemap.c
index 97f49ed..5eca728 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -835,7 +835,7 @@ repeat:
 				 * when entry at index 0 moves out of or back
 				 * to root: none yet gotten, safe to restart.
 				 */
-				WARN_ON(start | i);
+				(void)WARN_ON(start | i);
 				goto restart;
 			}
 			/*
diff --git a/mm/dmapool.c b/mm/dmapool.c
index c5ab33b..2e1d5e0 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -501,7 +501,7 @@ void dmam_pool_destroy(struct dma_pool *pool)
 {
 	struct device *dev = pool->dev;
 
-	WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
+	(void)WARN_ON(devres_destroy(dev, dmam_pool_release, dmam_pool_match, pool));
 	dma_pool_destroy(pool);
 }
 EXPORT_SYMBOL(dmam_pool_destroy);
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 363ba70..8acc410 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -753,7 +753,7 @@ static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,
 	bw = written - bdi->written_stamp;
 	bw *= HZ;
 	if (unlikely(elapsed > period)) {
-		do_div(bw, elapsed);
+		(void)do_div(bw, elapsed);
 		avg = bw;
 		goto out;
 	}
diff --git a/kernel/signal.c b/kernel/signal.c
index c73c428..d4e07db 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -324,7 +324,7 @@ static bool task_participate_group_stop(struct task_struct *task)
 	struct signal_struct *sig = task->signal;
 	bool consume = task->jobctl & JOBCTL_STOP_CONSUME;
 
-	WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));
+	(void)WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));
 
 	task_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);
 
@@ -838,7 +838,7 @@ static int check_kill_permission(int sig, struct siginfo *info,
  */
 static void ptrace_trap_notify(struct task_struct *t)
 {
-	WARN_ON_ONCE(!(t->ptrace & PT_SEIZED));
+	(void)WARN_ON_ONCE(!(t->ptrace & PT_SEIZED));
 	assert_spin_locked(&t->sighand->siglock);
 
 	task_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);
@@ -1949,7 +1949,7 @@ static void ptrace_do_notify(int signr, int exit_code, int why)
 {
 	siginfo_t info;
 
-	memset(&info, 0, sizeof info);
+	(void)memset(&info, 0, sizeof info);
 	info.si_signo = signr;
 	info.si_code = exit_code;
 	info.si_pid = task_pid_vnr(current);
@@ -2000,7 +2000,7 @@ static bool do_signal_stop(int signr)
 		struct task_struct *t;
 
 		/* signr will be recorded in task->jobctl for retries */
-		WARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);
+		(void)WARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);
 
 		if (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||
 		    unlikely(signal_group_exit(sig)))
@@ -2116,11 +2116,11 @@ static void do_jobctl_trap(void)
 		if (!signal->group_stop_count &&
 		    !(signal->flags & SIGNAL_STOP_STOPPED))
 			signr = SIGTRAP;
-		WARN_ON_ONCE(!signr);
+		(void)WARN_ON_ONCE(!signr);
 		ptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),
 				 CLD_STOPPED);
 	} else {
-		WARN_ON_ONCE(!signr);
+		(void)WARN_ON_ONCE(!signr);
 		ptrace_stop(signr, CLD_STOPPED, 0, NULL);
 		current->exit_code = 0;
 	}
@@ -2910,7 +2910,7 @@ SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,
 	 */
 	if (info.si_code >= 0 || info.si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info.si_code < 0);
+		(void)WARN_ON_ONCE(info.si_code < 0);
 		return -EPERM;
 	}
 	info.si_signo = sig;
@@ -2930,7 +2930,7 @@ long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 	 */
 	if (info->si_code >= 0 || info->si_code == SI_TKILL) {
 		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info->si_code < 0);
+		(void)WARN_ON_ONCE(info->si_code < 0);
 		return -EPERM;
 	}
 	info->si_signo = sig;
diff --git a/kernel/exit.c b/kernel/exit.c
index 294b170..8b137c6 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -894,7 +894,7 @@ void do_exit(long code)
 
 	profile_task_exit(tsk);
 
-	WARN_ON(blk_needs_flush_plug(tsk));
+	(void)WARN_ON(blk_needs_flush_plug(tsk));
 
 	if (unlikely(in_interrupt()))
 		panic("Aiee, killing interrupt handler!");
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 62f4fb3..a722ea6 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -339,7 +339,7 @@ static int sysfs_open_file(struct inode *inode, struct file *file)
 	if (kobj->ktype && kobj->ktype->sysfs_ops)
 		ops = kobj->ktype->sysfs_ops;
 	else {
-		WARN(1, KERN_ERR "missing sysfs attribute operations for "
+		(void)WARN(1, KERN_ERR "missing sysfs attribute operations for "
 		       "kobject: %s\n", kobject_name(kobj));
 		goto err_out;
 	}
@@ -510,7 +510,7 @@ int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 	ns = ops->namespace(kobj, attr);
 out:
 	if (err) {
-		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
+		(void)WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 		     "kobject: %s\n", kobject_name(kobj));
 	}
 	*pns = ns;
diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index 0c672588..c4daf72 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -60,7 +60,7 @@ nfs_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EKEYEXPIRED)
 			break;
-		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		(void)freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
diff --git a/fs/xattr.c b/fs/xattr.c
index 82f4337..24570cc 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -198,7 +198,7 @@ vfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,
 		value = krealloc(*xattr_value, error + 1, flags);
 		if (!value)
 			return -ENOMEM;
-		memset(value, 0, error + 1);
+		(void)memset(value, 0, error + 1);
 	}
 
 	error = inode->i_op->getxattr(dentry, name, value, error);
diff --git a/fs/namespace.c b/fs/namespace.c
index e608199..46a6601 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -792,7 +792,7 @@ static inline void mntfree(struct mount *mnt)
 	 * The locking used to deal with mnt_count decrement provides barriers,
 	 * so mnt_get_writers() below is safe.
 	 */
-	WARN_ON(mnt_get_writers(mnt));
+	(void)WARN_ON(mnt_get_writers(mnt));
 	fsnotify_vfsmount_delete(m);
 	dput(m->mnt_root);
 	free_vfsmnt(mnt);
@@ -2048,7 +2048,7 @@ static long exact_copy_from_user(void *to, const void __user * from,
 
 	while (n) {
 		if (__get_user(c, f)) {
-			memset(t, 0, n);
+			(void)memset(t, 0, n);
 			break;
 		}
 		*t++ = c;
@@ -2086,7 +2086,7 @@ int copy_mount_options(const void __user * data, unsigned long *where)
 		return -EFAULT;
 	}
 	if (i != PAGE_SIZE)
-		memset((char *)page + i, 0, PAGE_SIZE - i);
+		(void)memset((char *)page + i, 0, PAGE_SIZE - i);
 	*where = page;
 	return 0;
 }
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 2edf34f..7bde9be 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -619,7 +619,7 @@ static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
 	ent = kmalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
 	if (!ent) goto out;
 
-	memset(ent, 0, sizeof(struct proc_dir_entry));
+	(void)memset(ent, 0, sizeof(struct proc_dir_entry));
 	memcpy(ent->name, fn, len + 1);
 	ent->namelen = len;
 	ent->mode = mode;
diff --git a/drivers/input/mouse/logips2pp.c b/drivers/input/mouse/logips2pp.c
index 84de2fc..28211fc 100644
--- a/drivers/input/mouse/logips2pp.c
+++ b/drivers/input/mouse/logips2pp.c
@@ -83,7 +83,7 @@ static psmouse_ret_t ps2pp_process_byte(struct psmouse *psmouse)
 			break;
 
 		default:
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "Received PS2++ packet #%x, but don't know how to handle.\n",
 				    (packet[1] >> 4) | (packet[0] & 0x30));
 			break;
diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c
index bd87380..cd32a08 100644
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@ -397,7 +397,7 @@ static void alps_process_trackstick_packet_v3(struct psmouse *psmouse)
 
 	/* Sanity check packet */
 	if (!(packet[0] & 0x40)) {
-		psmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");
+		(void)psmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");
 		return;
 	}
 
@@ -705,7 +705,7 @@ static psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)
 		      psmouse->packet[4] |
 		      psmouse->packet[5]) & 0x80) ||
 		    (!alps_is_valid_first_byte(priv->i, psmouse->packet[6]))) {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "refusing packet %x %x %x %x (suspected interleaved ps/2)\n",
 				    psmouse->packet[3], psmouse->packet[4],
 				    psmouse->packet[5], psmouse->packet[6]);
@@ -769,7 +769,7 @@ static void alps_flush_packet(unsigned long data)
 		if ((psmouse->packet[3] |
 		     psmouse->packet[4] |
 		     psmouse->packet[5]) & 0x80) {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "refusing packet %x %x %x (suspected interleaved ps/2)\n",
 				    psmouse->packet[3], psmouse->packet[4],
 				    psmouse->packet[5]);
@@ -804,7 +804,7 @@ static psmouse_ret_t alps_process_byte(struct psmouse *psmouse)
 	}
 
 	if (!alps_is_valid_first_byte(model, psmouse->packet[0])) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",
 			    psmouse->packet[0], model->mask0, model->byte0);
 		return PSMOUSE_BAD_DATA;
@@ -813,7 +813,7 @@ static psmouse_ret_t alps_process_byte(struct psmouse *psmouse)
 	/* Bytes 2 - pktsize should have 0 in the highest bit */
 	if (psmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&
 	    (psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {
-		psmouse_dbg(psmouse, "refusing packet[%i] = %x\n",
+		(void)psmouse_dbg(psmouse, "refusing packet[%i] = %x\n",
 			    psmouse->pktcnt - 1,
 			    psmouse->packet[psmouse->pktcnt - 1]);
 		return PSMOUSE_BAD_DATA;
@@ -923,7 +923,7 @@ static int alps_enter_command_mode(struct psmouse *psmouse,
 	}
 
 	if (param[0] != 0x88 && param[1] != 0x07) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "unknown response while entering command mode: %2.2x %2.2x %2.2x\n",
 			    param[0], param[1], param[2]);
 		return -1;
@@ -965,7 +965,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return NULL;
 
-	psmouse_dbg(psmouse, "E6 report: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "E6 report: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	if (param[0] != 0 || param[1] != 0 || (param[2] != 10 && param[2] != 100))
@@ -986,7 +986,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 	if (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return NULL;
 
-	psmouse_dbg(psmouse, "E7 report: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "E7 report: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	if (version) {
@@ -1023,7 +1023,7 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 			alps_exit_command_mode(psmouse);
 
 			if (!model)
-				psmouse_dbg(psmouse,
+				(void)psmouse_dbg(psmouse,
 					    "Unknown command mode response %2.2x\n",
 					    param[0]);
 		}
@@ -1084,7 +1084,7 @@ static int alps_get_status(struct psmouse *psmouse, char *param)
 	    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
 		return -1;
 
-	psmouse_dbg(psmouse, "Status: %2.2x %2.2x %2.2x",
+	(void)psmouse_dbg(psmouse, "Status: %2.2x %2.2x %2.2x",
 		    param[0], param[1], param[2]);
 
 	return 0;
@@ -1264,7 +1264,7 @@ static int alps_hw_init_v3(struct psmouse *psmouse)
 		    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {
 			psmouse_warn(psmouse, "trackstick E7 report failed\n");
 		} else {
-			psmouse_dbg(psmouse,
+			(void)psmouse_dbg(psmouse,
 				    "trackstick E7 report: %2.2x %2.2x %2.2x\n",
 				    param[0], param[1], param[2]);
 
diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c
index 8081a0a..dec924a 100644
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@ -476,7 +476,7 @@ static int synaptics_parse_hw_state(const unsigned char buf[],
 				    struct synaptics_data *priv,
 				    struct synaptics_hw_state *hw)
 {
-	memset(hw, 0, sizeof(struct synaptics_hw_state));
+	(void)memset(hw, 0, sizeof(struct synaptics_hw_state));
 
 	if (SYN_MODEL_NEWABS(priv->model_id)) {
 		hw->w = (((buf[0] & 0x30) >> 2) |
@@ -1306,7 +1306,7 @@ static int synaptics_reconnect(struct psmouse *psmouse)
 		return -1;
 
 	if (retry > 1)
-		psmouse_dbg(psmouse, "reconnected after %d tries\n", retry);
+		(void)psmouse_dbg(psmouse, "reconnected after %d tries\n", retry);
 
 	if (synaptics_query_hardware(psmouse)) {
 		psmouse_err(psmouse, "Unable to query device.\n");
diff --git a/drivers/input/mouse/psmouse-base.c b/drivers/input/mouse/psmouse-base.c
index e6c9931..421c062 100644
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@ -654,11 +654,11 @@ static void psmouse_apply_defaults(struct psmouse *psmouse)
 {
 	struct input_dev *input_dev = psmouse->dev;
 
-	memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
-	memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
-	memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
-	memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
-	memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
+	(void)memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
+	(void)memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
+	(void)memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
+	(void)memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
+	(void)memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
 
 	__set_bit(EV_KEY, input_dev->evbit);
 	__set_bit(EV_REL, input_dev->evbit);
@@ -1015,7 +1015,7 @@ static const struct psmouse_protocol *psmouse_protocol_by_type(enum psmouse_type
 		if (psmouse_protocols[i].type == type)
 			return &psmouse_protocols[i];
 
-	WARN_ON(1);
+	(void)WARN_ON(1);
 	return &psmouse_protocols[0];
 }
 
@@ -1472,7 +1472,7 @@ static int psmouse_reconnect(struct serio *serio)
 	int rc = -1;
 
 	if (!drv || !psmouse) {
-		psmouse_dbg(psmouse,
+		(void)psmouse_dbg(psmouse,
 			    "reconnect request, but serio is disconnected, ignoring...\n");
 		return -1;
 	}
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index d29e206..ad64a09 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -128,7 +128,7 @@ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 
 	BUG_ON(!card);
 	BUG_ON(fn > 7);
-	WARN_ON(blksz == 0);
+	(void)WARN_ON(blksz == 0);
 
 	/* sanity check */
 	if (addr & ~0x1FFFF)
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 59b9ba5..c699ddb 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -810,7 +810,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	u8 *ext_csd = NULL;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Set correct bus mode for MMC before attempting init */
 	if (!mmc_host_is_spi(host))
@@ -1429,7 +1429,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	u32 ocr;
 
 	BUG_ON(!host);
-	WARN_ON(!host->claimed);
+	(void)WARN_ON(!host->claimed);
 
 	/* Set correct bus mode for MMC before attempting attach */
 	if (!mmc_host_is_spi(host))
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 0cad48a..8af6caa 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -568,7 +568,7 @@ static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 	if (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))
 		return (u32)-1;
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
+	(void)memset(&cmd, 0, sizeof(struct mmc_command));
 
 	cmd.opcode = SD_APP_SEND_NUM_WR_BLKS;
 	cmd.arg = 0;
@@ -1093,7 +1093,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		(rq_data_dir(req) == WRITE) &&
 		(md->flags & MMC_BLK_REL_WR);
 
-	memset(brq, 0, sizeof(struct mmc_blk_request));
+	(void)memset(brq, 0, sizeof(struct mmc_blk_request));
 	brq->mrq.cmd = &brq->cmd;
 	brq->mrq.data = &brq->data;
 
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 2517547..2acadee 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -175,8 +175,8 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	if (!mq->queue)
 		return -ENOMEM;
 
-	memset(&mq->mqrq_cur, 0, sizeof(mq->mqrq_cur));
-	memset(&mq->mqrq_prev, 0, sizeof(mq->mqrq_prev));
+	(void)memset(&mq->mqrq_cur, 0, sizeof(mq->mqrq_cur));
+	(void)memset(&mq->mqrq_prev, 0, sizeof(mq->mqrq_prev));
 	mq->mqrq_cur = mqrq_cur;
 	mq->mqrq_prev = mqrq_prev;
 	mq->queue->queuedata = mq;
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index a9a907c..f602687 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -663,7 +663,7 @@ done:
 				(margins) ? " with margins" : "",
 				(interlace) ? " interlaced" : "");
 
-			memset(&cvt_mode, 0, sizeof(cvt_mode));
+			(void)memset(&cvt_mode, 0, sizeof(cvt_mode));
 			cvt_mode.xres = xres;
 			cvt_mode.yres = yres;
 			cvt_mode.refresh = (refresh) ? refresh : 60;
@@ -1102,7 +1102,7 @@ const struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,
 	if (specs->max_x && specs->max_y) {
 		struct fb_var_screeninfo var;
 
-		memset(&var, 0, sizeof(struct fb_var_screeninfo));
+		(void)memset(&var, 0, sizeof(struct fb_var_screeninfo));
 		var.xres = (specs->max_x * 7200)/254;
 		var.yres = (specs->max_y * 7200)/254;
 		m = fb_find_best_mode(&var, head);
diff --git a/drivers/base/power/clock_ops.c b/drivers/base/power/clock_ops.c
index 428e55e..d1faa07 100644
--- a/drivers/base/power/clock_ops.c
+++ b/drivers/base/power/clock_ops.c
@@ -43,7 +43,7 @@ static void pm_clk_acquire(struct device *dev, struct pm_clock_entry *ce)
 		ce->status = PCE_STATUS_ERROR;
 	} else {
 		ce->status = PCE_STATUS_ACQUIRED;
-		dev_dbg(dev, "Clock %s managed by runtime PM.\n", ce->con_id);
+		(void)dev_dbg(dev, "Clock %s managed by runtime PM.\n", ce->con_id);
 	}
 }
 
@@ -341,7 +341,7 @@ int pm_clk_suspend(struct device *dev)
 	struct pm_clock_entry *ce;
 	unsigned long flags;
 
-	dev_dbg(dev, "%s()\n", __func__);
+	(void)dev_dbg(dev, "%s()\n", __func__);
 
 	/* If there is no driver, the clocks are already disabled. */
 	if (!psd || !dev->driver)
@@ -367,7 +367,7 @@ int pm_clk_resume(struct device *dev)
 	struct pm_clock_entry *ce;
 	unsigned long flags;
 
-	dev_dbg(dev, "%s()\n", __func__);
+	(void)dev_dbg(dev, "%s()\n", __func__);
 
 	/* If there is no driver, the clocks should remain disabled. */
 	if (!psd || !dev->driver)
@@ -437,7 +437,7 @@ static int pm_clk_notify(struct notifier_block *nb,
 	struct device *dev = data;
 	char **con_id;
 
-	dev_dbg(dev, "%s() %ld\n", __func__, action);
+	(void)dev_dbg(dev, "%s() %ld\n", __func__, action);
 
 	clknb = container_of(nb, struct pm_clk_notifier_block, nb);
 
diff --git a/block/blk.h b/block/blk.h
index 7efd772..4894459 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -222,7 +222,7 @@ void create_io_context_slowpath(struct task_struct *task, gfp_t gfp_mask,
 static inline struct io_context *create_io_context(struct task_struct *task,
 						   gfp_t gfp_mask, int node)
 {
-	WARN_ON_ONCE(irqs_disabled());
+	(void)WARN_ON_ONCE(irqs_disabled());
 	if (unlikely(!task->io_context))
 		create_io_context_slowpath(task, gfp_mask, node);
 	return task->io_context;
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index 524bf96..d681942 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -91,7 +91,7 @@ static __always_inline struct devres * alloc_dr(dr_release_t release,
 	if (unlikely(!dr))
 		return NULL;
 
-	memset(dr, 0, tot_size);
+	(void)memset(dr, 0, tot_size);
 	INIT_LIST_HEAD(&dr->node.entry);
 	dr->node.release = release;
 	return dr;
@@ -519,7 +519,7 @@ void devres_close_group(struct device *dev, void *id)
 	if (grp)
 		add_dr(dev, &grp->node[1]);
 	else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 }
@@ -547,7 +547,7 @@ void devres_remove_group(struct device *dev, void *id)
 		list_del_init(&grp->node[1].entry);
 		devres_log(dev, &grp->node[0], "REM");
 	} else
-		WARN_ON(1);
+		(void)WARN_ON(1);
 
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
 
@@ -585,7 +585,7 @@ int devres_release_group(struct device *dev, void *id)
 
 		cnt = release_nodes(dev, first, end, flags);
 	} else {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		spin_unlock_irqrestore(&dev->devres_lock, flags);
 	}
 
@@ -646,6 +646,6 @@ void devm_kfree(struct device *dev, void *p)
 	int rc;
 
 	rc = devres_destroy(dev, devm_kzalloc_release, devm_kzalloc_match, p);
-	WARN_ON(rc);
+	(void)WARN_ON(rc);
 }
 EXPORT_SYMBOL_GPL(devm_kfree);
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 0c63581..abc3492 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -74,7 +74,7 @@ static void timekeeper_setup_internals(struct clocksource *clock)
 	tmp <<= clock->shift;
 	ntpinterval = tmp;
 	tmp += clock->mult/2;
-	do_div(tmp, clock->mult);
+	(void)do_div(tmp, clock->mult);
 	if (tmp == 0)
 		tmp = 1;
 
@@ -219,7 +219,7 @@ void getnstimeofday(struct timespec *ts)
 	unsigned long seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -242,7 +242,7 @@ ktime_t ktime_get(void)
 	unsigned int seq;
 	s64 secs, nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -275,7 +275,7 @@ void ktime_get_ts(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
@@ -854,7 +854,7 @@ static void timekeeping_adjust(s64 offset)
 	} else /* No adjustment needed */
 		return;
 
-	WARN_ONCE(timekeeper.clock->maxadj &&
+	(void)WARN_ONCE(timekeeper.clock->maxadj &&
 			(timekeeper.mult + adj > timekeeper.clock->mult +
 						timekeeper.clock->maxadj),
 			"Adjusting %s more then 11%% (%ld vs %ld)\n",
@@ -1098,7 +1098,7 @@ void get_monotonic_boottime(struct timespec *ts)
 	unsigned int seq;
 	s64 nsecs;
 
-	WARN_ON(timekeeping_suspended);
+	(void)WARN_ON(timekeeping_suspended);
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147d..456d605 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -230,7 +230,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 	u64 tmp = ((u64)1000000) << shift_constant;
 
 	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
+	(void)do_div(tmp, khz);
 
 	return (u32)tmp;
 }
@@ -256,7 +256,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	u64 tmp = ((u64)1000000000) << shift_constant;
 
 	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
+	(void)do_div(tmp, hz);
 
 	return (u32)tmp;
 }
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index f487f25..1ed87ef 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1985,7 +1985,7 @@ void unregister_sysctl_table(struct ctl_table_header * header)
 	spin_lock(&sysctl_lock);
 	start_unregistering(header);
 	if (!--header->parent->count) {
-		WARN_ON(1);
+		(void)WARN_ON(1);
 		kfree_rcu(header->parent, rcu);
 	}
 	if (!--header->count)
diff --git a/lib/devres.c b/lib/devres.c
index 9676617..d9d62c3 100644
--- a/lib/devres.c
+++ b/lib/devres.c
@@ -79,7 +79,7 @@ EXPORT_SYMBOL(devm_ioremap_nocache);
  */
 void devm_iounmap(struct device *dev, void __iomem *addr)
 {
-	WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
+	(void)WARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,
 			       (void *)addr));
 	iounmap(addr);
 }
@@ -191,7 +191,7 @@ EXPORT_SYMBOL(devm_ioport_map);
 void devm_ioport_unmap(struct device *dev, void __iomem *addr)
 {
 	ioport_unmap(addr);
-	WARN_ON(devres_destroy(dev, devm_ioport_map_release,
+	(void)WARN_ON(devres_destroy(dev, devm_ioport_map_release,
 			       devm_ioport_map_match, (void *)addr));
 }
 EXPORT_SYMBOL(devm_ioport_unmap);
diff --git a/kernel/rcutiny.c b/kernel/rcutiny.c
index 977296d..df20d79 100644
--- a/kernel/rcutiny.c
+++ b/kernel/rcutiny.c
@@ -70,7 +70,7 @@ static void rcu_idle_enter_common(long long oldval)
 		RCU_TRACE(trace_rcu_dyntick("Error on entry: not idle task",
 					    oldval, rcu_dynticks_nesting));
 		ftrace_dump(DUMP_ALL);
-		WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
+		(void)WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
 			  current->pid, current->comm,
 			  idle->pid, idle->comm); /* must be idle task! */
 	}
@@ -104,7 +104,7 @@ void rcu_irq_exit(void)
 	local_irq_save(flags);
 	oldval = rcu_dynticks_nesting;
 	rcu_dynticks_nesting--;
-	WARN_ON_ONCE(rcu_dynticks_nesting < 0);
+	(void)WARN_ON_ONCE(rcu_dynticks_nesting < 0);
 	rcu_idle_enter_common(oldval);
 	local_irq_restore(flags);
 }
@@ -124,7 +124,7 @@ static void rcu_idle_exit_common(long long oldval)
 		RCU_TRACE(trace_rcu_dyntick("Error on exit: not idle task",
 			  oldval, rcu_dynticks_nesting));
 		ftrace_dump(DUMP_ALL);
-		WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
+		(void)WARN_ONCE(1, "Current pid: %d comm: %s / Idle pid: %d comm: %s",
 			  current->pid, current->comm,
 			  idle->pid, idle->comm); /* must be idle task! */
 	}
@@ -140,7 +140,7 @@ void rcu_idle_exit(void)
 
 	local_irq_save(flags);
 	oldval = rcu_dynticks_nesting;
-	WARN_ON_ONCE(oldval != 0);
+	(void)WARN_ON_ONCE(oldval != 0);
 	rcu_dynticks_nesting = DYNTICK_TASK_NESTING;
 	rcu_idle_exit_common(oldval);
 	local_irq_restore(flags);
@@ -157,7 +157,7 @@ void rcu_irq_enter(void)
 	local_irq_save(flags);
 	oldval = rcu_dynticks_nesting;
 	rcu_dynticks_nesting++;
-	WARN_ON_ONCE(rcu_dynticks_nesting == 0);
+	(void)WARN_ON_ONCE(rcu_dynticks_nesting == 0);
 	rcu_idle_exit_common(oldval);
 	local_irq_restore(flags);
 }
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 00ab2ca..338c719 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -157,7 +157,7 @@ int ptrace_check_attach(struct task_struct *child, bool ignore_state)
 		 * does ptrace_unlink() before __exit_signal().
 		 */
 		spin_lock_irq(&child->sighand->siglock);
-		WARN_ON_ONCE(task_is_stopped(child));
+		(void)WARN_ON_ONCE(task_is_stopped(child));
 		if (ignore_state || (task_is_traced(child) &&
 				     !(child->jobctl & JOBCTL_LISTENING)))
 			ret = 0;
diff --git a/kernel/sys.c b/kernel/sys.c
index 4070153..4ceab79 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1284,7 +1284,7 @@ SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->nodename, tmp, len);
-		memset(u->nodename + len, 0, sizeof(u->nodename) - len);
+		(void)memset(u->nodename + len, 0, sizeof(u->nodename) - len);
 		errno = 0;
 	}
 	uts_proc_notify(UTS_PROC_HOSTNAME);
@@ -1335,7 +1335,7 @@ SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
 		struct new_utsname *u = utsname();
 
 		memcpy(u->domainname, tmp, len);
-		memset(u->domainname + len, 0, sizeof(u->domainname) - len);
+		(void)memset(u->domainname + len, 0, sizeof(u->domainname) - len);
 		errno = 0;
 	}
 	uts_proc_notify(UTS_PROC_DOMAINNAME);
@@ -1604,7 +1604,7 @@ static void k_getrusage(struct task_struct *p, int who, struct rusage *r)
 	cputime_t tgutime, tgstime, utime, stime;
 	unsigned long maxrss = 0;
 
-	memset((char *) r, 0, sizeof *r);
+	(void)memset((char *) r, 0, sizeof *r);
 	utime = stime = 0;
 
 	if (who == RUSAGE_THREAD) {
