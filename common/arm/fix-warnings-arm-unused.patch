diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index b2dc2dd..8d962d9 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -685,7 +685,7 @@ void __init gic_init_bases(unsigned int gic_nr, int irq_start,
 	} else
 #endif
 	{			/* Normal, sane GIC... */
-		WARN(percpu_offset,
+		(void)WARN(percpu_offset,
 		     "GIC_NON_BANKED not enabled, ignoring %08x offset!",
 		     percpu_offset);
 		gic->dist_base.common_base = dist_base;
diff --git a/arch/arm/include/asm/uaccess.h b/arch/arm/include/asm/uaccess.h
index b293616..0308934 100644
--- a/arch/arm/include/asm/uaccess.h
+++ b/arch/arm/include/asm/uaccess.h
@@ -406,7 +406,7 @@ static inline unsigned long __must_check copy_from_user(void *to, const void __u
 	if (access_ok(VERIFY_READ, from, n))
 		n = __copy_from_user(to, from, n);
 	else /* security hole - plug it */
-		memset(to, 0, n);
+		(void)memset(to, 0, n);
 	return n;
 }
 
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index 1e9be5d..e82ed1c 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -278,7 +278,7 @@ int module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
 	struct mod_unwind_map maps[ARM_SEC_MAX];
 	int i;
 
-	memset(maps, 0, sizeof(maps));
+	(void)memset(maps, 0, sizeof(maps));
 
 	for (s = sechdrs; s < sechdrs_end; s++) {
 		const char *secname = secstrs + s->sh_name;
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4ee00c8..551d99a 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -247,7 +247,7 @@ void cpu_idle(void)
 				 * functions should always return with IRQs
 				 * enabled.
 				 */
-				WARN_ON(irqs_disabled());
+				(void)WARN_ON(irqs_disabled());
 				local_irq_enable();
 			}
 		}
@@ -377,9 +377,9 @@ void flush_thread(void)
 
 	flush_ptrace_hw_breakpoint(tsk);
 
-	memset(thread->used_cp, 0, sizeof(thread->used_cp));
-	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
-	memset(&thread->fpstate, 0, sizeof(union fp_state));
+	(void)memset(thread->used_cp, 0, sizeof(thread->used_cp));
+	(void)memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
+	(void)memset(&thread->fpstate, 0, sizeof(union fp_state));
 
 	thread_notify(THREAD_NOTIFY_FLUSH, thread);
 }
@@ -401,7 +401,7 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	childregs->ARM_r0 = 0;
 	childregs->ARM_sp = stack_start;
 
-	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
+	(void)memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
 	thread->cpu_context.sp = (unsigned long)childregs;
 	thread->cpu_context.pc = (unsigned long)ret_from_fork;
 
@@ -483,7 +483,7 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
 
-	memset(&regs, 0, sizeof(regs));
+	(void)memset(&regs, 0, sizeof(regs));
 
 	regs.ARM_r4 = (unsigned long)arg;
 	regs.ARM_r5 = (unsigned long)fn;
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index e1d5e19..6013d4a 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -405,7 +405,7 @@ static void ptrace_hbptriggered(struct perf_event *bp,
  */
 void clear_ptrace_hw_breakpoint(struct task_struct *tsk)
 {
-	memset(tsk->thread.debug.hbp, 0, sizeof(tsk->thread.debug.hbp));
+	(void)memset(tsk->thread.debug.hbp, 0, sizeof(tsk->thread.debug.hbp));
 }
 
 /*
diff --git a/arch/arm/kernel/sched_clock.c b/arch/arm/kernel/sched_clock.c
index 5416c7c..9bcb20e 100644
--- a/arch/arm/kernel/sched_clock.c
+++ b/arch/arm/kernel/sched_clock.c
@@ -104,8 +104,8 @@ void __init setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate)
 	char r_unit;
 
 	BUG_ON(bits > 32);
-	WARN_ON(!irqs_disabled());
-	WARN_ON(read_sched_clock != jiffy_sched_clock_read);
+	(void)WARN_ON(!irqs_disabled());
+	(void)WARN_ON(read_sched_clock != jiffy_sched_clock_read);
 	read_sched_clock = read;
 	sched_clock_mask = (1 << bits) - 1;
 
@@ -124,7 +124,7 @@ void __init setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate)
 
 	/* calculate how many ns until we wrap */
 	wrap = cyc_to_ns((1ULL << bits) - 1, cd.mult, cd.shift);
-	do_div(wrap, NSEC_PER_MSEC);
+	(void)do_div(wrap, NSEC_PER_MSEC);
 	w = wrap;
 
 	/* calculate the ns resolution of this counter */
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 0340224..95ccd9a 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -92,8 +92,8 @@ sys_sigaction(int sig, const struct old_sigaction __user *act,
 		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
 		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
 			return -EFAULT;
-		__get_user(new_ka.sa.sa_flags, &act->sa_flags);
-		__get_user(mask, &act->sa_mask);
+		(void)__get_user(new_ka.sa.sa_flags, &act->sa_flags);
+		(void)__get_user(mask, &act->sa_mask);
 		siginitset(&new_ka.sa.sa_mask, mask);
 	}
 
@@ -104,8 +104,8 @@ sys_sigaction(int sig, const struct old_sigaction __user *act,
 		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
 		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
 			return -EFAULT;
-		__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
-		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
+		(void)__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
+		(void)__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
 	}
 
 	return ret;
@@ -574,7 +574,7 @@ setup_rt_frame(int usig, struct k_sigaction *ka, siginfo_t *info,
 	__put_user_error(0, &frame->sig.uc.uc_flags, err);
 	__put_user_error(NULL, &frame->sig.uc.uc_link, err);
 
-	memset(&stack, 0, sizeof(stack));
+	(void)memset(&stack, 0, sizeof(stack));
 	stack.ss_sp = (void __user *)current->sas_ss_sp;
 	stack.ss_flags = sas_ss_flags(regs->ARM_sp);
 	stack.ss_size = current->sas_ss_size;
diff --git a/arch/arm/kernel/sys_arm.c b/arch/arm/kernel/sys_arm.c
index d2b1779..024f29c 100644
--- a/arch/arm/kernel/sys_arm.c
+++ b/arch/arm/kernel/sys_arm.c
@@ -86,7 +86,7 @@ int kernel_execve(const char *filename,
 	struct pt_regs regs;
 	int ret;
 
-	memset(&regs, 0, sizeof(struct pt_regs));
+	(void)memset(&regs, 0, sizeof(struct pt_regs));
 	ret = do_execve(filename,
 			(const char __user *const __user *)argv,
 			(const char __user *const __user *)envp, &regs);
diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c
index af0aaeb..697f7b5 100644
--- a/arch/arm/kernel/sys_oabi-compat.c
+++ b/arch/arm/kernel/sys_oabi-compat.c
@@ -418,7 +418,7 @@ asmlinkage long sys_oabi_sendmsg(int fd, struct msghdr __user *msg, unsigned fla
 		 * to run for cover.  In most cases it will "just work fine".
 		 * If it doesn't, well, tough.
 		 */
-		put_user(110, &msg->msg_namelen);
+		(void)put_user(110, &msg->msg_namelen);
 	}
 	return sys_sendmsg(fd, msg, flags);
 }
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 99a5727..27e780d 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -106,7 +106,7 @@ static void dump_mem(const char *lvl, const char *str, unsigned long bottom,
 		unsigned long p;
 		char str[sizeof(" 12345678") * 8 + 1];
 
-		memset(str, ' ', sizeof(str));
+		(void)memset(str, ' ', sizeof(str));
 		str[sizeof(str) - 1] = '\0';
 
 		for (p = first, i = 0; i < 8 && p < top; i++, p += 4) {
@@ -388,15 +388,15 @@ asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
 #endif
 			instr = *(u32 *) pc;
 	} else if (thumb_mode(regs)) {
-		get_user(instr, (u16 __user *)pc);
+		(void)get_user(instr, (u16 __user *)pc);
 		if (is_wide_instruction(instr)) {
 			unsigned int instr2;
-			get_user(instr2, (u16 __user *)pc+1);
+			(void)get_user(instr2, (u16 __user *)pc+1);
 			instr <<= 16;
 			instr |= instr2;
 		}
 	} else {
-		get_user(instr, (u32 __user *)pc);
+		(void)get_user(instr, (u32 __user *)pc);
 	}
 
 	if (call_undef_hook(regs, instr) == 0)
diff --git a/arch/arm/mm/copypage-v6.c b/arch/arm/mm/copypage-v6.c
index 3d9a155..18b900f 100644
--- a/arch/arm/mm/copypage-v6.c
+++ b/arch/arm/mm/copypage-v6.c
@@ -125,7 +125,7 @@ static void v6_clear_user_highpage_aliasing(struct page *page, unsigned long vad
 
 	set_pte_ext(TOP_PTE(to_address) + offset, pfn_pte(page_to_pfn(page), PAGE_KERNEL), 0);
 	flush_tlb_kernel_page(to);
-	clear_page((void *)to);
+	(void)clear_page((void *)to);
 
 	raw_spin_unlock(&v6_lock);
 }
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 340c2d0..eff7868 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -94,7 +94,7 @@ static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf
 	 * lurking in the kernel direct-mapped region is invalidated.
 	 */
 	ptr = page_address(page);
-	memset(ptr, 0, size);
+	(void)memset(ptr, 0, size);
 	dmac_flush_range(ptr, ptr + size);
 	outer_flush_range(__pa(ptr), __pa(ptr) + size);
 
@@ -171,7 +171,7 @@ static int __init consistent_init(void)
 			ret = -ENOMEM;
 			break;
 		}
-		WARN_ON(!pmd_none(*pmd));
+		(void)WARN_ON(!pmd_none(*pmd));
 
 		pte = pte_alloc_kernel(pmd, base);
 		if (!pte) {
@@ -441,7 +441,7 @@ EXPORT_SYMBOL(dma_mmap_writecombine);
  */
 void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
 {
-	WARN_ON(irqs_disabled());
+	(void)WARN_ON(irqs_disabled());
 
 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
 		return;
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 6ec1226..149f6d0 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -236,7 +236,7 @@ static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 	/*
 	 * initialise the zones.
 	 */
-	memset(zone_size, 0, sizeof(zone_size));
+	(void)memset(zone_size, 0, sizeof(zone_size));
 
 	/*
 	 * The memory size has already been determined.  If we need
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 94c5a0c..a83e089 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -551,7 +551,7 @@ EXPORT_SYMBOL(phys_mem_access_prot);
 static void __init *early_alloc_aligned(unsigned long sz, unsigned long align)
 {
 	void *ptr = __va(memblock_alloc(sz, align));
-	memset(ptr, 0, sz);
+	(void)memset(ptr, 0, sz);
 	return ptr;
 }
 
diff --git a/arch/arm/mm/pgd.c b/arch/arm/mm/pgd.c
index a3e78cc..a5d9c27 100644
--- a/arch/arm/mm/pgd.c
+++ b/arch/arm/mm/pgd.c
@@ -40,7 +40,7 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 	if (!new_pgd)
 		goto no_pgd;
 
-	memset(new_pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
+	(void)memset(new_pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
 
 	/*
 	 * Copy over the kernel and IO PGD entries
diff --git a/arch/arm/nwfpe/fpa11.c b/arch/arm/nwfpe/fpa11.c
index cc60acd..a316414 100644
--- a/arch/arm/nwfpe/fpa11.c
+++ b/arch/arm/nwfpe/fpa11.c
@@ -89,7 +89,7 @@ void nwfpe_init_fpa(union fp_state *fp)
 #ifdef NWFPE_DEBUG
 	printk("NWFPE: setting up state.\n");
 #endif
- 	memset(fpa11, 0, sizeof(FPA11));
+ 	(void)memset(fpa11, 0, sizeof(FPA11));
 	resetFPA11();
 	fpa11->initflag = 1;
 }
diff --git a/arch/arm/nwfpe/fpa11_cpdt.c b/arch/arm/nwfpe/fpa11_cpdt.c
index d31c49f..e9fcbaa 100644
--- a/arch/arm/nwfpe/fpa11_cpdt.c
+++ b/arch/arm/nwfpe/fpa11_cpdt.c
@@ -32,7 +32,7 @@ static inline void loadSingle(const unsigned int Fn, const unsigned int __user *
 {
 	FPA11 *fpa11 = GET_FPA11();
 	fpa11->fType[Fn] = typeSingle;
-	get_user(fpa11->fpreg[Fn].fSingle, pMem);
+	(void)get_user(fpa11->fpreg[Fn].fSingle, pMem);
 }
 
 static inline void loadDouble(const unsigned int Fn, const unsigned int __user *pMem)
@@ -42,11 +42,11 @@ static inline void loadDouble(const unsigned int Fn, const unsigned int __user *
 	p = (unsigned int *) &fpa11->fpreg[Fn].fDouble;
 	fpa11->fType[Fn] = typeDouble;
 #ifdef __ARMEB__
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
-	get_user(p[1], &pMem[1]);
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[1], &pMem[1]);
 #else
-	get_user(p[0], &pMem[1]);
-	get_user(p[1], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[1]);
+	(void)get_user(p[1], &pMem[0]);	/* sign & exponent */
 #endif
 }
 
@@ -57,13 +57,13 @@ static inline void loadExtended(const unsigned int Fn, const unsigned int __user
 	unsigned int *p;
 	p = (unsigned int *) &fpa11->fpreg[Fn].fExtended;
 	fpa11->fType[Fn] = typeExtended;
-	get_user(p[0], &pMem[0]);	/* sign & exponent */
+	(void)get_user(p[0], &pMem[0]);	/* sign & exponent */
 #ifdef __ARMEB__
-	get_user(p[1], &pMem[1]);	/* ms bits */
-	get_user(p[2], &pMem[2]);	/* ls bits */
+	(void)get_user(p[1], &pMem[1]);	/* ms bits */
+	(void)get_user(p[2], &pMem[2]);	/* ls bits */
 #else
-	get_user(p[1], &pMem[2]);	/* ls bits */
-	get_user(p[2], &pMem[1]);	/* ms bits */
+	(void)get_user(p[1], &pMem[2]);	/* ls bits */
+	(void)get_user(p[2], &pMem[1]);	/* ms bits */
 #endif
 }
 #endif
@@ -75,15 +75,15 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 	unsigned long x;
 
 	p = (unsigned int *) &(fpa11->fpreg[Fn]);
-	get_user(x, &pMem[0]);
+	(void)get_user(x, &pMem[0]);
 	fpa11->fType[Fn] = (x >> 14) & 0x00000003;
 
 	switch (fpa11->fType[Fn]) {
 	case typeSingle:
 	case typeDouble:
 		{
-			get_user(p[0], &pMem[2]);	/* Single */
-			get_user(p[1], &pMem[1]);	/* double msw */
+			(void)get_user(p[0], &pMem[2]);	/* Single */
+			(void)get_user(p[1], &pMem[1]);	/* double msw */
 			p[2] = 0;			/* empty */
 		}
 		break;
@@ -91,8 +91,8 @@ static inline void loadMultiple(const unsigned int Fn, const unsigned int __user
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			get_user(p[1], &pMem[2]);
-			get_user(p[2], &pMem[1]);	/* msw */
+			(void)get_user(p[1], &pMem[2]);
+			(void)get_user(p[2], &pMem[1]);	/* msw */
 			p[0] = (x & 0x80003fff);
 		}
 		break;
@@ -123,7 +123,7 @@ static inline void storeSingle(struct roundingData *roundData, const unsigned in
 		val.f = fpa11->fpreg[Fn].fSingle;
 	}
 
-	put_user(val.i[0], pMem);
+	(void)put_user(val.i[0], pMem);
 }
 
 static inline void storeDouble(struct roundingData *roundData, const unsigned int Fn, unsigned int __user *pMem)
@@ -150,11 +150,11 @@ static inline void storeDouble(struct roundingData *roundData, const unsigned in
 	}
 
 #ifdef __ARMEB__
-	put_user(val.i[0], &pMem[0]);	/* msw */
-	put_user(val.i[1], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[0], &pMem[0]);	/* msw */
+	(void)put_user(val.i[1], &pMem[1]);	/* lsw */
 #else
-	put_user(val.i[1], &pMem[0]);	/* msw */
-	put_user(val.i[0], &pMem[1]);	/* lsw */
+	(void)put_user(val.i[1], &pMem[0]);	/* msw */
+	(void)put_user(val.i[0], &pMem[1]);	/* lsw */
 #endif
 }
 
@@ -180,13 +180,13 @@ static inline void storeExtended(const unsigned int Fn, unsigned int __user *pMe
 		val.f = fpa11->fpreg[Fn].fExtended;
 	}
 
-	put_user(val.i[0], &pMem[0]);	/* sign & exp */
+	(void)put_user(val.i[0], &pMem[0]);	/* sign & exp */
 #ifdef __ARMEB__
-	put_user(val.i[1], &pMem[1]);	/* msw */
-	put_user(val.i[2], &pMem[2]);
+	(void)put_user(val.i[1], &pMem[1]);	/* msw */
+	(void)put_user(val.i[2], &pMem[2]);
 #else
-	put_user(val.i[1], &pMem[2]);
-	put_user(val.i[2], &pMem[1]);	/* msw */
+	(void)put_user(val.i[1], &pMem[2]);
+	(void)put_user(val.i[2], &pMem[1]);	/* msw */
 #endif
 }
 #endif
@@ -203,18 +203,18 @@ static inline void storeMultiple(const unsigned int Fn, unsigned int __user *pMe
 	case typeSingle:
 	case typeDouble:
 		{
-			put_user(p[0], &pMem[2]);	/* single */
-			put_user(p[1], &pMem[1]);	/* double msw */
-			put_user(nType << 14, &pMem[0]);
+			(void)put_user(p[0], &pMem[2]);	/* single */
+			(void)put_user(p[1], &pMem[1]);	/* double msw */
+			(void)put_user(nType << 14, &pMem[0]);
 		}
 		break;
 
 #ifdef CONFIG_FPE_NWFPE_XP
 	case typeExtended:
 		{
-			put_user(p[2], &pMem[1]);	/* msw */
-			put_user(p[1], &pMem[2]);
-			put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
+			(void)put_user(p[2], &pMem[1]);	/* msw */
+			(void)put_user(p[1], &pMem[2]);
+			(void)put_user((p[0] & 0x80003fff) | (nType << 14), &pMem[0]);
 		}
 		break;
 #endif
diff --git a/arch/arm/nwfpe/softfloat-macros b/arch/arm/nwfpe/softfloat-macros
index cf2a617..d7136f3 100644
--- a/arch/arm/nwfpe/softfloat-macros
+++ b/arch/arm/nwfpe/softfloat-macros
@@ -568,7 +568,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
         z = LIT64( 0xFFFFFFFF00000000 );
     }  else {
         z = a0;
-        do_div( z, b0 );
+        (void)do_div( z, b0 );
         z <<= 32;
     }
     mul64To128( b, z, &term0, &term1 );
@@ -582,7 +582,7 @@ static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
     if ( b0<<32 <= rem0 ) {
         z |= 0xFFFFFFFF;
     } else {
-        do_div( rem0, b0 );
+        (void)do_div( rem0, b0 );
         z |= rem0;
     }
     return z;
@@ -627,7 +627,7 @@ static bits32 estimateSqrt32( int16 aExp, bits32 a )
         if ( z <= a ) return (bits32) ( ( (sbits32) a )>>1 );
     }
     A = ( (bits64) a )<<31;
-    do_div( A, z );
+    (void)do_div( A, z );
     return ( (bits32) A ) + ( z>>1 );
 
 }
diff --git a/arch/arm/nwfpe/softfloat.c b/arch/arm/nwfpe/softfloat.c
index ffa6b43..9a9ded3 100644
--- a/arch/arm/nwfpe/softfloat.c
+++ b/arch/arm/nwfpe/softfloat.c
@@ -1327,7 +1327,7 @@ float32 float32_div( struct roundingData *roundData, float32 a, float32 b )
     }
     {
         bits64 tmp = ( (bits64) aSig )<<32;
-        do_div( tmp, bSig );
+        (void)do_div( tmp, bSig );
         zSig = tmp;
     }
     if ( ( zSig & 0x3F ) == 0 ) {
@@ -1396,7 +1396,7 @@ float32 float32_rem( struct roundingData *roundData, float32 a, float32 b )
         if ( q ) aSig -= bSig;
         if ( 0 < expDiff ) {
             bits64 tmp = ( (bits64) aSig )<<32;
-            do_div( tmp, bSig );
+            (void)do_div( tmp, bSig );
             q = tmp;
             q >>= 32 - expDiff;
             bSig >>= 2;
diff --git a/arch/arm/vfp/vfp.h b/arch/arm/vfp/vfp.h
index c8c98dd..5a0c1e8 100644
--- a/arch/arm/vfp/vfp.h
+++ b/arch/arm/vfp/vfp.h
@@ -121,7 +121,7 @@ static inline u64 vfp_estimate_div128to64(u64 nh, u64 nl, u64 m)
 		z = 0xffffffff00000000ULL;
 	} else {
 		z = nh;
-		do_div(z, mh);
+		(void)do_div(z, mh);
 		z <<= 32;
 	}
 	mul64to128(&termh, &terml, m, z);
@@ -135,7 +135,7 @@ static inline u64 vfp_estimate_div128to64(u64 nh, u64 nl, u64 m)
 	if (mh << 32 <= remh) {
 		z |= 0xffffffff;
 	} else {
-		do_div(remh, mh);
+		(void)do_div(remh, mh);
 		z |= remh;
 	}
 	return z;
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index 8f3ccdd..0e9705a 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -103,7 +103,7 @@ static void vfp_thread_flush(struct thread_info *thread)
 	fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
 	put_cpu();
 
-	memset(vfp, 0, sizeof(union vfp_state));
+	(void)memset(vfp, 0, sizeof(union vfp_state));
 
 	vfp->hard.fpexc = FPEXC_EN;
 	vfp->hard.fpscr = FPSCR_ROUND_NEAREST;
@@ -216,7 +216,7 @@ static void vfp_raise_sigfpe(unsigned int sicode, struct pt_regs *regs)
 {
 	siginfo_t info;
 
-	memset(&info, 0, sizeof(info));
+	(void)memset(&info, 0, sizeof(info));
 
 	info.si_signo = SIGFPE;
 	info.si_code = sicode;
diff --git a/arch/arm/vfp/vfpsingle.c b/arch/arm/vfp/vfpsingle.c
index b252631..90c2b05 100644
--- a/arch/arm/vfp/vfpsingle.c
+++ b/arch/arm/vfp/vfpsingle.c
@@ -308,7 +308,7 @@ u32 vfp_estimate_sqrt_significand(u32 exponent, u32 significand)
 	}
 	{
 		u64 v = (u64)a << 31;
-		do_div(v, z);
+		(void)do_div(v, z);
 		return v + (z >> 1);
 	}
 }
@@ -1117,7 +1117,7 @@ static u32 vfp_single_fdiv(int sd, int sn, s32 m, u32 fpscr)
 	}
 	{
 		u64 significand = (u64)vsn.significand << 32;
-		do_div(significand, vsm.significand);
+		(void)do_div(significand, vsm.significand);
 		vsd.significand = significand;
 	}
 	if ((vsd.significand & 0x3f) == 0)
diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index bd8e788..b126264 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -87,7 +87,7 @@ void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 {
 	struct irq_devres match_data = { irq, dev_id };
 
-	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
+	(void)WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
 			       &match_data));
 	free_irq(irq, dev_id);
 }
diff --git a/sound/arm/aaci.c b/sound/arm/aaci.c
index b37b702a..5181a7f 100644
--- a/sound/arm/aaci.c
+++ b/sound/arm/aaci.c
@@ -46,13 +46,13 @@ static void aaci_ac97_select_codec(struct aaci *aaci, struct snd_ac97 *ac97)
 	 */
 	v = readl(aaci->base + AACI_SLFR);
 	if (v & SLFR_2RXV)
-		readl(aaci->base + AACI_SL2RX);
+		(void)readl(aaci->base + AACI_SL2RX);
 	if (v & SLFR_1RXV)
-		readl(aaci->base + AACI_SL1RX);
+		(void)readl(aaci->base + AACI_SL1RX);
 
 	if (maincr != readl(aaci->base + AACI_MAINCR)) {
 		writel(maincr, aaci->base + AACI_MAINCR);
-		readl(aaci->base + AACI_MAINCR);
+		(void)readl(aaci->base + AACI_MAINCR);
 		udelay(1);
 	}
 }
@@ -461,7 +461,7 @@ static int aaci_pcm_close(struct snd_pcm_substream *substream)
 	struct aaci *aaci = substream->private_data;
 	struct aaci_runtime *aacirun = substream->runtime->private_data;
 
-	WARN_ON(aacirun->cr & CR_EN);
+	(void)WARN_ON(aacirun->cr & CR_EN);
 
 	aacirun->substream = NULL;
 
@@ -480,7 +480,7 @@ static int aaci_pcm_hw_free(struct snd_pcm_substream *substream)
 	/*
 	 * This must not be called with the device enabled.
 	 */
-	WARN_ON(aacirun->cr & CR_EN);
+	(void)WARN_ON(aacirun->cr & CR_EN);
 
 	if (aacirun->pcm_open)
 		snd_ac97_pcm_close(aacirun->pcm);
@@ -859,7 +859,7 @@ static int __devinit aaci_probe_ac97(struct aaci *aaci)
 	ac97_bus->clock = 48000;
 	aaci->ac97_bus = ac97_bus;
 
-	memset(&ac97_template, 0, sizeof(struct snd_ac97_template));
+	(void)memset(&ac97_template, 0, sizeof(struct snd_ac97_template));
 	ac97_template.private_data = aaci;
 	ac97_template.num = 0;
 	ac97_template.scaps = AC97_SCAP_SKIP_MODEM;
@@ -970,7 +970,7 @@ static unsigned int __devinit aaci_size_fifo(struct aaci *aaci)
 	 * disabling the channel doesn't clear the FIFO.
 	 */
 	writel(aaci->maincr & ~MAINCR_IE, aaci->base + AACI_MAINCR);
-	readl(aaci->base + AACI_MAINCR);
+	(void)readl(aaci->base + AACI_MAINCR);
 	udelay(1);
 	writel(aaci->maincr, aaci->base + AACI_MAINCR);
 
@@ -1034,7 +1034,7 @@ static int __devinit aaci_probe(struct amba_device *dev,
 	 * Fix: ac97 read back fail errors by reading
 	 * from any arbitrary aaci register.
 	 */
-	readl(aaci->base + AACI_CSCH1);
+	(void)readl(aaci->base + AACI_CSCH1);
 	ret = aaci_probe_ac97(aaci);
 	if (ret)
 		goto out;
