diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 94c5a0c..a83e089 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -551,7 +551,7 @@ EXPORT_SYMBOL(phys_mem_access_prot);
 static void __init *early_alloc_aligned(unsigned long sz, unsigned long align)
 {
 	void *ptr = __va(memblock_alloc(sz, align));
-	memset(ptr, 0, sz);
+	(void)memset(ptr, 0, sz);
 	return ptr;
 }
 
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 99a5727..27e780d 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -106,7 +106,7 @@ static void dump_mem(const char *lvl, const char *str, unsigned long bottom,
 		unsigned long p;
 		char str[sizeof(" 12345678") * 8 + 1];
 
-		memset(str, ' ', sizeof(str));
+		(void)memset(str, ' ', sizeof(str));
 		str[sizeof(str) - 1] = '\0';
 
 		for (p = first, i = 0; i < 8 && p < top; i++, p += 4) {
@@ -388,15 +388,15 @@ asmlinkage void __exception do_undefinstr(struct pt_regs *regs)
 #endif
 			instr = *(u32 *) pc;
 	} else if (thumb_mode(regs)) {
-		get_user(instr, (u16 __user *)pc);
+		(void)get_user(instr, (u16 __user *)pc);
 		if (is_wide_instruction(instr)) {
 			unsigned int instr2;
-			get_user(instr2, (u16 __user *)pc+1);
+			(void)get_user(instr2, (u16 __user *)pc+1);
 			instr <<= 16;
 			instr |= instr2;
 		}
 	} else {
-		get_user(instr, (u32 __user *)pc);
+		(void)get_user(instr, (u32 __user *)pc);
 	}
 
 	if (call_undef_hook(regs, instr) == 0)
diff --git a/arch/arm/kernel/sched_clock.c b/arch/arm/kernel/sched_clock.c
index 5416c7c..9bcb20e 100644
--- a/arch/arm/kernel/sched_clock.c
+++ b/arch/arm/kernel/sched_clock.c
@@ -104,8 +104,8 @@ void __init setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate)
 	char r_unit;
 
 	BUG_ON(bits > 32);
-	WARN_ON(!irqs_disabled());
-	WARN_ON(read_sched_clock != jiffy_sched_clock_read);
+	(void)WARN_ON(!irqs_disabled());
+	(void)WARN_ON(read_sched_clock != jiffy_sched_clock_read);
 	read_sched_clock = read;
 	sched_clock_mask = (1 << bits) - 1;
 
@@ -124,7 +124,7 @@ void __init setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate)
 
 	/* calculate how many ns until we wrap */
 	wrap = cyc_to_ns((1ULL << bits) - 1, cd.mult, cd.shift);
-	do_div(wrap, NSEC_PER_MSEC);
+	(void)do_div(wrap, NSEC_PER_MSEC);
 	w = wrap;
 
 	/* calculate the ns resolution of this counter */
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index a45ca16..9e8ebfd 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -153,7 +153,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)
 	for (sft = 32; sft > 0; sft--) {
 		tmp = (u64) to << sft;
 		tmp += from / 2;
-		do_div(tmp, from);
+		(void)do_div(tmp, from);
 		if ((tmp >> sftacc) == 0)
 			break;
 	}
@@ -503,7 +503,7 @@ static u32 clocksource_max_adjustment(struct clocksource *cs)
 	 * We won't try to correct for more then 11% adjustments (110,000 ppm),
 	 */
 	ret = (u64)cs->mult * 11;
-	do_div(ret,100);
+	(void)do_div(ret,100);
 	return (u32)ret;
 }
 
@@ -670,8 +670,8 @@ void __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq)
 	 * margin as we do in clocksource_max_deferment()
 	 */
 	sec = (cs->mask - (cs->mask >> 3));
-	do_div(sec, freq);
-	do_div(sec, scale);
+	(void)do_div(sec, freq);
+	(void)do_div(sec, scale);
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && cs->mask > UINT_MAX)
@@ -735,7 +735,7 @@ int clocksource_register(struct clocksource *cs)
 {
 	/* calculate max adjustment for given mult/shift */
 	cs->maxadj = clocksource_max_adjustment(cs);
-	WARN_ONCE(cs->mult + cs->maxadj < cs->mult,
+	(void)WARN_ONCE(cs->mult + cs->maxadj < cs->mult,
 		"Clocksource %s might overflow on 11%% adjustment\n",
 		cs->name);
 
diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c
index bd8e788..b126264 100644
--- a/kernel/irq/devres.c
+++ b/kernel/irq/devres.c
@@ -87,7 +87,7 @@ void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)
 {
 	struct irq_devres match_data = { irq, dev_id };
 
-	WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
+	(void)WARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,
 			       &match_data));
 	free_irq(irq, dev_id);
 }
