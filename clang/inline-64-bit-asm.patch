From ed6fa8795028e62feea0c9309524f2b3089820c4 Mon Sep 17 00:00:00 2001
From: Weiming Zhao <weimingz@quicinc.com>
Date: Mon, 2 Apr 2012 09:54:08 -0700
Subject: [PATCH] Bug 6753: spport for 64-bit integer register input and %H
 modifier for inline ASM

This patch adds support for using paired GPR registers for
64-bit
integer input for inline ASM. It also supports %H
modifier for
inline ASM.
---
 include/llvm/Target/TargetLowering.h             |    8 +++++
 lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp |   32 +++++++++++++--------
 lib/Target/ARM/ARMAsmPrinter.cpp                 |   11 +++++++-
 lib/Target/ARM/ARMISelLowering.cpp               |   15 +++++++++-
 lib/Target/ARM/ARMISelLowering.h                 |    3 +-
 5 files changed, 53 insertions(+), 16 deletions(-)
 mode change 100755 => 100644 include/llvm/Target/TargetLowering.h

diff --git a/include/llvm/Target/TargetLowering.h b/include/llvm/Target/TargetLowering.h
old mode 100755
new mode 100644
index 3d019de..73499f8
--- a/include/llvm/Target/TargetLowering.h
+++ b/include/llvm/Target/TargetLowering.h
@@ -1500,6 +1500,14 @@ public:
     getRegForInlineAsmConstraint(const std::string &Constraint,
                                  EVT VT) const;
 
+  virtual std::pair<unsigned, const TargetRegisterClass*>
+    getRegForInlineAsmConstraint(const std::string &Constraint,
+                                 EVT VT,
+                                 SmallVectorImpl<unsigned> &AssignedPhyRegs
+                                ) const {
+      return getRegForInlineAsmConstraint(Constraint, VT);
+    }
+
   /// LowerXConstraint - try to replace an X constraint, which matches anything,
   /// with another that has more specific requirements based on the type of the
   /// corresponding operand.  This returns null if there is no replacement to
diff --git a/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp b/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
index d3303a8..015bf8c 100644
--- a/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
+++ b/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
@@ -5764,7 +5764,8 @@ typedef SmallVector<SDISelAsmOperandInfo,16> SDISelAsmOperandInfoVector;
 static void GetRegistersForValue(SelectionDAG &DAG,
                                  const TargetLowering &TLI,
                                  DebugLoc DL,
-                                 SDISelAsmOperandInfo &OpInfo) {
+                                 SDISelAsmOperandInfo &OpInfo,
+                                 SmallVector<unsigned, 8> &AssignedPhyRegs) {
   LLVMContext &Context = *DAG.getContext();
 
   MachineFunction &MF = DAG.getMachineFunction();
@@ -5774,7 +5775,8 @@ static void GetRegistersForValue(SelectionDAG &DAG,
   // register class, find it.
   std::pair<unsigned, const TargetRegisterClass*> PhysReg =
     TLI.getRegForInlineAsmConstraint(OpInfo.ConstraintCode,
-                                     OpInfo.ConstraintVT);
+                                     OpInfo.ConstraintVT,
+                                     AssignedPhyRegs);
 
   unsigned NumRegs = 1;
   if (OpInfo.ConstraintVT != MVT::Other) {
@@ -5824,6 +5826,7 @@ static void GetRegistersForValue(SelectionDAG &DAG,
 
     // This is a explicit reference to a physical register.
     Regs.push_back(AssignedReg);
+    AssignedPhyRegs.push_back(AssignedReg);
 
     // If this is an expanded reference, add the rest of the regs to Regs.
     if (NumRegs != 1) {
@@ -5836,9 +5839,9 @@ static void GetRegistersForValue(SelectionDAG &DAG,
       for (; NumRegs; --NumRegs, ++I) {
         assert(I != RC->end() && "Ran out of registers to allocate!");
         Regs.push_back(*I);
+        AssignedPhyRegs.push_back(*I);
       }
     }
-
     OpInfo.AssignedRegs = RegsForValue(Regs, RegVT, ValueVT);
     return;
   }
@@ -5866,6 +5869,7 @@ static void GetRegistersForValue(SelectionDAG &DAG,
 ///
 void SelectionDAGBuilder::visitInlineAsm(ImmutableCallSite CS) {
   const InlineAsm *IA = cast<InlineAsm>(CS.getCalledValue());
+  SmallVector<unsigned, 8> AssignedPhyRegs;
 
   /// ConstraintOperands - Information about all of the constraints.
   SDISelAsmOperandInfoVector ConstraintOperands;
@@ -5962,12 +5966,16 @@ void SelectionDAGBuilder::visitInlineAsm(ImmutableCallSite CS) {
       SDISelAsmOperandInfo &Input = ConstraintOperands[OpInfo.MatchingInput];
 
       if (OpInfo.ConstraintVT != Input.ConstraintVT) {
-	std::pair<unsigned, const TargetRegisterClass*> MatchRC =
-	  TLI.getRegForInlineAsmConstraint(OpInfo.ConstraintCode,
-                                           OpInfo.ConstraintVT);
-	std::pair<unsigned, const TargetRegisterClass*> InputRC =
-	  TLI.getRegForInlineAsmConstraint(Input.ConstraintCode,
-                                           Input.ConstraintVT);
+        std::pair<unsigned, const TargetRegisterClass*> MatchRC =
+        TLI.getRegForInlineAsmConstraint(OpInfo.ConstraintCode,
+                                           OpInfo.ConstraintVT,
+                                           AssignedPhyRegs);
+
+        std::pair<unsigned, const TargetRegisterClass*> InputRC =
+        TLI.getRegForInlineAsmConstraint(Input.ConstraintCode,
+                                           Input.ConstraintVT,
+                                           AssignedPhyRegs);
+
         if ((OpInfo.ConstraintVT.isInteger() !=
              Input.ConstraintVT.isInteger()) ||
             (MatchRC.second != InputRC.second)) {
@@ -6031,18 +6039,18 @@ void SelectionDAGBuilder::visitInlineAsm(ImmutableCallSite CS) {
     // If this constraint is for a specific register, allocate it before
     // anything else.
     if (OpInfo.ConstraintType == TargetLowering::C_Register)
-      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo);
+      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo, AssignedPhyRegs);
   }
 
   // Second pass - Loop over all of the operands, assigning virtual or physregs
   // to register class operands.
+
   for (unsigned i = 0, e = ConstraintOperands.size(); i != e; ++i) {
     SDISelAsmOperandInfo &OpInfo = ConstraintOperands[i];
-
     // C_Register operands have already been allocated, Other/Memory don't need
     // to be.
     if (OpInfo.ConstraintType == TargetLowering::C_RegisterClass)
-      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo);
+      GetRegistersForValue(DAG, TLI, getCurDebugLoc(), OpInfo, AssignedPhyRegs);
   }
 
   // AsmNodeOperands - The operands for the ISD::INLINEASM node.
diff --git a/lib/Target/ARM/ARMAsmPrinter.cpp b/lib/Target/ARM/ARMAsmPrinter.cpp
index 06fd318..14e3f24 100644
--- a/lib/Target/ARM/ARMAsmPrinter.cpp
+++ b/lib/Target/ARM/ARMAsmPrinter.cpp
@@ -519,8 +519,17 @@ bool ARMAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNum,
 
     // These modifiers are not yet supported.
     case 'h': // A range of VFP/NEON registers suitable for VLD1/VST1.
-    case 'H': // The highest-numbered register of a pair.
       return true;
+    case 'H': // The highest-numbered register of a pair.
+      if (!MI->getOperand(OpNum).isReg())
+        return true;
+      const MachineOperand &MO = MI->getOperand(OpNum);
+      if (!MO.isReg())
+        return true;
+      unsigned Reg = MO.getReg();
+      Reg = (Reg - ARM::R0) & 1 ? Reg : Reg + 1;
+      O << ARMInstPrinter::getRegisterName(Reg);
+      return false;
     }
   }
 
diff --git a/lib/Target/ARM/ARMISelLowering.cpp b/lib/Target/ARM/ARMISelLowering.cpp
index 429e6a7..2480295 100644
--- a/lib/Target/ARM/ARMISelLowering.cpp
+++ b/lib/Target/ARM/ARMISelLowering.cpp
@@ -8931,7 +8931,8 @@ ARMTargetLowering::getSingleConstraintMatchWeight(
 typedef std::pair<unsigned, const TargetRegisterClass*> RCPair;
 RCPair
 ARMTargetLowering::getRegForInlineAsmConstraint(const std::string &Constraint,
-                                                EVT VT) const {
+                                                                       EVT VT,
+                            SmallVectorImpl<unsigned> &AssignedPhyRegs) const {
   if (Constraint.size() == 1) {
     // GCC ARM Constraint Letters
     switch (Constraint[0]) {
@@ -8945,6 +8946,15 @@ ARMTargetLowering::getRegForInlineAsmConstraint(const std::string &Constraint,
         return RCPair(0U, ARM::hGPRRegisterClass);
       break;
     case 'r':
+      if (VT.getSizeInBits() == 64) {
+        SmallVectorImpl<unsigned>::iterator First = AssignedPhyRegs.begin(),
+          Last = AssignedPhyRegs.end();
+        for (unsigned Reg = ARM::R0; Reg < ARM::R12; Reg += 2)
+          if (std::find(First, Last, Reg) == Last &&
+              std::find(First, Last, Reg + 1) == Last)
+            return RCPair(Reg, ARM::GPRRegisterClass);
+        return RCPair(0U, NULL);
+      }
       return RCPair(0U, ARM::GPRRegisterClass);
     case 'w':
       if (VT == MVT::f32)
@@ -8971,7 +8981,8 @@ ARMTargetLowering::getRegForInlineAsmConstraint(const std::string &Constraint,
   if (StringRef("{cc}").equals_lower(Constraint))
     return std::make_pair(unsigned(ARM::CPSR), ARM::CCRRegisterClass);
 
-  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT);
+  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT,
+                                                      AssignedPhyRegs);
 }
 
 /// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
diff --git a/lib/Target/ARM/ARMISelLowering.h b/lib/Target/ARM/ARMISelLowering.h
index a71b74e..d07dde0 100644
--- a/lib/Target/ARM/ARMISelLowering.h
+++ b/lib/Target/ARM/ARMISelLowering.h
@@ -333,7 +333,8 @@ namespace llvm {
 
     std::pair<unsigned, const TargetRegisterClass*>
       getRegForInlineAsmConstraint(const std::string &Constraint,
-                                   EVT VT) const;
+                             EVT VT,
+                             SmallVectorImpl<unsigned>& AssignedPhyRegs) const;
 
     /// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
     /// vector.  If it is invalid, don't add anything to Ops. If hasMemory is
-- 
1.7.8.3

