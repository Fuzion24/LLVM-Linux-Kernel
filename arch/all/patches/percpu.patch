See http://kernel.opensuse.org/cgit/kernel/commit/?id=509eb76ebf97

The use of sp as a register variable is not supported in clang and
the behavior they are working around in GCC may not even be present 
in clang.

From the link above:

Unfortunately, GCC doesn't treat a "memory" clobber on a non-volatile
asm block as a side-effect, and will happily re-order it before other
memory clobbers (including those in prempt_disable()) and cache the
value. This has been observed to break the cmpxchg logic in the slub
allocator, leading to livelock in kmem_cache_alloc in mainline kernels.

Because the GCC workaround causes numerous warnings, revert the change
until it can be verified that it is in fact an issue for clang.


Signed-off-by: Mark Charlebois <charlebm@gmail.com>
---

diff --git a/arch/arm/include/asm/percpu.h b/arch/arm/include/asm/percpu.h
index 209e650..cb25d85 100644
--- a/arch/arm/include/asm/percpu.h
+++ b/arch/arm/include/asm/percpu.h
@@ -30,14 +30,13 @@ static inline void set_my_cpu_offset(unsigned long off)
 static inline unsigned long __my_cpu_offset(void)
 {
 	unsigned long off;
-	register unsigned long *sp asm ("sp");
 
 	/*
 	 * Read TPIDRPRW.
-	 * We want to allow caching the value, so avoid using volatile and
-	 * instead use a fake stack read to hazard against barrier().
+	 * TODO: Need to verify that unlike GCC, clang will treat a "memory" 
+	 * clobber on a non-volatile asm block as a side-effect.
 	 */
-	asm("mrc p15, 0, %0, c13, c0, 4" : "=r" (off) : "Q" (*sp));
+	asm("mrc p15, 0, %0, c13, c0, 4" : "=r" (off) : : "memory");
 
 	return off;
 }
