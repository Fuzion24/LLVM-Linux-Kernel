From c4be1d921cb69943aadf9a42c039062991656bc5 Mon Sep 17 00:00:00 2001
From: Behan Webster <behanw@converseincode.com>
Date: Fri, 28 Sep 2012 15:18:18 -0400
Subject: [PATCH 3/8] Remove VLAIS usage from gadget code

The use of variable length arrays in structs (VLAIS) in the Linux Kernel code
precludes the use of compilers which don't implement VLAIS (for instance the
Clang compiler). This patch instead calculates offsets into the kmalloc-ed
memory buffer using macros from valign.h.

Signed-off-by: Behan Webster <behanw@converseincode.com>
---
 drivers/usb/gadget/f_fs.c |  106 ++++++++++++++++++++++++++-------------------
 1 file changed, 61 insertions(+), 45 deletions(-)

--- linux.orig/drivers/usb/gadget/f_fs.c
+++ linux/drivers/usb/gadget/f_fs.c
@@ -22,6 +22,7 @@
 #include <linux/pagemap.h>
 #include <linux/export.h>
 #include <linux/hid.h>
+#include <linux/valign.h>
 #include <asm/unaligned.h>
 
 #include <linux/usb/composite.h>
@@ -30,6 +31,18 @@
 
 #define FUNCTIONFS_MAGIC	0xa647361 /* Chosen by a honest dice roll ;) */
 
+/* Variable Length Array Macros **********************************************/
+#define vla_struct(structname) size_t structname##__##next = 0
+#define vla_struct_size(structname) structname##__##next
+
+#define vla_item(structname, type, name, n) \
+	type * structname##_##name; \
+	size_t structname##_##name##__##pad = (structname##__##next & (__alignof__(type)-1)); \
+	size_t structname##_##name##__##offset = structname##__##next + structname##_##name##__##pad; \
+	size_t structname##_##name##__##sz = n * sizeof(type); \
+	structname##__##next = structname##__##next + structname##_##name##__##pad + structname##_##name##__##sz;
+
+#define vla_ptr(ptr,structname,name) structname##_##name = (typeof(structname##_##name))&ptr[structname##_##name##__##offset]
 
 /* Debugging ****************************************************************/
 
@@ -1911,30 +1924,34 @@
 
 	/* Allocate everything in one chunk so there's less maintenance. */
 	{
-		struct {
-			struct usb_gadget_strings *stringtabs[lang_count + 1];
-			struct usb_gadget_strings stringtab[lang_count];
-			struct usb_string strings[lang_count*(needed_count+1)];
-		} *d;
 		unsigned i = 0;
+		vla_struct(d);
+		vla_item(d, struct usb_gadget_strings *, stringtabs, lang_count + 1);
+		vla_item(d, struct usb_gadget_strings, stringtab, lang_count);
+		vla_item(d, struct usb_string, strings, lang_count*(needed_count+1));
+
+		d = malloc(vla_struct_size(d));
+
+		vla_set_ptr(d, d, stringtabs);
+		vla_set_ptr(d, d, stringtab);
+		vla_set_ptr(d, d, strings);
 
-		d = kmalloc(sizeof *d, GFP_KERNEL);
 		if (unlikely(!d)) {
 			kfree(_data);
 			return -ENOMEM;
 		}
 
-		stringtabs = d->stringtabs;
-		t = d->stringtab;
+		stringtabs = d_stringtabs;
+		t = d_stringtab;
 		i = lang_count;
 		do {
 			*stringtabs++ = t++;
 		} while (--i);
 		*stringtabs = NULL;
 
-		stringtabs = d->stringtabs;
-		t = d->stringtab;
-		s = d->strings;
+		stringtabs = d_stringtabs;
+		t = d_stringtab;
+		s = d_strings;
 		strings = s;
 	}
 
@@ -2210,16 +2227,15 @@
 	int ret;
 
 	/* Make it a single chunk, less management later on */
-	struct {
-		struct ffs_ep eps[ffs->eps_count];
-		struct usb_descriptor_header
-			*fs_descs[full ? ffs->fs_descs_count + 1 : 0];
-		struct usb_descriptor_header
-			*hs_descs[high ? ffs->hs_descs_count + 1 : 0];
-		short inums[ffs->interfaces_count];
-		char raw_descs[high ? ffs->raw_descs_length
-				    : ffs->raw_fs_descs_length];
-	} *data;
+	vla_struct(data);
+	vla_item(data, struct ffs_ep, eps, ffs->eps_count);
+	vla_item(data, struct usb_descriptor_header *,
+			fs_descs, full ? ffs->fs_descs_count + 1 : 0);
+	vla_item(data, struct usb_descriptor_header *,
+			hs_descs, high ? ffs->hs_descs_count + 1 : 0);
+	vla_item(data, short, inums, ffs->interfaces_count);
+	vla_item(data, char, raw_descs, high ? ffs->raw_descs_length
+				    : ffs->raw_fs_descs_length);
 
 	ENTER();
 
@@ -2227,21 +2243,28 @@
 	if (unlikely(!(full | high)))
 		return -ENOTSUPP;
 
-	/* Allocate */
-	data = kmalloc(sizeof *data, GFP_KERNEL);
+	/* Allocate a single chunk, less management later on */
+	data = kmalloc(vla_struct_size(data), GFP_KERNEL);
 	if (unlikely(!data))
 		return -ENOMEM;
 
+	/* Initialize each struct member pointer in the allocated memory */
+	vla_ptr(data, data, eps);
+	vla_ptr(data, data, fs_descs);
+	vla_ptr(data, data, hs_descs);
+	vla_ptr(data, data, inums);
+	vla_ptr(data, data, inums);
+
 	/* Zero */
-	memset(data->eps, 0, sizeof data->eps);
-	memcpy(data->raw_descs, ffs->raw_descs + 16, sizeof data->raw_descs);
-	memset(data->inums, 0xff, sizeof data->inums);
+	memset(data_eps, 0, data_eps__sz);
+	memcpy(data_raw_descs, ffs->raw_descs + 16, data_raw_descs__sz);
+	memset(data_inums, 0xff, data_inums__sz);
 	for (ret = ffs->eps_count; ret; --ret)
-		data->eps[ret].num = -1;
+		data_eps[ret].num = -1;
 
 	/* Save pointers */
-	func->eps             = data->eps;
-	func->interfaces_nums = data->inums;
+	func->eps             = data_eps;
+	func->interfaces_nums = data_inums;
 
 	/*
 	 * Go through all the endpoint descriptors and allocate
@@ -2249,10 +2272,10 @@
 	 * numbers without worrying that it may be described later on.
 	 */
 	if (likely(full)) {
-		func->function.descriptors = data->fs_descs;
+		func->function.descriptors = data_fs_descs;
 		ret = ffs_do_descs(ffs->fs_descs_count,
-				   data->raw_descs,
-				   sizeof data->raw_descs,
+				   data_raw_descs,
+				   data_raw_descs__sz,
 				   __ffs_func_bind_do_descs, func);
 		if (unlikely(ret < 0))
 			goto error;
@@ -2261,10 +2284,10 @@
 	}
 
 	if (likely(high)) {
-		func->function.hs_descriptors = data->hs_descs;
+		func->function.hs_descriptors = data_hs_descs;
 		ret = ffs_do_descs(ffs->hs_descs_count,
-				   data->raw_descs + ret,
-				   (sizeof data->raw_descs) - ret,
+				   data_raw_descs + ret,
+				   data_raw_descs__sz - ret,
 				   __ffs_func_bind_do_descs, func);
 	}
 
@@ -2275,7 +2298,7 @@
 	 */
 	ret = ffs_do_descs(ffs->fs_descs_count +
 			   (high ? ffs->hs_descs_count : 0),
-			   data->raw_descs, sizeof data->raw_descs,
+			   data_raw_descs, data_raw_descs__sz,
 			   __ffs_func_bind_do_nums, func);
 	if (unlikely(ret < 0))
 		goto error;
