From 88b143ef7a6e5878a6b96f627bc0ade5474b7e10 Mon Sep 17 00:00:00 2001
From: Behan Webster <behanw@converseincode.com>
Date: Fri, 26 Oct 2012 19:57:44 -0400
Subject: [PATCH 1/8] Helper macros used for replacing the use of VLAIS

The use of variable length arrays in structs (VLAIS) in the Linux Kernel code
precludes the use of compilers which don't implement VLAIS (for instance the
Clang compiler). This new header file contains macros which can be used to
calculate the size and offset of variables in an allocated buffer of memory
taking into account alignment issues.

Signed-off-by: Behan Webster <behanw@converseincode.com>
---
 include/linux/valign.h |   41 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 41 insertions(+)
 create mode 100644 include/linux/valign.h

diff --git a/include/linux/valign.h b/include/linux/valign.h
new file mode 100644
index 0000000..5798f87
--- /dev/null
+++ b/include/linux/valign.h
@@ -0,0 +1,41 @@
+/*
+ * Variable alignment macros used to break up a larger chunk of memory into
+ * smaller variables. Meant to be used to replace the use of Variable Length
+ * Arrays In Structures (VLAIS)
+ *
+ * Author: Behan Webster <behanw@conversincode.com>
+ */
+
+#ifndef _VALIGN_H_
+#define _VALIGN_H_
+
+/* Truncate an address or size to a particular memory alignment */
+#define truncalign(num,padwidth) ((long)(num) & ~((padwidth)-1))
+
+/* Pad out an address or size to a particular memory alignment */
+#define padalign(num,padwidth) truncalign((long)(num) + ((padwidth)-1), padwidth)
+
+/* Calculate the size that a variable will take as a part of a larger piece of
+ * memory.  Takes into account alignment of the variable type, and the
+ * alignement of the variable to be used after that.
+ *
+ * Example: size_t l = paddedsize(2, 2, short, int);
+ *
+ * The example above would give you a padded size of 6 bytes: 2x 16-bit shorts,
+ * starting 2 bytes into the buffer followed by 2 bytes of padding so that the
+ * next type (a 32-bit int) would be 32-bit aligned.
+ */
+#define paddedsize(offset,n,type,nexttype) (padalign((offset) + (n) * sizeof(type), __alignof__(nexttype)) - (offset))
+
+/* Calculate the start address of a variable based on the offset from an
+ * address, aligned based on the type of the variable specified.
+ *
+ * Example: char *buffer = kmalloc(size, GFP_KERNEL);
+ *          long *var = paddedstart(buffer, 12, long);
+ *
+ * The example above on a 64-bit machine would return the equivalent of
+ * &buffer[16] since a long needs to be 8 byte aligned.
+ */
+#define paddedstart(ptr,offset,type) (type *)padalign((long)ptr+(offset),__alignof__(type))
+
+#endif
-- 
1.7.9.5

